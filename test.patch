diff --git a/mangos/src/game/AchievementMgr.cpp b/Core/src/game/AchievementMgr.cpp
index 6517f81..3989b5e 100644
--- a/mangos/src/game/AchievementMgr.cpp
+++ b/Core/src/game/AchievementMgr.cpp
@@ -100,6 +100,8 @@ bool AchievementCriteriaRequirement::IsValid(AchievementCriteriaEntry const* cri
         case ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET2:
             break;
         default:
+            if (requirementType == ACHIEVEMENT_CRITERIA_REQUIRE_HOLIDAY)
+            break;
             sLog.outErrorDb( "Table `achievement_criteria_requirement` have data for not supported criteria type (Entry: %u Type: %u), ignore.", criteria->ID, criteria->requiredType);
             return false;
     }
@@ -437,6 +439,23 @@ void AchievementMgr::ResetAchievementCriteria(AchievementCriteriaTypes type, uin
                 if (achievementCriteria->win_rated_arena.flag == miscvalue1)
                     SetCriteriaProgress(achievementCriteria, 0, PROGRESS_SET);
                 break;
+            case ACHIEVEMENT_CRITERIA_TYPE_GET_KILLING_BLOWS:
+            case ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL:
+            case ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL:
+            case ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE:
+            case ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA:
+            {
+                switch(achievementCriteria->referredAchievement)
+                {
+                    case 200:
+                    case 206:
+                    case 1252:
+                    case 158:
+                    case 157:
+                        continue;
+                }
+                SetCriteriaProgress(achievementCriteria, 0, PROGRESS_SET);
+            }
             default:                                        // reset all cases
                 break;
         }
@@ -779,10 +798,36 @@ void AchievementMgr::UpdateAchievementCriteria(AchievementCriteriaTypes type, ui
 
                 if (achievementCriteria->win_bg.additionalRequirement1_type || achievementCriteria->win_bg.additionalRequirement2_type)
                 {
+                    // some hardcoded requirements
+                    switch(achievementCriteria->referredAchievement)
+                    {
+                        case 214:							// EY, win under 6 minutes
+                        case 226:							// AV, win under 6 minutes
+                        case 159:							// AB, win under 6 minutes
+                        {
+                            // set 8 minutes because there is 2 minutes long preparation
+                            if(GetPlayer()->GetBattleGround()->GetStartTime() > (8 * MINUTE * IN_MILLISECONDS))
+                                continue;
+                            
+                            break;
+                        }
+                        case 201:							// WS, win under 7 minutes
+                        {
+                            // set 9 minutes because there is 2 minutes long preparation
+                            if(GetPlayer()->GetBattleGround()->GetStartTime() > (9 * MINUTE * IN_MILLISECONDS))
+                                continue;
+                            
+                            break;
+                        }
+                        default:
+                        {
                     // those requirements couldn't be found in the dbc
                     AchievementCriteriaRequirementSet const* data = sAchievementMgr.GetCriteriaRequirementSet(achievementCriteria);
                     if (!data || !data->Meets(GetPlayer(),unit))
                         continue;
+                            break;
+                        }
+                    }
                 }
                 // some hardcoded requirements
                 else
@@ -795,7 +840,7 @@ void AchievementMgr::UpdateAchievementCriteria(AchievementCriteriaTypes type, ui
                     {
                         case 161:                           // AB, Overcome a 500 resource disadvantage
                         {
-                            if (bg->GetTypeID() != BATTLEGROUND_AB)
+                            if (bg->GetTypeID(true) != BATTLEGROUND_AB)
                                 continue;
                             if(!((BattleGroundAB*)bg)->IsTeamScores500Disadvantage(GetPlayer()->GetTeam()))
                                 continue;
@@ -1141,6 +1186,12 @@ void AchievementMgr::UpdateAchievementCriteria(AchievementCriteriaTypes type, ui
                 // AchievementMgr::UpdateAchievementCriteria might also be called on login - skip in this case
                 if(!miscvalue1)
                     continue;
+                if(AchievementCriteriaRequirementSet const* data = sAchievementMgr.GetCriteriaRequirementSet(achievementCriteria))
+                {
+                    if(!data->Meets(GetPlayer(),unit))
+                        continue;
+                }
+
                 if(achievementCriteria->use_item.itemID != miscvalue1)
                     continue;
                 SetCriteriaProgress(achievementCriteria, 1, PROGRESS_ACCUMULATE);
@@ -1303,7 +1354,7 @@ void AchievementMgr::UpdateAchievementCriteria(AchievementCriteriaTypes type, ui
                 break;
             case ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL:
             {
-                // AchievementMgr::UpdateAchievementCriteria might also be called on login - skip in this case
+                //AchievementMgr::UpdateAchievementCriteria might also be called on login - skip in this case
                 if (!miscvalue1)
                     continue;
 
@@ -1421,6 +1472,139 @@ void AchievementMgr::UpdateAchievementCriteria(AchievementCriteriaTypes type, ui
             case ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_GOLD_VALUE_OWNED:
                 SetCriteriaProgress(achievementCriteria, GetPlayer()->GetMoney(), PROGRESS_HIGHEST);
                 break;
+            case ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL:
+            case ACHIEVEMENT_CRITERIA_TYPE_GET_KILLING_BLOWS:
+            {	
+                BattleGround* bg = GetPlayer()->GetBattleGround();
+                if (!bg || !miscvalue1 || GetPlayer()->GetMapId() != achievementCriteria->healing_done.mapid)
+                    continue;
+
+                // some hardcoded requirements
+                switch(achievementCriteria->referredAchievement)
+                {
+                    case 231:					// Wrecking Ball
+                    {
+                        if(bg->GetPlayerScore(GetPlayer(),SCORE_DEATHS) != 0)
+                            continue;
+                        break;
+                    }
+                    case 233:					// Bloodthirsty Berserker
+                    {
+                        if(bg->GetTypeID(true) != BATTLEGROUND_EY)
+                            continue;
+                        if(!GetPlayer()->HasAura(23505))
+                            continue;
+                        break;
+                    }
+                }
+
+                SetCriteriaProgress(achievementCriteria, miscvalue1, PROGRESS_ACCUMULATE);
+                break;
+            }
+            case ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA:
+            {
+                if(GetPlayer()->GetAreaId() != achievementCriteria->honorable_kill_at_area.areaID)
+                    continue;
+
+                SetCriteriaProgress(achievementCriteria, miscvalue1, PROGRESS_ACCUMULATE);
+                break;
+            }
+            case ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE:
+            {
+                BattleGround* bg = GetPlayer()->GetBattleGround();
+                if (!miscvalue1 || !bg)
+                    continue;
+
+                // some hardcoded requirements
+                switch(achievementCriteria->objective_capture.captureID)
+                {
+                    case 42:							// WS, capture a flag
+                    {
+                        if(bg->GetTypeID(true) != BATTLEGROUND_WS)
+                            continue;
+
+                        if(miscvalue2 == 1)
+                            continue;
+                        break;
+                    }
+                    case 44:                           // WS, return a flag
+                    {
+                        if(bg->GetTypeID(true) != BATTLEGROUND_WS)
+                            continue;
+                        break;
+                    }
+                    case 183:							// EY, capture a flag
+                    {
+                        if(bg->GetTypeID(true) != BATTLEGROUND_EY)
+                            continue;
+
+                        switch(achievementCriteria->referredAchievement)
+                        {
+                            case 211:					// EY, capture flag while controling all 4 bases
+                            {
+                                if(!bg->IsAllNodesConrolledByTeam(GetPlayer()->GetTeam()))
+                                    continue;
+                                break;
+                            }
+                            case 216:					// EY, capture 3 flags without dying
+                            {
+                                if(bg->GetPlayerScore(GetPlayer(),SCORE_DEATHS) != 0)
+                                    continue;
+                                break;
+                            }
+                        }
+                        break;
+                    }
+                    case 122:                           // AB, assault a base
+                    {
+                        if(bg->GetTypeID(true) != BATTLEGROUND_AB)
+                            continue;
+                        
+                        if(miscvalue2 == 1)
+                            continue;
+
+                        break;
+                    }
+                    case 123:                           // AB, defend a base
+                    {
+                        if(bg->GetTypeID(true) != BATTLEGROUND_AB)
+                            continue;
+                        
+                        if(miscvalue2 == 0)
+                            continue;
+
+                        break;
+                    }
+                    case 61:                            // AV, assault a tower
+                    {                   
+                        if(miscvalue2 != 0)
+                            continue;
+                        break;
+                    }
+                    case 63:	                        // AV, take a graveyard
+                    {                   
+                        if(miscvalue2 != 1)
+                            continue;
+                        break;
+                    }
+                    case 64:	                        // AV, defend a tower
+                    {                   
+                        if(miscvalue2 != 2)
+                            continue;
+                        break;
+                    }
+                    case 65:	                        // AV, defend a graveyard
+                    {                   
+                        if(miscvalue2 != 3)
+                            continue;
+                        break;
+                    }
+
+                }
+                SetCriteriaProgress(achievementCriteria, miscvalue1, PROGRESS_ACCUMULATE);
+                break;
+            }
+
             // std case: not exist in DBC, not triggered in code as result
             case ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HEALTH:
             case ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_SPELLPOWER:
@@ -1432,15 +1616,11 @@ void AchievementMgr::UpdateAchievementCriteria(AchievementCriteriaTypes type, ui
             // FIXME: not triggered in code as result, need to implement
             case ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_DAILY_QUEST_DAILY:
             case ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_RAID:
-            case ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE:
-            case ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA:
             case ACHIEVEMENT_CRITERIA_TYPE_WIN_ARENA:
             case ACHIEVEMENT_CRITERIA_TYPE_PLAY_ARENA:
-            case ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL:
             case ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_TEAM_RATING:
             case ACHIEVEMENT_CRITERIA_TYPE_REACH_TEAM_RATING:
             case ACHIEVEMENT_CRITERIA_TYPE_OWN_RANK:
-            case ACHIEVEMENT_CRITERIA_TYPE_GET_KILLING_BLOWS:
             case ACHIEVEMENT_CRITERIA_TYPE_EARNED_PVP_TITLE:
             case ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE_TYPE:
             case ACHIEVEMENT_CRITERIA_TYPE_EARN_ACHIEVEMENT_POINTS:
@@ -1520,6 +1700,8 @@ bool AchievementMgr::IsCompletedCriteria(AchievementCriteriaEntry const* achieve
             return progress->counter >= achievementCriteria->complete_quests_in_zone.questCount;
         case ACHIEVEMENT_CRITERIA_TYPE_DAMAGE_DONE:
         case ACHIEVEMENT_CRITERIA_TYPE_HEALING_DONE:
+        case ACHIEVEMENT_CRITERIA_TYPE_GET_KILLING_BLOWS:
+        case ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL:
             return progress->counter >= achievementCriteria->healing_done.count;
         case ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_DAILY_QUEST:
             return progress->counter >= achievementCriteria->complete_daily_quest.questCount;
@@ -1588,6 +1770,10 @@ bool AchievementMgr::IsCompletedCriteria(AchievementCriteriaEntry const* achieve
             return progress->counter >= achievementCriteria->learn_skill_line.spellCount;
         case ACHIEVEMENT_CRITERIA_TYPE_EARN_HONORABLE_KILL:
             return progress->counter >= achievementCriteria->honorable_kill.killCount;
+        case ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA:
+            return progress->counter >= achievementCriteria->honorable_kill_at_area.killCount;
+        case ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE:
+            return progress->counter >= achievementCriteria->objective_capture.captureCount;
 
         // handle all statistic-only criteria here
         case ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_BATTLEGROUND:
@@ -1694,7 +1880,7 @@ bool AchievementMgr::IsCompletedAchievement(AchievementEntry const* entry)
 
         // completed as have req. count of completed criterias
         if(achievementForTestCount > 0 && achievementForTestCount <= count)
-            return true;
+           return true;
     }
 
     // all criterias completed requirement
diff --git a/mangos/src/game/AchievementMgr.h b/Core/src/game/AchievementMgr.h
index da3328f..3784db3 100644
--- a/mangos/src/game/AchievementMgr.h
+++ b/Core/src/game/AchievementMgr.h
@@ -251,6 +251,7 @@ class AchievementMgr
         void UpdateAchievementCriteria(AchievementCriteriaTypes type, uint32 miscvalue1=0, uint32 miscvalue2=0, Unit *unit=NULL, uint32 time=0);
         void CheckAllAchievementCriteria();
         void SendAllAchievementData();
+        void CompletedAchievement(AchievementEntry const* entry);
         void SendRespondInspectAchievements(Player* player);
         Player* GetPlayer() { return m_player;}
 
@@ -260,7 +261,6 @@ class AchievementMgr
         void SendCriteriaUpdate(uint32 id, CriteriaProgress const* progress);
         void SetCriteriaProgress(AchievementCriteriaEntry const* entry, uint32 changeValue, ProgressType ptype = PROGRESS_SET);
         void CompletedCriteriaFor(AchievementEntry const* achievement);
-        void CompletedAchievement(AchievementEntry const* entry);
         bool IsCompletedCriteria(AchievementCriteriaEntry const* criteria, AchievementEntry const* achievement);
         bool IsCompletedAchievement(AchievementEntry const* entry);
         void CompleteAchievementsWithRefs(AchievementEntry const* entry);
diff --git a/mangos/src/game/AggressorAI.cpp b/Core/src/game/AggressorAI.cpp
index 2cb7606..d31bfcb 100644
--- a/mangos/src/game/AggressorAI.cpp
+++ b/Core/src/game/AggressorAI.cpp
@@ -56,7 +56,6 @@ AggressorAI::MoveInLineOfSight(Unit *u)
             if(!m_creature->getVictim())
             {
                 AttackStart(u);
-                u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
             }
             else if(sMapStore.LookupEntry(m_creature->GetMapId())->IsDungeon())
             {
@@ -103,7 +102,7 @@ void AggressorAI::EnterEvadeMode()
         //i_tracker.Reset(TIME_INTERVAL_LOOK);
     }
 
-    if (!m_creature->isCharmed())
+    if(!m_creature->isCharmed() && !m_creature->GetVehicleGUID())
     {
         m_creature->RemoveAllAuras();
 
@@ -116,6 +115,7 @@ void AggressorAI::EnterEvadeMode()
     i_victimGuid = 0;
     m_creature->CombatStop(true);
     m_creature->SetLootRecipient(NULL);
+    m_creature->ResetObtainedDamage();
 }
 
 void
diff --git a/mangos/src/game/ArenaTeam.cpp b/Core/src/game/ArenaTeam.cpp
index 25ceb77..a7de6a4 100644
--- a/mangos/src/game/ArenaTeam.cpp
+++ b/Core/src/game/ArenaTeam.cpp
@@ -544,8 +544,8 @@ float ArenaTeam::GetChanceAgainst(uint32 own_rating, uint32 enemy_rating)
     // ELO system
 
     if (sWorld.getConfig(CONFIG_UINT32_ARENA_SEASON_ID) >= 6)
-        if (enemy_rating < 1000)
-            enemy_rating = 1000;
+        if (enemy_rating < 1500)
+            enemy_rating = 1500;
     return 1.0f/(1.0f+exp(log(10.0f)*(float)((float)enemy_rating - (float)own_rating)/400.0f));
 }
 
@@ -573,7 +573,7 @@ int32 ArenaTeam::WonAgainst(uint32 againstRating)
     // called when the team has won
     // 'chance' calculation - to beat the opponent
     float chance = GetChanceAgainst(m_stats.rating, againstRating);
-    float K = (m_stats.rating < 1000) ? 48.0f : 32.0f;
+    float K = (m_stats.rating < 1500) ? 48.0f : 32.0f;
     // calculate the rating modification (ELO system with k=32 or k=48 if rating<1000)
     int32 mod = (int32)floor(K* (1.0f - chance));
     // modify the team stats accordingly
@@ -590,9 +590,15 @@ int32 ArenaTeam::LostAgainst(uint32 againstRating)
     // called when the team has lost
     //'chance' calculation - to loose to the opponent
     float chance = GetChanceAgainst(m_stats.rating, againstRating);
-    float K = (m_stats.rating < 1000) ? 48.0f : 32.0f;
+    float K = (m_stats.rating < 1500) ? 48.0f : 32.0f;
     // calculate the rating modification (ELO system with k=32 or k=48 if rating<1000)
     int32 mod = (int32)ceil(K * (0.0f - chance));
+	
+    if(againstRating <= sWorld.getConfig(CONFIG_UINT32_LOSERNOCHANGE) || m_stats.rating <= sWorld.getConfig(CONFIG_UINT32_LOSERNOCHANGE))
+        mod = 0;
+    else if (m_stats.rating <= sWorld.getConfig(CONFIG_UINT32_LOSERHALFCHANGE))
+        mod /= 2;
+
     // modify the team stats accordingly
     FinishGame(mod);
 
@@ -609,9 +615,15 @@ void ArenaTeam::MemberLost(Player * plr, uint32 againstRating)
         {
             // update personal rating
             float chance = GetChanceAgainst(itr->personal_rating, againstRating);
-            float K = (itr->personal_rating < 1000) ? 48.0f : 32.0f;
+            float K = (itr->personal_rating < 1500) ? 48.0f : 32.0f;
             // calculate the rating modification (ELO system with k=32 or k=48 if rating<1000)
             int32 mod = (int32)ceil(K * (0.0f - chance));
+
+            if(againstRating <= sWorld.getConfig(CONFIG_UINT32_LOSERNOCHANGE) || itr->personal_rating <= sWorld.getConfig(CONFIG_UINT32_LOSERNOCHANGE))
+                mod = 0;
+            else if (itr->personal_rating <= sWorld.getConfig(CONFIG_UINT32_LOSERHALFCHANGE))
+                mod /= 2;
+
             itr->ModifyPersonalRating(plr, mod, GetSlot());
             // update personal played stats
             itr->games_week += 1;
@@ -657,7 +669,7 @@ void ArenaTeam::MemberWon(Player * plr, uint32 againstRating)
         {
             // update personal rating
             float chance = GetChanceAgainst(itr->personal_rating, againstRating);
-            float K = (itr->personal_rating < 1000) ? 48.0f : 32.0f;
+            float K = (itr->personal_rating < 1500) ? 48.0f : 32.0f;
             // calculate the rating modification (ELO system with k=32 or k=48 if rating<1000)
             int32 mod = (int32)floor(K* (1.0f - chance));
             itr->ModifyPersonalRating(plr, mod, GetSlot());
diff --git a/Core/src/game/AuctionHouseBot.cpp b/Core/src/game/AuctionHouseBot.cpp
new file mode 100644
index 0000000..93d3413
--- /dev/null
+++ b/Core/src/game/AuctionHouseBot.cpp
@@ -0,0 +1,1490 @@
+#include "AuctionHouseBot.h"
+#include "ObjectMgr.h"
+#include "AuctionHouseMgr.h"
+
+#include "Policies/SingletonImp.h"
+
+INSTANTIATE_SINGLETON_1( AuctionHouseBot );
+
+using namespace std;
+
+AuctionHouseBot::AuctionHouseBot()
+{
+    AllianceConfig = AHBConfig(2);
+    HordeConfig = AHBConfig(6);
+    NeutralConfig = AHBConfig(7);
+}
+
+AuctionHouseBot::~AuctionHouseBot()
+{
+
+}
+
+void AuctionHouseBot::addNewAuctions(Player *AHBplayer, AHBConfig *config)
+{
+    if (!sWorld.getConfig(CONFIG_BOOL_AHBOT_SELLER_ENABLED))
+         return;
+
+    AuctionHouseEntry const* ahEntry = sAuctionMgr.GetAuctionHouseEntry(config->GetAHFID());
+    AuctionHouseObject* auctionHouse = sAuctionMgr.GetAuctionsMap(config->GetAHFID());
+    uint32 items = 0;
+    uint32 minItems = config->GetMinItems();
+    uint32 maxItems = config->GetMaxItems();
+    uint32 auctions = auctionHouse->Getcount();
+    uint32 AuctioneerGUID = 0;
+    switch (config->GetAHID()){
+        case 2:
+            AuctioneerGUID = 79707; //Human in stormwind.
+            break;
+        case 6:
+            AuctioneerGUID = 4656; //orc in Orgrimmar
+            break;
+        case 7:
+            AuctioneerGUID = 23442; //goblin in GZ
+            break;
+        default:
+            sLog.outError("GetAHID() - Default switch reached");
+            AuctioneerGUID = 23442; //default to neutral 7
+            break;
+    }
+
+    if (auctions >= minItems)
+        return;
+
+    if (auctions <= maxItems)
+    {
+        if ((maxItems - auctions) > ItemsPerCycle)
+            items = ItemsPerCycle;
+        else
+            items = (maxItems - auctions);
+    }
+    uint32 greyTGcount = config->GetPercents(AHB_GREY_TG);
+    uint32 whiteTGcount = config->GetPercents(AHB_WHITE_TG);
+    uint32 greenTGcount = config->GetPercents(AHB_GREEN_TG);
+    uint32 blueTGcount = config->GetPercents(AHB_BLUE_TG);
+    uint32 purpleTGcount = config->GetPercents(AHB_PURPLE_TG);
+    uint32 orangeTGcount = config->GetPercents(AHB_ORANGE_TG);
+    uint32 yellowTGcount = config->GetPercents(AHB_YELLOW_TG);
+    uint32 greyIcount = config->GetPercents(AHB_GREY_I);
+    uint32 whiteIcount = config->GetPercents(AHB_WHITE_I);
+    uint32 greenIcount = config->GetPercents(AHB_GREEN_I);
+    uint32 blueIcount = config->GetPercents(AHB_BLUE_I);
+    uint32 purpleIcount = config->GetPercents(AHB_PURPLE_I);
+    uint32 orangeIcount = config->GetPercents(AHB_ORANGE_I);
+    uint32 yellowIcount = config->GetPercents(AHB_YELLOW_I);
+    uint32 total = greyTGcount + whiteTGcount + greenTGcount + blueTGcount
+        + purpleTGcount + orangeTGcount + yellowTGcount
+        + whiteIcount + greenIcount + blueIcount + purpleIcount
+        + orangeIcount + yellowIcount;
+
+    uint32 greyTGoods = 0;
+    uint32 whiteTGoods = 0;
+    uint32 greenTGoods = 0;
+    uint32 blueTGoods = 0;
+    uint32 purpleTGoods = 0;
+    uint32 orangeTGoods = 0;
+    uint32 yellowTGoods = 0;
+
+    uint32 greyItems = 0;
+    uint32 whiteItems = 0;
+    uint32 greenItems = 0;
+    uint32 blueItems = 0;
+    uint32 purpleItems = 0;
+    uint32 orangeItems = 0;
+    uint32 yellowItems = 0;
+
+    for (AuctionHouseObject::AuctionEntryMap::const_iterator itr = auctionHouse->GetAuctionsBegin();itr != auctionHouse->GetAuctionsEnd();++itr)
+    {
+        AuctionEntry *Aentry = itr->second;
+        Item *item = sAuctionMgr.GetAItem(Aentry->item_guidlow);
+        if (item)
+        {
+            ItemPrototype const *prototype = item->GetProto();
+            if (prototype)
+            {
+                switch (prototype->Quality)
+                {
+                case 0:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        ++greyTGoods;
+                    else
+                        ++greyItems;
+                    break;
+                case 1:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        ++whiteTGoods;
+                    else
+                        ++whiteItems;
+                    break;
+                case 2:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        ++greenTGoods;
+                    else
+                        ++greenItems;
+                    break;
+                case 3:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        ++blueTGoods;
+                    else
+                        ++blueItems;
+                    break;
+                case 4:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        ++purpleTGoods;
+                    else
+                        ++purpleItems;
+                    break;
+                case 5:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        ++orangeTGoods;
+                    else
+                        ++orangeItems;
+                    break;
+                case 6:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        ++yellowTGoods;
+                    else
+                        ++yellowItems;
+                    break;
+                }
+            }
+        }
+    }
+
+    // only insert a few at a time, so as not to peg the processor
+    for (uint32 cnt = 1;cnt <= items;cnt++)
+    {
+        uint32 itemID = 0;
+        uint32 loopBreaker = 0;                     // This will prevent endless looping condition where AHBot
+        while (itemID == 0 && loopBreaker < 50)     //  cannot allocate an item.
+        {
+            uint32 choice = urand(0, 13);
+            switch (choice)
+            {
+            case 0:
+                if ((greyItemsBin.size() > 0) && (greyItems < greyIcount))
+                {
+                    itemID = greyItemsBin[urand(0, greyItemsBin.size() - 1)];
+                    ++greyItems;
+                }
+                break;
+            case 1:
+                if ((whiteItemsBin.size() > 0) && (whiteItems < whiteIcount))
+                {
+                    itemID = whiteItemsBin[urand(0, whiteItemsBin.size() - 1)];
+                    ++whiteItems;
+                }
+                break;
+            case 2:
+                if ((greenItemsBin.size() > 0) && (greenItems < greenIcount))
+                {
+                    itemID = greenItemsBin[urand(0, greenItemsBin.size() - 1)];
+                    ++greenItems;
+                }
+                break;
+            case 3:
+                if ((blueItemsBin.size() > 0) && (blueItems < blueIcount))
+                {
+                    itemID = blueItemsBin[urand(0, blueItemsBin.size() - 1)];
+                    ++blueItems;
+                }
+                break;
+            case 4:
+                if ((purpleItemsBin.size() > 0) && (purpleItems < purpleIcount))
+                {
+                    itemID = purpleItemsBin[urand(0, purpleItemsBin.size() - 1)];
+                    ++purpleItems;
+                }
+                break;
+            case 5:
+                if ((orangeItemsBin.size() > 0) && (orangeItems < orangeIcount))
+                {
+                    itemID = orangeItemsBin[urand(0, orangeItemsBin.size() - 1)];
+                    ++orangeItems;
+                }
+                break;
+            case 6:
+                if ((yellowItemsBin.size() > 0) && (yellowItems < yellowIcount))
+                {
+                    itemID = yellowItemsBin[urand(0, yellowItemsBin.size() - 1)];
+                    ++yellowItems;
+                }
+                break;
+            case 7:
+                if ((greyTradeGoodsBin.size() > 0) && (greyTGoods < greyTGcount))
+                {
+                    itemID = whiteTradeGoodsBin[urand(0, whiteTradeGoodsBin.size() - 1)];
+                    ++greyTGoods;
+                }
+                break;
+            case 8:
+                if ((whiteTradeGoodsBin.size() > 0) && (whiteTGoods < whiteTGcount))
+                {
+                    itemID = whiteTradeGoodsBin[urand(0, whiteTradeGoodsBin.size() - 1)];
+                    ++whiteTGoods;
+                }
+                break;
+            case 9:
+                if ((greenTradeGoodsBin.size() > 0) && (greenTGoods < greenTGcount))
+                {
+                    itemID = greenTradeGoodsBin[urand(0, greenTradeGoodsBin.size() - 1)];
+                    ++greenTGoods;
+                }
+                break;
+            case 10:
+                if ((blueTradeGoodsBin.size() > 0) && (blueTGoods < blueTGcount))
+                {
+                    itemID = blueTradeGoodsBin[urand(0, blueTradeGoodsBin.size() - 1)];
+                    ++blueTGoods;
+                }
+                break;
+            case 11:
+                if ((purpleTradeGoodsBin.size() > 0) && (purpleTGoods < purpleTGcount))
+                {
+                    itemID = purpleTradeGoodsBin[urand(0, purpleTradeGoodsBin.size() - 1)];
+                    ++purpleTGoods;
+                }
+                break;
+            case 12:
+                if ((orangeTradeGoodsBin.size() > 0) && (orangeTGoods < orangeTGcount))
+                {
+                    itemID = orangeTradeGoodsBin[urand(0, orangeTradeGoodsBin.size() - 1)];
+                    ++orangeTGoods;
+                }
+                break;
+            case 13:
+                if ((yellowTradeGoodsBin.size() > 0) && (yellowTGoods < yellowTGcount))
+                {
+                    itemID = yellowTradeGoodsBin[urand(0, yellowTradeGoodsBin.size() - 1)];
+                    ++yellowTGoods;
+                }
+                break;
+            default:
+                sLog.outString("AuctionHouseBot> itemID Switch - Default Reached");
+                break;
+            }
+
+            ++loopBreaker;
+        }
+
+        if (itemID == 0)
+        {
+            if (debug_Out)
+                sLog.outString("AuctionHouseBot> Item::CreateItem() - Unable to find item");
+            continue;
+        }
+
+        ItemPrototype const* prototype = sObjectMgr.GetItemPrototype(itemID);
+        if (prototype == NULL)
+        {
+            sLog.outString("AuctionHouseBot> Huh?!?! prototype == NULL");
+            continue;
+        }
+
+        // Disable Items with an item level lower than X
+        if ((sWorld.getConfig(CONFIG_UINT32_AHBOT_ITEM_MIN_ITEM_LEVEL)) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->ItemLevel < sWorld.getConfig(CONFIG_UINT32_AHBOT_ITEM_MIN_ITEM_LEVEL)))
+            continue;
+
+        // Disable Items with an item level higher than X
+        if ((sWorld.getConfig(CONFIG_UINT32_AHBOT_ITEM_MAX_ITEM_LEVEL)) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->ItemLevel > sWorld.getConfig(CONFIG_UINT32_AHBOT_ITEM_MAX_ITEM_LEVEL)))
+            continue;
+
+        // Disable trade goods with an item level lower than X
+        if ((sWorld.getConfig(CONFIG_UINT32_AHBOT_TG_MIN_ITEM_LEVEL)) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->ItemLevel < sWorld.getConfig(CONFIG_UINT32_AHBOT_TG_MIN_ITEM_LEVEL)))
+            continue;
+
+        // Disable trade goods with an item level higher than X
+        if ((sWorld.getConfig(CONFIG_UINT32_AHBOT_TG_MAX_ITEM_LEVEL)) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->ItemLevel > sWorld.getConfig(CONFIG_UINT32_AHBOT_TG_MAX_ITEM_LEVEL)))
+            continue;
+
+
+        // Disable items for level lower than X
+        if ((sWorld.getConfig(CONFIG_UINT32_AHBOT_ITEM_MIN_REQ_LEVEL)) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->RequiredLevel < sWorld.getConfig(CONFIG_UINT32_AHBOT_ITEM_MIN_REQ_LEVEL)))
+            continue;
+
+        // Disable items for level higher than X
+        if ((sWorld.getConfig(CONFIG_UINT32_AHBOT_ITEM_MAX_REQ_LEVEL)) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->RequiredLevel > sWorld.getConfig(CONFIG_UINT32_AHBOT_ITEM_MAX_REQ_LEVEL)))
+            continue;
+
+        // Disable trade goods for level lower than X
+        if ((sWorld.getConfig(CONFIG_UINT32_AHBOT_TG_MIN_REQ_LEVEL)) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->RequiredLevel < sWorld.getConfig(CONFIG_UINT32_AHBOT_TG_MIN_REQ_LEVEL)))
+            continue;
+
+        // Disable trade goods for level higher than X
+        if ((sWorld.getConfig(CONFIG_UINT32_AHBOT_TG_MAX_REQ_LEVEL)) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->RequiredLevel > sWorld.getConfig(CONFIG_UINT32_AHBOT_TG_MAX_REQ_LEVEL)))
+            continue;
+
+
+        // Disable items with skill requirement lower then X
+        if ((sWorld.getConfig(CONFIG_UINT32_AHBOT_ITEM_MIN_SKILL_RANK)) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->RequiredSkillRank < sWorld.getConfig(CONFIG_UINT32_AHBOT_ITEM_MIN_SKILL_RANK)))
+            continue;
+
+        // Disable items with skill requirement higher then X
+        if ((sWorld.getConfig(CONFIG_UINT32_AHBOT_ITEM_MAX_SKILL_RANK)) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->RequiredSkillRank < sWorld.getConfig(CONFIG_UINT32_AHBOT_ITEM_MAX_SKILL_RANK)))
+            continue;
+
+        // Disable trade goods with skill requirement lower then X
+        if ((sWorld.getConfig(CONFIG_UINT32_AHBOT_TG_MIN_SKILL_RANK)) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->RequiredSkillRank < sWorld.getConfig(CONFIG_UINT32_AHBOT_TG_MIN_SKILL_RANK)))
+            continue;
+
+        // Disable trade goods with skill requirement higher then X
+        if ((sWorld.getConfig(CONFIG_UINT32_AHBOT_TG_MAX_SKILL_RANK)) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->RequiredSkillRank < sWorld.getConfig(CONFIG_UINT32_AHBOT_TG_MAX_SKILL_RANK)))
+            continue;
+
+
+        Item* item = Item::CreateItem(itemID, 1, AHBplayer);
+        item->AddToUpdateQueueOf(AHBplayer);
+        if (item == NULL)
+        {
+            sLog.outString("AuctionHouseBot> Item::CreateItem() returned NULL");
+            break;
+        }
+
+        uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(itemID);
+        if (randomPropertyId != 0)
+            item->SetItemRandomProperties(randomPropertyId);
+
+        uint32 buyoutPrice;
+        uint32 bidPrice = 0;
+        uint32 stackCount = urand(1, item->GetMaxStackCount());
+
+        if(sWorld.getConfig(CONFIG_BOOL_AHBOT_BUYPRICE_SELLER))
+            buyoutPrice  = prototype->BuyPrice * item->GetCount();
+        else
+            buyoutPrice  = prototype->SellPrice * item->GetCount();
+
+        switch (prototype->Quality)
+        {
+        case 0:
+            if (config->GetMaxStack(AHB_GREY) != 0)
+            {
+                stackCount = urand(1, minValue(item->GetMaxStackCount(), config->GetMaxStack(AHB_GREY)));
+            }
+            buyoutPrice *= urand(config->GetMinPrice(AHB_GREY), config->GetMaxPrice(AHB_GREY)) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * urand(config->GetMinBidPrice(AHB_GREY), config->GetMaxBidPrice(AHB_GREY));
+            bidPrice /= 100;
+            break;
+        case 1:
+            if (config->GetMaxStack(AHB_WHITE) != 0)
+            {
+                stackCount = urand(1, minValue(item->GetMaxStackCount(), config->GetMaxStack(AHB_WHITE)));
+            }
+            buyoutPrice *= urand(config->GetMinPrice(AHB_WHITE), config->GetMaxPrice(AHB_WHITE)) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * urand(config->GetMinBidPrice(AHB_WHITE), config->GetMaxBidPrice(AHB_WHITE));
+            bidPrice /= 100;
+            break;
+        case 2:
+            if (config->GetMaxStack(AHB_GREEN) != 0)
+            {
+                stackCount = urand(1, minValue(item->GetMaxStackCount(), config->GetMaxStack(AHB_GREEN)));
+            }
+            buyoutPrice *= urand(config->GetMinPrice(AHB_GREEN), config->GetMaxPrice(AHB_GREEN)) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * urand(config->GetMinBidPrice(AHB_GREEN), config->GetMaxBidPrice(AHB_GREEN));
+            bidPrice /= 100;
+            break;
+        case 3:
+            if (config->GetMaxStack(AHB_BLUE) != 0)
+            {
+                stackCount = urand(1, minValue(item->GetMaxStackCount(), config->GetMaxStack(AHB_BLUE)));
+            }
+            buyoutPrice *= urand(config->GetMinPrice(AHB_BLUE), config->GetMaxPrice(AHB_BLUE)) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * urand(config->GetMinBidPrice(AHB_BLUE), config->GetMaxBidPrice(AHB_BLUE));
+            bidPrice /= 100;
+            break;
+        case 4:
+            if (config->GetMaxStack(AHB_PURPLE) != 0)
+            {
+                stackCount = urand(1, minValue(item->GetMaxStackCount(), config->GetMaxStack(AHB_PURPLE)));
+            }
+            buyoutPrice *= urand(config->GetMinPrice(AHB_PURPLE), config->GetMaxPrice(AHB_PURPLE)) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * urand(config->GetMinBidPrice(AHB_PURPLE), config->GetMaxBidPrice(AHB_PURPLE));
+            bidPrice /= 100;
+            break;
+        case 5:
+            if (config->GetMaxStack(AHB_ORANGE) != 0)
+            {
+                stackCount = urand(1, minValue(item->GetMaxStackCount(), config->GetMaxStack(AHB_ORANGE)));
+            }
+            buyoutPrice *= urand(config->GetMinPrice(AHB_ORANGE), config->GetMaxPrice(AHB_ORANGE)) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * urand(config->GetMinBidPrice(AHB_ORANGE), config->GetMaxBidPrice(AHB_ORANGE));
+            bidPrice /= 100;
+            break;
+        case 6:
+            if (config->GetMaxStack(AHB_YELLOW) != 0)
+            {
+                stackCount = urand(1, minValue(item->GetMaxStackCount(), config->GetMaxStack(AHB_YELLOW)));
+            }
+            buyoutPrice *= urand(config->GetMinPrice(AHB_YELLOW), config->GetMaxPrice(AHB_YELLOW)) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * urand(config->GetMinBidPrice(AHB_YELLOW), config->GetMaxBidPrice(AHB_YELLOW));
+            bidPrice /= 100;
+            break;
+        }
+
+        item->SetCount(stackCount);
+
+        AuctionEntry* auctionEntry = new AuctionEntry;
+        auctionEntry->Id = sObjectMgr.GenerateAuctionID();
+        auctionEntry->auctioneer = AuctioneerGUID;
+        auctionEntry->item_guidlow = item->GetGUIDLow();
+        auctionEntry->item_template = item->GetEntry();
+        auctionEntry->owner = AHBplayer->GetGUIDLow();
+        auctionEntry->startbid = bidPrice;
+        auctionEntry->buyout = buyoutPrice;
+        auctionEntry->bidder = 0;
+        auctionEntry->bid = 0;
+        auctionEntry->deposit = 0;
+        auctionEntry->expire_time = (time_t) (urand(config->GetMinTime(), config->GetMaxTime()) * 60 * 60 + time(NULL));
+        auctionEntry->auctionHouseEntry = ahEntry;
+        item->SaveToDB();
+        item->RemoveFromUpdateQueueOf(AHBplayer);
+        sAuctionMgr.AddAItem(item);
+        auctionHouse->AddAuction(auctionEntry);
+        auctionEntry->SaveToDB();
+    }
+}
+
+void AuctionHouseBot::addNewAuctionBuyerBotBid(Player *AHBplayer, AHBConfig *config, WorldSession *session)
+{
+    if (!sWorld.getConfig(CONFIG_BOOL_AHBOT_BUYER_ENABLED))
+        return;
+
+    // Fetches content of selected AH
+    AuctionHouseObject* auctionHouse = sAuctionMgr.GetAuctionsMap(config->GetAHFID());
+    vector<uint32> possibleBids;
+
+    for (AuctionHouseObject::AuctionEntryMap::const_iterator itr = auctionHouse->GetAuctionsBegin();itr != auctionHouse->GetAuctionsEnd();++itr)
+    {
+        // Check if the auction is ours
+        // if it is, we skip this iteration.
+        if (itr->second->owner == sWorld.getConfig(CONFIG_UINT32_AHBOT_CHARACTER_ID))
+        {
+            continue;
+        }
+        // Check that we haven't bidded in this auction already.
+        if (itr->second->bidder != sWorld.getConfig(CONFIG_UINT32_AHBOT_CHARACTER_ID))
+        {
+            uint32 tmpdata = itr->second->Id;
+            possibleBids.push_back(tmpdata);
+        }
+    }
+
+    for (uint32 count = 0;count < config->GetBidsPerInterval();++count)
+    {
+
+        // Do we have anything to bid? If not, stop here.
+        if (possibleBids.empty())
+        {
+            count = config->GetBidsPerInterval();
+            continue;
+        }
+
+        // Choose random auction from possible auctions
+        uint32 vectorPos = urand(0, possibleBids.size() - 1);
+        uint32 auctionID = possibleBids[vectorPos];
+
+        // Erase the auction from the vector to prevent bidding on item in next iteration.
+        vector<uint32>::iterator iter = possibleBids.begin();
+        advance(iter, vectorPos);
+        possibleBids.erase(iter);
+
+        // from auctionhousehandler.cpp, creates auction pointer & player pointer
+        AuctionEntry* auction = auctionHouse->GetAuction(auctionID);
+        if (!auction)
+        {
+            sLog.outError("Item doesn't exists, perhaps bought already?");
+            continue;
+        }
+
+        // get exact item information
+        Item *pItem = sAuctionMgr.GetAItem(auction->item_guidlow);
+        if (!pItem)
+        {
+            sLog.outError("Item doesn't exists, perhaps bought already?");
+            continue;
+        }
+
+        // get item prototype
+        ItemPrototype const* prototype = sObjectMgr.GetItemPrototype(auction->item_template);
+
+        // check which price we have to use, startbid or if it is bidded already
+        if (debug_Out)
+        {
+            sLog.outError("Auction Number: %u", auction->Id);
+            sLog.outError("Item Template: %u", auction->item_template);
+            sLog.outError("Buy Price: %u", prototype->BuyPrice);
+            sLog.outError("Sell Price: %u", prototype->SellPrice);
+            sLog.outError("Quality: %u", prototype->Quality);
+        }
+        uint32 currentprice;
+        if (auction->bid)
+        {
+            currentprice = auction->bid;
+            if (debug_Out)
+                sLog.outError("Current Price: %u", auction->bid);
+        }
+        else
+        {
+            currentprice = auction->startbid;
+            if (debug_Out)
+                sLog.outError("Current Price: %u", auction->startbid);
+        }
+        uint32 bidprice;
+
+        // Prepare portion from maximum bid
+        uint32 tmprate2 = urand(0, 100);
+        double tmprate = static_cast<double>(tmprate2);
+        if (debug_Out)
+            sLog.outError("tmprate: %f", tmprate);
+
+        double bidrate = tmprate / 100;
+        if (debug_Out)
+            sLog.outError("bidrate: %f", bidrate);
+
+        long double bidMax = 0;
+
+        // check that bid has acceptable value and take bid based on vendorprice, stacksize and quality
+        if(sWorld.getConfig(CONFIG_BOOL_AHBOT_BUYPRICE_BUYER))
+        {
+            switch (prototype->Quality)
+            {
+                case 0:
+                    if (currentprice < prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_GREY))
+                    {
+                        bidMax = prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_GREY);
+                    }
+                    break;
+                case 1:
+                    if (currentprice < prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_WHITE))
+                    {
+                        bidMax = prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_WHITE);
+                    }
+                    break;
+                case 2:
+                    if (currentprice < prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_GREEN))
+                    {
+                        bidMax = prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_GREEN);
+                    }
+                    break;
+                case 3:
+                    if (currentprice < prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_BLUE))
+                    {
+                        bidMax = prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_BLUE);
+                    }
+                    break;
+                case 4:
+                    if (currentprice < prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_PURPLE))
+                    {
+                        bidMax = prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_PURPLE);
+                    }
+                    break;
+                case 5:
+                    if (currentprice < prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_ORANGE))
+                    {
+                        bidMax = prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_ORANGE);
+                    }
+                    break;
+                case 6:
+                    if (currentprice < prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_YELLOW))
+                    {
+                        bidMax = prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_YELLOW);
+                    }
+                    break;
+                default:
+                    // quality is something it shouldn't be, let's get out of here
+                    if (debug_Out)
+                        sLog.outError("bidMax(fail): %f", bidMax);
+                    continue;
+                    break;
+            }
+        }
+        else
+        {
+            switch (prototype->Quality)
+            {
+                case 0:
+                    if (currentprice < prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_GREY))
+                    {
+                        bidMax = prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_GREY);
+                    }
+                    break;
+                case 1:
+                    if (currentprice < prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_WHITE))
+                    {
+                        bidMax = prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_WHITE);
+                    }
+                    break;
+                case 2:
+                    if (currentprice < prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_GREEN))
+                    {
+                        bidMax = prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_GREEN);
+                    }
+                    break;
+                case 3:
+                    if (currentprice < prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_BLUE))
+                    {
+                        bidMax = prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_BLUE);
+                    }
+                    break;
+                case 4:
+                    if (currentprice < prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_PURPLE))
+                   {
+                        bidMax = prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_PURPLE);
+                    }
+                    break;
+                case 5:
+                    if (currentprice < prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_ORANGE))
+                    {
+                        bidMax = prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_ORANGE);
+                    }
+                    break;
+                case 6:
+                    if (currentprice < prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_YELLOW))
+                    {
+                        bidMax = prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(AHB_YELLOW);
+                    }
+                    break;
+                default:
+                    // quality is something it shouldn't be, let's get out of here
+                    if (debug_Out)
+                        sLog.outError("bidMax(fail): %f", bidMax);
+                    continue;
+                    break;
+            }
+        }
+
+        if (debug_Out)
+            sLog.outError("bidMax(succeed): %f", bidMax);
+
+        // check some special items, and do recalculating to their prices
+        switch (prototype->Class)
+        {
+            // ammo
+            case 6:
+                bidMax = 0;
+                break;
+            default:
+                break;
+        }
+
+        if (bidMax == 0)
+            continue;   // quality check failed to get bidmax, let's get out of here
+
+        // Calculate our bid
+        long double bidvalue = currentprice + ((bidMax - currentprice) * bidrate);
+        if (debug_Out)
+            sLog.outError("bidvalue: %f", bidvalue);
+
+        // Convert to uint32
+        bidprice = static_cast<uint32>(bidvalue);
+        if (debug_Out)
+            sLog.outError("bidprice: %u", bidprice);
+
+        // Check our bid is high enough to be valid. If not, correct it to minimum.
+        if ((currentprice + auction->GetAuctionOutBid()) > bidprice)
+        {
+            bidprice = currentprice + auction->GetAuctionOutBid();
+            if (debug_Out)
+                sLog.outError("bidprice(>): %u", bidprice);
+        }
+
+        // Check wether we do normal bid, or buyout
+        if ((bidprice < auction->buyout) || (auction->buyout == 0))
+        {
+
+            if (auction->bidder > 0)
+            {
+                if (auction->bidder == AHBplayer->GetGUIDLow())
+                {
+                    //pl->ModifyMoney(-int32(price - auction->bid));
+                }
+                else
+                {
+                    // mail to last bidder and return money
+                    session->SendAuctionOutbiddedMail(auction , bidprice);
+                    //pl->ModifyMoney(-int32(price));
+                }
+            }
+
+            auction->bidder = AHBplayer->GetGUIDLow();
+            auction->bid = bidprice;
+
+            // Saving auction into database
+            CharacterDatabase.PExecute("UPDATE auctionhouse SET buyguid = '%u',lastbid = '%u' WHERE id = '%u'", auction->bidder, auction->bid, auction->Id);
+        }
+        else
+        {
+            //buyout
+            if (AHBplayer->GetGUIDLow() == auction->bidder)
+            {
+                //pl->ModifyMoney(-int32(auction->buyout - auction->bid));
+            }
+            else
+            {
+                //pl->ModifyMoney(-int32(auction->buyout));
+                if (auction->bidder)
+                {
+                    session->SendAuctionOutbiddedMail(auction, auction->buyout);
+                }
+            }
+            auction->bidder = AHBplayer->GetGUIDLow();
+            auction->bid = auction->buyout;
+
+            // Send mails to buyer & seller
+            sAuctionMgr.SendAuctionSuccessfulMail(auction);
+            sAuctionMgr.SendAuctionWonMail(auction);
+
+            // Remove item from auctionhouse
+            sAuctionMgr.RemoveAItem(auction->item_guidlow);
+            // Remove auction
+            auctionHouse->RemoveAuction(auction->Id);
+            // Remove from database
+            auction->DeleteFromDB();
+        }
+    }
+}
+
+void AuctionHouseBot::Update()
+{
+    time_t _newrun = time(NULL);
+    if ((!sWorld.getConfig(CONFIG_BOOL_AHBOT_SELLER_ENABLED)) && (!sWorld.getConfig(CONFIG_BOOL_AHBOT_BUYER_ENABLED)))
+        return;
+
+    WorldSession _session(sWorld.getConfig(CONFIG_UINT32_AHBOT_ACCOUNT_ID), NULL, SEC_PLAYER, true, 0, LOCALE_enUS);
+
+    Player _AHBplayer(&_session);
+    _AHBplayer.Initialize(sWorld.getConfig(CONFIG_UINT32_AHBOT_CHARACTER_ID));
+    ObjectAccessor::Instance().AddObject(&_AHBplayer);
+
+    // Add New Bids
+    if (!sWorld.getConfig(CONFIG_BOOL_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    {
+        addNewAuctions(&_AHBplayer, &AllianceConfig);
+        if (((_newrun - _lastrun_a) > (AllianceConfig.GetBiddingInterval() * 60)) && (AllianceConfig.GetBidsPerInterval() > 0))
+        {
+            addNewAuctionBuyerBotBid(&_AHBplayer, &AllianceConfig, &_session);
+            _lastrun_a = _newrun;
+        }
+
+        addNewAuctions(&_AHBplayer, &HordeConfig);
+        if (((_newrun - _lastrun_h) > (HordeConfig.GetBiddingInterval() *60)) && (HordeConfig.GetBidsPerInterval() > 0))
+        {
+            addNewAuctionBuyerBotBid(&_AHBplayer, &HordeConfig, &_session);
+            _lastrun_h = _newrun;
+        }
+    }
+    addNewAuctions(&_AHBplayer, &NeutralConfig);
+    if (((_newrun - _lastrun_n) > (NeutralConfig.GetBiddingInterval() * 60)) && (NeutralConfig.GetBidsPerInterval() > 0))
+    {
+        addNewAuctionBuyerBotBid(&_AHBplayer, &NeutralConfig, &_session);
+        _lastrun_n = _newrun;
+    }
+
+    ObjectAccessor::Instance().RemoveObject(&_AHBplayer);
+}
+
+void AuctionHouseBot::LoadDbConfig()
+{
+    if (!sWorld.getConfig(CONFIG_BOOL_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    {
+        LoadValues(&AllianceConfig);
+        LoadValues(&HordeConfig);
+    }
+    LoadValues(&NeutralConfig);
+}
+
+void AuctionHouseBot::Initialize()
+{
+    debug_Out = sConfig.GetIntDefault("AuctionHouseBot.DEBUG", 0);
+    ItemsPerCycle = sWorld.getConfig(CONFIG_UINT32_AHBOT_ITEMS_CYCLE);
+    LoadDbConfig();
+
+    if (sWorld.getConfig(CONFIG_BOOL_AHBOT_SELLER_ENABLED))
+    {
+        QueryResult* results = (QueryResult*) NULL;
+        char npcQuery[] = "SELECT distinct `item` FROM `npc_vendor`";
+        results = WorldDatabase.PQuery(npcQuery);
+        if (results != NULL)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                npcItems.push_back(fields[0].GetUInt32());
+
+            } while (results->NextRow());
+
+            delete results;
+        }
+        else
+        {
+            sLog.outString("AuctionHouseBot> \"%s\" failed", npcQuery);
+        }
+
+        char lootQuery[] = "SELECT `item` FROM `creature_loot_template` UNION "
+            "SELECT `item` FROM `disenchant_loot_template` UNION "
+            "SELECT `item` FROM `fishing_loot_template` UNION "
+            "SELECT `item` FROM `gameobject_loot_template` UNION "
+            "SELECT `item` FROM `item_loot_template` UNION "
+            "SELECT `item` FROM `milling_loot_template` UNION "
+            "SELECT `item` FROM `pickpocketing_loot_template` UNION "
+            "SELECT `item` FROM `prospecting_loot_template` UNION "
+            "SELECT `item` FROM `skinning_loot_template`";
+
+        results = WorldDatabase.PQuery(lootQuery);
+        if (results != NULL)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                lootItems.push_back(fields[0].GetUInt32());
+
+            } while (results->NextRow());
+
+            delete results;
+        }
+        else
+        {
+            sLog.outString("AuctionHouseBot> \"%s\" failed", lootQuery);
+        }
+
+        for (uint32 itemID = 0; itemID < sItemStorage.MaxEntry; itemID++)
+        {
+            ItemPrototype const* prototype = sObjectMgr.GetItemPrototype(itemID);
+
+            if (prototype == NULL)
+                continue;
+
+            switch (prototype->Bonding)
+            {
+                case 0:
+                    if (!sWorld.getConfig(CONFIG_BOOL_AHBOT_BIND_NO))
+                        continue;
+                    break;
+                case 1:
+                    if (!sWorld.getConfig(CONFIG_BOOL_AHBOT_BIND_PICKUP))
+                        continue;
+                    break;
+                case 2:
+                    if (!sWorld.getConfig(CONFIG_BOOL_AHBOT_BIND_EQUIP))
+                        continue;
+                    break;
+                case 3:
+                    if (!sWorld.getConfig(CONFIG_BOOL_AHBOT_BIND_USE))
+                        continue;
+                    break;
+                case 4:
+                    if (!sWorld.getConfig(CONFIG_BOOL_AHBOT_BIND_QUEST))
+                        continue;
+                    break;
+                default:
+                    continue;
+                    break;
+            }
+
+            if(sWorld.getConfig(CONFIG_BOOL_AHBOT_BUYPRICE_SELLER))
+            {
+                if(prototype->BuyPrice == 0)
+                    continue;
+            }
+            else
+            {
+                if (prototype->SellPrice == 0)
+                    continue;
+            }
+
+            if ((prototype->Quality < 0) || (prototype->Quality > 6))
+                continue;
+
+            if (!sWorld.getConfig(CONFIG_BOOL_AHBOT_ITEMS_VENDOR))
+            {
+                bool isVendorItem = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+                {
+                    if (itemID == npcItems[i])
+                        isVendorItem = true;
+                }
+
+                if (isVendorItem)
+                    continue;
+            }
+
+            if (!sWorld.getConfig(CONFIG_BOOL_AHBOT_ITEMS_LOOT))
+            {
+                bool isLootItem = false;
+
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+                {
+                    if (itemID == lootItems[i])
+                        isLootItem = true;
+                }
+
+                if (isLootItem)
+                    continue;
+            }
+
+            if (!sWorld.getConfig(CONFIG_BOOL_AHBOT_ITEMS_MISC))
+            {
+                bool isVendorItem = false;
+                bool isLootItem = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+                {
+                    if (itemID == npcItems[i])
+                        isVendorItem = true;
+                }
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+                {
+                    if (itemID == lootItems[i])
+                        isLootItem = true;
+                }
+                if ((!isLootItem) && (!isVendorItem))
+                    continue;
+            }
+
+            switch (prototype->Quality)
+            {
+                case 0:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        greyTradeGoodsBin.push_back(itemID);
+                    else
+                        greyItemsBin.push_back(itemID);
+                    break;
+
+                case 1:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        whiteTradeGoodsBin.push_back(itemID);
+                    else
+                        whiteItemsBin.push_back(itemID);
+                    break;
+
+                case 2:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        greenTradeGoodsBin.push_back(itemID);
+                    else
+                        greenItemsBin.push_back(itemID);
+                    break;
+
+                case 3:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        blueTradeGoodsBin.push_back(itemID);
+                    else
+                        blueItemsBin.push_back(itemID);
+                    break;
+
+                case 4:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        purpleTradeGoodsBin.push_back(itemID);
+                    else
+                        purpleItemsBin.push_back(itemID);
+                    break;
+
+                case 5:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        orangeTradeGoodsBin.push_back(itemID);
+                    else
+                        orangeItemsBin.push_back(itemID);
+                    break;
+
+                case 6:
+                    if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                        yellowTradeGoodsBin.push_back(itemID);
+                    else
+                        yellowItemsBin.push_back(itemID);
+                    break;
+            }
+        }
+
+        if (
+            (greyTradeGoodsBin.size() == 0) &&
+            (whiteTradeGoodsBin.size() == 0) &&
+            (greenTradeGoodsBin.size() == 0) &&
+            (blueTradeGoodsBin.size() == 0) &&
+            (purpleTradeGoodsBin.size() == 0) &&
+            (orangeTradeGoodsBin.size() == 0) &&
+            (yellowTradeGoodsBin.size() == 0) &&
+            (greyItemsBin.size() == 0) &&
+            (whiteItemsBin.size() == 0) &&
+            (greenItemsBin.size() == 0) &&
+            (blueItemsBin.size() == 0) &&
+            (purpleItemsBin.size() == 0) &&
+            (orangeItemsBin.size() == 0) &&
+            (yellowItemsBin.size() == 0)
+            )
+        {
+            sLog.outString("AuctionHouseBot> No items");
+            sWorld.setConfig(CONFIG_BOOL_AHBOT_SELLER_ENABLED, false);
+        }
+
+        sLog.outString("========AuctionHouseBot========");
+        sLog.outString("loaded %d grey trade goods", greyTradeGoodsBin.size());
+        sLog.outString("loaded %d white trade goods", whiteTradeGoodsBin.size());
+        sLog.outString("loaded %d green trade goods", greenTradeGoodsBin.size());
+        sLog.outString("loaded %d blue trade goods", blueTradeGoodsBin.size());
+        sLog.outString("loaded %d purple trade goods", purpleTradeGoodsBin.size());
+        sLog.outString("loaded %d orange trade goods", orangeTradeGoodsBin.size());
+        sLog.outString("loaded %d yellow trade goods", yellowTradeGoodsBin.size());
+        sLog.outString("loaded %d grey items", greyItemsBin.size());
+        sLog.outString("loaded %d white items", whiteItemsBin.size());
+        sLog.outString("loaded %d green items", greenItemsBin.size());
+        sLog.outString("loaded %d blue items", blueItemsBin.size());
+        sLog.outString("loaded %d purple items", purpleItemsBin.size());
+        sLog.outString("loaded %d orange items", orangeItemsBin.size());
+        sLog.outString("loaded %d yellow items", yellowItemsBin.size());
+    }
+    sLog.outString("AuctionHouseBot is now loaded.");
+    sLog.outString("AuctionHouseBot: updated by Xeross and Darkrulerz");
+}
+
+void AuctionHouseBot::Commands(uint32 command, uint32 ahMapID, uint32 col, char* args)
+{
+    AHBConfig *config;
+    switch (ahMapID)
+    {
+    case 2:
+        config = &AllianceConfig;
+        break;
+    case 6:
+        config = &HordeConfig;
+        break;
+    case 7:
+        config = &NeutralConfig;
+        break;
+    }
+    std::string color;
+    switch (col)
+    {
+    case AHB_GREY:
+        color = "grey";
+        break;
+    case AHB_WHITE:
+        color = "white";
+        break;
+    case AHB_GREEN:
+        color = "green";
+        break;
+    case AHB_BLUE:
+        color = "blue";
+        break;
+    case AHB_PURPLE:
+        color = "purple";
+        break;
+    case AHB_ORANGE:
+        color = "orange";
+        break;
+    case AHB_YELLOW:
+        color = "yellow";
+        break;
+    default:
+        break;
+    }
+    switch (command)
+    {
+    case 0:     //ahexpire
+        {
+            AuctionHouseObject* auctionHouse = sAuctionMgr.GetAuctionsMap(config->GetAHFID());
+
+            AuctionHouseObject::AuctionEntryMap::iterator itr;
+            itr = auctionHouse->GetAuctionsBegin();
+
+            while (itr != auctionHouse->GetAuctionsEnd())
+            {
+                if (itr->second->owner == sWorld.getConfig(CONFIG_UINT32_AHBOT_CHARACTER_ID))
+                    itr->second->expire_time = sWorld.GetGameTime();
+
+                ++itr;
+            }
+        }break;
+    case 1:     //min items
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minItems = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minitems = '%u' WHERE auctionhouse = '%u'", minItems, ahMapID);
+            config->SetMinItems(minItems);
+        }break;
+    case 2:     //max items
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxItems = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxitems = '%u' WHERE auctionhouse = '%u'", maxItems, ahMapID);
+            config->SetMaxItems(maxItems);
+        }break;
+    case 3:     //min time
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minTime = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET mintime = '%u' WHERE auctionhouse = '%u'", minTime, ahMapID);
+            config->SetMinTime(minTime);
+        }break;
+    case 4:     //max time
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxTime = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxtime = '%u' WHERE auctionhouse = '%u'", maxTime, ahMapID);
+            config->SetMaxTime(maxTime);
+        }break;
+    case 5:     //percentages
+        {
+            char * param1 = strtok(args, " ");
+            char * param2 = strtok(NULL, " ");
+            char * param3 = strtok(NULL, " ");
+            char * param4 = strtok(NULL, " ");
+            char * param5 = strtok(NULL, " ");
+            char * param6 = strtok(NULL, " ");
+            char * param7 = strtok(NULL, " ");
+            char * param8 = strtok(NULL, " ");
+            char * param9 = strtok(NULL, " ");
+            char * param10 = strtok(NULL, " ");
+            char * param11 = strtok(NULL, " ");
+            char * param12 = strtok(NULL, " ");
+            char * param13 = strtok(NULL, " ");
+            char * param14 = strtok(NULL, " ");
+            uint32 greytg = (uint32) strtoul(param1, NULL, 0);
+            uint32 whitetg = (uint32) strtoul(param2, NULL, 0);
+            uint32 greentg = (uint32) strtoul(param3, NULL, 0);
+            uint32 bluetg = (uint32) strtoul(param4, NULL, 0);
+            uint32 purpletg = (uint32) strtoul(param5, NULL, 0);
+            uint32 orangetg = (uint32) strtoul(param6, NULL, 0);
+            uint32 yellowtg = (uint32) strtoul(param7, NULL, 0);
+            uint32 greyi = (uint32) strtoul(param8, NULL, 0);
+            uint32 whitei = (uint32) strtoul(param9, NULL, 0);
+            uint32 greeni = (uint32) strtoul(param10, NULL, 0);
+            uint32 bluei = (uint32) strtoul(param11, NULL, 0);
+            uint32 purplei = (uint32) strtoul(param12, NULL, 0);
+            uint32 orangei = (uint32) strtoul(param13, NULL, 0);
+            uint32 yellowi = (uint32) strtoul(param14, NULL, 0);
+
+            CharacterDatabase.BeginTransaction();
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentgreytradegoods = '%u' WHERE auctionhouse = '%u'", greytg, ahMapID);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentwhitetradegoods = '%u' WHERE auctionhouse = '%u'", whitetg, ahMapID);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentgreentradegoods = '%u' WHERE auctionhouse = '%u'", greentg, ahMapID);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentbluetradegoods = '%u' WHERE auctionhouse = '%u'", bluetg, ahMapID);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentpurpletradegoods = '%u' WHERE auctionhouse = '%u'", purpletg, ahMapID);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentorangetradegoods = '%u' WHERE auctionhouse = '%u'", orangetg, ahMapID);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentyellowtradegoods = '%u' WHERE auctionhouse = '%u'", yellowtg, ahMapID);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentgreyitems = '%u' WHERE auctionhouse = '%u'", greyi, ahMapID);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentwhiteitems = '%u' WHERE auctionhouse = '%u'", whitei, ahMapID);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentgreenitems = '%u' WHERE auctionhouse = '%u'", greeni, ahMapID);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentblueitems = '%u' WHERE auctionhouse = '%u'", bluei, ahMapID);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentpurpleitems = '%u' WHERE auctionhouse = '%u'", purplei, ahMapID);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentorangeitems = '%u' WHERE auctionhouse = '%u'", orangei, ahMapID);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET percentyellowitems = '%u' WHERE auctionhouse = '%u'", yellowi, ahMapID);
+            CharacterDatabase.CommitTransaction();
+            config->SetPercentages(greytg, whitetg, greentg, bluetg, purpletg, orangetg, yellowtg, greyi, whitei, greeni, bluei, purplei, orangei, yellowi);
+        }break;
+    case 6:     //min prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), minPrice, ahMapID);
+            config->SetMinPrice(col, minPrice);
+        }break;
+    case 7:     //max prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxPrice, ahMapID);
+            config->SetMaxPrice(col, maxPrice);
+        }break;
+    case 8:     //min bid price
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minBidPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minbidprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), minBidPrice, ahMapID);
+            config->SetMinBidPrice(col, minBidPrice);
+        }break;
+    case 9:     //max bid price
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxBidPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxbidprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxBidPrice, ahMapID);
+            config->SetMaxBidPrice(col, maxBidPrice);
+        }break;
+    case 10:        //max stacks
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxStack = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxstack%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxStack, ahMapID);
+            config->SetMaxStack(col, maxStack);
+        }break;
+    case 11:        //buyer bid prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 buyerPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), buyerPrice, ahMapID);
+            config->SetBuyerPrice(col, buyerPrice);
+        }break;
+    case 12:        //buyer bidding interval
+        {
+            char * param1 = strtok(args, " ");
+            uint32 bidInterval = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerbiddinginterval = '%u' WHERE auctionhouse = '%u'", bidInterval, ahMapID);
+            config->SetBiddingInterval(bidInterval);
+        }break;
+    case 13:        //buyer bids per interval
+        {
+            char * param1 = strtok(args, " ");
+            uint32 bidsPerInterval = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerbidsperinterval = '%u' WHERE auctionhouse = '%u'", bidsPerInterval, ahMapID);
+            config->SetBidsPerInterval(bidsPerInterval);
+        }break;
+    default:
+        break;
+    }
+}
+
+void AuctionHouseBot::LoadValues(AHBConfig *config)
+{
+    if (sWorld.getConfig(CONFIG_BOOL_AHBOT_SELLER_ENABLED))
+    {
+        //load min and max items
+        config->SetMinItems(CharacterDatabase.PQuery("SELECT minitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxItems(CharacterDatabase.PQuery("SELECT maxitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minItems = %u", config->GetMinItems());
+            sLog.outError("maxItems = %u", config->GetMaxItems());
+        }
+        //load min and max auction times
+        config->SetMinTime(CharacterDatabase.PQuery("SELECT mintime FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxTime(CharacterDatabase.PQuery("SELECT maxtime FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minTime = %u", config->GetMinTime());
+            sLog.outError("maxTime = %u", config->GetMaxTime());
+        }
+        //load percentages
+        uint32 greytg = CharacterDatabase.PQuery("SELECT percentgreytradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 whitetg = CharacterDatabase.PQuery("SELECT percentwhitetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greentg = CharacterDatabase.PQuery("SELECT percentgreentradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 bluetg = CharacterDatabase.PQuery("SELECT percentbluetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 purpletg = CharacterDatabase.PQuery("SELECT percentpurpletradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 orangetg = CharacterDatabase.PQuery("SELECT percentorangetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 yellowtg = CharacterDatabase.PQuery("SELECT percentyellowtradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greyi = CharacterDatabase.PQuery("SELECT percentgreyitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 whitei = CharacterDatabase.PQuery("SELECT percentwhiteitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greeni = CharacterDatabase.PQuery("SELECT percentgreenitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 bluei = CharacterDatabase.PQuery("SELECT percentblueitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 purplei = CharacterDatabase.PQuery("SELECT percentpurpleitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 orangei = CharacterDatabase.PQuery("SELECT percentorangeitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 yellowi = CharacterDatabase.PQuery("SELECT percentyellowitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        config->SetPercentages(greytg, whitetg, greentg, bluetg, purpletg, orangetg, yellowtg, greyi, whitei, greeni, bluei, purplei, orangei, yellowi);
+        if (debug_Out)
+        {
+            sLog.outError("percentGreyTradeGoods = %u", config->GetPercentages(AHB_GREY_TG));
+            sLog.outError("percentWhiteTradeGoods = %u", config->GetPercentages(AHB_WHITE_TG));
+            sLog.outError("percentGreenTradeGoods = %u", config->GetPercentages(AHB_GREEN_TG));
+            sLog.outError("percentBlueTradeGoods = %u", config->GetPercentages(AHB_BLUE_TG));
+            sLog.outError("percentPurpleTradeGoods = %u", config->GetPercentages(AHB_PURPLE_TG));
+            sLog.outError("percentOrangeTradeGoods = %u", config->GetPercentages(AHB_ORANGE_TG));
+            sLog.outError("percentYellowTradeGoods = %u", config->GetPercentages(AHB_YELLOW_TG));
+            sLog.outError("percentGreyItems = %u", config->GetPercentages(AHB_GREY_I));
+            sLog.outError("percentWhiteItems = %u", config->GetPercentages(AHB_WHITE_I));
+            sLog.outError("percentGreenItems = %u", config->GetPercentages(AHB_GREEN_I));
+            sLog.outError("percentBlueItems = %u", config->GetPercentages(AHB_BLUE_I));
+            sLog.outError("percentPurpleItems = %u", config->GetPercentages(AHB_PURPLE_I));
+            sLog.outError("percentOrangeItems = %u", config->GetPercentages(AHB_ORANGE_I));
+            sLog.outError("percentYellowItems = %u", config->GetPercentages(AHB_YELLOW_I));
+        }
+        //load min and max prices
+        config->SetMinPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT minpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT maxpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minPriceGrey = %u", config->GetMinPrice(AHB_GREY));
+            sLog.outError("maxPriceGrey = %u", config->GetMaxPrice(AHB_GREY));
+        }
+        config->SetMinPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT minpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minPriceWhite = %u", config->GetMinPrice(AHB_WHITE));
+            sLog.outError("maxPriceWhite = %u", config->GetMaxPrice(AHB_WHITE));
+        }
+        config->SetMinPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT minpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minPriceGreen = %u", config->GetMinPrice(AHB_GREEN));
+            sLog.outError("maxPriceGreen = %u", config->GetMaxPrice(AHB_GREEN));
+        }
+        config->SetMinPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT minpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minPriceBlue = %u", config->GetMinPrice(AHB_BLUE));
+            sLog.outError("maxPriceBlue = %u", config->GetMaxPrice(AHB_BLUE));
+        }
+        config->SetMinPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT minpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minPricePurple = %u", config->GetMinPrice(AHB_PURPLE));
+            sLog.outError("maxPricePurple = %u", config->GetMaxPrice(AHB_PURPLE));
+        }
+        config->SetMinPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT minpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minPriceOrange = %u", config->GetMinPrice(AHB_ORANGE));
+            sLog.outError("maxPriceOrange = %u", config->GetMaxPrice(AHB_ORANGE));
+        }
+        config->SetMinPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT minpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minPriceYellow = %u", config->GetMinPrice(AHB_YELLOW));
+            sLog.outError("maxPriceYellow = %u", config->GetMaxPrice(AHB_YELLOW));
+        }
+        //load min and max bid prices
+        config->SetMinBidPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT minbidpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minBidPriceGrey = %u", config->GetMinBidPrice(AHB_GREY));
+        }
+        config->SetMaxBidPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT maxbidpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("maxBidPriceGrey = %u", config->GetMaxBidPrice(AHB_GREY));
+        }
+        config->SetMinBidPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT minbidpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minBidPriceWhite = %u", config->GetMinBidPrice(AHB_WHITE));
+        }
+        config->SetMaxBidPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxbidpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("maxBidPriceWhite = %u", config->GetMaxBidPrice(AHB_WHITE));
+        }
+        config->SetMinBidPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT minbidpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minBidPriceGreen = %u", config->GetMinBidPrice(AHB_GREEN));
+        }
+        config->SetMaxBidPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxbidpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("maxBidPriceGreen = %u", config->GetMaxBidPrice(AHB_GREEN));
+        }
+        config->SetMinBidPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT minbidpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minBidPriceBlue = %u", config->GetMinBidPrice(AHB_BLUE));
+        }
+        config->SetMaxBidPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxbidpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("maxBidPriceBlue = %u", config->GetMinBidPrice(AHB_BLUE));
+        }
+        config->SetMinBidPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT minbidpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minBidPricePurple = %u", config->GetMinBidPrice(AHB_PURPLE));
+        }
+        config->SetMaxBidPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxbidpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("maxBidPricePurple = %u", config->GetMaxBidPrice(AHB_PURPLE));
+        }
+        config->SetMinBidPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT minbidpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minBidPriceOrange = %u", config->GetMinBidPrice(AHB_ORANGE));
+        }
+        config->SetMaxBidPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxbidpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("maxBidPriceOrange = %u", config->GetMaxBidPrice(AHB_ORANGE));
+        }
+        config->SetMinBidPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT minbidpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("minBidPriceYellow = %u", config->GetMinBidPrice(AHB_YELLOW));
+        }
+        config->SetMaxBidPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxbidpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {sLog.outError("maxBidPriceYellow = %u", config->GetMaxBidPrice(AHB_YELLOW));
+        }
+        //load max stacks
+        config->SetMaxStack(AHB_GREY, CharacterDatabase.PQuery("SELECT maxstackgrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("maxStackGrey = %u", config->GetMaxStack(AHB_GREY));
+        }
+        config->SetMaxStack(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxstackwhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("maxStackWhite = %u", config->GetMaxStack(AHB_WHITE));
+        }
+        config->SetMaxStack(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxstackgreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("maxStackGreen = %u", config->GetMaxStack(AHB_GREEN));
+        }
+        config->SetMaxStack(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxstackblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("maxStackBlue = %u", config->GetMaxStack(AHB_BLUE));
+        }
+        config->SetMaxStack(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxstackpurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("maxStackPurple = %u", config->GetMaxStack(AHB_PURPLE));
+        }
+        config->SetMaxStack(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxstackorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("maxStackOrange = %u", config->GetMaxStack(AHB_ORANGE));
+        }
+        config->SetMaxStack(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxstackyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("maxStackYellow = %u", config->GetMaxStack(AHB_YELLOW));
+        }
+    }
+    if (sWorld.getConfig(CONFIG_BOOL_AHBOT_BUYER_ENABLED))
+    {
+        //load buyer bid prices
+        config->SetBuyerPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT buyerpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT buyerpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT buyerpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT buyerpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT buyerpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT buyerpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT buyerpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("buyerPriceGrey = %u", config->GetBuyerPrice(AHB_GREY));
+            sLog.outError("buyerPriceWhite = %u", config->GetBuyerPrice(AHB_WHITE));
+            sLog.outError("buyerPriceGreen = %u", config->GetBuyerPrice(AHB_GREEN));
+            sLog.outError("buyerPriceBlue = %u", config->GetBuyerPrice(AHB_BLUE));
+            sLog.outError("buyerPricePurple = %u", config->GetBuyerPrice(AHB_PURPLE));
+            sLog.outError("buyerPriceOrange = %u", config->GetBuyerPrice(AHB_ORANGE));
+            sLog.outError("buyerPriceYellow = %u", config->GetBuyerPrice(AHB_YELLOW));
+        }
+        //load bidding interval
+        config->SetBiddingInterval(CharacterDatabase.PQuery("SELECT buyerbiddinginterval FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("buyerBiddingInterval = %u", config->GetBiddingInterval());
+        }
+        //load bids per interval
+        config->SetBidsPerInterval(CharacterDatabase.PQuery("SELECT buyerbidsperinterval FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog.outError("buyerBidsPerInterval = %u", config->GetBidsPerInterval());
+        }
+    }
+}
+
+void Player::Initialize(uint32 guid )
+{
+    Object::_Create( guid, 0, HIGHGUID_PLAYER );
+}
\ No newline at end of file
diff --git a/Core/src/game/AuctionHouseBot.h b/Core/src/game/AuctionHouseBot.h
new file mode 100644
index 0000000..2e3289c
--- /dev/null
+++ b/Core/src/game/AuctionHouseBot.h
@@ -0,0 +1,964 @@
+#ifndef AUCTION_HOUSE_BOT_H
+#define AUCTION_HOUSE_BOT_H
+
+#include "World.h"
+#include "Player.h"
+#include "Config/ConfigEnv.h"
+#include "ace/Vector_T.h"
+
+#define AHB_GREY        0
+#define AHB_WHITE       1
+#define AHB_GREEN       2
+#define AHB_BLUE        3
+#define AHB_PURPLE      4
+#define AHB_ORANGE      5
+#define AHB_YELLOW      6
+#define AHB_GREY_TG     0
+#define AHB_WHITE_TG    1
+#define AHB_GREEN_TG    2
+#define AHB_BLUE_TG     3
+#define AHB_PURPLE_TG   4
+#define AHB_ORANGE_TG   5
+#define AHB_YELLOW_TG   6
+#define AHB_GREY_I      7
+#define AHB_WHITE_I     8
+#define AHB_GREEN_I     9
+#define AHB_BLUE_I      10
+#define AHB_PURPLE_I    11
+#define AHB_ORANGE_I    12
+#define AHB_YELLOW_I    13
+
+class AHBConfig
+{
+private:
+    uint32 AHID;
+    uint32 AHFID;
+    uint32 minItems;
+    uint32 maxItems;
+    uint32 minTime;
+    uint32 maxTime;
+    uint32 percentGreyTradeGoods;
+    uint32 percentWhiteTradeGoods;
+    uint32 percentGreenTradeGoods;
+    uint32 percentBlueTradeGoods;
+    uint32 percentPurpleTradeGoods;
+    uint32 percentOrangeTradeGoods;
+    uint32 percentYellowTradeGoods;
+    uint32 percentGreyItems;
+    uint32 percentWhiteItems;
+    uint32 percentGreenItems;
+    uint32 percentBlueItems;
+    uint32 percentPurpleItems;
+    uint32 percentOrangeItems;
+    uint32 percentYellowItems;
+    uint32 minPriceGrey;
+    uint32 maxPriceGrey;
+    uint32 minBidPriceGrey;
+    uint32 maxBidPriceGrey;
+    uint32 maxStackGrey;
+    uint32 minPriceWhite;
+    uint32 maxPriceWhite;
+    uint32 minBidPriceWhite;
+    uint32 maxBidPriceWhite;
+    uint32 maxStackWhite;
+    uint32 minPriceGreen;
+    uint32 maxPriceGreen;
+    uint32 minBidPriceGreen;
+    uint32 maxBidPriceGreen;
+    uint32 maxStackGreen;
+    uint32 minPriceBlue;
+    uint32 maxPriceBlue;
+    uint32 minBidPriceBlue;
+    uint32 maxBidPriceBlue;
+    uint32 maxStackBlue;
+    uint32 minPricePurple;
+    uint32 maxPricePurple;
+    uint32 minBidPricePurple;
+    uint32 maxBidPricePurple;
+    uint32 maxStackPurple;
+    uint32 minPriceOrange;
+    uint32 maxPriceOrange;
+    uint32 minBidPriceOrange;
+    uint32 maxBidPriceOrange;
+    uint32 maxStackOrange;
+    uint32 minPriceYellow;
+    uint32 maxPriceYellow;
+    uint32 minBidPriceYellow;
+    uint32 maxBidPriceYellow;
+    uint32 maxStackYellow;
+
+    uint32 buyerPriceGrey;
+    uint32 buyerPriceWhite;
+    uint32 buyerPriceGreen;
+    uint32 buyerPriceBlue;
+    uint32 buyerPricePurple;
+    uint32 buyerPriceOrange;
+    uint32 buyerPriceYellow;
+    uint32 buyerBiddingInterval;
+    uint32 buyerBidsPerInterval;
+
+    uint32 greytgp;
+    uint32 whitetgp;
+    uint32 greentgp;
+    uint32 bluetgp;
+    uint32 purpletgp;
+    uint32 orangetgp;
+    uint32 yellowtgp;
+    uint32 greyip;
+    uint32 whiteip;
+    uint32 greenip;
+    uint32 blueip;
+    uint32 purpleip;
+    uint32 orangeip;
+    uint32 yellowip;
+
+public:
+    AHBConfig(uint32 ahid)
+    {
+        AHID = ahid;
+        switch(ahid)
+        {
+        case 2:
+            AHFID = 55;
+            break;
+        case 6:
+            AHFID = 29;
+            break;
+        case 7:
+            AHFID = 120;
+            break;
+        default:
+            AHFID = 120;
+            break;
+        }
+    }
+    AHBConfig()
+    {
+    }
+    uint32 GetAHID()
+    {
+        return AHID;
+    }
+    uint32 GetAHFID()
+    {
+        return AHFID;
+    }
+    void SetMinItems(uint32 value)
+    {
+        minItems = value;
+    }
+    uint32 GetMinItems()
+    {
+        if ((minItems  == 0) && (maxItems))
+            return maxItems;
+        else if ((maxItems) && (minItems > maxItems))
+            return maxItems;
+        else
+            return minItems;
+    }
+    void SetMaxItems(uint32 value)
+    {
+        maxItems = value;
+        CalculatePercents();
+    }
+    uint32 GetMaxItems()
+    {
+        return maxItems;
+    }
+    void SetMinTime(uint32 value)
+    {
+        minTime = value;
+    }
+    uint32 GetMinTime()
+    {
+        if (minTime < 1)
+            return 1;
+        else if ((maxTime) && (minTime > maxTime))
+            return maxTime;
+        else
+            return minTime;
+    }
+    void SetMaxTime(uint32 value)
+    {
+        maxTime = value;
+    }
+    uint32 GetMaxTime()
+    {
+        return maxTime;
+    }
+    void SetPercentages(uint32 greytg, uint32 whitetg, uint32 greentg, uint32 bluetg, uint32 purpletg, uint32 orangetg, uint32 yellowtg, uint32 greyi, uint32 whitei, uint32 greeni, uint32 bluei, uint32 purplei, uint32 orangei, uint32 yellowi)
+    {
+        uint32 totalPercent = greytg + whitetg + greentg + bluetg + purpletg + orangetg + yellowtg + greyi + whitei + greeni + bluei + purplei + orangei + yellowi;
+
+        if (totalPercent == 0)
+        {
+            maxItems = 0;
+        }
+        else if (totalPercent != 100)
+        {
+            greytg = 0;
+            whitetg = 27;
+            greentg = 12;
+            bluetg = 10;
+            purpletg = 1;
+            orangetg = 0;
+            yellowtg = 0;
+            greyi = 0;
+            whitei = 10;
+            greeni = 30;
+            bluei = 8;
+            purplei = 2;
+            orangei = 0;
+            yellowi = 0;
+        }
+        percentGreyTradeGoods = greytg;
+        percentWhiteTradeGoods = whitetg;
+        percentGreenTradeGoods = greentg;
+        percentBlueTradeGoods = bluetg;
+        percentPurpleTradeGoods = purpletg;
+        percentOrangeTradeGoods = orangetg;
+        percentYellowTradeGoods = yellowtg;
+        percentGreyItems = greyi;
+        percentWhiteItems = whitei;
+        percentGreenItems = greeni;
+        percentBlueItems = bluei;
+        percentPurpleItems = purplei;
+        percentOrangeItems = orangei;
+        percentYellowItems = yellowi;
+        CalculatePercents();
+    }
+    uint32 GetPercentages(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return percentGreyTradeGoods;
+            break;
+        case AHB_WHITE_TG:
+            return percentWhiteTradeGoods;
+            break;
+        case AHB_GREEN_TG:
+            return percentGreenTradeGoods;
+            break;
+        case AHB_BLUE_TG:
+            return percentBlueTradeGoods;
+            break;
+        case AHB_PURPLE_TG:
+            return percentPurpleTradeGoods;
+            break;
+        case AHB_ORANGE_TG:
+            return percentOrangeTradeGoods;
+            break;
+        case AHB_YELLOW_TG:
+            return percentYellowTradeGoods;
+            break;
+        case AHB_GREY_I:
+            return percentGreyItems;
+            break;
+        case AHB_WHITE_I:
+            return percentWhiteItems;
+            break;
+        case AHB_GREEN_I:
+            return percentGreenItems;
+            break;
+        case AHB_BLUE_I:
+            return percentBlueItems;
+            break;
+        case AHB_PURPLE_I:
+            return percentPurpleItems;
+            break;
+        case AHB_ORANGE_I:
+            return percentOrangeItems;
+            break;
+        case AHB_YELLOW_I:
+            return percentYellowItems;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetMinPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            minPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            minPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            minPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            minPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            minPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            minPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            minPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMinPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (minPriceGrey == 0)
+                    return 100;
+                else if (minPriceGrey > maxPriceGrey)
+                    return maxPriceGrey;
+                else
+                    return minPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (minPriceWhite == 0)
+                    return 150;
+                else if (minPriceWhite > maxPriceWhite)
+                    return maxPriceWhite;
+                else
+                    return minPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (minPriceGreen == 0)
+                    return 200;
+                else if (minPriceGreen > maxPriceGreen)
+                    return maxPriceGreen;
+                else
+                    return minPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (minPriceBlue == 0)
+                    return 250;
+                else if (minPriceBlue > maxPriceBlue)
+                    return maxPriceBlue;
+                else
+                    return minPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (minPricePurple == 0)
+                    return 300;
+                else if (minPricePurple > maxPricePurple)
+                    return maxPricePurple;
+                else
+                    return minPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (minPriceOrange == 0)
+                    return 400;
+                else if (minPriceOrange > maxPriceOrange)
+                    return maxPriceOrange;
+                else
+                    return minPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (minPriceYellow == 0)
+                    return 500;
+                else if (minPriceYellow > maxPriceYellow)
+                    return maxPriceYellow;
+                else
+                    return minPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            maxPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            maxPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            maxPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            maxPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (maxPriceGrey == 0)
+                    return 150;
+                else
+                    return maxPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (maxPriceWhite == 0)
+                    return 250;
+                else
+                    return maxPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (maxPriceGreen == 0)
+                    return 300;
+                else
+                    return maxPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (maxPriceBlue == 0)
+                    return 350;
+                else
+                    return maxPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (maxPricePurple == 0)
+                    return 450;
+                else
+                    return maxPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (maxPriceOrange == 0)
+                    return 550;
+                else
+                    return maxPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (maxPriceYellow == 0)
+                    return 650;
+                else
+                    return maxPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMinBidPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            minBidPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            minBidPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            minBidPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            minBidPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            minBidPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            minBidPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            minBidPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMinBidPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (minBidPriceGrey > 100)
+                    return 100;
+                else
+                    return minBidPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (minBidPriceWhite > 100)
+                    return 100;
+                else
+                    return minBidPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (minBidPriceGreen > 100)
+                    return 100;
+                else
+                    return minBidPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (minBidPriceBlue > 100)
+                    return 100;
+                else
+                    return minBidPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (minBidPricePurple > 100)
+                    return 100;
+                else
+                    return minBidPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (minBidPriceOrange > 100)
+                    return 100;
+                else
+                    return minBidPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (minBidPriceYellow > 100)
+                    return 100;
+                else
+                    return minBidPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxBidPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxBidPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            maxBidPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            maxBidPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            maxBidPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxBidPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            maxBidPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxBidPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxBidPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (maxBidPriceGrey > 100)
+                    return 100;
+                else
+                    return maxBidPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (maxBidPriceWhite > 100)
+                    return 100;
+                else
+                    return maxBidPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (maxBidPriceGreen > 100)
+                    return 100;
+                else
+                    return maxBidPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (maxBidPriceBlue > 100)
+                    return 100;
+                else
+                    return maxBidPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (maxBidPricePurple > 100)
+                    return 100;
+                else
+                    return maxBidPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (maxBidPriceOrange > 100)
+                    return 100;
+                else
+                    return maxBidPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (maxBidPriceYellow > 100)
+                    return 100;
+                else
+                    return maxBidPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxStack(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxStackGrey = value;
+            break;
+        case AHB_WHITE:
+            maxStackWhite = value;
+            break;
+        case AHB_GREEN:
+            maxStackGreen = value;
+            break;
+        case AHB_BLUE:
+            maxStackBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxStackPurple = value;
+            break;
+        case AHB_ORANGE:
+            maxStackOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxStackYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxStack(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                return maxStackGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                return maxStackWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                return maxStackGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                return maxStackBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                return maxStackPurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                return maxStackOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                return maxStackYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetBuyerPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            buyerPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            buyerPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            buyerPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            buyerPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            buyerPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            buyerPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            buyerPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetBuyerPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            return buyerPriceGrey;
+            break;
+        case AHB_WHITE:
+            return buyerPriceWhite;
+            break;
+        case AHB_GREEN:
+            return buyerPriceGreen;
+            break;
+        case AHB_BLUE:
+            return buyerPriceBlue;
+            break;
+        case AHB_PURPLE:
+            return buyerPricePurple;
+            break;
+        case AHB_ORANGE:
+            return buyerPriceOrange;
+            break;
+        case AHB_YELLOW:
+            return buyerPriceYellow;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetBiddingInterval(uint32 value)
+    {
+        buyerBiddingInterval = value;
+    }
+    uint32 GetBiddingInterval()
+    {
+        return buyerBiddingInterval;
+    }
+    void CalculatePercents()
+    {
+        greytgp = (uint32) (((double)percentGreyTradeGoods / 100.0) * maxItems);
+        whitetgp = (uint32) (((double)percentWhiteTradeGoods / 100.0) * maxItems);
+        greentgp = (uint32) (((double)percentGreenTradeGoods / 100.0) * maxItems);
+        bluetgp = (uint32) (((double)percentBlueTradeGoods / 100.0) * maxItems);
+        purpletgp = (uint32) (((double)percentPurpleTradeGoods / 100.0) * maxItems);
+        orangetgp = (uint32) (((double)percentOrangeTradeGoods / 100.0) * maxItems);
+        yellowtgp = (uint32) (((double)percentYellowTradeGoods / 100.0) * maxItems);
+        greyip = (uint32) (((double)percentGreyItems / 100.0) * maxItems);
+        whiteip = (uint32) (((double)percentWhiteItems / 100.0) * maxItems);
+        greenip = (uint32) (((double)percentGreenItems / 100.0) * maxItems);
+        blueip = (uint32) (((double)percentBlueItems / 100.0) * maxItems);
+        purpleip = (uint32) (((double)percentPurpleItems / 100.0) * maxItems);
+        orangeip = (uint32) (((double)percentOrangeItems / 100.0) * maxItems);
+        yellowip = (uint32) (((double)percentYellowItems / 100.0) * maxItems);
+        uint32 total = greytgp + whitetgp + greentgp + bluetgp + purpletgp + orangetgp + yellowtgp + greyip + whiteip + greenip + blueip + purpleip + orangeip + yellowip;
+        int32 diff = (maxItems - total);
+        if (diff < 0)
+        {
+            if ((whiteip - diff) > 0)
+                whiteip -= diff;
+            else if ((greenip - diff) > 0)
+                greenip -= diff;
+        }
+        else if (diff < 0)
+        {
+            whiteip += diff;
+        }
+    }
+    uint32 GetPercents(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return greytgp;
+            break;
+        case AHB_WHITE_TG:
+            return whitetgp;
+            break;
+        case AHB_GREEN_TG:
+            return greentgp;
+            break;
+        case AHB_BLUE_TG:
+            return bluetgp;
+            break;
+        case AHB_PURPLE_TG:
+            return purpletgp;
+            break;
+        case AHB_ORANGE_TG:
+            return orangetgp;
+            break;
+        case AHB_YELLOW_TG:
+            return yellowtgp;
+            break;
+        case AHB_GREY_I:
+            return greyip;
+            break;
+        case AHB_WHITE_I:
+            return whiteip;
+            break;
+        case AHB_GREEN_I:
+            return greenip;
+            break;
+        case AHB_BLUE_I:
+            return blueip;
+            break;
+        case AHB_PURPLE_I:
+            return purpleip;
+            break;
+        case AHB_ORANGE_I:
+            return orangeip;
+            break;
+        case AHB_YELLOW_I:
+            return yellowip;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetBidsPerInterval(uint32 value)
+    {
+        buyerBidsPerInterval = value;
+    }
+    uint32 GetBidsPerInterval()
+    {
+        return buyerBidsPerInterval;
+    }
+    ~AHBConfig()
+    {
+    }
+};
+
+class AuctionHouseBot
+{
+private:
+    ACE_Vector<uint32> npcItems;
+    ACE_Vector<uint32> lootItems;
+    ACE_Vector<uint32> greyTradeGoodsBin;
+    ACE_Vector<uint32> whiteTradeGoodsBin;
+    ACE_Vector<uint32> greenTradeGoodsBin;
+    ACE_Vector<uint32> blueTradeGoodsBin;
+    ACE_Vector<uint32> purpleTradeGoodsBin;
+    ACE_Vector<uint32> orangeTradeGoodsBin;
+    ACE_Vector<uint32> yellowTradeGoodsBin;
+    ACE_Vector<uint32> greyItemsBin;
+    ACE_Vector<uint32> whiteItemsBin;
+    ACE_Vector<uint32> greenItemsBin;
+    ACE_Vector<uint32> blueItemsBin;
+    ACE_Vector<uint32> purpleItemsBin;
+    ACE_Vector<uint32> orangeItemsBin;
+    ACE_Vector<uint32> yellowItemsBin;
+
+    bool debug_Out;
+
+    AHBConfig AllianceConfig;
+    AHBConfig HordeConfig;
+    AHBConfig NeutralConfig;
+
+    time_t _lastrun_a;
+    time_t _lastrun_h;
+    time_t _lastrun_n;
+
+    uint32 ItemsPerCycle;
+
+    inline uint32 minValue(uint32 a, uint32 b) { return a <= b ? a : b; };
+    void addNewAuctions(Player *AHBplayer, AHBConfig *config);
+    void addNewAuctionBuyerBotBid(Player *AHBplayer, AHBConfig *config, WorldSession *session);
+
+public:
+    AuctionHouseBot();
+    ~AuctionHouseBot();
+    void Update();
+    void Initialize();
+    void LoadDbConfig();
+    void LoadValues(AHBConfig*);
+    void Commands(uint32, uint32, uint32, char*);
+    uint32 GetAHBplayerGUID() { return sWorld.getConfig(CONFIG_UINT32_AHBOT_CHARACTER_ID); };
+};
+
+#define auctionbot MaNGOS::Singleton<AuctionHouseBot>::Instance()
+
+#endif
diff --git a/mangos/src/game/AuctionHouseHandler.cpp b/Core/src/game/AuctionHouseHandler.cpp
index 8769c64..23c026e 100644
--- a/mangos/src/game/AuctionHouseHandler.cpp
+++ b/Core/src/game/AuctionHouseHandler.cpp
@@ -28,6 +28,7 @@
 #include "AuctionHouseMgr.h"
 #include "Mail.h"
 #include "Util.h"
+#include "AuctionHouseBot.h"
 
 // please DO NOT use iterator++, because it is slower than ++iterator!!!
 // post-incrementation is always slower than pre-incrementation !
@@ -122,7 +123,12 @@ void WorldSession::SendAuctionOutbiddedMail(AuctionEntry *auction, uint32 newPri
         std::ostringstream msgAuctionOutbiddedSubject;
         msgAuctionOutbiddedSubject << auction->item_template << ":0:" << AUCTION_OUTBIDDED << ":0:0";
 
-        if (oldBidder)
+        // Added for AHBot
+        if (oldBidder && !_player)
+            oldBidder->GetSession()->SendAuctionBidderNotification( auction->GetHouseId(), auction->Id, auctionbot.GetAHBplayerGUID(), newPrice, auction->GetAuctionOutBid(), auction->item_template);
+
+        // Modified for AHBot
+        if (oldBidder && _player)
             oldBidder->GetSession()->SendAuctionBidderNotification( auction->GetHouseId(), auction->Id, _player->GetGUID(), newPrice, auction->GetAuctionOutBid(), auction->item_template);
 
         MailDraft(msgAuctionOutbiddedSubject.str(), "")     // TODO: fix body
@@ -252,6 +258,13 @@ void WorldSession::HandleAuctionSellItem( WorldPacket & recv_data )
 
     AuctionEntry *AH = new AuctionEntry;
     AH->Id = sObjectMgr.GenerateAuctionID();
+
+    // Added by AHBot, Unknown use (Commented)
+    /*if(sWorld.getConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+        AH->auctioneer = 23442;
+    else
+        AH->auctioneer = GUID_LOPART(auctioneer);*/
+    // Original
     AH->auctioneer = GUID_LOPART(auctioneer);
     AH->item_guidlow = GUID_LOPART(item);
     AH->item_template = it->GetEntry();
@@ -264,7 +277,8 @@ void WorldSession::HandleAuctionSellItem( WorldPacket & recv_data )
     AH->deposit = deposit;
     AH->auctionHouseEntry = auctionHouseEntry;
 
-    DETAIL_LOG("selling item %u to auctioneer %u with initial bid %u with buyout %u and with time %u (in sec) in auctionhouse %u", GUID_LOPART(item), GUID_LOPART(auctioneer), bid, buyout, auction_time, AH->GetHouseId());
+    // Modified for AHBot
+    DETAIL_LOG("selling item %u to auctioneer %u with initial bid %u with buyout %u and with time %u (in sec) in auctionhouse %u", GUID_LOPART(item), AH->auctioneer, bid, buyout, auction_time, AH->GetHouseId());
     auctionHouse->AddAuction(AH);
 
     sAuctionMgr.AddAItem(it);
diff --git a/mangos/src/game/AuctionHouseMgr.cpp b/Core/src/game/AuctionHouseMgr.cpp
index 05d172c..a772cd3 100644
--- a/mangos/src/game/AuctionHouseMgr.cpp
+++ b/Core/src/game/AuctionHouseMgr.cpp
@@ -462,12 +462,13 @@ void AuctionHouseMgr::Update()
 
 AuctionHouseEntry const* AuctionHouseMgr::GetAuctionHouseEntry(uint32 factionTemplateId)
 {
-    uint32 houseid = 1;                                     // dwarf auction house (used for normal cut/etc percents)
+    // Change by AHBot
+    uint32 houseid = 7;                            // goblin auction house
 
     if(!sWorld.getConfig(CONFIG_BOOL_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
     {
         //FIXME: found way for proper auctionhouse selection by another way
-        // AuctionHo use.dbc have faction field with _player_ factions associated with auction house races.
+        // AuctionHouse.dbc have faction field with _player_ factions associated with auction house races.
         // but no easy way convert creature faction to player race faction for specific city
         switch(factionTemplateId)
         {
diff --git a/mangos/src/game/AuctionHouseMgr.h b/Core/src/game/AuctionHouseMgr.h
index 0d1b040..d12acda 100644
--- a/mangos/src/game/AuctionHouseMgr.h
+++ b/Core/src/game/AuctionHouseMgr.h
@@ -84,6 +84,10 @@ class AuctionHouseObject
 
         uint32 Getcount() { return AuctionsMap.size(); }
 
+        // Added by AHBot
+        AuctionEntryMap::iterator GetAuctionsBegin() {return AuctionsMap.begin();}
+        AuctionEntryMap::iterator GetAuctionsEnd() {return AuctionsMap.end();}
+
         void AddAuction(AuctionEntry *ah)
         {
             ASSERT( ah );
diff --git a/mangos/src/game/BattleGround.cpp b/Core/src/game/BattleGround.cpp
index eb6ba1b..cf62edf 100644
--- a/mangos/src/game/BattleGround.cpp
+++ b/Core/src/game/BattleGround.cpp
@@ -34,6 +34,7 @@
 #include "Util.h"
 #include "Formulas.h"
 #include "GridNotifiersImpl.h"
+#include "GameEventMgr.h"
 
 namespace MaNGOS
 {
@@ -209,6 +210,7 @@ void BattleGround::BroadcastWorker(Do& _do)
 BattleGround::BattleGround()
 {
     m_TypeID            = BattleGroundTypeId(0);
+    m_RandomTypeID      = BattleGroundTypeId(0);
     m_Status            = STATUS_NONE;
     m_ClientInstanceID  = 0;
     m_EndTime           = 0;
@@ -222,11 +224,14 @@ BattleGround::BattleGround()
     m_Events            = 0;
     m_IsRated           = false;
     m_BuffChange        = false;
+    m_IsRandom          = false;
     m_Name              = "";
     m_LevelMin          = 0;
     m_LevelMax          = 0;
     m_InBGFreeSlotQueue = false;
 
+    m_ArenaBuffTimer    = 0;
+
     m_MaxPlayersPerTeam = 0;
     m_MaxPlayers        = 0;
     m_MinPlayersPerTeam = 0;
@@ -394,14 +399,14 @@ void BattleGround::Update(uint32 diff)
     /*********************************************************/
     /***           ARENA BUFF OBJECT SPAWNING              ***/
     /*********************************************************/
-    if (isArena() && !m_ArenaBuffSpawned)
+    if (isArena() && !m_ArenaBuffSpawned && GetStatus() == STATUS_IN_PROGRESS)
     {
         // 60 seconds after start the buffobjects in arena should get spawned
-        if (m_StartTime > uint32(m_StartDelayTimes[BG_STARTING_EVENT_FIRST] + ARENA_SPAWN_BUFF_OBJECTS))
+        if (m_ArenaBuffTimer > uint32(m_StartDelayTimes[BG_STARTING_EVENT_FIRST] + ARENA_SPAWN_BUFF_OBJECTS))
         {
             SpawnEvent(ARENA_BUFF_EVENT, 0, true);
             m_ArenaBuffSpawned = true;
-        }
+        } else m_ArenaBuffTimer += diff;
     }
 
     /*********************************************************/
@@ -628,7 +633,7 @@ void BattleGround::RewardHonorToTeam(uint32 Honor, uint32 TeamID)
         if(!team) team = plr->GetTeam();
 
         if (team == TeamID)
-            UpdatePlayerScore(plr, SCORE_BONUS_HONOR, Honor);
+            plr->RewardHonor(NULL, 1, (float)Honor);
     }
 }
 
@@ -720,7 +725,10 @@ void BattleGround::EndBattleGround(uint32 winner)
             winner_rating = winner_arena_team->GetStats().rating;
             int32 winner_change = winner_arena_team->WonAgainst(loser_rating);
             int32 loser_change = loser_arena_team->LostAgainst(winner_rating);
-            DEBUG_LOG("--- Winner rating: %u, Loser rating: %u, Winner change: %u, Losser change: %u ---", winner_rating, loser_rating, winner_change, loser_change);
+            uint32 noratinglimit = sWorld.getConfig(CONFIG_UINT32_LOSERNOCHANGE);
+            uint32 halfratinglimit = sWorld.getConfig(CONFIG_UINT32_LOSERHALFCHANGE);
+
+            DEBUG_LOG("--- Winner rating: %u, Loser rating: %u, Winner change: %i, Losser change: %i ---", winner_rating, loser_rating, winner_change, loser_change);
             SetArenaTeamRatingChangeForTeam(winner, winner_change);
             SetArenaTeamRatingChangeForTeam(GetOtherTeam(winner), loser_change);
         }
@@ -753,6 +761,11 @@ void BattleGround::EndBattleGround(uint32 winner)
             sLog.outError("BattleGround:EndBattleGround Player (GUID: %u) not found!", GUID_LOPART(itr->first));
             continue;
         }
+        
+        if(!team) team = plr->GetTeam();
+        
+        if(!isArena())
+            plr->RewardHonorEndBattlegroud(team == winner);
 
         // should remove spirit of redemption
         if (plr->HasAuraType(SPELL_AURA_SPIRIT_OF_REDEMPTION))
@@ -794,14 +807,31 @@ void BattleGround::EndBattleGround(uint32 winner)
             }
         }
 
+        uint32 win_kills = plr->GetRandomWinner() ? BG_REWARD_WINNER_HONOR_LAST : BG_REWARD_WINNER_HONOR_FIRST;
+        uint32 loos_kills = plr->GetRandomWinner() ? BG_REWARD_LOOSER_HONOR_LAST : BG_REWARD_LOOSER_HONOR_FIRST;
+        uint32 win_arena = plr->GetRandomWinner() ? BG_REWARD_WINNER_ARENA_LAST : BG_REWARD_WINNER_ARENA_FIRST;
+
         if (team == winner)
         {
             RewardMark(plr,ITEM_WINNER_COUNT);
             RewardQuestComplete(plr);
-            plr->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_BG, 1);
+
+            if (IsRandom() || BattleGroundMgr::IsBGWeekend(GetTypeID()))
+            {
+                UpdatePlayerScore(plr, SCORE_BONUS_HONOR, GetBonusHonorFromKill(win_kills*4));
+                plr->ModifyArenaPoints(win_arena);
+                if(!plr->GetRandomWinner())
+                    plr->SetRandomWinner(true);
+            }
+
+            plr->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_BG, 1);            
         }
         else
+        {
             RewardMark(plr,ITEM_LOSER_COUNT);
+            if (IsRandom() || BattleGroundMgr::IsBGWeekend(GetTypeID()))
+                UpdatePlayerScore(plr, SCORE_BONUS_HONOR, GetBonusHonorFromKill(loos_kills*4));
+        }
 
         plr->CombatStopWithPets(true);
 
@@ -836,13 +866,12 @@ void BattleGround::EndBattleGround(uint32 winner)
 
 uint32 BattleGround::GetBonusHonorFromKill(uint32 kills) const
 {
-    //variable kills means how many honorable kills you scored (so we need kills * honor_for_one_kill)
-    return (uint32)MaNGOS::Honor::hk_honor_at_level(GetMaxLevel(), kills);
+    return (uint32)(MaNGOS::Honor::hk_honor_at_level(GetMaxLevel(), kills));
 }
 
 uint32 BattleGround::GetBattlemasterEntry() const
 {
-    switch(GetTypeID())
+    switch(GetTypeID(true))
     {
         case BATTLEGROUND_AV: return 15972;
         case BATTLEGROUND_WS: return 14623;
@@ -855,7 +884,7 @@ uint32 BattleGround::GetBattlemasterEntry() const
 
 void BattleGround::RewardMark(Player *plr,uint32 count)
 {
-    switch(GetTypeID())
+    switch(GetTypeID(true))
     {
         case BATTLEGROUND_AV:
             if (count == ITEM_WINNER_COUNT)
@@ -961,7 +990,7 @@ void BattleGround::SendRewardMarkByMail(Player *plr,uint32 mark, uint32 count)
 void BattleGround::RewardQuestComplete(Player *plr)
 {
     uint32 quest;
-    switch(GetTypeID())
+    switch(GetTypeID(true))
     {
         case BATTLEGROUND_AV:
             quest = SPELL_AV_QUEST_REWARD;
@@ -1031,6 +1060,9 @@ void BattleGround::RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPac
             plr->ClearAfkReports();
 
             if(!team) team = plr->GetTeam();
+            
+            // remove arena/battleground specific auras
+            plr->RemoveAurasDueToSpell(SPELL_AURA_PVP_HEALING); 
 
             // if arena, remove the specific arena auras
             if (isArena())
@@ -1038,10 +1070,6 @@ void BattleGround::RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPac
                 plr->RemoveArenaAuras(true);                // removes debuffs / dots etc., we don't want the player to die after porting out
                 bgTypeId=BATTLEGROUND_AA;                   // set the bg type to all arenas (it will be used for queue refreshing)
 
-                // unsummon current and summon old pet if there was one and there isn't a current pet
-                plr->RemovePet(NULL, PET_SAVE_NOT_IN_SLOT);
-                plr->ResummonPetTemporaryUnSummonedIfAny();
-
                 if (isRated() && GetStatus() == STATUS_IN_PROGRESS)
                 {
                     //left a rated match while the encounter was in progress, consider as loser
@@ -1185,6 +1213,9 @@ void BattleGround::AddPlayer(Player *plr)
     sBattleGroundMgr.BuildPlayerJoinedBattleGroundPacket(&data, plr);
     SendPacketToTeam(team, &data, plr, false);
 
+    // add arena/battleground specific auras
+    plr->CastSpell(plr, SPELL_AURA_PVP_HEALING,true); 
+
     // add arena specific auras
     if (isArena())
     {
@@ -1207,7 +1238,7 @@ void BattleGround::AddPlayer(Player *plr)
         }
 
         plr->DestroyConjuredItems(true);
-        plr->UnsummonPetTemporaryIfAny();
+        plr->RemovePet(NULL, PET_SAVE_NOT_IN_SLOT);
 
         if(GetStatus() == STATUS_WAIT_JOIN)                 // not started yet
         {
@@ -1220,11 +1251,19 @@ void BattleGround::AddPlayer(Player *plr)
     else
     {
         if(GetStatus() == STATUS_WAIT_JOIN)                 // not started yet
+        {
             plr->CastSpell(plr, SPELL_PREPARATION, true);   // reduces all mana cost of spells.
+            if (plr->IsMounted())
+                plr->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED); // dismount on bg start
+        }
     }
-
     plr->GetAchievementMgr().ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HEALING_DONE, ACHIEVEMENT_CRITERIA_CONDITION_MAP, GetMapId());
     plr->GetAchievementMgr().ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DAMAGE_DONE, ACHIEVEMENT_CRITERIA_CONDITION_MAP, GetMapId());
+    plr->GetAchievementMgr().ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GET_KILLING_BLOWS);
+    plr->GetAchievementMgr().ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL);
+    plr->GetAchievementMgr().ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL);
+    plr->GetAchievementMgr().ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE);
+    plr->GetAchievementMgr().ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA);
 
     // setup BG group membership
     PlayerAddedToBGCheckIfBGIsRunning(plr);
@@ -1361,11 +1400,7 @@ void BattleGround::UpdatePlayerScore(Player *Source, uint32 type, uint32 value)
         case SCORE_BONUS_HONOR:                             // Honor bonus
             // do not add honor in arenas
             if (isBattleGround())
-            {
-                // reward honor instantly
-                if (Source->RewardHonor(NULL, 1, (float)value))
-                    itr->second->BonusHonor += value;
-            }
+                itr->second->BonusHonor += value;
             break;
             //used only in EY, but in MSG_PVP_LOG_DATA opcode
         case SCORE_DAMAGE_DONE:                             // Damage Done
@@ -1380,6 +1415,25 @@ void BattleGround::UpdatePlayerScore(Player *Source, uint32 type, uint32 value)
     }
 }
 
+uint32 BattleGround::GetPlayerScore(Player *Source, uint32 type)
+{
+    BattleGroundScoreMap::const_iterator itr = m_PlayerScores.find(Source->GetGUID());
+
+    if(itr == m_PlayerScores.end())                         // player not found...
+        return 0;
+
+    switch(type)
+    {
+        case SCORE_KILLING_BLOWS:                           // Killing blows
+            return itr->second->KillingBlows;
+        case SCORE_DEATHS:                                  // Deaths
+            return itr->second->Deaths;
+        default:
+            sLog.outError("BattleGround: Unknown player score type %u", type);
+            return 0;
+    }
+}
+
 bool BattleGround::AddObject(uint32 type, uint32 entry, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3, uint32 /*respawnTime*/)
 {
     // must be created this way, adding to godatamap would add it to the base map of the instance
@@ -1691,7 +1745,7 @@ void BattleGround::HandleTriggerBuff(uint64 const& go_guid)
         index--;
     if (index < 0)
     {
-        sLog.outError("BattleGround (Type: %u) has buff gameobject (Guid: %u Entry: %u Type:%u) but it hasn't that object in its internal data",GetTypeID(),GUID_LOPART(go_guid),obj->GetEntry(),obj->GetGoType());
+        sLog.outError("BattleGround (Type: %u) has buff gameobject (Guid: %u Entry: %u Type:%u) but it hasn't that object in its internal data",GetTypeID(true),GUID_LOPART(go_guid),obj->GetEntry(),obj->GetGoType());
         return;
     }
 
@@ -1726,6 +1780,9 @@ void BattleGround::HandleKillPlayer( Player *player, Player *killer )
     {
         UpdatePlayerScore(killer, SCORE_HONORABLE_KILLS, 1);
         UpdatePlayerScore(killer, SCORE_KILLING_BLOWS, 1);
+        killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GET_KILLING_BLOWS,1);
+        killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL,1);
+        killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA,1);
 
         for(BattleGroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
         {
@@ -1735,7 +1792,11 @@ void BattleGround::HandleKillPlayer( Player *player, Player *killer )
                 continue;
 
             if (plr->GetTeam() == killer->GetTeam() && plr->IsAtGroupRewardDistance(player))
+            {
                 UpdatePlayerScore(plr, SCORE_HONORABLE_KILLS, 1);
+                plr->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL,1);
+                plr->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA,1);
+            }
         }
     }
 
diff --git a/mangos/src/game/BattleGround.h b/Core/src/game/BattleGround.h
index 32554e4..31a4986 100644
--- a/mangos/src/game/BattleGround.h
+++ b/Core/src/game/BattleGround.h
@@ -95,7 +95,8 @@ enum BattleGroundSpells
     SPELL_HORDE_GREEN_FLAG          = 35775,
     SPELL_PREPARATION               = 44521,                // Preparation
     SPELL_RECENTLY_DROPPED_FLAG     = 42792,                // Recently Dropped Flag
-    SPELL_AURA_PLAYER_INACTIVE      = 43681                 // Inactive
+    SPELL_AURA_PLAYER_INACTIVE      = 43681,                 // Inactive
+    SPELL_AURA_PVP_HEALING          = 74410                 // PvP 10% healing reduction 
 };
 
 enum BattleGroundTimeIntervals
@@ -128,6 +129,16 @@ enum BattleGroundBuffObjects
     BG_OBJECTID_BERSERKERBUFF_ENTRY = 179905
 };
 
+enum BattleGroundRandomRewards
+{
+    BG_REWARD_WINNER_HONOR_FIRST    = 30,
+    BG_REWARD_WINNER_ARENA_FIRST    = 25,
+    BG_REWARD_WINNER_HONOR_LAST     = 15,
+    BG_REWARD_WINNER_ARENA_LAST     = 0,
+    BG_REWARD_LOOSER_HONOR_FIRST    = 5,
+    BG_REWARD_LOOSER_HONOR_LAST     = 5
+};
+
 const uint32 Buff_Entries[3] = { BG_OBJECTID_SPEEDBUFF_ENTRY, BG_OBJECTID_REGENBUFF_ENTRY, BG_OBJECTID_BERSERKERBUFF_ENTRY };
 
 enum BattleGroundStatus
@@ -164,11 +175,12 @@ enum BattleGroundQueueTypeId
     BATTLEGROUND_QUEUE_EY       = 4,
     BATTLEGROUND_QUEUE_SA       = 5,
     BATTLEGROUND_QUEUE_IC       = 6,
-    BATTLEGROUND_QUEUE_2v2      = 7,
-    BATTLEGROUND_QUEUE_3v3      = 8,
-    BATTLEGROUND_QUEUE_5v5      = 9
+    BATTLEGROUND_QUEUE_RB       = 7,
+    BATTLEGROUND_QUEUE_2v2      = 8,
+    BATTLEGROUND_QUEUE_3v3      = 9,
+    BATTLEGROUND_QUEUE_5v5      = 10
 };
-#define MAX_BATTLEGROUND_QUEUE_TYPES 10
+#define MAX_BATTLEGROUND_QUEUE_TYPES 11
 
 enum ScoreType
 {
@@ -307,7 +319,7 @@ class BattleGround
         /* Battleground */
         // Get methods:
         char const* GetName() const         { return m_Name; }
-        BattleGroundTypeId GetTypeID() const { return m_TypeID; }
+        BattleGroundTypeId GetTypeID(bool GetRandom = false) const { return GetRandom ? m_RandomTypeID : m_TypeID; }
         BattleGroundBracketId GetBracketId() const { return m_BracketId; }
         // the instanceId check is also used to determine a bg-template
         // that's why the m_map hack is here..
@@ -330,10 +342,12 @@ class BattleGround
         uint8 GetWinner() const             { return m_Winner; }
         uint32 GetBattlemasterEntry() const;
         uint32 GetBonusHonorFromKill(uint32 kills) const;
+        bool IsRandom() { return m_IsRandom; }
 
         // Set methods:
         void SetName(char const* Name)      { m_Name = Name; }
         void SetTypeID(BattleGroundTypeId TypeID) { m_TypeID = TypeID; }
+        void SetRandomTypeID(BattleGroundTypeId TypeID) { m_RandomTypeID = TypeID; }
         //here we can count minlevel and maxlevel for players
         void SetBracket(PvPDifficultyEntry const* bracketEntry);
         void SetStatus(BattleGroundStatus Status) { m_Status = Status; }
@@ -359,6 +373,8 @@ class BattleGround
 
         void DecreaseInvitedCount(uint32 team)      { (team == ALLIANCE) ? --m_InvitedAlliance : --m_InvitedHorde; }
         void IncreaseInvitedCount(uint32 team)      { (team == ALLIANCE) ? ++m_InvitedAlliance : ++m_InvitedHorde; }
+
+        void SetRandom(bool isRandom) { m_IsRandom = isRandom; }
         uint32 GetInvitedCount(uint32 team) const
         {
             if (team == ALLIANCE)
@@ -443,6 +459,7 @@ class BattleGround
         void SetBgRaid(uint32 TeamID, Group *bg_raid);
 
         virtual void UpdatePlayerScore(Player *Source, uint32 type, uint32 value);
+        uint32 GetPlayerScore(Player *Source, uint32 type);
 
         static BattleGroundTeamId GetTeamIndexByTeamId(uint32 Team) { return Team == ALLIANCE ? BG_TEAM_ALLIANCE : BG_TEAM_HORDE; }
         uint32 GetPlayersCountByTeam(uint32 Team) const { return m_PlayersCount[GetTeamIndexByTeamId(Team)]; }
@@ -568,14 +585,17 @@ class BattleGround
         uint32 m_StartMessageIds[BG_STARTING_EVENT_COUNT];
 
         bool   m_BuffChange;
+        bool   m_IsRandom;
 
     private:
         /* Battleground */
         BattleGroundTypeId m_TypeID;
+        BattleGroundTypeId m_RandomTypeID;
         BattleGroundStatus m_Status;
         uint32 m_ClientInstanceID;                          //the instance-id which is sent to the client and without any other internal use
         uint32 m_StartTime;
         bool m_ArenaBuffSpawned;                            // to cache if arenabuff event is started (cause bool is faster than checking IsActiveEvent)
+        uint32 m_ArenaBuffTimer;
         int32 m_EndTime;                                    // it is set to 120000 when bg is ending and it decreases itself
         BattleGroundBracketId m_BracketId;
         uint8  m_ArenaType;                                 // 2=2v2, 3=3v3, 5=5v5
diff --git a/mangos/src/game/BattleGroundAB.cpp b/Core/src/game/BattleGroundAB.cpp
index 58934ec..6ebe8da 100644
--- a/mangos/src/game/BattleGroundAB.cpp
+++ b/Core/src/game/BattleGroundAB.cpp
@@ -27,6 +27,7 @@
 #include "Util.h"
 #include "WorldPacket.h"
 #include "MapManager.h"
+#include "World.h"
 
 BattleGroundAB::BattleGroundAB()
 {
@@ -121,7 +122,7 @@ void BattleGroundAB::Update(uint32 diff)
                 }
                 if (m_HonorScoreTics[team] >= m_HonorTics)
                 {
-                    RewardHonorToTeam(GetBonusHonorFromKill(1), (team == BG_TEAM_ALLIANCE) ? ALLIANCE : HORDE);
+                    RewardHonorToTeam(GetBonusHonorFromKill(sWorld.getConfig(CONFIG_UINT32_BONUS_HONOR_FLAG_AB)), (team == BG_TEAM_ALLIANCE) ? ALLIANCE : HORDE);
                     m_HonorScoreTics[team] -= m_HonorTics;
                 }
                 if (!m_IsInformedNearVictory && m_TeamScores[team] > BG_AB_WARNING_NEAR_VICTORY_SCORE)
@@ -376,6 +377,7 @@ void BattleGroundAB::EventPlayerClickedOnFlag(Player *source, GameObject* target
         if (m_prevNodes[node] < BG_AB_NODE_TYPE_OCCUPIED)
         {
             UpdatePlayerScore(source, SCORE_BASES_ASSAULTED, 1);
+            source->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE,1,0);
             m_prevNodes[node] = m_Nodes[node];
             m_Nodes[node] = teamIndex + BG_AB_NODE_TYPE_CONTESTED;
             // create new contested banner
@@ -392,6 +394,7 @@ void BattleGroundAB::EventPlayerClickedOnFlag(Player *source, GameObject* target
         else
         {
             UpdatePlayerScore(source, SCORE_BASES_DEFENDED, 1);
+            source->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE,1,1);
             m_prevNodes[node] = m_Nodes[node];
             m_Nodes[node] = teamIndex + BG_AB_NODE_TYPE_OCCUPIED;
             // create new occupied banner
@@ -411,6 +414,7 @@ void BattleGroundAB::EventPlayerClickedOnFlag(Player *source, GameObject* target
     else
     {
         UpdatePlayerScore(source, SCORE_BASES_ASSAULTED, 1);
+        source->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE,1,0);
         m_prevNodes[node] = m_Nodes[node];
         m_Nodes[node] = teamIndex + BG_AB_NODE_TYPE_CONTESTED;
         // create new contested banner
@@ -487,13 +491,12 @@ void BattleGroundAB::Reset()
 void BattleGroundAB::EndBattleGround(uint32 winner)
 {
     //win reward
-    if (winner == ALLIANCE)
-        RewardHonorToTeam(GetBonusHonorFromKill(1), ALLIANCE);
-    if (winner == HORDE)
-        RewardHonorToTeam(GetBonusHonorFromKill(1), HORDE);
+    if (winner)
+        RewardHonorToTeam(GetBonusHonorFromKill(sWorld.getConfig(CONFIG_UINT32_BONUS_HONOR_AB_WIN)), winner);
+    
     //complete map_end rewards (even if no team wins)
-    RewardHonorToTeam(GetBonusHonorFromKill(1), HORDE);
-    RewardHonorToTeam(GetBonusHonorFromKill(1), ALLIANCE);
+    RewardHonorToTeam(GetBonusHonorFromKill(sWorld.getConfig(CONFIG_UINT32_BONUS_HONOR_AB_END)), HORDE);
+    RewardHonorToTeam(GetBonusHonorFromKill(sWorld.getConfig(CONFIG_UINT32_BONUS_HONOR_AB_END)), ALLIANCE);
 
     BattleGround::EndBattleGround(winner);
 }
diff --git a/mangos/src/game/BattleGroundAV.cpp b/Core/src/game/BattleGroundAV.cpp
index 166ae81..381a956 100644
--- a/mangos/src/game/BattleGroundAV.cpp
+++ b/Core/src/game/BattleGroundAV.cpp
@@ -345,6 +345,7 @@ void BattleGroundAV::EndBattleGround(uint32 winner)
         RewardHonorToTeam(m_HonorMapComplete, ALLIANCE);
         RewardHonorToTeam(m_HonorMapComplete, HORDE);
     }
+
     BattleGround::EndBattleGround(winner);
 }
 
@@ -522,9 +523,11 @@ void BattleGroundAV::EventPlayerClickedOnFlag(Player *source, GameObject* target
     {
         case POINT_CONTROLLED:
             EventPlayerAssaultsPoint(source, node);
+            source->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE,1, IsTower(node) ? 0:1);
             break;
         case POINT_ASSAULTED:
             EventPlayerDefendsPoint(source, node);
+            source->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE,1, IsTower(node) ? 2:3);
             break;
         default:
             break;
diff --git a/mangos/src/game/BattleGroundDS.cpp b/Core/src/game/BattleGroundDS.cpp
index e6a298d..62d347e 100644
--- a/mangos/src/game/BattleGroundDS.cpp
+++ b/Core/src/game/BattleGroundDS.cpp
@@ -16,14 +16,16 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#include "Object.h"
 #include "Player.h"
 #include "BattleGround.h"
 #include "BattleGroundDS.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
 #include "Language.h"
 
 BattleGroundDS::BattleGroundDS()
 {
-
     m_StartDelayTimes[BG_STARTING_EVENT_FIRST]  = BG_START_DELAY_1M;
     m_StartDelayTimes[BG_STARTING_EVENT_SECOND] = BG_START_DELAY_30S;
     m_StartDelayTimes[BG_STARTING_EVENT_THIRD]  = BG_START_DELAY_15S;
@@ -43,6 +45,24 @@ BattleGroundDS::~BattleGroundDS()
 void BattleGroundDS::Update(uint32 diff)
 {
     BattleGround::Update(diff);
+    if (GetStatus() == STATUS_IN_PROGRESS)
+    {
+        // knockback
+        if(m_uiKnockback < diff)
+        {
+            for(BattleGroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
+            {
+                Player * plr = sObjectMgr.GetPlayer(itr->first);
+                if (plr && plr->IsWithinLOS(1214,765,14) && plr->GetDistance2d(1214,765) <= 50)
+                    plr->KnockBackPlayerWithAngle(6.40f,55,7);
+                if (plr && plr->IsWithinLOS(1369,817,14) && plr->GetDistance2d(1369,817) <= 50)
+                    plr->KnockBackPlayerWithAngle(3.03f,55,7);
+            }
+            m_uiKnockback = 1000;
+        }
+        else
+            m_uiKnockback -= diff;
+    }
 }
 
 void BattleGroundDS::StartingEventCloseDoors()
@@ -51,6 +71,7 @@ void BattleGroundDS::StartingEventCloseDoors()
 
 void BattleGroundDS::StartingEventOpenDoors()
 {
+    OpenDoorEvent(BG_EVENT_DOOR);
 }
 
 void BattleGroundDS::AddPlayer(Player *plr)
@@ -60,19 +81,76 @@ void BattleGroundDS::AddPlayer(Player *plr)
     BattleGroundDSScore* sc = new BattleGroundDSScore;
 
     m_PlayerScores[plr->GetGUID()] = sc;
+
+    UpdateWorldState(0xe11, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xe10, GetAlivePlayersCountByTeam(HORDE));
+}
+
+void BattleGroundDS::RemovePlayer(Player* /*plr*/, uint64 /*guid*/)
+{
+    if (GetStatus() == STATUS_WAIT_LEAVE)
+        return;
+
+    UpdateWorldState(0xe11, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xe10, GetAlivePlayersCountByTeam(HORDE));
+
+    CheckArenaWinConditions();
 }
 
-void BattleGroundDS::RemovePlayer(Player * /*plr*/, uint64 /*guid*/)
+void BattleGroundDS::HandleKillPlayer(Player *player, Player *killer)
 {
+    if (GetStatus() != STATUS_IN_PROGRESS)
+        return;
+
+    if (!killer)
+    {
+        sLog.outError("BattleGroundDS: Killer player not found");
+        return;
+    }
+
+    BattleGround::HandleKillPlayer(player,killer);
+
+    UpdateWorldState(0xe11, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xe10, GetAlivePlayersCountByTeam(HORDE));
+
+    CheckArenaWinConditions();
+}
+
+bool BattleGroundDS::HandlePlayerUnderMap(Player *player)
+{
+    player->TeleportTo(GetMapId(),1299.046f,784.825f,9.338f,player->GetOrientation(),false);
+    return true;
+}
+
+void BattleGroundDS::HandleAreaTrigger(Player *Source, uint32 Trigger)
+{
+    if (GetStatus() != STATUS_IN_PROGRESS)
+        return;
+
+    switch(Trigger)
+    {
+        case 5347:
+        case 5348:
+            break;
+        default:
+            sLog.outError("WARNING: Unhandled AreaTrigger in Battleground: %u", Trigger);
+            Source->GetSession()->SendAreaTriggerMessage("Warning: Unhandled AreaTrigger in Battleground: %u", Trigger);
+            break;
+    }
 }
 
-void BattleGroundDS::HandleKillPlayer(Player* player, Player* killer)
+void BattleGroundDS::FillInitialWorldStates(WorldPacket &data, uint32& count)
 {
-    BattleGround::HandleKillPlayer(player, killer);
+    FillInitialWorldState(data, count, 0xe11, GetAlivePlayersCountByTeam(ALLIANCE));
+    FillInitialWorldState(data, count, 0xe10, GetAlivePlayersCountByTeam(HORDE));
+    FillInitialWorldState(data, count, 0xe1a, 1);
 }
 
-void BattleGroundDS::HandleAreaTrigger(Player * /*Source*/, uint32 /*Trigger*/)
+void BattleGroundDS::Reset()
 {
+    //call parent's class reset
+    BattleGround::Reset();
+    m_uiKnockback = 5000;
 }
 
 bool BattleGroundDS::SetupBattleGround()
diff --git a/mangos/src/game/BattleGroundDS.h b/Core/src/game/BattleGroundDS.h
index 0034226..2d21b58 100644
--- a/mangos/src/game/BattleGroundDS.h
+++ b/Core/src/game/BattleGroundDS.h
@@ -45,6 +45,11 @@ class BattleGroundDS : public BattleGround
         void RemovePlayer(Player *plr, uint64 guid);
         void HandleAreaTrigger(Player *Source, uint32 Trigger);
         bool SetupBattleGround();
+        virtual void Reset();
+        virtual void FillInitialWorldStates(WorldPacket &d, uint32& count);
         void HandleKillPlayer(Player* player, Player *killer);
+        bool HandlePlayerUnderMap(Player * plr);
+    private:
+        uint32 m_uiKnockback;
 };
 #endif
diff --git a/mangos/src/game/BattleGroundEY.cpp b/Core/src/game/BattleGroundEY.cpp
index ea8e466..c18fcb6 100644
--- a/mangos/src/game/BattleGroundEY.cpp
+++ b/Core/src/game/BattleGroundEY.cpp
@@ -27,6 +27,7 @@
 #include "WorldPacket.h"
 #include "Util.h"
 #include "MapManager.h"
+#include "World.h"
 
 BattleGroundEY::BattleGroundEY()
 {
@@ -118,7 +119,7 @@ void BattleGroundEY::AddPoints(uint32 Team, uint32 Points)
     m_HonorScoreTics[team_index] += Points;
     if (m_HonorScoreTics[team_index] >= m_HonorTics )
     {
-        RewardHonorToTeam(GetBonusHonorFromKill(1), Team);
+        RewardHonorToTeam(GetBonusHonorFromKill(sWorld.getConfig(CONFIG_UINT32_BONUS_HONOR_FLAG_EOS)), Team);
         m_HonorScoreTics[team_index] -= m_HonorTics;
     }
     UpdateTeamScore(Team);
@@ -261,13 +262,12 @@ void BattleGroundEY::UpdateTeamScore(uint32 Team)
 void BattleGroundEY::EndBattleGround(uint32 winner)
 {
     //win reward
-    if (winner == ALLIANCE)
-        RewardHonorToTeam(GetBonusHonorFromKill(1), ALLIANCE);
-    if (winner == HORDE)
-        RewardHonorToTeam(GetBonusHonorFromKill(1), HORDE);
+    if (winner)
+        RewardHonorToTeam(GetBonusHonorFromKill(sWorld.getConfig(CONFIG_UINT32_BONUS_HONOR_EOS_WIN)), winner);
+    
     //complete map reward
-    RewardHonorToTeam(GetBonusHonorFromKill(1), ALLIANCE);
-    RewardHonorToTeam(GetBonusHonorFromKill(1), HORDE);
+    RewardHonorToTeam(GetBonusHonorFromKill(sWorld.getConfig(CONFIG_UINT32_BONUS_HONOR_EOS_END)), ALLIANCE);
+    RewardHonorToTeam(GetBonusHonorFromKill(sWorld.getConfig(CONFIG_UINT32_BONUS_HONOR_EOS_END)), HORDE);
 
     BattleGround::EndBattleGround(winner);
 }
@@ -642,6 +642,7 @@ void BattleGroundEY::EventPlayerCapturedFlag(Player *Source, BG_EY_Nodes node)
         AddPoints(Source->GetTeam(), BG_EY_FlagPoints[m_TeamPointsCount[team_id] - 1]);
 
     UpdatePlayerScore(Source, SCORE_FLAG_CAPTURES, 1);
+    Source->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE,1);
 }
 
 void BattleGroundEY::UpdatePlayerScore(Player *Source, uint32 type, uint32 value)
diff --git a/mangos/src/game/BattleGroundHandler.cpp b/Core/src/game/BattleGroundHandler.cpp
index 0be0c96..78f5f61 100644
--- a/mangos/src/game/BattleGroundHandler.cpp
+++ b/Core/src/game/BattleGroundHandler.cpp
@@ -99,6 +99,7 @@ void WorldSession::HandleBattlemasterJoinOpcode( WorldPacket & recv_data )
 
     // can do this, since it's battleground, not arena
     BattleGroundQueueTypeId bgQueueTypeId = BattleGroundMgr::BGQueueTypeId(bgTypeId, 0);
+    BattleGroundQueueTypeId bgQueueTypeIdRandom = BattleGroundMgr::BGQueueTypeId(BATTLEGROUND_RB, 0);
 
     // ignore if player is already in BG
     if (_player->InBattleGround())
@@ -133,13 +134,38 @@ void WorldSession::HandleBattlemasterJoinOpcode( WorldPacket & recv_data )
             _player->GetSession()->SendPacket(&data);
             return;
         }
+
+        if (_player->GetBattleGroundQueueIndex(bgQueueTypeIdRandom) < PLAYER_MAX_BATTLEGROUND_QUEUES)
+        {
+            //player is already in random queue
+            WorldPacket data;
+            sBattleGroundMgr.BuildGroupJoinedBattlegroundPacket(&data, ERR_IN_RANDOM_BG);
+            _player->GetSession()->SendPacket(&data);
+            return;
+        }
+        
+        if(_player->InBattleGroundQueue() && bgTypeId == BATTLEGROUND_RB)
+        {
+            //player is already in queue, can't start random queue
+            WorldPacket data;
+            sBattleGroundMgr.BuildGroupJoinedBattlegroundPacket(&data, ERR_IN_NON_RANDOM_BG);
+            _player->GetSession()->SendPacket(&data);
+            return;
+        }
+
         // check if already in queue
         if (_player->GetBattleGroundQueueIndex(bgQueueTypeId) < PLAYER_MAX_BATTLEGROUND_QUEUES)
             //player is already in this queue
             return;
+
         // check if has free queue slots
         if (!_player->HasFreeBattleGroundQueueId())
+        {
+            WorldPacket data;
+            sBattleGroundMgr.BuildGroupJoinedBattlegroundPacket(&data, ERR_BATTLEGROUND_TOO_MANY_QUEUES);
+            _player->GetSession()->SendPacket(&data);
             return;
+        }
     }
     else
     {
@@ -220,7 +246,7 @@ void WorldSession::HandleBattleGroundPlayerPositionsOpcode( WorldPacket & /*recv
     if(!bg)                                                 // can't be received if player not in battleground
         return;
 
-    switch( bg->GetTypeID() )
+    switch( bg->GetTypeID(true) )
     {
         case BATTLEGROUND_WS:
             {
@@ -417,7 +443,7 @@ void WorldSession::HandleBattleFieldPortOpcode( WorldPacket &recv_data )
             // stop taxi flight at port
             if (_player->isInFlight())
             {
-                _player->GetMotionMaster()->MovementExpired();
+                _player->GetMotionMaster()->MovementExpired(false);
                 _player->m_taxi.ClearTaxiDestinations();
             }
 
diff --git a/mangos/src/game/BattleGroundMgr.cpp b/Core/src/game/BattleGroundMgr.cpp
index a735417..e7661f9 100644
--- a/mangos/src/game/BattleGroundMgr.cpp
+++ b/Core/src/game/BattleGroundMgr.cpp
@@ -43,6 +43,7 @@
 #include "World.h"
 #include "WorldPacket.h"
 #include "GameEventMgr.h"
+#include "Formulas.h"
 
 #include "Policies/SingletonImp.h"
 
@@ -173,6 +174,7 @@ GroupQueueInfo * BattleGroundQueue::AddGroup(Player *leader, Group* grp, BattleG
         index += BG_TEAMS_COUNT;
     if (ginfo->Team == HORDE)
         index++;
+
     DEBUG_LOG("Adding Group to BattleGroundQueue bgTypeId : %u, bracket_id : %u, index : %u", BgTypeId, bracketId, index);
 
     uint32 lastOnlineTime = getMSTime();
@@ -864,6 +866,7 @@ void BattleGroundQueue::Update(BattleGroundTypeId bgTypeId, BattleGroundBracketI
             for(uint32 i = 0; i < BG_TEAMS_COUNT; i++)
                 for(GroupsQueueType::const_iterator citr = m_SelectionPools[BG_TEAM_ALLIANCE + i].SelectedGroups.begin(); citr != m_SelectionPools[BG_TEAM_ALLIANCE + i].SelectedGroups.end(); ++citr)
                     InviteGroupToBG((*citr), bg2, (*citr)->Team);
+
             //start bg
             bg2->StartBattleGround();
             //clear structures
@@ -891,6 +894,7 @@ void BattleGroundQueue::Update(BattleGroundTypeId bgTypeId, BattleGroundBracketI
             for(uint32 i = 0; i < BG_TEAMS_COUNT; i++)
                 for(GroupsQueueType::const_iterator citr = m_SelectionPools[BG_TEAM_ALLIANCE + i].SelectedGroups.begin(); citr != m_SelectionPools[BG_TEAM_ALLIANCE + i].SelectedGroups.end(); ++citr)
                     InviteGroupToBG((*citr), bg2, (*citr)->Team);
+
             // start bg
             bg2->StartBattleGround();
         }
@@ -938,6 +942,8 @@ void BattleGroundQueue::Update(BattleGroundTypeId bgTypeId, BattleGroundBracketI
 
         //optimalization : --- we dont need to use selection_pools - each update we select max 2 groups
 
+        uint32 teamId = 0;
+
         for(uint32 i = BG_QUEUE_PREMADE_ALLIANCE; i < BG_QUEUE_NORMAL_ALLIANCE; i++)
         {
             // take the group that joined first
@@ -969,8 +975,11 @@ void BattleGroundQueue::Update(BattleGroundTypeId bgTypeId, BattleGroundBracketI
                     && (((*itr_team[BG_TEAM_ALLIANCE])->ArenaTeamRating >= arenaMinRating && (*itr_team[BG_TEAM_ALLIANCE])->ArenaTeamRating <= arenaMaxRating)
                         || (*itr_team[BG_TEAM_ALLIANCE])->JoinTime < discardTime) )
                 {
-                    m_SelectionPools[BG_TEAM_ALLIANCE].AddGroup((*itr_team[BG_TEAM_ALLIANCE]), MaxPlayersPerTeam);
-                    break;
+                    if((*itr_team[BG_TEAM_ALLIANCE])->ArenaTeamId != teamId)
+                    {
+                        m_SelectionPools[BG_TEAM_ALLIANCE].AddGroup((*itr_team[BG_TEAM_ALLIANCE]), MaxPlayersPerTeam);
+                        break;
+                    }
                 }
             }
         }
@@ -985,8 +994,11 @@ void BattleGroundQueue::Update(BattleGroundTypeId bgTypeId, BattleGroundBracketI
                     && (((*itr_team[BG_TEAM_HORDE])->ArenaTeamRating >= arenaMinRating && (*itr_team[BG_TEAM_HORDE])->ArenaTeamRating <= arenaMaxRating)
                         || (*itr_team[BG_TEAM_HORDE])->JoinTime < discardTime) )
                 {
-                    m_SelectionPools[BG_TEAM_HORDE].AddGroup((*itr_team[BG_TEAM_HORDE]), MaxPlayersPerTeam);
-                    break;
+                    if((*itr_team[BG_TEAM_HORDE])->ArenaTeamId != teamId)
+                    {
+                        m_SelectionPools[BG_TEAM_HORDE].AddGroup((*itr_team[BG_TEAM_HORDE]), MaxPlayersPerTeam);
+                        break;
+                    }
                 }
             }
         }
@@ -1267,17 +1279,17 @@ void BattleGroundMgr::BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg)
 
     if(type)                                                // arena
     {
-        // it seems this must be according to BG_WINNER_A/H and _NOT_ BG_TEAM_A/H
-        for(int i = 1; i >= 0; --i)
+        // Rating Changes and Arena Team names seems to be correct for 3.3
+        for(int i = 0; i < BG_TEAMS_COUNT; ++i)
         {
-            *data << uint32(bg->m_ArenaTeamRatingChanges[i]);
-            *data << uint32(3999);                          // huge thanks for TOM_RUS for this!
-            *data << uint32(0);                             // added again in 3.1
+            *data << uint32(-(bg->m_ArenaTeamRatingChanges[(bg->GetWinner()+i)%BG_TEAMS_COUNT]));
+            *data << uint32(0);                             // seems it should be 0 since 3.0
+            *data << uint32(0);                             // matchmaking value
             DEBUG_LOG("rating change: %d", bg->m_ArenaTeamRatingChanges[i]);
         }
-        for(int i = 1; i >= 0; --i)
+        for(int i = 1; i <= BG_TEAMS_COUNT; ++i)
         {
-            uint32 at_id = bg->m_ArenaTeamIds[i];
+            uint32 at_id = bg->m_ArenaTeamIds[(bg->GetWinner()+i)%BG_TEAMS_COUNT];
             ArenaTeam * at = sObjectMgr.GetArenaTeamById(at_id);
             if (at)
                 *data << at->GetName();
@@ -1293,7 +1305,7 @@ void BattleGroundMgr::BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg)
     else
     {
         *data << uint8(1);                                  // bg ended
-        *data << uint8(bg->GetWinner());                    // who win
+        *data << uint8(0);                                  // ???
     }
 
     *data << (int32)(bg->GetPlayerScoresSize());
@@ -1306,7 +1318,7 @@ void BattleGroundMgr::BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg)
         {
             *data << (int32)itr->second->HonorableKills;
             *data << (int32)itr->second->Deaths;
-            *data << (int32)(itr->second->BonusHonor);
+            *data << (int32)itr->second->BonusHonor;
         }
         else
         {
@@ -1314,14 +1326,14 @@ void BattleGroundMgr::BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg)
             uint32 team = bg->GetPlayerTeam(itr->first);
             if (!team && plr)
                 team = plr->GetTeam();
-            if (( bg->GetWinner()==0 && team == ALLIANCE ) || ( bg->GetWinner()==1 && team==HORDE ))
+            if (( bg->GetWinner()== BG_TEAM_ALLIANCE && team == ALLIANCE ) || ( bg->GetWinner()== BG_TEAM_HORDE && team==HORDE ))
                 *data << uint8(1);
             else
                 *data << uint8(0);
         }
         *data << (int32)itr->second->DamageDone;             // damage done
         *data << (int32)itr->second->HealingDone;            // healing done
-        switch(bg->GetTypeID())                              // battleground specific things
+        switch(bg->GetTypeID(true))                          // battleground specific things
         {
             case BATTLEGROUND_AV:
                 *data << (uint32)0x00000005;                // count of next fields
@@ -1345,11 +1357,15 @@ void BattleGroundMgr::BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg)
                 *data << (uint32)0x00000001;                // count of next fields
                 *data << (uint32)((BattleGroundEYScore*)itr->second)->FlagCaptures;         // flag captures
                 break;
+            case BATTLEGROUND_SA:
+                *data << (uint32)0x00000002;                // count of next fields
+                *data << (uint32)((BattleGroundSAScore*)itr->second)->DemolishersDestroyed; // demolishers destroyed
+                *data << (uint32)((BattleGroundSAScore*)itr->second)->GatesDestroyed;       // gates destroyed
+                break;
             case BATTLEGROUND_NA:
             case BATTLEGROUND_BE:
             case BATTLEGROUND_AA:
             case BATTLEGROUND_RL:
-            case BATTLEGROUND_SA:                           // wotlk
             case BATTLEGROUND_DS:                           // wotlk
             case BATTLEGROUND_RV:                           // wotlk
             case BATTLEGROUND_IC:                           // wotlk
@@ -1357,7 +1373,7 @@ void BattleGroundMgr::BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg)
                 *data << (int32)0;                          // 0
                 break;
             default:
-                DEBUG_LOG("Unhandled MSG_PVP_LOG_DATA for BG id %u", bg->GetTypeID());
+                DEBUG_LOG("Unhandled MSG_PVP_LOG_DATA for BG id %u", bg->GetTypeID(true));
                 *data << (int32)0;
                 break;
         }
@@ -1476,8 +1492,8 @@ BattleGround * BattleGroundMgr::CreateNewBattleGround(BattleGroundTypeId bgTypeI
     //for arenas there is random map used
     if (bg_template->isArena())
     {
-        BattleGroundTypeId arenas[] = {BATTLEGROUND_NA, BATTLEGROUND_BE, BATTLEGROUND_RL};
-        uint32 arena_num = urand(0,2);
+        BattleGroundTypeId arenas[] = {BATTLEGROUND_NA, BATTLEGROUND_BE, BATTLEGROUND_RL, BATTLEGROUND_DS, BATTLEGROUND_RV};
+        uint32 arena_num = urand(0,4);
         bgTypeId = arenas[arena_num];
         bg_template = GetBattleGroundTemplate(bgTypeId);
         if (!bg_template)
@@ -1487,6 +1503,22 @@ BattleGround * BattleGroundMgr::CreateNewBattleGround(BattleGroundTypeId bgTypeI
         }
     }
 
+    bool isRandom = false;
+
+    if(bgTypeId==BATTLEGROUND_RB)
+    {
+        BattleGroundTypeId random_bgs[] = {BATTLEGROUND_AV, BATTLEGROUND_WS, BATTLEGROUND_AB, BATTLEGROUND_EY/*, BATTLEGROUND_SA, BATTLEGROUND_IC*/};
+        uint32 bg_num = urand(0,3/*5*/);
+        bgTypeId = random_bgs[bg_num];
+        bg_template = GetBattleGroundTemplate(bgTypeId);
+        if (!bg_template)
+        {
+            sLog.outError("BattleGround: CreateNewBattleGround - bg template not found for %u", bgTypeId);
+            return NULL;
+        }
+        isRandom = true;
+    }
+
     BattleGround *bg = NULL;
     // create a copy of the BG template
     switch(bgTypeId)
@@ -1541,7 +1573,7 @@ BattleGround * BattleGroundMgr::CreateNewBattleGround(BattleGroundTypeId bgTypeI
     // will also set m_bgMap, instanceid
     sMapMgr.CreateBgMap(bg->GetMapId(), bg);
 
-    bg->SetClientInstanceID(CreateClientVisibleInstanceId(bgTypeId, bracketEntry->GetBracketId()));
+    bg->SetClientInstanceID(CreateClientVisibleInstanceId(isRandom ? BATTLEGROUND_RB : bgTypeId, bracketEntry->GetBracketId()));
 
     // reset the new bg (set status to status_wait_queue from status_none)
     bg->Reset();
@@ -1550,6 +1582,9 @@ BattleGround * BattleGroundMgr::CreateNewBattleGround(BattleGroundTypeId bgTypeI
     bg->SetStatus(STATUS_WAIT_JOIN);
     bg->SetArenaType(arenaType);
     bg->SetRated(isRated);
+    bg->SetRandom(isRandom);
+    bg->SetTypeID(isRandom ? BATTLEGROUND_RB : bgTypeId);
+    bg->SetRandomTypeID(bgTypeId);
 
     return bg;
 }
@@ -1785,6 +1820,13 @@ void BattleGroundMgr::BuildBattleGroundListPacket(WorldPacket *data, const uint6
     if (!plr)
         return;
 
+    uint32 win_kills = plr->GetRandomWinner() ? BG_REWARD_WINNER_HONOR_LAST : BG_REWARD_WINNER_HONOR_FIRST;
+    uint32 win_arena = plr->GetRandomWinner() ? BG_REWARD_WINNER_ARENA_LAST : BG_REWARD_WINNER_ARENA_FIRST;
+    uint32 loos_kills = plr->GetRandomWinner() ? BG_REWARD_LOOSER_HONOR_LAST : BG_REWARD_LOOSER_HONOR_FIRST;
+
+    win_kills = (uint32)MaNGOS::Honor::hk_honor_at_level(plr->getLevel(), win_kills*4);
+    loos_kills = (uint32)MaNGOS::Honor::hk_honor_at_level(plr->getLevel(), loos_kills*4);
+
     data->Initialize(SMSG_BATTLEFIELD_LIST);
     *data << uint64(guid);                                  // battlemaster guid
     *data << uint8(fromWhere);                              // from where you joined
@@ -1793,20 +1835,22 @@ void BattleGroundMgr::BuildBattleGroundListPacket(WorldPacket *data, const uint6
     *data << uint8(0);                                      // unk
 
     // Rewards
-    *data << uint8(0);                                      // 3.3.3 hasWin
-    *data << uint32(0);                                     // 3.3.3 winHonor
-    *data << uint32(0);                                     // 3.3.3 winArena
-    *data << uint32(0);                                     // 3.3.3 lossHonor
+    *data << uint8( plr->GetRandomWinner() );               // 3.3.3 hasWin
+    *data << uint32( win_kills );                           // 3.3.3 winHonor
+    *data << uint32( win_arena );                           // 3.3.3 winArena
+    *data << uint32( loos_kills );                          // 3.3.3 lossHonor
+
+    uint8 isRandom = bgTypeId == BATTLEGROUND_RB;
 
-    uint8 isRandom = 0;
     *data << uint8(isRandom);                               // 3.3.3 isRandom
+
     if(isRandom)
     {
         // Rewards (random)
-        *data << uint8(0);                                  // 3.3.3 hasWin_Random
-        *data << uint32(0);                                 // 3.3.3 winHonor_Random
-        *data << uint32(0);                                 // 3.3.3 winArena_Random
-        *data << uint32(0);                                 // 3.3.3 lossHonor_Random
+        *data << uint8( plr->GetRandomWinner() );           // 3.3.3 hasWin_Random
+        *data << uint32( win_kills );                       // 3.3.3 winHonor_Random
+        *data << uint32( win_arena );                       // 3.3.3 winArena_Random
+        *data << uint32( loos_kills );                      // 3.3.3 lossHonor_Random
     }
 
     if(bgTypeId == BATTLEGROUND_AA)                         // arena
@@ -1862,7 +1906,9 @@ bool BattleGroundMgr::IsArenaType(BattleGroundTypeId bgTypeId)
     return ( bgTypeId == BATTLEGROUND_AA ||
         bgTypeId == BATTLEGROUND_BE ||
         bgTypeId == BATTLEGROUND_NA ||
-        bgTypeId == BATTLEGROUND_RL );
+        bgTypeId == BATTLEGROUND_RL ||
+        bgTypeId == BATTLEGROUND_DS ||
+        bgTypeId == BATTLEGROUND_RV );
 }
 
 BattleGroundQueueTypeId BattleGroundMgr::BGQueueTypeId(BattleGroundTypeId bgTypeId, uint8 arenaType)
@@ -1882,7 +1928,7 @@ BattleGroundQueueTypeId BattleGroundMgr::BGQueueTypeId(BattleGroundTypeId bgType
         case BATTLEGROUND_IC:
             return BATTLEGROUND_QUEUE_IC;
         case BATTLEGROUND_RB:
-            return BATTLEGROUND_QUEUE_NONE;
+            return BATTLEGROUND_QUEUE_RB;
         case BATTLEGROUND_AA:
         case BATTLEGROUND_NA:
         case BATTLEGROUND_RL:
@@ -1921,6 +1967,8 @@ BattleGroundTypeId BattleGroundMgr::BGTemplateId(BattleGroundQueueTypeId bgQueue
             return BATTLEGROUND_SA;
         case BATTLEGROUND_QUEUE_IC:
             return BATTLEGROUND_IC;
+        case BATTLEGROUND_QUEUE_RB:
+            return BATTLEGROUND_RB;
         case BATTLEGROUND_QUEUE_2v2:
         case BATTLEGROUND_QUEUE_3v3:
         case BATTLEGROUND_QUEUE_5v5:
diff --git a/mangos/src/game/BattleGroundRV.cpp b/Core/src/game/BattleGroundRV.cpp
index e54e4db..9bdf290 100644
--- a/mangos/src/game/BattleGroundRV.cpp
+++ b/Core/src/game/BattleGroundRV.cpp
@@ -19,11 +19,13 @@
 #include "Player.h"
 #include "BattleGround.h"
 #include "BattleGroundRV.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "GameObject.h"
 #include "Language.h"
 
 BattleGroundRV::BattleGroundRV()
 {
-
     m_StartDelayTimes[BG_STARTING_EVENT_FIRST]  = BG_START_DELAY_1M;
     m_StartDelayTimes[BG_STARTING_EVENT_SECOND] = BG_START_DELAY_30S;
     m_StartDelayTimes[BG_STARTING_EVENT_THIRD]  = BG_START_DELAY_15S;
@@ -43,6 +45,24 @@ BattleGroundRV::~BattleGroundRV()
 void BattleGroundRV::Update(uint32 diff)
 {
     BattleGround::Update(diff);
+    if (GetStatus() == STATUS_IN_PROGRESS)
+    {
+        // teleport buggers
+        if(m_uiTeleport < diff)
+        {
+            for(BattleGroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
+            {
+                Player * plr = sObjectMgr.GetPlayer(itr->first);
+                if (plr && plr->GetPositionZ() < 27)
+                    plr->TeleportTo(618, plr->GetPositionX(), plr->GetPositionY(), 29, plr->GetOrientation(), false);
+                if (plr && plr->GetPositionZ() < 27)
+                    plr->TeleportTo(618, plr->GetPositionX(), plr->GetPositionY(), 29, plr->GetOrientation(), false);
+            }
+            m_uiTeleport = 1000;
+        }
+        else
+            m_uiTeleport -= diff;
+    }
 }
 
 void BattleGroundRV::StartingEventCloseDoors()
@@ -51,6 +71,7 @@ void BattleGroundRV::StartingEventCloseDoors()
 
 void BattleGroundRV::StartingEventOpenDoors()
 {
+    OpenDoorEvent(BG_EVENT_DOOR);
 }
 
 void BattleGroundRV::AddPlayer(Player *plr)
@@ -60,19 +81,78 @@ void BattleGroundRV::AddPlayer(Player *plr)
     BattleGroundRVScore* sc = new BattleGroundRVScore;
 
     m_PlayerScores[plr->GetGUID()] = sc;
+
+    UpdateWorldState(0xe11, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xe10, GetAlivePlayersCountByTeam(HORDE));
 }
 
 void BattleGroundRV::RemovePlayer(Player * /*plr*/, uint64 /*guid*/)
 {
+    if (GetStatus() == STATUS_WAIT_LEAVE)
+        return;
+
+    UpdateWorldState(0xe11, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xe10, GetAlivePlayersCountByTeam(HORDE));
+
+    CheckArenaWinConditions();
 }
 
 void BattleGroundRV::HandleKillPlayer(Player* player, Player* killer)
 {
+    if (GetStatus() != STATUS_IN_PROGRESS)
+        return;
+
+    if (!killer)
+    {
+        sLog.outError("BattleGroundRV: Killer player not found");
+        return;
+    }
+
     BattleGround::HandleKillPlayer(player, killer);
+
+    UpdateWorldState(0xe11, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xe10, GetAlivePlayersCountByTeam(HORDE));
+
+    CheckArenaWinConditions();
+}
+
+bool BattleGroundRV::HandlePlayerUnderMap(Player *player)
+{
+    player->TeleportTo(GetMapId(), 763.5f, -284, 28.276f, player->GetOrientation(), false);
+    return true;
+}
+
+void BattleGroundRV::HandleAreaTrigger(Player * Source, uint32 Trigger)
+{
+    if (GetStatus() != STATUS_IN_PROGRESS)
+        return;
+
+    switch(Trigger)
+    {
+        case 5224:
+        case 5226:
+        case 5473:
+        case 5474:
+            break;
+        default:
+            sLog.outError("WARNING: Unhandled AreaTrigger in Battleground: %u", Trigger);
+            Source->GetSession()->SendAreaTriggerMessage("Warning: Unhandled AreaTrigger in Battleground: %u", Trigger);
+            break;
+    }
+}
+
+void BattleGroundRV::FillInitialWorldStates(WorldPacket &data, uint32& count)
+{
+    FillInitialWorldState(data, count, 0xe11, GetAlivePlayersCountByTeam(ALLIANCE));
+    FillInitialWorldState(data, count, 0xe10, GetAlivePlayersCountByTeam(HORDE));
+    FillInitialWorldState(data, count, 0xe1a, 1);
 }
 
-void BattleGroundRV::HandleAreaTrigger(Player * /*Source*/, uint32 /*Trigger*/)
+void BattleGroundRV::Reset()
 {
+    //call parent's class reset
+    BattleGround::Reset();
+    m_uiTeleport = 22000;
 }
 
 bool BattleGroundRV::SetupBattleGround()
diff --git a/mangos/src/game/BattleGroundRV.h b/Core/src/game/BattleGroundRV.h
index d53dd23..d8bc665 100644
--- a/mangos/src/game/BattleGroundRV.h
+++ b/Core/src/game/BattleGroundRV.h
@@ -45,6 +45,11 @@ class BattleGroundRV : public BattleGround
         void RemovePlayer(Player *plr, uint64 guid);
         void HandleAreaTrigger(Player *Source, uint32 Trigger);
         bool SetupBattleGround();
+        virtual void Reset();
+        virtual void FillInitialWorldStates(WorldPacket &d, uint32& count);
         void HandleKillPlayer(Player* player, Player *killer);
+        bool HandlePlayerUnderMap(Player * plr);
+    private:
+        uint32 m_uiTeleport;
 };
 #endif
diff --git a/mangos/src/game/BattleGroundSA.h b/Core/src/game/BattleGroundSA.h
index 31a3ffa..9324999 100644
--- a/mangos/src/game/BattleGroundSA.h
+++ b/Core/src/game/BattleGroundSA.h
@@ -24,8 +24,10 @@ class BattleGround;
 class BattleGroundSAScore : public BattleGroundScore
 {
     public:
-        BattleGroundSAScore() {};
+        BattleGroundSAScore(): DemolishersDestroyed(0), GatesDestroyed(0) {};
         virtual ~BattleGroundSAScore() {};
+        uint32 DemolishersDestroyed;
+        uint32 GatesDestroyed;
 };
 
 class BattleGroundSA : public BattleGround
diff --git a/mangos/src/game/BattleGroundWS.cpp b/Core/src/game/BattleGroundWS.cpp
index 88d25a7..a01adbe 100644
--- a/mangos/src/game/BattleGroundWS.cpp
+++ b/Core/src/game/BattleGroundWS.cpp
@@ -27,6 +27,7 @@
 #include "WorldPacket.h"
 #include "Language.h"
 #include "MapManager.h"
+#include "World.h"
 
 BattleGroundWS::BattleGroundWS()
 {
@@ -239,6 +240,7 @@ void BattleGroundWS::EventPlayerCapturedFlag(Player *Source)
     UpdateTeamScore(Source->GetTeam());
     // only flag capture should be updated
     UpdatePlayerScore(Source, SCORE_FLAG_CAPTURES, 1);      // +1 flag captures
+    Source->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE,1);
 
     if (GetTeamScore(ALLIANCE) == BG_WS_MAX_TEAM_SCORE)
         winner = ALLIANCE;
@@ -392,6 +394,7 @@ void BattleGroundWS::EventPlayerClickedOnFlag(Player *Source, GameObject* target
             RespawnFlag(ALLIANCE, false);
             PlaySoundToAll(BG_WS_SOUND_FLAG_RETURNED);
             UpdatePlayerScore(Source, SCORE_FLAG_RETURNS, 1);
+            Source->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE,1,1);
         }
         else
         {
@@ -420,6 +423,7 @@ void BattleGroundWS::EventPlayerClickedOnFlag(Player *Source, GameObject* target
             RespawnFlag(HORDE, false);
             PlaySoundToAll(BG_WS_SOUND_FLAG_RETURNED);
             UpdatePlayerScore(Source, SCORE_FLAG_RETURNS, 1);
+            Source->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE,1,1);
         }
         else
         {
@@ -560,10 +564,9 @@ void BattleGroundWS::Reset()
 void BattleGroundWS::EndBattleGround(uint32 winner)
 {
     //win reward
-    if (winner == ALLIANCE)
-        RewardHonorToTeam(GetBonusHonorFromKill(m_HonorWinKills), ALLIANCE);
-    if (winner == HORDE)
-        RewardHonorToTeam(GetBonusHonorFromKill(m_HonorWinKills), HORDE);
+    if (winner)
+        RewardHonorToTeam(GetBonusHonorFromKill(sWorld.getConfig(CONFIG_UINT32_BONUS_HONOR_WSG_WIN)), winner);
+
     //complete map_end rewards (even if no team wins)
     RewardHonorToTeam(GetBonusHonorFromKill(m_HonorEndKills), ALLIANCE);
     RewardHonorToTeam(GetBonusHonorFromKill(m_HonorEndKills), HORDE);
diff --git a/mangos/src/game/BattleGroundWS.h b/Core/src/game/BattleGroundWS.h
index 7fe71e0..decd95a 100644
--- a/mangos/src/game/BattleGroundWS.h
+++ b/Core/src/game/BattleGroundWS.h
@@ -145,6 +145,7 @@ class BattleGroundWS : public BattleGround
         void AddPoint(uint32 TeamID, uint32 Points = 1)     { m_TeamScores[GetTeamIndexByTeamId(TeamID)] += Points; }
         void SetTeamPoint(uint32 TeamID, uint32 Points = 0) { m_TeamScores[GetTeamIndexByTeamId(TeamID)] = Points; }
         void RemovePoint(uint32 TeamID, uint32 Points = 1)  { m_TeamScores[GetTeamIndexByTeamId(TeamID)] -= Points; }
+
     private:
         uint64 m_FlagKeepers[BG_TEAMS_COUNT];
 
diff --git a/mangos/src/game/Channel.cpp b/Core/src/game/Channel.cpp
index a749e1a..4012c63 100644
--- a/mangos/src/game/Channel.cpp
+++ b/Core/src/game/Channel.cpp
@@ -538,11 +538,13 @@ void Channel::Say(uint64 p, const char *what, uint32 lang)
 {
     if(!what)
         return;
+
+    Player *plr = sObjectMgr.GetPlayer(p);
+
     if (sWorld.getConfig(CONFIG_BOOL_ALLOW_TWO_SIDE_INTERACTION_CHANNEL))
         lang = LANG_UNIVERSAL;
 
     uint32 sec = 0;
-    Player *plr = sObjectMgr.GetPlayer(p);
     if(plr)
         sec = plr->GetSession()->GetSecurity();
 
@@ -606,7 +608,7 @@ void Channel::Invite(uint64 p, const char *newname)
     if (!plr)
         return;
 
-    if (newp->GetTeam() != plr->GetTeam() && !sWorld.getConfig(CONFIG_BOOL_ALLOW_TWO_SIDE_INTERACTION_CHANNEL))
+    if (newp->GetTeam() != plr->GetTeam() && (!(sWorld.getConfig(CONFIG_BOOL_ALLOW_TWO_SIDE_INTERACTION_CHANNEL))))
     {
         WorldPacket data;
         MakeInviteWrongFaction(&data);
diff --git a/mangos/src/game/CharacterHandler.cpp b/Core/src/game/CharacterHandler.cpp
index 8357ede..97ac243 100644
--- a/mangos/src/game/CharacterHandler.cpp
+++ b/Core/src/game/CharacterHandler.cpp
@@ -39,6 +39,9 @@
 #include "ArenaTeam.h"
 #include "Language.h"
 
+// Playerbot mod:
+#include "PlayerbotMgr.h"
+
 // config option SkipCinematics supported values
 enum CinematicsSkipMode
 {
@@ -72,7 +75,7 @@ bool LoginQueryHolder::Initialize()
         "position_x, position_y, position_z, map, orientation, taximask, cinematic, totaltime, leveltime, rest_bonus, logout_time, is_logout_resting, resettalents_cost,"
         "resettalents_time, trans_x, trans_y, trans_z, trans_o, transguid, extra_flags, stable_slots, at_login, zone, online, death_expire_time, taxi_path, dungeon_difficulty,"
         "arenaPoints, totalHonorPoints, todayHonorPoints, yesterdayHonorPoints, totalKills, todayKills, yesterdayKills, chosenTitle, knownCurrencies, watchedFaction, drunk,"
-        "health, power1, power2, power3, power4, power5, power6, power7, specCount, activeSpec, exploredZones, equipmentCache, ammoId, knownTitles, actionBars FROM characters WHERE guid = '%u'", GUID_LOPART(m_guid));
+        "health, power1, power2, power3, power4, power5, power6, power7, specCount, activeSpec, exploredZones, equipmentCache, ammoId, knownTitles, actionBars, gmlevel FROM characters WHERE guid = '%u'", GUID_LOPART(m_guid));
     res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADGROUP,           "SELECT groupId FROM group_member WHERE memberGuid ='%u'", GUID_LOPART(m_guid));
     res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADBOUNDINSTANCES,  "SELECT id, permanent, map, difficulty, resettime FROM character_instance LEFT JOIN instance ON instance = id WHERE guid = '%u'", GUID_LOPART(m_guid));
     res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADAURAS,           "SELECT caster_guid,spell,effect_index,stackcount,amount,maxduration,remaintime,remaincharges FROM character_aura WHERE guid = '%u'", GUID_LOPART(m_guid));
@@ -95,12 +98,14 @@ bool LoginQueryHolder::Initialize()
     res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADCRITERIAPROGRESS,"SELECT criteria, counter, date FROM character_achievement_progress WHERE guid = '%u'", GUID_LOPART(m_guid));
     res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS,   "SELECT setguid, setindex, name, iconname, item0, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10, item11, item12, item13, item14, item15, item16, item17, item18 FROM character_equipmentsets WHERE guid = '%u' ORDER BY setindex", GUID_LOPART(m_guid));
     res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADBGDATA,          "SELECT instance_id, team, join_x, join_y, join_z, join_o, join_map, taxi_start, taxi_end, mount_spell FROM character_battleground_data WHERE guid = '%u'", GUID_LOPART(m_guid));
-    res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADACCOUNTDATA,     "SELECT type, time, data FROM character_account_data WHERE guid='%u'", GUID_LOPART(m_guid));
+    res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADBGSTATUS,        "SELECT daily_bg FROM character_battleground_status WHERE guid = '%u'", GUID_LOPART(m_guid));
+	res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADACCOUNTDATA,     "SELECT type, time, data FROM character_account_data WHERE guid='%u'", GUID_LOPART(m_guid));
     res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADTALENTS,         "SELECT talent_id, current_rank, spec FROM character_talent WHERE guid = '%u'", GUID_LOPART(m_guid));
     res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADSKILLS,          "SELECT skill, value, max FROM character_skills WHERE guid = '%u'", GUID_LOPART(m_guid));
     res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADGLYPHS,          "SELECT spec, slot, glyph FROM character_glyphs WHERE guid='%u'", GUID_LOPART(m_guid));
     res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADMAILS,           "SELECT id,messageType,sender,receiver,subject,body,has_items,expire_time,deliver_time,money,cod,checked,stationery,mailTemplateId FROM mail WHERE receiver = '%u' ORDER BY id DESC", GUID_LOPART(m_guid));
     res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADMAILEDITEMS,     "SELECT data, text, mail_id, item_guid, item_template FROM mail_items JOIN item_instance ON item_guid = guid WHERE receiver = '%u'", GUID_LOPART(m_guid));
+    res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADRANDOMBG,        "SELECT guid FROM character_battleground_random WHERE guid = '%u'", GUID_LOPART(m_guid));
 
     return res;
 }
@@ -132,6 +137,31 @@ class CharacterHandler
             }
             session->HandlePlayerLogin((LoginQueryHolder*)holder);
         }
+        // Playerbot mod: is different from the normal HandlePlayerLoginCallback in that it
+        // sets up the bot's world session and also stores the pointer to the bot player in the master's
+        // world session m_playerBots map
+        void HandlePlayerBotLoginCallback(QueryResult * /*dummy*/, SqlQueryHolder * holder)
+        {
+            if (!holder)
+                return;
+
+            LoginQueryHolder* lqh = (LoginQueryHolder*) holder;
+
+            WorldSession* masterSession = sWorld.FindSession(lqh->GetAccountId());
+
+            if (! masterSession || sObjectMgr.GetPlayer(lqh->GetGuid()))
+            {
+                delete holder;
+                return;
+            }
+
+            // The bot's WorldSession is owned by the bot's Player object
+            // The bot's WorldSession is deleted by PlayerbotMgr::LogoutPlayerBot
+            WorldSession *botSession = new WorldSession(lqh->GetAccountId(), NULL, SEC_PLAYER, masterSession->Expansion(), 0, LOCALE_enUS);
+            botSession->m_Address = "bot";
+            botSession->HandlePlayerLogin(lqh); // will delete lqh
+            masterSession->GetPlayer()->GetPlayerbotMgr()->OnBotLogin(botSession->GetPlayer());
+        }
 } chrHandler;
 
 void WorldSession::HandleCharEnum(QueryResult * result)
@@ -570,6 +600,27 @@ void WorldSession::HandlePlayerLoginOpcode( WorldPacket & recv_data )
     CharacterDatabase.DelayQueryHolder(&chrHandler, &CharacterHandler::HandlePlayerLoginCallback, holder);
 }
 
+// Playerbot mod. Can't easily reuse HandlePlayerLoginOpcode for logging in bots because it assumes
+// a WorldSession exists for the bot. The WorldSession for a bot is created after the character is loaded.
+void PlayerbotMgr::AddPlayerBot(uint64 playerGuid)
+{
+    // has bot already been added?
+    if (sObjectMgr.GetPlayer(playerGuid))
+        return;
+
+    uint32 accountId = sObjectMgr.GetPlayerAccountIdByGUID(playerGuid);
+    if (accountId == 0)
+        return;
+
+    LoginQueryHolder *holder = new LoginQueryHolder(accountId, playerGuid);
+    if(!holder->Initialize())
+    {
+        delete holder;                                      // delete all unprocessed queries
+        return;
+    }
+    CharacterDatabase.DelayQueryHolder(&chrHandler, &CharacterHandler::HandlePlayerBotLoginCallback, holder);
+}
+
 void WorldSession::HandlePlayerLogin(LoginQueryHolder *holder)
 {
     uint64 playerGuid = holder->GetGuid();
@@ -685,6 +736,71 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder *holder)
     data << uint32(0);
     SendPacket(&data);
 
+    if (sWorld.getConfig(CONFIG_BOOL_ALLOW_FLYING_MOUNTS_EVERYWHERE))
+        pCurrChar->FlyingMountsSpellsToItems();
+        
+    if (sWorld.getConfig(CONFIG_BOOL_EVERYONE_DRUNK))
+    {
+        pCurrChar->SetDrunkValue(23000);
+    }
+    if (pCurrChar->GetDrunkValue() >= 10000)
+        pCurrChar->SetDrunkValue(0);
+    
+    if (sWorld.getConfig(CONFIG_BOOL_ALL_WEAPONS_MAX_SKILL))
+    {
+        pCurrChar->SetSkill(SKILL_UNARMED, 450, 450);
+        pCurrChar->SetSkill(SKILL_2H_SWORDS, 450, 450);
+        pCurrChar->SetSkill(SKILL_GUNS, 450, 450);
+        pCurrChar->SetSkill(SKILL_BOWS, 450, 450);
+        pCurrChar->SetSkill(SKILL_AXES, 450, 450);
+        pCurrChar->SetSkill(SKILL_SWORDS, 450, 450);
+        pCurrChar->SetSkill(SKILL_STAVES, 450, 450);
+        pCurrChar->SetSkill(SKILL_2H_MACES, 450, 450);
+        pCurrChar->SetSkill(SKILL_MACES, 450, 450);
+        pCurrChar->SetSkill(SKILL_WANDS, 450, 450);
+        pCurrChar->SetSkill(SKILL_2H_AXES, 450, 450);
+        pCurrChar->SetSkill(SKILL_DAGGERS, 450, 450);
+        pCurrChar->SetSkill(SKILL_THROWN, 450, 450);
+        pCurrChar->SetSkill(SKILL_CROSSBOWS, 450, 450);
+        pCurrChar->SetSkill(SKILL_POLEARMS, 450, 450);
+        pCurrChar->SetSkill(SKILL_FIST_WEAPONS, 450, 450);
+    }
+
+    if (sWorld.getConfig(CONFIG_BOOL_ALL_WEAPONS_FOR_CLASS_MAX_SKILL))
+    {
+        if(pCurrChar->getClass() == CLASS_HUNTER || pCurrChar->getClass() == CLASS_ROGUE || pCurrChar->getClass() == CLASS_WARRIOR)
+        {
+            pCurrChar->SetSkill(SKILL_BOWS, 450, 450);
+            pCurrChar->SetSkill(SKILL_CROSSBOWS, 450, 450);
+            pCurrChar->SetSkill(SKILL_GUNS, 450, 450);
+            pCurrChar->SetSkill(SKILL_THROWN, 450, 450);
+        }
+        if(pCurrChar->getClass() == CLASS_DRUID || pCurrChar->getClass() == CLASS_HUNTER || pCurrChar->getClass() == CLASS_MAGE || pCurrChar->getClass() == CLASS_PRIEST || pCurrChar->getClass() == CLASS_ROGUE || pCurrChar->getClass() == CLASS_SHAMAN || pCurrChar->getClass() == CLASS_WARLOCK || pCurrChar->getClass() == CLASS_WARRIOR)
+        {
+            pCurrChar->SetSkill(SKILL_DAGGERS, 450, 450);
+            pCurrChar->SetSkill(SKILL_STAVES, 450, 450);
+        }
+        if(pCurrChar->getClass() == CLASS_DRUID || pCurrChar->getClass() == CLASS_HUNTER || pCurrChar->getClass() == CLASS_ROGUE || pCurrChar->getClass() == CLASS_SHAMAN || pCurrChar->getClass() == CLASS_WARRIOR)
+            pCurrChar->SetSkill(SKILL_FIST_WEAPONS, 450, 450);
+        if(pCurrChar->getClass() == CLASS_DEATH_KNIGHT || pCurrChar->getClass() == CLASS_HUNTER || pCurrChar->getClass() == CLASS_PALADIN || pCurrChar->getClass() == CLASS_ROGUE || pCurrChar->getClass() == CLASS_SHAMAN || pCurrChar->getClass() == CLASS_WARRIOR)
+            pCurrChar->SetSkill(SKILL_AXES, 450, 450);
+        if(pCurrChar->getClass() == CLASS_DEATH_KNIGHT || pCurrChar->getClass() == CLASS_DRUID || pCurrChar->getClass() == CLASS_PALADIN || pCurrChar->getClass() == CLASS_PRIEST || pCurrChar->getClass() == CLASS_ROGUE || pCurrChar->getClass() == CLASS_SHAMAN || pCurrChar->getClass() == CLASS_WARRIOR)
+            pCurrChar->SetSkill(SKILL_MACES, 450, 450);
+        if(pCurrChar->getClass() == CLASS_DEATH_KNIGHT || pCurrChar->getClass() == CLASS_HUNTER || pCurrChar->getClass() == CLASS_MAGE || pCurrChar->getClass() == CLASS_PALADIN || pCurrChar->getClass() == CLASS_PRIEST || pCurrChar->getClass() == CLASS_ROGUE || pCurrChar->getClass() == CLASS_WARLOCK || pCurrChar->getClass() == CLASS_WARRIOR)
+            pCurrChar->SetSkill(SKILL_SWORDS, 450, 450);
+        if(pCurrChar->getClass() == CLASS_DEATH_KNIGHT || pCurrChar->getClass() == CLASS_DRUID || pCurrChar->getClass() == CLASS_HUNTER || pCurrChar->getClass() == CLASS_PALADIN || pCurrChar->getClass() == CLASS_WARRIOR)
+            pCurrChar->SetSkill(SKILL_POLEARMS, 450, 450);
+        if(pCurrChar->getClass() == CLASS_MAGE || pCurrChar->getClass() == CLASS_PRIEST || pCurrChar->getClass() == CLASS_WARLOCK)
+            pCurrChar->SetSkill(SKILL_WANDS, 450, 450);
+        if(pCurrChar->getClass() == CLASS_DEATH_KNIGHT || pCurrChar->getClass() == CLASS_HUNTER || pCurrChar->getClass() == CLASS_PALADIN || pCurrChar->getClass() == CLASS_SHAMAN || pCurrChar->getClass() == CLASS_WARRIOR)
+            pCurrChar->SetSkill(SKILL_2H_AXES, 450, 450);
+        if(pCurrChar->getClass() == CLASS_DEATH_KNIGHT || pCurrChar->getClass() == CLASS_DRUID || pCurrChar->getClass() == CLASS_PALADIN || pCurrChar->getClass() == CLASS_SHAMAN || pCurrChar->getClass() == CLASS_WARRIOR)
+            pCurrChar->SetSkill(SKILL_2H_MACES, 450, 450);
+        if(pCurrChar->getClass() == CLASS_DEATH_KNIGHT || pCurrChar->getClass() == CLASS_HUNTER || pCurrChar->getClass() == CLASS_PALADIN || pCurrChar->getClass() == CLASS_WARRIOR)
+            pCurrChar->SetSkill(SKILL_2H_SWORDS, 450, 450);
+        pCurrChar->SetSkill(SKILL_UNARMED, 450, 450);
+    }
+    
     pCurrChar->SendInitialPacketsBeforeAddToMap();
 
     //Show cinematic at the first time that player login
@@ -790,6 +906,8 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder *holder)
     if(!pCurrChar->IsStandState() && !pCurrChar->hasUnitState(UNIT_STAT_STUNNED))
         pCurrChar->SetStandState(UNIT_STAND_STATE_STAND);
 
+    pCurrChar->UpdateHonorFields();
+
     m_playerLoading = false;
     delete holder;
 }
@@ -1047,7 +1165,7 @@ void WorldSession::HandleSetPlayerDeclinedNames(WorldPacket& recv_data)
         }
     }
 
-    if(!ObjectMgr::CheckDeclinedNames(GetMainPartOfName(wname, 0), declinedname))
+    if(!ObjectMgr::CheckDeclinedNames(wname, declinedname))
     {
         WorldPacket data(SMSG_SET_PLAYER_DECLINED_NAMES_RESULT, 4+8);
         data << uint32(1);
@@ -1138,6 +1256,197 @@ void WorldSession::HandleRemoveGlyph( WorldPacket & recv_data )
     }
 }
 
+void WorldSession::HandleCharFactionOrRaceChange(WorldPacket& recv_data)
+{
+    uint64 guid;
+    std::string newname;
+    uint8 gender, skin, face, hairStyle, hairColor, facialHair, race;
+    recv_data >> guid;
+    recv_data >> newname;
+    recv_data >> gender >> skin >> hairColor >> hairStyle >> facialHair >> face >> race;
+
+    QueryResult *result = CharacterDatabase.PQuery("SELECT at_login FROM characters WHERE guid ='%u'", GUID_LOPART(guid));
+    if (!result)
+    {
+        WorldPacket data(SMSG_CHAR_FACTION_CHANGE, 1);
+        data << uint8(CHAR_CREATE_ERROR);
+        SendPacket( &data );
+        return;
+    }
+
+    Field *fields = result->Fetch();
+    uint32 at_loginFlags = fields[0].GetUInt32();
+    uint32 used_loginFlag = recv_data.GetOpcode() == CMSG_CHAR_RACE_CHANGE ? AT_LOGIN_CHANGE_RACE : AT_LOGIN_CHANGE_FACTION;
+    delete result;
+
+    if (!(at_loginFlags & used_loginFlag))
+    {
+        WorldPacket data(SMSG_CHAR_FACTION_CHANGE, 1);
+        data << uint8(CHAR_CREATE_ERROR);
+        SendPacket( &data );
+        return;
+    }
+
+    // prevent character rename to invalid name
+    if (!normalizePlayerName(newname))
+    {
+        WorldPacket data(SMSG_CHAR_FACTION_CHANGE, 1);
+        data << uint8(CHAR_NAME_NO_NAME);
+        SendPacket( &data );
+        return;
+    }
+
+    uint8 res = ObjectMgr::CheckPlayerName(newname,true);
+    if (res != CHAR_NAME_SUCCESS)
+    {
+        WorldPacket data(SMSG_CHAR_FACTION_CHANGE, 1);
+        data << uint8(res);
+        SendPacket( &data );
+        return;
+    }
+
+    // check name limitations
+    if (GetSecurity() == SEC_PLAYER && sObjectMgr.IsReservedName(newname))
+    {
+        WorldPacket data(SMSG_CHAR_FACTION_CHANGE, 1);
+        data << uint8(CHAR_NAME_RESERVED);
+        SendPacket( &data );
+        return;
+    }
+
+    // character with this name already exist
+    if (uint64 newguid = sObjectMgr.GetPlayerGUIDByName(newname))
+    {
+        if (newguid != guid)
+        {
+            WorldPacket data(SMSG_CHAR_FACTION_CHANGE, 1);
+            data << uint8(CHAR_CREATE_NAME_IN_USE);
+            SendPacket( &data );
+            return;
+        }
+    }
+
+    CharacterDatabase.escape_string(newname);
+    Player::Customize(guid, gender, skin, face, hairStyle, hairColor, facialHair);
+    CharacterDatabase.BeginTransaction();
+    CharacterDatabase.PExecute("UPDATE characters set name = '%s', race = '%u', at_login = at_login & ~ %u WHERE guid ='%u'", newname.c_str(), race, uint32(used_loginFlag), GUID_LOPART(guid));
+    CharacterDatabase.PExecute("DELETE FROM character_declinedname WHERE guid ='%u'", GUID_LOPART(guid));
+
+    if(recv_data.GetOpcode() == CMSG_CHAR_FACTION_CHANGE)
+    {
+        // Delete all Flypaths
+        CharacterDatabase.PExecute("UPDATE characters set taxi_path = '' WHERE guid ='%u'",GUID_LOPART(guid));
+        // Delete all current quests
+        CharacterDatabase.PExecute("DELETE FROM `character_queststatus` WHERE `status` = 3 AND guid ='%u'",GUID_LOPART(guid));
+        // Reset guild
+        CharacterDatabase.PExecute("DELETE FROM `guild_member` WHERE `guid`= '%u'",GUID_LOPART(guid));
+        // Delete Friend List
+        CharacterDatabase.PExecute("DELETE FROM `character_social` WHERE `guid`= '%u'",GUID_LOPART(guid));
+        CharacterDatabase.PExecute("DELETE FROM `character_social` WHERE `friend`= '%u'",GUID_LOPART(guid));
+        // Leave Arena Teams
+        Player::LeaveAllArenaTeams(GUID_LOPART(guid));
+
+        // Search each faction is targeted
+        BattleGroundTeamId team = BG_TEAM_ALLIANCE;
+        switch(race)
+        {
+            case RACE_ORC:
+            case RACE_TAUREN:
+            case RACE_UNDEAD_PLAYER:
+            case RACE_TROLL:
+            case RACE_BLOODELF:
+            //case RACE_GOBLIN: for cataclysm
+                team = BG_TEAM_HORDE;
+                break;
+            default: break;
+        }
+        
+        // Reset homebind
+        CharacterDatabase.PExecute("DELETE FROM `character_homebind` WHERE guid = '%u'",GUID_LOPART(guid));
+        if(team == BG_TEAM_ALLIANCE)
+            CharacterDatabase.PExecute("INSERT INTO `character_homebind` VALUES ('%u','0','1519','-8867.68','673.373','97.9034')",GUID_LOPART(guid));
+        else
+            CharacterDatabase.PExecute("INSERT INTO `character_homebind` VALUES ('%u','1','1637','1633.33','-4439.11','15.7588')",GUID_LOPART(guid));
+
+        // Achievement conversion
+        if(QueryResult *result2 = WorldDatabase.Query("SELECT alliance_id, horde_id FROM player_factionchange_achievements"))
+        {
+            do
+            {
+                Field *fields2 = result2->Fetch();
+                uint32 achiev_alliance = fields2[0].GetUInt32();
+                uint32 achiev_horde = fields2[1].GetUInt32();
+                CharacterDatabase.PExecute("UPDATE `character_achievement` set achievement = '%u' where achievement = '%u' AND guid = '%u'",
+                    team == BG_TEAM_ALLIANCE ? achiev_alliance : achiev_horde, team == BG_TEAM_ALLIANCE ? achiev_horde : achiev_alliance, GUID_LOPART(guid));
+            }
+            while( result2->NextRow() );
+        }
+
+        // Item conversion
+        if(QueryResult *result2 = WorldDatabase.Query("SELECT alliance_id, horde_id FROM player_factionchange_items"))
+        {
+            do
+            {
+                Field *fields2 = result2->Fetch();
+                uint32 item_alliance = fields2[0].GetUInt32();
+                uint32 item_horde = fields2[1].GetUInt32();
+                CharacterDatabase.PExecute("UPDATE `character_inventory` set item = '%u' where item = '%u' AND guid = '%u'",
+                    team == BG_TEAM_ALLIANCE ? item_alliance : item_horde, team == BG_TEAM_ALLIANCE ? item_horde : item_alliance, guid);
+
+                CharacterDatabase.PExecute("UPDATE `item_instance` SET `data`=CONCAT(CAST(SUBSTRING_INDEX(`data`, ' ', 3) AS CHAR), ' ', '%u', ' ',    CAST(SUBSTRING_INDEX(`data`, ' ', (3-64))AS CHAR)) WHERE CAST(SUBSTRING_INDEX(SUBSTRING_INDEX(`data`, ' ', 4), ' ', '-1') AS UNSIGNED) = '%u' AND owner_guid = '%u'",
+                        team == BG_TEAM_ALLIANCE ? item_alliance : item_horde, team == BG_TEAM_ALLIANCE ? item_horde : item_alliance, GUID_LOPART(guid));
+            }
+            while( result2->NextRow() );
+        }
+
+        // Spell conversion
+        if(QueryResult *result2 = WorldDatabase.Query("SELECT alliance_id, horde_id FROM player_factionchange_spells"))
+        {
+            do
+            {
+                Field *fields2 = result2->Fetch();
+                uint32 spell_alliance = fields2[0].GetUInt32();
+                uint32 spell_horde = fields2[1].GetUInt32();
+                CharacterDatabase.PExecute("UPDATE `character_spell` set spell = '%u' where spell = '%u' AND guid = '%u'",
+                    team == BG_TEAM_ALLIANCE ? spell_alliance : spell_horde, team == BG_TEAM_ALLIANCE ? spell_horde : spell_alliance, GUID_LOPART(guid));
+            }
+            while( result2->NextRow() );
+        }
+
+        // Reputation conversion
+        if(QueryResult *result2 = WorldDatabase.Query("SELECT alliance_id, horde_id FROM player_factionchange_reputations"))
+        {
+            do
+            {
+                Field *fields2 = result2->Fetch();
+                uint32 reputation_alliance = fields2[0].GetUInt32();
+                uint32 reputation_horde = fields2[1].GetUInt32();
+                CharacterDatabase.PExecute("DELETE FROM character_reputation WHERE faction = '%u' AND guid = '%u'",team == BG_TEAM_ALLIANCE ? reputation_horde : reputation_alliance, GUID_LOPART(guid));
+                CharacterDatabase.PExecute("UPDATE `character_reputation` set faction = '%u' where faction = '%u' AND guid = '%u'",
+                    team == BG_TEAM_ALLIANCE ? reputation_alliance : reputation_horde, team == BG_TEAM_ALLIANCE ? reputation_horde : reputation_alliance, GUID_LOPART(guid));
+            }
+            while( result2->NextRow() );
+        }
+    }
+    CharacterDatabase.CommitTransaction();
+
+    std::string IP_str = GetRemoteAddress();
+    sLog.outChar("Account: %d (IP: %s), Character guid: %u Change Race/Faction to: %s", GetAccountId(), IP_str.c_str(), GUID_LOPART(guid), newname.c_str());
+
+    WorldPacket data(SMSG_CHAR_FACTION_CHANGE, 1+8+(newname.size()+1)+7);
+    data << uint8(RESPONSE_SUCCESS);
+    data << uint64(guid);
+    data << newname;
+    data << uint8(gender);
+    data << uint8(skin);
+    data << uint8(face);
+    data << uint8(hairStyle);
+    data << uint8(hairColor);
+    data << uint8(facialHair);
+    data << uint8(race);
+    SendPacket(&data);
+}
+
 void WorldSession::HandleCharCustomize(WorldPacket& recv_data)
 {
     uint64 guid;
@@ -1330,6 +1639,6 @@ void WorldSession::HandleEquipmentSetUse(WorldPacket &recv_data)
     }
 
     WorldPacket data(SMSG_EQUIPMENT_SET_USE_RESULT, 1);
-    data << uint8(0);                                       // 4 - equipment swap failed - inventory is full
+    data << uint8(0);   // 4 - equipment swap failed - inventory is full
     SendPacket(&data);
 }
diff --git a/mangos/src/game/Chat.cpp b/Core/src/game/Chat.cpp
index 9750696..abffb85 100644
--- a/mangos/src/game/Chat.cpp
+++ b/Core/src/game/Chat.cpp
@@ -75,6 +75,7 @@ ChatCommand * ChatHandler::getCommandTable()
         { "characters",     SEC_CONSOLE,        true,  &ChatHandler::HandleAccountCharactersCommand,   "", NULL },
         { "create",         SEC_CONSOLE,        true,  &ChatHandler::HandleAccountCreateCommand,       "", NULL },
         { "delete",         SEC_CONSOLE,        true,  &ChatHandler::HandleAccountDeleteCommand,       "", NULL },
+        { "gmlevel",        SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleCharacterGMLevelCommand,    "", NULL },
         { "onlinelist",     SEC_CONSOLE,        true,  &ChatHandler::HandleAccountOnlineListCommand,   "", NULL },
         { "lock",           SEC_PLAYER,         true,  &ChatHandler::HandleAccountLockCommand,         "", NULL },
         { "set",            SEC_ADMINISTRATOR,  true,  NULL,                                           "", accountSetCommandTable },
@@ -128,8 +129,10 @@ ChatCommand * ChatHandler::getCommandTable()
 
     static ChatCommand characterCommandTable[] =
     {
-        { "customize",      SEC_GAMEMASTER,     true,  &ChatHandler::HandleCharacterCustomizeCommand,  "", NULL },
-        { "deleted",        SEC_GAMEMASTER,     true,  NULL,                                           "", characterDeletedCommandTable},
+        { "customize",      SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleCharacterCustomizeCommand,  "", NULL },
+        { "deleted",        SEC_ADMINISTRATOR,  true,  NULL,                                           "", characterDeletedCommandTable},
+        { "changefaction",  SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleCharacterChangeFactionCommand,	"", NULL },
+        { "changerace",     SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleCharacterChangeRaceCommand,		"", NULL },
         { "erase",          SEC_CONSOLE,        true,  &ChatHandler::HandleCharacterEraseCommand,      "", NULL },
         { "level",          SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleCharacterLevelCommand,      "", NULL },
         { "rename",         SEC_GAMEMASTER,     true,  &ChatHandler::HandleCharacterRenameCommand,     "", NULL },
@@ -256,6 +259,7 @@ ChatCommand * ChatHandler::getCommandTable()
         { "unbind",         SEC_ADMINISTRATOR,  false, &ChatHandler::HandleInstanceUnbindCommand,      "", NULL },
         { "stats",          SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleInstanceStatsCommand,       "", NULL },
         { "savedata",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleInstanceSaveDataCommand,    "", NULL },
+        { "start",          SEC_ADMINISTRATOR,  false, &ChatHandler::HandleInstanceStartCommand,       "", NULL },
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
@@ -354,6 +358,7 @@ ChatCommand * ChatHandler::getCommandTable()
     static ChatCommand npcCommandTable[] =
     {
         { "add",            SEC_GAMEMASTER,     false, &ChatHandler::HandleNpcAddCommand,              "", NULL },
+		{ "addaspet",       SEC_GAMEMASTER,     false, &ChatHandler::HandleNpcAddAsPetCommand,         "", NULL },
         { "additem",        SEC_GAMEMASTER,     false, &ChatHandler::HandleNpcAddVendorItemCommand,    "", NULL },
         { "addmove",        SEC_GAMEMASTER,     false, &ChatHandler::HandleNpcAddMoveCommand,          "", NULL },
         { "allowmove",      SEC_ADMINISTRATOR,  false, &ChatHandler::HandleNpcAllowMovementCommand,    "", NULL },
@@ -495,7 +500,9 @@ ChatCommand * ChatHandler::getCommandTable()
         { "spell_scripts",               SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadSpellScriptsCommand,            "", NULL },
         { "spell_target_position",       SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadSpellTargetPositionCommand,     "", NULL },
         { "spell_threats",               SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadSpellThreatsCommand,            "", NULL },
-
+        { "spell_disabled",              SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadSpellDisabledCommand,           "", NULL },
+        { "vehicle_data",                SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadVehicleDataCommand,             "", NULL },
+        { "vehicle_seat_data",           SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadVehicleSeatDataCommand,         "", NULL },
         { NULL,                          0,                 false, NULL,                                                     "", NULL }
     };
 
@@ -642,9 +649,15 @@ ChatCommand * ChatHandler::getCommandTable()
         { "titles",         SEC_GAMEMASTER,     false, NULL,                                           "", titlesCommandTable   },
         { "wp",             SEC_GAMEMASTER,     false, NULL,                                           "", wpCommandTable       },
 
+        // Jail by WarHead
+        { "jail",           SEC_MODERATOR,      false, &ChatHandler::HandleJailCommand,                "", NULL },
+        { "jailinfo",       SEC_PLAYER,         false, &ChatHandler::HandleJailInfoCommand,            "", NULL },
+        { "unjail",         SEC_MODERATOR,      false, &ChatHandler::HandleUnJailCommand,              "", NULL },
+        { "jailreload",     SEC_ADMINISTRATOR,  false, &ChatHandler::HandleJailReloadCommand,          "", NULL },
         { "aura",           SEC_ADMINISTRATOR,  false, &ChatHandler::HandleAuraCommand,                "", NULL },
         { "unaura",         SEC_ADMINISTRATOR,  false, &ChatHandler::HandleUnAuraCommand,              "", NULL },
-        { "announce",       SEC_MODERATOR,      true,  &ChatHandler::HandleAnnounceCommand,            "", NULL },
+        { "announce",       SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleAnnounceCommand,            "", NULL },
+        { "nameannounce",   SEC_MODERATOR,  	false, &ChatHandler::HandleNameAnnounceCommand,        "", NULL },
         { "notify",         SEC_MODERATOR,      true,  &ChatHandler::HandleNotifyCommand,              "", NULL },
         { "goname",         SEC_MODERATOR,      false, &ChatHandler::HandleGonameCommand,              "", NULL },
         { "namego",         SEC_MODERATOR,      false, &ChatHandler::HandleNamegoCommand,              "", NULL },
@@ -679,6 +692,7 @@ ChatCommand * ChatHandler::getCommandTable()
         { "showarea",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleShowAreaCommand,            "", NULL },
         { "hidearea",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleHideAreaCommand,            "", NULL },
         { "additem",        SEC_ADMINISTRATOR,  false, &ChatHandler::HandleAddItemCommand,             "", NULL },
+		{ "delitem",        SEC_ADMINISTRATOR,  false, &ChatHandler::HandleDeleteItemCommand,          "", NULL },
         { "additemset",     SEC_ADMINISTRATOR,  false, &ChatHandler::HandleAddItemSetCommand,          "", NULL },
         { "bank",           SEC_ADMINISTRATOR,  false, &ChatHandler::HandleBankCommand,                "", NULL },
         { "wchange",        SEC_ADMINISTRATOR,  false, &ChatHandler::HandleChangeWeather,              "", NULL },
@@ -697,9 +711,12 @@ ChatCommand * ChatHandler::getCommandTable()
         { "cometome",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleComeToMeCommand,            "", NULL },
         { "damage",         SEC_ADMINISTRATOR,  false, &ChatHandler::HandleDamageCommand,              "", NULL },
         { "combatstop",     SEC_GAMEMASTER,     false, &ChatHandler::HandleCombatStopCommand,          "", NULL },
+        { "ahbotoptions",   SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleAHBotOptionsCommand,        "", NULL },
         { "flusharenapoints",SEC_ADMINISTRATOR, false, &ChatHandler::HandleFlushArenaPointsCommand,    "", NULL },
         { "repairitems",    SEC_GAMEMASTER,     true,  &ChatHandler::HandleRepairitemsCommand,         "", NULL },
         { "waterwalk",      SEC_GAMEMASTER,     false, &ChatHandler::HandleWaterwalkCommand,           "", NULL },
+        //Playerbot mod
+        { "bot",            SEC_PLAYER,         false, &ChatHandler::HandlePlayerbotCommand,           "", NULL },
         { "quit",           SEC_CONSOLE,        true,  &ChatHandler::HandleQuitCommand,                "", NULL },
 
         { NULL,             0,                  false, NULL,                                           "", NULL }
@@ -933,7 +950,7 @@ bool ChatHandler::ExecuteCommandInTable(ChatCommand *table, const char* text, co
                         fullcmd.c_str(),p->GetName(),GetAccountId(),p->GetPositionX(),p->GetPositionY(),p->GetPositionZ(),p->GetMapId(),
                         sel_guid.GetString().c_str());
                 }
-                else                                        // 0 account -> console
+                else                                   // 0 account -> console
                 {
                     sLog.outCommand(GetAccountId(),"Command: %s [Account: %u from %s]",
                         fullcmd.c_str(),GetAccountId(),GetAccountId() ? "RA-connection" : "Console");
@@ -1813,7 +1830,7 @@ Creature* ChatHandler::getSelectedCreature()
     if(!m_session)
         return NULL;
 
-    return m_session->GetPlayer()->GetMap()->GetCreatureOrPetOrVehicle(m_session->GetPlayer()->GetSelection());
+    return ObjectAccessor::GetCreatureOrPetOrVehicle(*m_session->GetPlayer(),m_session->GetPlayer()->GetSelection());
 }
 
 char* ChatHandler::extractKeyFromLink(char* text, char const* linkType, char** something1)
diff --git a/mangos/src/game/Chat.h b/Core/src/game/Chat.h
index 87aa895..0b5f0c9 100644
--- a/mangos/src/game/Chat.h
+++ b/Core/src/game/Chat.h
@@ -32,7 +32,7 @@ class ChatCommand
 {
     public:
         const char *       Name;
-        uint32             SecurityLevel;                   // function pointer required correct align (use uint32)
+        uint32             SecurityLevel;                  // function pointer required correct align (use uint32)
         bool               AllowConsole;
         bool (ChatHandler::*Handler)(const char* args);
         std::string        Help;
@@ -108,6 +108,7 @@ class ChatHandler
         bool HandleAccountSetAddonCommand(const char* args);
         bool HandleAccountSetGmLevelCommand(const char* args);
         bool HandleAccountSetPasswordCommand(const char* args);
+        bool HandleAHBotOptionsCommand(const char* args);
 
         bool HandleBanAccountCommand(const char* args);
         bool HandleBanCharacterCommand(const char* args);
@@ -126,12 +127,15 @@ class ChatHandler
         bool HandleCastTargetCommand(const char *args);
 
         bool HandleCharacterCustomizeCommand(const char * args);
+        bool HandleCharacterChangeFactionCommand(const char* args);
+        bool HandleCharacterChangeRaceCommand(const char* args);
         bool HandleCharacterDeletedDeleteCommand(const char* args);
         bool HandleCharacterDeletedListCommand(const char* args);
         bool HandleCharacterDeletedRestoreCommand(const char* args);
         bool HandleCharacterDeletedOldCommand(const char* args);
         bool HandleCharacterEraseCommand(const char* args);
         bool HandleCharacterLevelCommand(const char* args);
+        bool HandleCharacterGMLevelCommand(const char* args);
         bool HandleCharacterRenameCommand(const char * args);
         bool HandleCharacterReputationCommand(const char* args);
         bool HandleCharacterTitlesCommand(const char* args);
@@ -214,6 +218,7 @@ class ChatHandler
         bool HandleInstanceUnbindCommand(const char* args);
         bool HandleInstanceStatsCommand(const char* args);
         bool HandleInstanceSaveDataCommand(const char * args);
+        bool HandleInstanceStartCommand(const char * args);
 
         bool HandleLearnCommand(const char* args);
         bool HandleLearnAllCommand(const char* args);
@@ -278,6 +283,7 @@ class ChatHandler
 
         //-----------------------Npc Commands-----------------------
         bool HandleNpcAddCommand(const char* args);
+		bool HandleNpcAddAsPetCommand(const char* args);
         bool HandleNpcAddMoveCommand(const char* args);
         bool HandleNpcAddVendorItemCommand(const char* args);
         bool HandleNpcAllowMovementCommand(const char* args);
@@ -405,6 +411,9 @@ class ChatHandler
         bool HandleReloadSpellTargetPositionCommand(const char* args);
         bool HandleReloadSpellThreatsCommand(const char* args);
         bool HandleReloadSpellPetAurasCommand(const char* args);
+        bool HandleReloadSpellDisabledCommand(const char* args);
+        bool HandleReloadVehicleDataCommand(const char* args);
+        bool HandleReloadVehicleSeatDataCommand(const char* args);
 
         bool HandleResetAchievementsCommand(const char * args);
         bool HandleResetAllCommand(const char * args);
@@ -466,6 +475,7 @@ class ChatHandler
         bool HandleGroupgoCommand(const char* args);
         bool HandleRecallCommand(const char* args);
         bool HandleAnnounceCommand(const char* args);
+        bool HandleNameAnnounceCommand(const char* args);
         bool HandleNotifyCommand(const char* args);
         bool HandleGPSCommand(const char* args);
         bool HandleTaxiCheatCommand(const char* args);
@@ -500,6 +510,7 @@ class ChatHandler
         bool HandleShowAreaCommand(const char* args);
         bool HandleHideAreaCommand(const char* args);
         bool HandleAddItemCommand(const char* args);
+		bool HandleDeleteItemCommand(const char* args);
         bool HandleAddItemSetCommand(const char* args);
 
         bool HandleBankCommand(const char* args);
@@ -516,7 +527,13 @@ class ChatHandler
         bool HandleFlushArenaPointsCommand(const char *args);
         bool HandleRepairitemsCommand(const char* args);
         bool HandleWaterwalkCommand(const char* args);
+        bool HandlePlayerbotCommand(const char* args);
         bool HandleQuitCommand(const char* args);
+        // Jail by WarHead
+        bool HandleJailCommand(const char* args);
+        bool HandleJailInfoCommand(const char* args);
+        bool HandleUnJailCommand(const char* args);
+        bool HandleJailReloadCommand(const char* args);
 
         //! Development Commands
         bool HandleSaveAllCommand(const char* args);
diff --git a/mangos/src/game/ChatHandler.cpp b/Core/src/game/ChatHandler.cpp
index 3e575bb..6906117 100644
--- a/mangos/src/game/ChatHandler.cpp
+++ b/Core/src/game/ChatHandler.cpp
@@ -18,6 +18,7 @@
 
 #include "Common.h"
 #include "Log.h"
+#include "ChatLog.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
 #include "World.h"
@@ -37,6 +38,9 @@
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
 
+// Playerbot mod
+#include "PlayerbotAI.h"
+
 bool WorldSession::processChatmessageFurtherAfterSecurityChecks(std::string& msg, uint32 lang)
 {
     if (lang != LANG_ADDON)
@@ -179,11 +183,20 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
                 break;
 
             if(type == CHAT_MSG_SAY)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
                 GetPlayer()->Say(msg, lang);
+            }
             else if(type == CHAT_MSG_EMOTE)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
                 GetPlayer()->TextEmote(msg);
+            }
             else if(type == CHAT_MSG_YELL)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
                 GetPlayer()->Yell(msg, lang);
+            }
         } break;
 
         case CHAT_MSG_WHISPER:
@@ -198,6 +211,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.WhisperMsg(GetPlayer(), to, msg);
+
             if(!normalizePlayerName(to))
             {
                 SendPlayerNotFoundNotice(to);
@@ -224,7 +239,15 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
                 }
             }
 
-            GetPlayer()->Whisper(msg, lang, player->GetGUID());
+            // Playerbot mod: handle whispered command to bot
+            if (player->GetPlayerbotAI())
+            {
+                player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                GetPlayer()->m_speakTime = 0;
+                GetPlayer()->m_speakCount = 0;
+            }
+            else
+                GetPlayer()->Whisper(msg, lang, player->GetGUID());
         } break;
 
         case CHAT_MSG_PARTY:
@@ -245,6 +268,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.PartyMsg(GetPlayer(), msg);
+
             // if player is in battleground, he cannot say to battleground members by /p
             Group *group = GetPlayer()->GetOriginalGroup();
             if(!group)
@@ -257,6 +282,19 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if((type == CHAT_MSG_PARTY_LEADER) && !group->IsLeader(_player->GetGUID()))
                 return;
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->getSource();
+                if (player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, type, lang, NULL, 0, msg.c_str(), NULL);
             group->BroadcastPacket(&data, false, group->GetMemberGroup(GetPlayer()->GetGUID()));
@@ -279,6 +317,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.GuildMsg(GetPlayer(), msg, false);
+
             if (GetPlayer()->GetGuildId())
                 if (Guild *guild = sObjectMgr.GetGuildById(GetPlayer()->GetGuildId()))
                     guild->BroadcastToGuild(this, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
@@ -301,6 +341,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.GuildMsg(GetPlayer(), msg, true);
+
             if (GetPlayer()->GetGuildId())
                 if (Guild *guild = sObjectMgr.GetGuildById(GetPlayer()->GetGuildId()))
                     guild->BroadcastToOfficers(this, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
@@ -323,6 +365,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             // if player is in battleground, he cannot say to battleground members by /ra
             Group *group = GetPlayer()->GetOriginalGroup();
             if(!group)
@@ -353,6 +397,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             // if player is in battleground, he cannot say to battleground members by /ra
             Group *group = GetPlayer()->GetOriginalGroup();
             if(!group)
@@ -378,6 +424,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup() || !(group->IsLeader(GetPlayer()->GetGUID()) || group->IsAssistant(GetPlayer()->GetGUID())))
                 return;
@@ -399,6 +447,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.BattleGroundMsg(GetPlayer(), msg, type);
+
             // battleground raid is always in Player->GetGroup(), never in GetOriginalGroup()
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isBGGroup())
@@ -420,6 +470,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.BattleGroundMsg(GetPlayer(), msg, type);
+
             // battleground raid is always in Player->GetGroup(), never in GetOriginalGroup()
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isBGGroup() || !group->IsLeader(GetPlayer()->GetGUID()))
@@ -442,6 +494,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.ChannelMsg(GetPlayer(), channel, msg);
+
             if(ChannelMgr* cMgr = channelMgr(_player->GetTeam()))
                 if(Channel *chn = cMgr->GetChannel(channel, _player))
                     chn->Say(_player->GetGUID(), msg.c_str(), lang);
@@ -591,7 +645,7 @@ void WorldSession::HandleChatIgnoredOpcode(WorldPacket& recv_data )
     //DEBUG_LOG("WORLD: Received CMSG_CHAT_IGNORED");
 
     recv_data >> iguid;
-    recv_data >> unk;                                       // probably related to spam reporting
+    recv_data >> unk;                                     // probably related to spam reporting
 
     Player *player = sObjectMgr.GetPlayer(iguid);
     if(!player || !player->GetSession())
diff --git a/Core/src/game/ChatLexicsCutter.cpp b/Core/src/game/ChatLexicsCutter.cpp
new file mode 100644
index 0000000..8a7e87d
--- /dev/null
+++ b/Core/src/game/ChatLexicsCutter.cpp
@@ -0,0 +1,287 @@
+/*
+ * Copyright (C) 2005-2010 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "ChatLexicsCutter.h"
+#include "Log.h"
+
+LexicsCutter::LexicsCutter()
+{
+    InvalidChars = "~`!@#$%^&*()-_+=[{]}|\\;:'\",<.>/?";
+}
+
+bool LexicsCutter::ReadUTF8(std::string& in, std::string& out, unsigned int& pos)
+{
+    if (pos >= in.length()) return false;
+
+    out = "";
+    unsigned char c = in[pos++];
+    out += c;
+    int toread = trailingBytesForUTF8[(int) c];
+    while ((pos < in.length()) && (toread > 0))
+    {
+        out += in[pos++];
+        toread--;
+    }
+
+    return true;
+}
+
+std::string LexicsCutter::trim(std::string& s, const std::string& drop)
+{
+    std::string r = s.erase(s.find_last_not_of(drop) + 1);
+    return r.erase(0, r.find_first_not_of(drop));
+}
+
+bool LexicsCutter::Read_Letter_Analogs(std::string& FileName)
+{
+    FILE *ma_file;
+    char line[1024];
+    unsigned int pos;
+    std::string line_s;
+    std::string lchar;
+    std::string lanalog;
+
+    ma_file = fopen(FileName.c_str(), "rb");
+
+    if (!ma_file)
+    {
+        sLog.outError("Chat lexics cutter disabled. Reason: LexicsCutterAnalogsFile file does not exist in the server directory.");
+        return false;
+    }
+
+    while (!feof(ma_file))
+    {
+        line[0] = 0x0;
+        fgets(line, 1020, ma_file);
+
+        // check for UTF8 prefix and comments
+        if (strlen(line) >= 3)
+        {
+            if (line[0] == '\xEF' && line[1] == '\xBB' && line[2] == '\xBF')
+            {
+                strncpy(&line[0], &line[3], strlen(line) - 3);
+            }
+        }
+
+        if (strlen(line) >= 2)
+        {
+            if (line[0] == '/' && line[1] == '/') continue;
+        }
+
+        // check for empty string
+        line_s = line;
+        line_s = trim(line_s, "\x0A\x0D\x20");
+        if (line_s == "") continue;
+
+        // process line without CR/LF
+        line_s = line;
+        line_s = trim(line_s, "\x0A\x0D");
+
+        pos = 0;
+        if (ReadUTF8(line_s, lchar, pos))
+        {
+            // create analogs vector
+            LC_AnalogVector av;
+            while (ReadUTF8(line_s, lanalog, pos))
+            {
+                av.push_back(lanalog);
+            }
+
+            // store vector in hash map
+            AnalogMap[lchar] = av;
+        }
+    }
+
+    fclose(ma_file);
+
+    return true;
+}
+
+bool LexicsCutter::Read_Innormative_Words(std::string& FileName)
+{
+    FILE *ma_file;
+    char line[1024];
+    unsigned int pos;
+    std::string line_s;
+    std::string lchar;
+
+    ma_file = fopen(FileName.c_str(), "rb");
+
+    if (!ma_file)
+    {
+        sLog.outError("Chat lexics cutter disabled. Reason: LexicsCutterWordsFile file does not exist in the server directory.");
+        return false;
+    }
+
+    while (!feof(ma_file))
+    {
+        line[0] = 0x0;
+        fgets(line, 1020, ma_file);
+
+        // check for UTF8 prefix and comment
+        if (strlen(line) >= 3)
+        {
+            if (line[0] == '\xEF' && line[1] == '\xBB' && line[2] == '\xBF')
+            {
+                strncpy(&line[0], &line[3], strlen(line) - 3);
+            }
+        }
+
+        if (strlen(line) >= 2)
+        {
+            if (line[0] == '/' && line[1] == '/') continue;
+        }
+
+        // check for empty string
+        line_s = line;
+        line_s = trim(line_s, "\x0A\x0D\x20");
+        if (line_s == "") continue;
+
+        // process line without CR/LF
+        line_s = line;
+        line_s = trim(line_s, "\x0A\x0D");
+
+        // create word vector of vectors
+        LC_WordVector vw;
+        pos = 0;
+        while (ReadUTF8(line_s, lchar, pos))
+        {
+            // create letter set
+            LC_LetterSet vl;
+
+            // initialize letter set with letter read
+            vl.insert(lchar);
+
+            // find letter analogs and push them onto the vector
+            LC_AnalogMap::iterator itr = AnalogMap.find(lchar);
+            if (itr != AnalogMap.end())
+            {
+                // analogs present, iterate
+                for (LC_AnalogVector::iterator itr2 = itr->second.begin(); itr2 != itr->second.end(); itr2++)
+                {
+                    vl.insert(*itr2);
+                }
+            }
+
+            // add letter vector to word vector
+            vw.push_back(vl);
+        }
+
+        // push new word to words list
+        WordList.push_back(vw);
+    }
+
+    fclose(ma_file);
+
+    return true;
+}
+
+void LexicsCutter::Map_Innormative_Words()
+{
+    // process all the words in the vector
+    for (unsigned int i = 0; i < WordList.size(); i++)
+    {
+        // parse all analogs in the first word letter
+        for (LC_LetterSet::iterator itr = (*WordList[i].begin()).begin(); itr != (*WordList[i].begin()).end(); itr++)
+        {
+            // map the word to its first letter variants
+            WordMap.insert(std::pair< std::string, unsigned int >(*itr, i));
+        }
+    }
+}
+
+bool LexicsCutter::Compare_Word(std::string& str, unsigned int pos, LC_WordVector word)
+{
+   std::string lchar_prev;
+    std::string lchar;
+
+   // read first letter of the word into lchar_prev
+   ReadUTF8(str, lchar, pos);
+
+    // okay, here we go, comparing word
+    // first letter is already okay, we do begin from second and go on
+    LC_WordVector::iterator i = word.begin();
+    i++;
+    while (i != word.end())
+    {
+        // get letter from word, return false if the string is shorter
+        if (!ReadUTF8(str, lchar, pos)) return(false);
+        // check, if the letter is in the set
+        LC_LetterSet ls = *i;
+        if (ls.count(lchar) == 0)
+       {
+           // letter is not in set, but we must check, if it is not space or repeat
+           if ( (!(IgnoreMiddleSpaces && (lchar == " "))) &&
+               (!(IgnoreLetterRepeat && (lchar == lchar_prev))) )
+           {
+               // no checks viable
+               return(false);
+           }
+       }
+       else
+       {
+           // next word letter
+           i++;
+       }
+       // set previous string letter to compare if needed (this check can really conserve time)
+       if (IgnoreLetterRepeat) lchar_prev = lchar;
+   }
+
+    return(true);
+}
+
+bool LexicsCutter::Check_Lexics(std::string& Phrase)
+{
+    std::string lchar;
+    LC_WordMap::iterator i;
+    std::pair< LC_WordMap::iterator, LC_WordMap::iterator > ii;
+
+    if (Phrase.size() == 0) return(false);
+
+    // first, convert the string, adding spaces and removing invalid characters
+    // also create fast position vector for the new positions
+    std::string str = " ";
+    unsigned int pos = 0;
+    while (ReadUTF8(Phrase, lchar, pos))
+    {
+        if (InvalidChars.find(lchar) == std::string::npos)
+        {
+            str.append(lchar);
+        }
+    }
+
+    // string prepared, now parse it and scan for all the words
+   unsigned int pos_prev = 0;
+    pos = 0;
+    while (ReadUTF8(str, lchar, pos))
+    {
+        // got character, now try to find wordmap for it
+        ii = WordMap.equal_range(lchar);
+        // iterate over all found words
+        for (i = ii.first; i != ii.second; i++)
+        {
+            // compare word at initial position
+            if (Compare_Word(str, pos_prev, WordList[i->second])) return(true);
+        }
+       // set initial position to the current position
+       pos_prev = pos;
+    }
+
+    return(false);
+}
diff --git a/Core/src/game/ChatLexicsCutter.h b/Core/src/game/ChatLexicsCutter.h
new file mode 100644
index 0000000..cf0aeb3
--- /dev/null
+++ b/Core/src/game/ChatLexicsCutter.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2005-2010 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MANGOSSERVER_CHATLEXICSCUTTER_H
+#define MANGOSSERVER_CHATLEXICSCUTTER_H
+
+typedef std::vector< std::string > LC_AnalogVector;
+typedef std::map< std::string, LC_AnalogVector > LC_AnalogMap;
+typedef std::set< std::string > LC_LetterSet;
+typedef std::vector< LC_LetterSet > LC_WordVector;
+typedef std::vector< LC_WordVector > LC_WordList;
+typedef std::multimap< std::string, unsigned int > LC_WordMap;
+
+static int trailingBytesForUTF8[256] = {
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
+};
+
+class LexicsCutter
+{
+    protected:
+        LC_AnalogMap AnalogMap;
+        LC_WordList WordList;
+        LC_WordMap WordMap;
+
+        std::string InvalidChars;
+
+    public:
+        LexicsCutter();
+
+        static bool ReadUTF8(std::string& in, std::string& out, unsigned int& pos);
+
+        std::string trim(std::string& s, const std::string& drop = " ");
+        bool Read_Letter_Analogs(std::string& FileName);
+        bool Read_Innormative_Words(std::string& FileName);
+        void Map_Innormative_Words();
+        bool Compare_Word(std::string& str, unsigned int pos, LC_WordVector word);
+        bool Check_Lexics(std::string& Phrase);
+
+        std::vector< std::pair< unsigned int, unsigned int > > Found;
+        bool IgnoreMiddleSpaces;
+        bool IgnoreLetterRepeat;
+};
+
+#endif
diff --git a/Core/src/game/ChatLog.cpp b/Core/src/game/ChatLog.cpp
new file mode 100644
index 0000000..c4c717a
--- /dev/null
+++ b/Core/src/game/ChatLog.cpp
@@ -0,0 +1,854 @@
+/*
+ * Copyright (C) 2005-2010 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "ChatLexicsCutter.h"
+#include "ChatLog.h"
+#include "Chat.h"
+#include "Group.h"
+#include "Guild.h"
+#include "ObjectMgr.h"
+#include "SpellAuras.h"
+#include "Policies/SingletonImp.h"
+#include "Config/ConfigEnv.h"
+
+INSTANTIATE_SINGLETON_1( ChatLog );
+
+ChatLog::ChatLog()
+{
+    for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+    {
+        names[i] = "";
+        files[i] = NULL;
+    }
+
+    Lexics = NULL;
+    fn_innormative = "";
+    f_innormative = NULL;
+
+    Initialize();
+}
+
+ChatLog::~ChatLog()
+{
+    // close all files (avoiding double-close)
+    CloseAllFiles();
+
+    if (Lexics)
+    {
+        delete Lexics;
+        Lexics = NULL;
+    }
+}
+
+void ChatLog::Initialize()
+{
+    // determine, if the chat logs are enabled
+    ChatLogEnable = sConfig.GetBoolDefault("ChatLogEnable", false);
+    ChatLogDateSplit = sConfig.GetBoolDefault("ChatLogDateSplit", false);
+    ChatLogUTFHeader = sConfig.GetBoolDefault("ChatLogUTFHeader", false);
+    ChatLogIgnoreUnprintable = sConfig.GetBoolDefault("ChatLogIgnoreUnprintable", false);
+
+    if (ChatLogEnable)
+    {
+        // read chat log file names
+        names[CHAT_LOG_CHAT] = sConfig.GetStringDefault("ChatLogChatFile", "");
+        names[CHAT_LOG_PARTY] = sConfig.GetStringDefault("ChatLogPartyFile", "");
+        names[CHAT_LOG_GUILD] = sConfig.GetStringDefault("ChatLogGuildFile", "");
+        names[CHAT_LOG_WHISPER] = sConfig.GetStringDefault("ChatLogWhisperFile", "");
+        names[CHAT_LOG_CHANNEL] = sConfig.GetStringDefault("ChatLogChannelFile", "");
+        names[CHAT_LOG_RAID] = sConfig.GetStringDefault("ChatLogRaidFile", "");
+        names[CHAT_LOG_BATTLEGROUND] = sConfig.GetStringDefault("ChatLogBattleGroundFile", "");
+
+        // read screen log flags
+        screenflag[CHAT_LOG_CHAT] = sConfig.GetBoolDefault("ChatLogChatScreen", false);
+        screenflag[CHAT_LOG_PARTY] = sConfig.GetBoolDefault("ChatLogPartyScreen", false);
+        screenflag[CHAT_LOG_GUILD] = sConfig.GetBoolDefault("ChatLogGuildScreen", false);
+        screenflag[CHAT_LOG_WHISPER] = sConfig.GetBoolDefault("ChatLogWhisperScreen", false);
+        screenflag[CHAT_LOG_CHANNEL] = sConfig.GetBoolDefault("ChatLogChannelScreen", false);
+        screenflag[CHAT_LOG_RAID] = sConfig.GetBoolDefault("ChatLogRaidScreen", false);
+        screenflag[CHAT_LOG_BATTLEGROUND] = sConfig.GetBoolDefault("ChatLogBattleGroundScreen", false);
+    }
+
+    // lexics cutter
+    LexicsCutterEnable = sConfig.GetBoolDefault("LexicsCutterEnable", false);
+
+    if (LexicsCutterEnable)
+    {
+        // initialize lexics cutter parameters
+        LexicsCutterInnormativeCut = sConfig.GetBoolDefault("LexicsCutterInnormativeCut", true);
+        LexicsCutterNoActionOnGM = sConfig.GetBoolDefault("LexicsCutterNoActionOnGM", true);
+        LexicsCutterScreenLog = sConfig.GetBoolDefault("LexicsCutterScreenLog", false);
+        LexicsCutterCutReplacement = sConfig.GetStringDefault("LexicsCutterCutReplacement", "&!@^%!^&*!!! [gibberish]");
+        LexicsCutterAction = sConfig.GetIntDefault("LexicsCutterAction", 0);
+        LexicsCutterActionDuration = sConfig.GetIntDefault("LexicsCutterActionDuration", 60000);
+        std::string fn_analogsfile = sConfig.GetStringDefault("LexicsCutterAnalogsFile", "");
+        std::string fn_wordsfile = sConfig.GetStringDefault("LexicsCutterWordsFile", "");
+
+        // read lexics cutter flags
+        cutflag[CHAT_LOG_CHAT] = sConfig.GetBoolDefault("LexicsCutInChat", true);
+        cutflag[CHAT_LOG_PARTY] = sConfig.GetBoolDefault("LexicsCutInParty", true);
+        cutflag[CHAT_LOG_GUILD] = sConfig.GetBoolDefault("LexicsCutInGuild", true);
+        cutflag[CHAT_LOG_WHISPER] = sConfig.GetBoolDefault("LexicsCutInWhisper", true);
+        cutflag[CHAT_LOG_CHANNEL] = sConfig.GetBoolDefault("LexicsCutInChannel", true);
+        cutflag[CHAT_LOG_RAID] = sConfig.GetBoolDefault("LexicsCutInRaid", true);
+        cutflag[CHAT_LOG_BATTLEGROUND] = sConfig.GetBoolDefault("LexicsCutInBattleGround", true);
+
+        if (fn_analogsfile == "" || fn_wordsfile == "")
+        {
+            LexicsCutterEnable = false;
+        }
+        else
+        {
+            // initialize lexics cutter
+            Lexics = new LexicsCutter;
+            if (Lexics) Lexics->Read_Letter_Analogs(fn_analogsfile);
+            if (Lexics) Lexics->Read_Innormative_Words(fn_wordsfile);
+            if (Lexics) Lexics->Map_Innormative_Words();
+
+            // read additional parameters
+            Lexics->IgnoreLetterRepeat = sConfig.GetBoolDefault("LexicsCutterIgnoreRepeats", true);
+            Lexics->IgnoreMiddleSpaces = sConfig.GetBoolDefault("LexicsCutterIgnoreSpaces", true);
+            fn_innormative = sConfig.GetStringDefault("LexicsCutterLogFile", "");
+        }
+    }
+
+    // open all files (with aliasing)
+    OpenAllFiles();
+
+    // write timestamps (init)
+    WriteInitStamps();
+}
+
+bool ChatLog::_ChatCommon(int ChatType, Player *player, std::string &msg)
+{
+    if (LexicsCutterEnable && Lexics && cutflag[ChatType] && Lexics->Check_Lexics(msg)) ChatBadLexicsAction(player, msg);
+
+    if (!ChatLogEnable) return(false);
+
+    if (ChatLogIgnoreUnprintable)
+    {
+        // have to ignore unprintables, verify string by UTF8 here
+        unsigned int pos = 0;
+        std::string lchar;
+        while (LexicsCutter::ReadUTF8(msg, lchar, pos))
+        {
+            if (lchar.size() == 1)
+            {
+                if (lchar[0] < ' ') return(false); // unprintable detected
+            }
+        }
+    }
+
+    return(true);
+}
+
+void ChatLog::ChatMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_CHAT, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    switch (type)
+    {
+        case CHAT_MSG_EMOTE:
+        log_str.append("{EMOTE} ");
+        break;
+
+        case CHAT_MSG_YELL:
+        log_str.append("{YELL} ");
+        break;
+    }
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("] ");
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_CHAT]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_CHAT])
+    {
+        OutTimestamp(files[CHAT_LOG_CHAT]);
+        fprintf(files[CHAT_LOG_CHAT], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_CHAT]);
+    }
+}
+
+void ChatLog::PartyMsg(Player *player, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_PARTY, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->GROUP:");
+
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown group] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = sObjectMgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = sObjectMgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_PARTY]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_PARTY])
+    {
+        OutTimestamp(files[CHAT_LOG_PARTY]);
+        fprintf(files[CHAT_LOG_PARTY], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_PARTY]);
+    }
+}
+
+void ChatLog::GuildMsg(Player *player, std::string &msg, bool officer)
+{
+    if (!_ChatCommon(CHAT_LOG_GUILD, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append((officer ? "]->GUILD_OFF:" : "]->GUILD:"));
+
+    if (!player->GetGuildId())
+    {
+        log_str.append("[unknown guild] ");
+    }
+    else
+    {
+        Guild *guild = sObjectMgr.GetGuildById(player->GetGuildId());
+        if (!guild)
+        {
+            log_str.append("[unknown guild] ");
+        }
+        else
+        {
+            // obtain guild information
+            log_str.append("(");
+            log_str.append(guild->GetName());
+            log_str.append(") ");
+        }
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_GUILD]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_GUILD])
+    {
+        OutTimestamp(files[CHAT_LOG_GUILD]);
+        fprintf(files[CHAT_LOG_GUILD], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_GUILD]);
+    }
+}
+
+void ChatLog::WhisperMsg(Player *player, std::string &to, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_WHISPER, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->");
+
+    if (to.size() == 0)
+    {
+        log_str.append("[???] ");
+    }
+    else
+    {
+        normalizePlayerName(to);
+        log_str.append("[");
+        log_str.append(to);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_WHISPER]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_WHISPER])
+    {
+        OutTimestamp(files[CHAT_LOG_WHISPER]);
+        fprintf(files[CHAT_LOG_WHISPER], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_WHISPER]);
+    }
+}
+
+void ChatLog::ChannelMsg(Player *player, std::string &channel, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_CHANNEL, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->CHANNEL:");
+
+    if (channel.size() == 0)
+    {
+        log_str.append("[unknown channel] ");
+    }
+    else
+    {
+        log_str.append("[");
+        log_str.append(channel);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_CHANNEL]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_CHANNEL])
+    {
+        OutTimestamp(files[CHAT_LOG_CHANNEL]);
+        fprintf(files[CHAT_LOG_CHANNEL], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_CHANNEL]);
+    }
+}
+
+void ChatLog::RaidMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_RAID, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+
+    switch (type)
+    {
+        case CHAT_MSG_RAID:
+        log_str.append("]->RAID:");
+        break;
+
+        case CHAT_MSG_RAID_LEADER:
+        log_str.append("]->RAID_LEADER:");
+        break;
+
+        case CHAT_MSG_RAID_WARNING:
+        log_str.append("]->RAID_WARN:");
+        break;
+
+        default:
+        log_str.append("]->RAID_UNKNOWN:");
+    }
+
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown raid] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = sObjectMgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = sObjectMgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_RAID]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_RAID])
+    {
+        OutTimestamp(files[CHAT_LOG_RAID]);
+        fprintf(files[CHAT_LOG_RAID], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_RAID]);
+    }
+}
+
+void ChatLog::BattleGroundMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_BATTLEGROUND, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+
+    switch (type)
+    {
+        case CHAT_MSG_BATTLEGROUND:
+        log_str.append("]->BG:");
+        break;
+
+        case CHAT_MSG_BATTLEGROUND_LEADER:
+        log_str.append("]->BG_LEADER:");
+        break;
+
+        default:
+        log_str.append("]->BG_UNKNOWN:");
+    }
+
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown group] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = sObjectMgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = sObjectMgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_BATTLEGROUND]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_BATTLEGROUND])
+    {
+        OutTimestamp(files[CHAT_LOG_BATTLEGROUND]);
+        fprintf(files[CHAT_LOG_BATTLEGROUND], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_BATTLEGROUND]);
+    }
+}
+
+void ChatLog::OpenAllFiles()
+{
+    std::string tempname;
+    char dstr[12];
+
+    if (ChatLogDateSplit)
+    {
+        time_t t = time(NULL);
+        tm* aTm = localtime(&t);
+        sprintf(dstr, "%-4d-%02d-%02d", aTm->tm_year + 1900, aTm->tm_mon + 1, aTm->tm_mday);
+    }
+
+    if (ChatLogEnable)
+    {
+        for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+        {
+            if (names[i] != "")
+            {
+                for (int j = i - 1; j >= 0; j--)
+                {
+                    if (names[i] == names[j])
+                    {
+                        files[i] = files[j];
+                        break;
+                    }
+                }
+                if (!files[i])
+                {
+                    tempname = names[i];
+                    if (ChatLogDateSplit)
+                    {
+                        // append date instead of $d if applicable
+                        int dpos = tempname.find("$d");
+                        if (dpos != tempname.npos)
+                        {
+                            tempname.replace(dpos, 2, &dstr[0], 10);
+                        }
+                    }
+                    files[i] = fopen(tempname.c_str(), "a+b");
+                    if (ChatLogUTFHeader && (ftell(files[i]) == 0)) fputs("\xEF\xBB\xBF", files[i]);
+                }
+            }
+        }
+    }
+
+    // initialize innormative log
+    if (LexicsCutterEnable)
+    {
+        if (fn_innormative != "")
+        {
+            tempname = fn_innormative;
+            if (ChatLogDateSplit)
+            {
+                // append date instead of $d if applicable
+                int dpos = tempname.find("$d");
+                if (dpos != tempname.npos)
+                {
+                    tempname.replace(dpos, 2, &dstr[0], 10);
+                }
+            }
+            f_innormative = fopen(tempname.c_str(), "a+b");
+            if (ChatLogUTFHeader && (ftell(f_innormative) == 0)) fputs("\xEF\xBB\xBF", f_innormative);
+        }
+    }
+}
+
+void ChatLog::CloseAllFiles()
+{
+    for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+    {
+        if (files[i])
+        {
+            for (int j = i + 1; j <= CHATLOG_CHAT_TYPES_COUNT - 1; j++)
+            {
+                if (files[j] == files[i]) files[j] = NULL;
+            }
+
+            fclose(files[i]);
+            files[i] = NULL;
+        }
+    }
+
+    if (f_innormative)
+    {
+        fclose(f_innormative);
+        f_innormative = NULL;
+    }
+}
+
+void ChatLog::CheckDateSwitch()
+{
+    if (ChatLogDateSplit)
+    {
+        time_t t = time(NULL);
+        tm* aTm = localtime(&t);
+        if (lastday != aTm->tm_mday)
+        {
+            // date switched
+            CloseAllFiles();
+            OpenAllFiles();
+            WriteInitStamps();
+        }
+    }
+}
+
+void ChatLog::WriteInitStamps()
+{
+    // remember date
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    lastday = aTm->tm_mday;
+
+    if (files[CHAT_LOG_CHAT])
+    {
+        OutTimestamp(files[CHAT_LOG_CHAT]);
+        fprintf(files[CHAT_LOG_CHAT], "%s", "[SYSTEM] Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_PARTY])
+    {
+        OutTimestamp(files[CHAT_LOG_PARTY]);
+        fprintf(files[CHAT_LOG_PARTY], "%s", "[SYSTEM] Party Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_GUILD])
+    {
+        OutTimestamp(files[CHAT_LOG_GUILD]);
+        fprintf(files[CHAT_LOG_GUILD], "%s", "[SYSTEM] Guild Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_WHISPER])
+    {
+        OutTimestamp(files[CHAT_LOG_WHISPER]);
+        fprintf(files[CHAT_LOG_WHISPER], "%s", "[SYSTEM] Whisper Log Initialized\n");
+    }
+    if (files[CHAT_LOG_CHANNEL])
+    {
+        OutTimestamp(files[CHAT_LOG_CHANNEL]);
+        fprintf(files[CHAT_LOG_CHANNEL], "%s", "[SYSTEM] Chat Channels Log Initialized\n");
+    }
+    if (files[CHAT_LOG_RAID])
+    {
+        OutTimestamp(files[CHAT_LOG_RAID]);
+        fprintf(files[CHAT_LOG_RAID], "%s", "[SYSTEM] Raid Party Chat Log Initialized\n");
+    }
+
+    if (f_innormative)
+    {
+        OutTimestamp(f_innormative);
+        fprintf(f_innormative, "%s", "[SYSTEM] Innormative Lexics Log Initialized\n");
+    }
+}
+
+void ChatLog::OutTimestamp(FILE* file)
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    fprintf(file, "%-4d-%02d-%02d %02d:%02d:%02d ", aTm->tm_year + 1900, aTm->tm_mon + 1, aTm->tm_mday, aTm->tm_hour, aTm->tm_min, aTm->tm_sec);
+}
+
+void ChatLog::ChatBadLexicsAction(Player* player, std::string& msg)
+{
+    // logging
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("] ");
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (LexicsCutterScreenLog) printf("<INNORMATIVE!> %s", log_str.c_str());
+    if (f_innormative)
+    {
+        OutTimestamp(f_innormative);
+        fprintf(f_innormative, "%s", log_str.c_str());
+        fflush(f_innormative);
+    }
+
+    // cutting innormative lexics
+    if (LexicsCutterInnormativeCut)
+    {
+        msg = LexicsCutterCutReplacement;
+    }
+
+    if (!player || !player->GetSession()) return;
+
+    if (LexicsCutterNoActionOnGM && player->GetSession()->GetSecurity()) return;
+
+    // special action
+    const SpellEntry* sl;
+
+    switch (LexicsCutterAction)
+    {
+        case LEXICS_ACTION_SHEEP:
+        {
+            // sheep me, yeah, yeah, sheep me
+            sl = sSpellStore.LookupEntry(118);
+            if (sl)
+            {
+                for (int i = 0; i < MAX_EFFECT_INDEX; i++)
+                {
+                    Aura* Aur = CreateAura(sl, SpellEffectIndex(i), NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_STUN:
+        {
+            // stunned surprised
+            sl = sSpellStore.LookupEntry(13005);
+            if (sl)
+            {
+                for (int i = 0; i < MAX_EFFECT_INDEX; i++)
+                {
+                    Aura* Aur = CreateAura(sl, SpellEffectIndex(i), NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_DIE:
+        {
+            // oops, kicked the bucket
+            player->DealDamage(player, player->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+        break;
+
+        case LEXICS_ACTION_DRAIN:
+        {
+            // living corpse :)
+            player->DealDamage(player, player->GetHealth() - 5, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+        break;
+
+        case LEXICS_ACTION_SILENCE:
+        {
+            // glue the mouth
+            time_t mutetime = time(NULL) + (int) (LexicsCutterActionDuration / 1000);
+            player->GetSession()->m_muteTime = mutetime;
+        }
+        break;
+
+        case LEXICS_ACTION_STUCK:
+        {
+            // yo, the Matrix has had you :) [by KAPATEJIb]
+            sl = sSpellStore.LookupEntry(23312);
+            if (sl)
+            {
+                for (int i = 0; i < MAX_EFFECT_INDEX; i++)
+                {
+                    Aura* Aur = CreateAura(sl, SpellEffectIndex(i), NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_SICKNESS:
+        {
+            // for absence of censorship, there is punishment [by Koshei]
+            sl = sSpellStore.LookupEntry(15007);
+            if (sl)
+            {
+                for (int i = 0; i < MAX_EFFECT_INDEX; i++)
+                {
+                    Aura* Aur = CreateAura(sl, SpellEffectIndex(i), NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_SHEAR:
+        {
+            // Lord Illidan to watch you [by Koshei]
+            sl = sSpellStore.LookupEntry(41032);
+            if (sl)
+            {
+                for (int i = 0; i < MAX_EFFECT_INDEX; i++)
+                {
+                    Aura* Aur = CreateAura(sl, SpellEffectIndex(i), NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        default:
+        // no action except logging
+        break;
+    }
+}
diff --git a/Core/src/game/ChatLog.h b/Core/src/game/ChatLog.h
new file mode 100644
index 0000000..102ef13
--- /dev/null
+++ b/Core/src/game/ChatLog.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2005-2010 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MANGOSSERVER_CHATLOG_H
+#define MANGOSSERVER_CHATLOG_H
+
+#include "SharedDefines.h"
+#include "ChatLexicsCutter.h"
+#include "ObjectMgr.h"
+#include "Policies/Singleton.h"
+
+#define CHATLOG_CHAT_TYPES_COUNT 7
+
+enum ChatLogFiles
+{
+    CHAT_LOG_CHAT = 0,
+    CHAT_LOG_PARTY = 1,
+    CHAT_LOG_GUILD = 2,
+    CHAT_LOG_WHISPER = 3,
+    CHAT_LOG_CHANNEL = 4,
+    CHAT_LOG_RAID = 5,
+    CHAT_LOG_BATTLEGROUND = 6,
+};
+
+enum LexicsActions
+{
+    LEXICS_ACTION_LOG = 0,
+    LEXICS_ACTION_SHEEP = 1,
+    LEXICS_ACTION_STUN = 2,
+    LEXICS_ACTION_DIE = 3,
+    LEXICS_ACTION_DRAIN = 4,
+    LEXICS_ACTION_SILENCE = 5,
+    LEXICS_ACTION_STUCK = 6,
+    LEXICS_ACTION_SICKNESS = 7,
+    LEXICS_ACTION_SHEAR = 8,
+};
+
+class ChatLog : public MaNGOS::Singleton<ChatLog, MaNGOS::ClassLevelLockable<ChatLog, /*ZThread::Mutex*/ACE_Thread_Mutex> >
+{
+    public:
+        ChatLog();
+        ~ChatLog();
+
+        void Initialize();
+
+        void ChatMsg(Player *player, std::string &msg, uint32 type);
+        void PartyMsg(Player *player, std::string &msg);
+        void GuildMsg(Player *player, std::string &msg, bool officer);
+        void WhisperMsg(Player *player, std::string &to, std::string &msg);
+        void ChannelMsg(Player *player, std::string &channel, std::string &msg);
+        void RaidMsg(Player *player, std::string &msg, uint32 type);
+        void BattleGroundMsg(Player *player, std::string &msg, uint32 type);
+
+        void ChatBadLexicsAction(Player *player, std::string &msg);
+
+    private:
+        bool _ChatCommon(int ChatType, Player *player, std::string &msg);
+
+        bool ChatLogEnable;
+        bool ChatLogDateSplit;
+        bool ChatLogUTFHeader;
+        bool ChatLogIgnoreUnprintable;
+
+        int lastday;
+
+        FILE* files[CHATLOG_CHAT_TYPES_COUNT];
+        std::string names[CHATLOG_CHAT_TYPES_COUNT];
+        bool screenflag[CHATLOG_CHAT_TYPES_COUNT];
+
+        LexicsCutter* Lexics;
+        bool cutflag[CHATLOG_CHAT_TYPES_COUNT];
+
+        bool LexicsCutterEnable;
+        bool LexicsCutterInnormativeCut;
+        bool LexicsCutterNoActionOnGM;
+        bool LexicsCutterScreenLog;
+        std::string LexicsCutterCutReplacement;
+        int LexicsCutterAction;
+        int LexicsCutterActionDuration;
+        std::string fn_innormative;
+        FILE* f_innormative;
+
+        void OpenAllFiles();
+        void CloseAllFiles();
+        void CheckDateSwitch();
+
+        void WriteInitStamps();
+        void OutTimestamp(FILE *file);
+};
+
+#define sChatLog MaNGOS::Singleton<ChatLog>::Instance()
+#endif
diff --git a/mangos/src/game/ConfusedMovementGenerator.cpp b/Core/src/game/ConfusedMovementGenerator.cpp
index 4cf7bf2..5fa88ba 100644
--- a/mangos/src/game/ConfusedMovementGenerator.cpp
+++ b/Core/src/game/ConfusedMovementGenerator.cpp
@@ -52,13 +52,14 @@ ConfusedMovementGenerator<T>::Initialize(T &unit)
         MaNGOS::NormalizeMapCoord(i_waypoints[idx][1]);
 
         bool is_water = map->IsInWater(i_waypoints[idx][0],i_waypoints[idx][1],z);
+
         // if generated wrong path just ignore
-        if ((is_water && !is_water_ok) || (!is_water && !is_land_ok))
+        if ((is_water && !is_water_ok) || (!is_water && !is_land_ok) ||
+            !map->IsNextZcoordOK(i_waypoints[idx][0], i_waypoints[idx][1], z))  // check if not under map
         {
             i_waypoints[idx][0] = idx > 0 ? i_waypoints[idx-1][0] : x;
             i_waypoints[idx][1] = idx > 0 ? i_waypoints[idx-1][1] : y;
         }
-
         unit.UpdateGroundPositionZ(i_waypoints[idx][0],i_waypoints[idx][1],z);
         i_waypoints[idx][2] =  z;
     }
diff --git a/mangos/src/game/Creature.cpp b/Core/src/game/Creature.cpp
index 6e984a9..305baab 100644
--- a/mangos/src/game/Creature.cpp
+++ b/Core/src/game/Creature.cpp
@@ -43,6 +43,9 @@
 #include "GridNotifiers.h"
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
+#include "Vehicle.h"
+#include "Object.h"
+#include "ZoneScript.h"
 
 // apply implementation of the singletons
 #include "Policies/SingletonImp.h"
@@ -130,6 +133,8 @@ m_creatureInfo(NULL), m_isActiveObject(false), m_splineFlags(SPLINEFLAG_WALKMODE
     m_GlobalCooldown = 0;
 
     m_splineFlags = SPLINEFLAG_WALKMODE;
+
+    ResetObtainedDamage();
 }
 
 Creature::~Creature()
@@ -146,7 +151,12 @@ void Creature::AddToWorld()
 {
     ///- Register the creature for guid lookup
     if(!IsInWorld() && GetObjectGuid().GetHigh() == HIGHGUID_UNIT)
+    {
+        if(m_zoneScript)
+            m_zoneScript->OnCreatureCreate(this, true);
+
         GetMap()->GetObjectsStore().insert<Creature>(GetGUID(), (Creature*)this);
+    }
 
     Unit::AddToWorld();
 }
@@ -155,14 +165,19 @@ void Creature::RemoveFromWorld()
 {
     ///- Remove the creature from the accessor
     if(IsInWorld() && GetObjectGuid().GetHigh() == HIGHGUID_UNIT)
+    {
+        if(m_zoneScript)
+            m_zoneScript->OnCreatureCreate(this, false);
+
         GetMap()->GetObjectsStore().erase<Creature>(GetGUID(), (Creature*)NULL);
+    }
 
     Unit::RemoveFromWorld();
 }
 
 void Creature::RemoveCorpse()
 {
-    if ((getDeathState() != CORPSE && !m_isDeadByDefault) || (getDeathState() != ALIVE && m_isDeadByDefault))
+    if (((getDeathState() != CORPSE && getDeathState() != GHOULED) && !m_isDeadByDefault) || (getDeathState() != ALIVE && m_isDeadByDefault))
         return;
 
     m_deathTimer = 0;
@@ -831,7 +846,7 @@ void Creature::PrepareBodyLootState()
     // if not have normal loot allow skinning if need
     if (!isAlive() && !lootForSkin && GetCreatureInfo()->SkinLootId)
     {
-        lootForBody = true;                                 // pass this loot mode
+        lootForBody = true; // pass this loot mode
 
         RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
         SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
@@ -842,7 +857,6 @@ void Creature::PrepareBodyLootState()
     RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
 }
 
-
 /**
  * Return original player who tap creature, it can be different from player/group allowed to loot so not use it for loot code
  */
@@ -1143,6 +1157,14 @@ float Creature::GetSpellDamageMod(int32 Rank)
 
 bool Creature::CreateFromProto(uint32 guidlow, uint32 Entry, uint32 team, const CreatureData *data)
 {
+    SetZoneScript();
+    if(m_zoneScript && data)
+    {
+        Entry = m_zoneScript->GetCreatureEntry(guidlow, data);
+        if(!Entry)
+            return false;
+    }
+
     CreatureInfo const *cinfo = ObjectMgr::GetCreatureTemplate(Entry);
     if(!cinfo)
     {
@@ -1151,7 +1173,7 @@ bool Creature::CreateFromProto(uint32 guidlow, uint32 Entry, uint32 team, const
     }
     m_originalEntry = Entry;
 
-    Object::_Create(guidlow, Entry, HIGHGUID_UNIT);
+   Object::_Create(guidlow, Entry, HIGHGUID_UNIT);
 
     if (!UpdateEntry(Entry, team, data, false))
         return false;
@@ -1373,11 +1395,14 @@ void Creature::setDeathState(DeathState s)
         }
 
         Unit::setDeathState(CORPSE);
+        if(isVehicle())
+            ((Vehicle*)this)->Die();
     }
     if (s == JUST_ALIVED)
     {
         SetHealth(GetMaxHealth());
         SetLootRecipient(NULL);
+        ResetObtainedDamage();
         CreatureInfo const *cinfo = GetCreatureInfo();
         SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0);
         RemoveFlag (UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
@@ -1476,6 +1501,32 @@ bool Creature::IsImmunedToSpellEffect(SpellEntry const* spellInfo, SpellEffectIn
             return true;
     }
 
+    // Heal immunity
+    if (isVehicle() && !(((Vehicle*)this)->GetVehicleFlags() & VF_CAN_BE_HEALED))
+    {
+        switch(spellInfo->Effect[index])
+        {
+            case SPELL_EFFECT_APPLY_AURA:
+                switch(spellInfo->EffectApplyAuraName[index])
+                {
+                    case SPELL_AURA_PERIODIC_HEAL:
+                    case SPELL_AURA_OBS_MOD_HEALTH:
+                    case SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
+                    case SPELL_AURA_MOD_REGEN:
+                        return true;
+                    default: break;
+                }
+                break;
+            case SPELL_EFFECT_HEAL:
+            case SPELL_EFFECT_HEAL_MAX_HEALTH:
+            // NOTE : this too?
+            case SPELL_EFFECT_HEAL_MECHANICAL:
+            case SPELL_EFFECT_HEAL_PCT:
+                return true;
+            default : break;
+        }
+    }
+
     return Unit::IsImmunedToSpellEffect(spellInfo, index);
 }
 
@@ -1981,6 +2032,29 @@ bool Creature::IsInEvadeMode() const
     return !i_motionMaster.empty() && i_motionMaster.GetCurrentMovementGeneratorType() == HOME_MOTION_TYPE;
 }
 
+float Creature::GetBaseSpeed() const
+{
+    if( isPet() )
+    {
+        switch( ((Pet*)this)->getPetType() )
+        {
+            case SUMMON_PET:
+            case HUNTER_PET:
+            {
+                //fixed speed fur hunter (and summon!?) pets
+                return 1.15f;
+            }
+            case GUARDIAN_PET:
+            case MINI_PET:
+            {
+                //speed of CreatureInfo for guardian- and minipets
+                break;
+            }
+        }
+    }
+    return m_creatureInfo->speed_run;
+}
+
 bool Creature::HasSpell(uint32 spellID) const
 {
     uint8 i;
diff --git a/mangos/src/game/Creature.h b/Core/src/game/Creature.h
index c6dff5d..4cbd931 100644
--- a/mangos/src/game/Creature.h
+++ b/Core/src/game/Creature.h
@@ -187,6 +187,7 @@ struct EquipmentInfo
 // from `creature` table
 struct CreatureData
 {
+    explicit CreatureData() : dbData(true) {}
     uint32 id;                                              // entry in creature_template
     uint16 mapid;
     uint16 phaseMask;
@@ -204,6 +205,7 @@ struct CreatureData
     bool  is_dead;
     uint8 movementType;
     uint8 spawnMask;
+    bool dbData;
 };
 
 struct CreatureDataAddonAura
@@ -212,6 +214,15 @@ struct CreatureDataAddonAura
     SpellEffectIndex effect_idx;
 };
 
+struct CreatureDataAddonPassengers
+{
+    CreatureDataAddonPassengers() : entry(0), guid(0), seat_idx(-1) {}
+
+    uint32 entry;
+    uint32 guid;
+    int8 seat_idx;
+};
+
 // from `creature_addon` table
 struct CreatureDataAddon
 {
@@ -221,6 +232,8 @@ struct CreatureDataAddon
     uint32 bytes2;
     uint32 emote;
     uint32 splineFlags;
+    uint32 vehicle_id;
+    CreatureDataAddonPassengers const* passengers;          // loaded as char* "entry1 seatid1 entry2 seatid2 ... "  
     CreatureDataAddonAura const* auras;                     // loaded as char* "spell1 eff1 spell2 eff2 ... "
 };
 
@@ -400,6 +413,9 @@ class MANGOS_DLL_SPEC Creature : public Unit
         void GetRespawnCoord(float &x, float &y, float &z, float* ori = NULL, float* dist =NULL) const;
         uint32 GetEquipmentId() const { return m_equipmentId; }
 
+        bool CreateVehicleKit(uint32 id);
+        Vehicle *GetVehicleKit()const { return m_vehicleKit; }
+
         CreatureSubtype GetSubtype() const { return m_subtype; }
         bool isPet() const { return m_subtype == CREATURE_SUBTYPE_PET; }
         bool isVehicle() const { return m_subtype == CREATURE_SUBTYPE_VEHICLE; }
@@ -571,6 +587,7 @@ class MANGOS_DLL_SPEC Creature : public Unit
 
         MovementGeneratorType GetDefaultMovementType() const { return m_defaultMovementType; }
         void SetDefaultMovementType(MovementGeneratorType mgt) { m_defaultMovementType = mgt; }
+        float GetBaseSpeed() const;
 
         // for use only in LoadHelper, Map::Add Map::CreatureCellRelocation
         Cell const& GetCurrentCell() const { return m_currentCell; }
@@ -634,10 +651,37 @@ class MANGOS_DLL_SPEC Creature : public Unit
 
         void SendAreaSpiritHealerQueryOpcode(Player *pl);
 
+        void IncrementReceivedDamage(Unit* pAttacker, uint32 unDamage)
+        {
+            if(!pAttacker || !unDamage)
+                return;
+
+            if(pAttacker->GetCharmerOrOwnerPlayerOrPlayerItself())
+            {
+                m_unPlayerDamageDone += unDamage;
+                return;
+            }
+            else if(pAttacker->GetTypeId() == TYPEID_UNIT)
+            {
+                //some conditions can be placed here
+                m_unUnitDamageDone += unDamage;
+                return;
+            }
+        }
+        bool AreLootAndRewardAllowed() { return (m_unPlayerDamageDone > m_unUnitDamageDone); }
+        void ResetObtainedDamage()
+        {
+            m_unPlayerDamageDone = 0;
+            m_unUnitDamageDone = 0;
+        }
+
     protected:
         bool CreateFromProto(uint32 guidlow,uint32 Entry,uint32 team, const CreatureData *data = NULL);
         bool InitEntry(uint32 entry, uint32 team=ALLIANCE, const CreatureData* data=NULL);
         void RelocationNotify();
+        
+        uint32 m_unPlayerDamageDone;
+        uint32 m_unUnitDamageDone;
 
         uint32 m_groupLootTimer;                            // (msecs)timer used for group loot
         uint32 m_groupLootId;                               // used to find group which is looting corpse
@@ -683,7 +727,7 @@ class MANGOS_DLL_SPEC Creature : public Unit
         float CombatStartX;
         float CombatStartY;
         float CombatStartZ;
-
+        Vehicle* m_vehicleKit;
         float m_summonXpoint;
         float m_summonYpoint;
         float m_summonZpoint;
diff --git a/mangos/src/game/CreatureAI.cpp b/Core/src/game/CreatureAI.cpp
index b650b65..bac2d46 100644
--- a/mangos/src/game/CreatureAI.cpp
+++ b/Core/src/game/CreatureAI.cpp
@@ -26,6 +26,10 @@ CreatureAI::~CreatureAI()
 
 void CreatureAI::AttackedBy( Unit* attacker )
 {
+    // vehicle dont have threat list, so this is unnecessary, because it calls move chase
+    if(m_creature->isVehicle())
+        return;
+
     if(!m_creature->getVictim())
         AttackStart(attacker);
 }
@@ -74,10 +78,16 @@ CanCastResult CreatureAI::CanCastSpell(Unit* pTarget, const SpellEntry *pSpell,
 
 CanCastResult CreatureAI::DoCastSpellIfCan(Unit* pTarget, uint32 uiSpell, uint32 uiCastFlags, uint64 uiOriginalCasterGUID)
 {
+    if (!pTarget)
+        return CAST_FAIL_OTHER;
+
     Unit* pCaster = m_creature;
 
     if (uiCastFlags & CAST_FORCE_TARGET_SELF)
         pCaster = pTarget;
+        
+    if (!pTarget)
+        return CAST_FAIL_OTHER;
 
     // Allowed to cast only if not casting (unless we interrupt ourself) or if spell is triggered
     if (!pCaster->IsNonMeleeSpellCasted(false) || (uiCastFlags & (CAST_TRIGGERED | CAST_INTERRUPT_PREVIOUS)))
diff --git a/mangos/src/game/CreatureAI.h b/Core/src/game/CreatureAI.h
index 423f2b6..d64ce30 100644
--- a/mangos/src/game/CreatureAI.h
+++ b/Core/src/game/CreatureAI.h
@@ -147,6 +147,8 @@ class MANGOS_DLL_SPEC CreatureAI
 
         // Called when victim entered water and creature can not enter water
         virtual bool canReachByRangeAttack(Unit*) { return false; }
+		
+		virtual void DoAction(uint32 action) { }
 
         ///== Fields =======================================
 
diff --git a/mangos/src/game/CreatureAISelector.cpp b/Core/src/game/CreatureAISelector.cpp
index 4b78c32..500c6e1 100644
--- a/mangos/src/game/CreatureAISelector.cpp
+++ b/Core/src/game/CreatureAISelector.cpp
@@ -47,7 +47,7 @@ namespace FactorySelector
         // excplicit check for isControlled() and owner type to allow guardian, mini-pets and pets controlled by NPCs to be scripted by EventAI
         Unit *owner=NULL;
         if ((creature->isPet() && ((Pet*)creature)->isControlled() &&
-            ((owner=creature->GetOwner()) && owner->GetTypeId()==TYPEID_PLAYER)) || creature->isCharmed())
+            ((owner=creature->GetOwner()) && owner->GetTypeId()==TYPEID_PLAYER)) || (creature->isCharmed() && !creature->isVehicle()))
             ai_factory = ai_registry.GetRegistryItem("PetAI");
         else if (creature->isTotem())
             ai_factory = ai_registry.GetRegistryItem("TotemAI");
diff --git a/mangos/src/game/CreatureEventAI.cpp b/Core/src/game/CreatureEventAI.cpp
index bbb12c6..75c227a 100644
--- a/mangos/src/game/CreatureEventAI.cpp
+++ b/Core/src/game/CreatureEventAI.cpp
@@ -851,6 +851,7 @@ void CreatureEventAI::JustReachedHome()
 
 void CreatureEventAI::EnterEvadeMode()
 {
+    m_creature->ExitVehicle();
     m_creature->RemoveAllAuras();
     m_creature->DeleteThreatList();
     m_creature->CombatStop(true);
@@ -859,6 +860,7 @@ void CreatureEventAI::EnterEvadeMode()
         m_creature->GetMotionMaster()->MoveTargetedHome();
 
     m_creature->SetLootRecipient(NULL);
+    m_creature->ResetObtainedDamage();
 
     if (bEmptyList)
         return;
diff --git a/mangos/src/game/DBCStores.cpp b/Core/src/game/DBCStores.cpp
index 8f0fd71..f1ff8ac 100644
--- a/mangos/src/game/DBCStores.cpp
+++ b/Core/src/game/DBCStores.cpp
@@ -32,6 +32,7 @@ typedef std::map<uint32,uint32> AreaFlagByMapID;
 
 DBCStorage <AreaTableEntry> sAreaStore(AreaTableEntryfmt);
 DBCStorage <AreaGroupEntry> sAreaGroupStore(AreaGroupEntryfmt);
+DBCStorage <AreaPOIEntry> sAreaPOIStore(AreaPOIEntryfmt);
 static AreaFlagByAreaID sAreaFlagByAreaID;
 static AreaFlagByMapID  sAreaFlagByMapID;                   // for instances without generated *.map files
 
@@ -256,13 +257,19 @@ struct LocalData
 };
 
 template<class T>
-inline void LoadDBC(LocalData& localeData,barGoLink& bar, StoreProblemList& errlist, DBCStorage<T>& storage, const std::string& dbc_path, const std::string& filename)
+inline void LoadDBC(LocalData& localeData,barGoLink& bar, StoreProblemList& errlist, DBCStorage<T>& storage, const std::string& dbc_path, const std::string& filename, const std::string * custom_entries = NULL, const std::string * idname = NULL)
 {
     // compatibility format and C++ structure sizes
     ASSERT(DBCFileLoader::GetFormatRecordSize(storage.GetFormat()) == sizeof(T) || LoadDBC_assert_print(DBCFileLoader::GetFormatRecordSize(storage.GetFormat()),sizeof(T),filename));
 
     std::string dbc_filename = dbc_path + filename;
-    if(storage.Load(dbc_filename.c_str()))
+
+    SqlDbc * sql = NULL;
+
+    if (custom_entries)
+        sql = new SqlDbc(&filename,custom_entries,idname,storage.GetFormat());
+
+    if(storage.Load(dbc_filename.c_str(),sql))
     {
         bar.step();
         for(uint8 i = 0; fullLocaleNameList[i].name; ++i)
@@ -316,6 +323,9 @@ inline void LoadDBC(LocalData& localeData,barGoLink& bar, StoreProblemList& errl
         else
             errlist.push_back(dbc_filename);
     }
+
+    if (sql)
+        delete sql;
 }
 
 void LoadDBCStores(const std::string& dataPath)
@@ -362,6 +372,7 @@ void LoadDBCStores(const std::string& dataPath)
     LoadDBC(availableDbcLocales,bar,bad_dbc_files,sAchievementCriteriaStore, dbcPath,"Achievement_Criteria.dbc");
     LoadDBC(availableDbcLocales,bar,bad_dbc_files,sAreaTriggerStore,         dbcPath,"AreaTrigger.dbc");
     LoadDBC(availableDbcLocales,bar,bad_dbc_files,sAreaGroupStore,           dbcPath,"AreaGroup.dbc");
+    LoadDBC(availableDbcLocales,bar,bad_dbc_files,sAreaPOIStore,             dbcPath,"AreaPOI.dbc");
     LoadDBC(availableDbcLocales,bar,bad_dbc_files,sAuctionHouseStore,        dbcPath,"AuctionHouse.dbc");
     LoadDBC(availableDbcLocales,bar,bad_dbc_files,sBankBagSlotPricesStore,   dbcPath,"BankBagSlotPrices.dbc");
     LoadDBC(availableDbcLocales,bar,bad_dbc_files,sBattlemasterListStore,    dbcPath,"BattlemasterList.dbc");
@@ -448,7 +459,7 @@ void LoadDBCStores(const std::string& dataPath)
     LoadDBC(availableDbcLocales,bar,bad_dbc_files,sSkillLineStore,           dbcPath,"SkillLine.dbc");
     LoadDBC(availableDbcLocales,bar,bad_dbc_files,sSkillLineAbilityStore,    dbcPath,"SkillLineAbility.dbc");
     LoadDBC(availableDbcLocales,bar,bad_dbc_files,sSoundEntriesStore,        dbcPath,"SoundEntries.dbc");
-    LoadDBC(availableDbcLocales,bar,bad_dbc_files,sSpellStore,               dbcPath,"Spell.dbc");
+    LoadDBC(availableDbcLocales,bar,bad_dbc_files,sSpellStore,               dbcPath,"Spell.dbc", &CustomSpellEntryfmt, &CustomSpellEntryIndex);
     for(uint32 i = 1; i < sSpellStore.GetNumRows(); ++i)
     {
         SpellEntry const * spell = sSpellStore.LookupEntry(i);
@@ -899,11 +910,15 @@ bool IsPointInAreaTriggerZone(AreaTriggerEntry const* atEntry, uint32 mapid, flo
 }
 
 // script support functions
-MANGOS_DLL_SPEC DBCStorage <SoundEntriesEntry>  const* GetSoundEntriesStore()   { return &sSoundEntriesStore;   }
-MANGOS_DLL_SPEC DBCStorage <SpellEntry>         const* GetSpellStore()          { return &sSpellStore;          }
-MANGOS_DLL_SPEC DBCStorage <SpellRangeEntry>    const* GetSpellRangeStore()     { return &sSpellRangeStore;     }
-MANGOS_DLL_SPEC DBCStorage <FactionEntry>       const* GetFactionStore()        { return &sFactionStore;        }
-MANGOS_DLL_SPEC DBCStorage <ItemEntry>          const* GetItemDisplayStore()    { return &sItemStore;           }
-MANGOS_DLL_SPEC DBCStorage <CreatureDisplayInfoEntry> const* GetCreatureDisplayStore() { return &sCreatureDisplayInfoStore; }
-MANGOS_DLL_SPEC DBCStorage <EmotesEntry>        const* GetEmotesStore()         { return &sEmotesStore;         }
-MANGOS_DLL_SPEC DBCStorage <EmotesTextEntry>    const* GetEmotesTextStore()     { return &sEmotesTextStore;     }
+MANGOS_DLL_SPEC DBCStorage <SoundEntriesEntry>  		const* GetSoundEntriesStore()   	{ return &sSoundEntriesStore;   }
+MANGOS_DLL_SPEC DBCStorage <SpellEntry>        		 	const* GetSpellStore()          	{ return &sSpellStore;          }
+MANGOS_DLL_SPEC DBCStorage <SpellRangeEntry>    		const* GetSpellRangeStore()     	{ return &sSpellRangeStore;     }
+MANGOS_DLL_SPEC DBCStorage <FactionEntry>       		const* GetFactionStore()        	{ return &sFactionStore;        }
+MANGOS_DLL_SPEC DBCStorage <ItemEntry>          		const* GetItemDisplayStore()    	{ return &sItemStore;           }
+MANGOS_DLL_SPEC DBCStorage <CreatureDisplayInfoEntry> 	const* GetCreatureDisplayStore() 	{ return &sCreatureDisplayInfoStore; }
+MANGOS_DLL_SPEC DBCStorage <EmotesEntry>        		const* GetEmotesStore()         	{ return &sEmotesStore;         }
+MANGOS_DLL_SPEC DBCStorage <AchievementEntry>                   const* GetAchievementStore()    { return &sAchievementStore;    }
+MANGOS_DLL_SPEC DBCStorage <EmotesTextEntry>
+            const* GetEmotesTextStore()    		{ return &sEmotesTextStore;     }
+MANGOS_DLL_SPEC DBCStorage <CharTitlesEntry>
+             const* GetCharTitlesStore() 		{ return &sCharTitlesStore; 	}
\ No newline at end of file
diff --git a/mangos/src/game/DBCStores.h b/Core/src/game/DBCStores.h
index 5051236..af6bbb5 100644
--- a/mangos/src/game/DBCStores.h
+++ b/Core/src/game/DBCStores.h
@@ -73,6 +73,7 @@ extern DBCStorage <AchievementEntry>             sAchievementStore;
 extern DBCStorage <AchievementCriteriaEntry>     sAchievementCriteriaStore;
 extern DBCStorage <AreaTableEntry>               sAreaStore;// recommend access using functions
 extern DBCStorage <AreaGroupEntry>               sAreaGroupStore;
+extern DBCStorage <AreaPOIEntry>                 sAreaPOIStore;
 extern DBCStorage <AreaTriggerEntry>             sAreaTriggerStore;
 extern DBCStorage <AuctionHouseEntry>            sAuctionHouseStore;
 extern DBCStorage <BankBagSlotPricesEntry>       sBankBagSlotPricesStore;
@@ -175,5 +176,7 @@ MANGOS_DLL_SPEC DBCStorage <FactionEntry>               const* GetFactionStore()
 MANGOS_DLL_SPEC DBCStorage <ItemEntry>                  const* GetItemDisplayStore();
 MANGOS_DLL_SPEC DBCStorage <CreatureDisplayInfoEntry>   const* GetCreatureDisplayStore();
 MANGOS_DLL_SPEC DBCStorage <EmotesEntry>                const* GetEmotesStore();
+MANGOS_DLL_SPEC DBCStorage <AchievementEntry>           const* GetAchievementStore();
 MANGOS_DLL_SPEC DBCStorage <EmotesTextEntry>            const* GetEmotesTextStore();
-#endif
+MANGOS_DLL_SPEC DBCStorage <CharTitlesEntry> 			const* GetCharTitlesStore();
+#endif
\ No newline at end of file
diff --git a/mangos/src/game/DBCStructure.h b/Core/src/game/DBCStructure.h
index e63ae5c..a08ea4d 100644
--- a/mangos/src/game/DBCStructure.h
+++ b/Core/src/game/DBCStructure.h
@@ -206,6 +206,17 @@ struct AchievementCriteriaEntry
             uint32  spellID;                                // 3
             uint32  castCount;                              // 4
         } cast_spell;
+        
+        // ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE       = 30
+        struct
+        {
+            uint32  captureID;                                // 3
+            uint32  captureCount;                             // 4
+            //uint32  additionalRequirement1_type;            // 5 
+            //uint32  additionalRequirement1_value;           // 6 
+            //uint32  additionalRequirement2_type;            // 7 
+            //uint32  additionalRequirement2_value;           // 8 
+        } objective_capture;
 
         // ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA = 31
         struct
@@ -411,6 +422,8 @@ struct AchievementCriteriaEntry
         {
             uint32  unused;                                 // 3
             uint32  killCount;                              // 4
+            uint32  flag;                                   // 5
+            uint32  mapid;                                  // 6
         } special_pvp_kill;
 
         // ACHIEVEMENT_CRITERIA_TYPE_FISH_IN_GAMEOBJECT     = 72
@@ -521,6 +534,24 @@ struct AreaGroupEntry
     uint32  nextGroup;                                      // 7 index of next group
 };
 
+struct AreaPOIEntry
+{
+    uint32 id;              //0
+    uint32 icon[11];        //1-11
+    float x;                //12
+    float y;                //13
+    float z;                //14
+    uint32 mapId;           //15
+    //uint32 val1;          //16
+    uint32 zoneId;          //17
+    //char* name[16];       //18-33
+    //uint32 name_flag;     //34
+    //char* name2[16];      //35-50
+    //uint32 name_flag2;    //51
+    uint32 worldState;      //52
+    //uint32 val2;          //53
+};
+
 struct AreaTriggerEntry
 {
     uint32  id;                                             // 0        m_ID
@@ -1578,9 +1609,9 @@ struct SpellItemEnchantmentEntry
     uint32      slot;                                       // 32       m_flags
     uint32      GemID;                                      // 33       m_src_itemID
     uint32      EnchantmentCondition;                       // 34       m_condition_id
-    //uint32      requiredSkill;                            // 35       m_requiredSkillID
-    //uint32      requiredSkillValue;                       // 36       m_requiredSkillRank
-                                                            // 37       new in 3.1
+    uint32      requiredSkill;                              // 35       m_requiredSkillID
+    uint32      requiredSkillValue;                         // 36       m_requiredSkillRank
+    uint32      requiredLevel;                              // 37       m_requiredLevel
 };
 
 struct SpellItemEnchantmentConditionEntry
@@ -1719,7 +1750,7 @@ struct VehicleEntry
     uint32  m_uiLocomotionType;                             // 34
     float   m_msslTrgtImpactTexRadius;                      // 35
     uint32  m_uiSeatIndicatorType;                          // 36
-                                                            // 37, new in 3.1
+    uint32  m_powerType;                                    // 37, new in 3.1                                                        // 37, new in 3.1
                                                             // 38, new in 3.1
                                                             // 39, new in 3.1
 };
@@ -1773,6 +1804,8 @@ struct VehicleSeatEntry
     int32   m_uiSkin;                                       // 44
     uint32  m_flagsB;                                       // 45
                                                             // 46-57 added in 3.1, floats mostly
+
+    bool IsUsable() const { return m_flags & 0x2000000; }
 };
 
 struct WorldMapAreaEntry
diff --git a/mangos/src/game/DBCfmt.h b/Core/src/game/DBCfmt.h
index 5824944..1d10e99 100644
--- a/mangos/src/game/DBCfmt.h
+++ b/Core/src/game/DBCfmt.h
@@ -23,6 +23,7 @@ const char Achievementfmt[]="niixssssssssssssssssxxxxxxxxxxxxxxxxxxiixixxxxxxxxx
 const char AchievementCriteriafmt[]="niiiiiiiixxxxxxxxxxxxxxxxxiixix";
 const char AreaTableEntryfmt[]="iiinixxxxxissssssssssssssssxixxxxxxx";
 const char AreaGroupEntryfmt[]="niiiiiii";
+const char AreaPOIEntryfmt[]="niiiiiiiiiiifffixixxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxix";
 const char AreaTriggerEntryfmt[]="niffffffff";
 const char AuctionHouseEntryfmt[]="niiixxxxxxxxxxxxxxxxx";
 const char BankBagSlotPricesEntryfmt[]="ni";
@@ -89,8 +90,10 @@ const char SpellCastTimefmt[]="nixx";
 const char SpellDurationfmt[]="niii";
 const char SpellDifficultyfmt[]="niiii";
 const char SpellEntryfmt[]="niiiiiiiiiixixixiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiifxiiiiiiiiiiiiiiiiiiiiiiiiiiiifffiiiiiiiiiiiiiiiiiiiiifffiiiiiiiiiiiiiiifffiiiiiiiiiiiiixssssssssssssssssxssssssssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxiiiiiiiiiiixfffxxxiiiiixxxxxxi";
+const std::string CustomSpellEntryfmt="pappppppppaapaaapaaaaaaaaaaapaaapapppppppaaaaapaapaaaaaaaaaaaaaaaaaappppppppppppppppppppppppppppppppppppaaaaaapppppppppaaapppppppppaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaappppppppapppaaaaappaaaaaaa";
+const std::string CustomSpellEntryIndex = "Id";
 const char SpellFocusObjectfmt[]="nxxxxxxxxxxxxxxxxx";
-const char SpellItemEnchantmentfmt[]="nxiiiiiixxxiiissssssssssssssssxiiiixxx";
+const char SpellItemEnchantmentfmt[]="nxiiiiiixxxiiissssssssssssssssxiiiiiii";
 const char SpellItemEnchantmentConditionfmt[]="nbbbbbxxxxxbbbbbbbbbbiiiiiXXXXX";
 const char SpellRadiusfmt[]="nfxf";
 const char SpellRangefmt[]="nffffxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
@@ -104,7 +107,7 @@ const char TaxiNodesEntryfmt[]="nifffssssssssssssssssxii";
 const char TaxiPathEntryfmt[]="niii";
 const char TaxiPathNodeEntryfmt[]="diiifffiiii";
 const char TotemCategoryEntryfmt[]="nxxxxxxxxxxxxxxxxxii";
-const char VehicleEntryfmt[]="niffffiiiiiiiifffffffffffffffssssfifixxx";
+const char VehicleEntryfmt[]="niffffiiiiiiiifffffffffffffffssssfifiixx";
 const char VehicleSeatEntryfmt[]="niiffffffffffiiiiiifffffffiiifffiiiiiiiffiiiiixxxxxxxxxxxx";
 const char WorldMapAreaEntryfmt[]="xinxffffixx";
 const char WorldMapOverlayEntryfmt[]="nxiiiixxxxxxxxxxx";
diff --git a/mangos/src/game/DynamicObject.cpp b/Core/src/game/DynamicObject.cpp
index 6a36f6d..964c991 100644
--- a/mangos/src/game/DynamicObject.cpp
+++ b/Core/src/game/DynamicObject.cpp
@@ -68,7 +68,7 @@ bool DynamicObject::Create( uint32 guidlow, Unit *caster, uint32 spellId, SpellE
     }
 
     SetEntry(spellId);
-    SetFloatValue( OBJECT_FIELD_SCALE_X, 1 );
+    SetFloatValue( OBJECT_FIELD_SCALE_X, 2 );
     SetUInt64Value( DYNAMICOBJECT_CASTER, caster->GetGUID() );
     SetUInt32Value( DYNAMICOBJECT_BYTES, 0x00000001 );
     SetUInt32Value( DYNAMICOBJECT_SPELLID, spellId );
diff --git a/mangos/src/game/Formulas.h b/Core/src/game/Formulas.h
index f96154e..bf4b889 100644
--- a/mangos/src/game/Formulas.h
+++ b/Core/src/game/Formulas.h
@@ -27,7 +27,13 @@ namespace MaNGOS
     {
         inline float hk_honor_at_level(uint32 level, uint32 count=1)
         {
-            return (float)ceil(count*(-0.53177f + 0.59357f * exp((level +23.54042f) / 26.07859f )));
+            // this one is hardly outdated
+            //return (float)ceil(count*(-0.53177f + 0.59357f * exp((level +23.54042f) / 26.07859f )));
+            //Not correct for lower levels....
+            float honor_points = sWorld.getConfig(CONFIG_UINT32_HONORABLE_KILL);  // For one kill at max level (from 3.3.3, lvl 80)
+            honor_points *= float(level) / float(sWorld.getConfig(CONFIG_UINT32_MAX_PLAYER_LEVEL));
+            honor_points *= count;
+            return honor_points;
         }
     }
     namespace XP
diff --git a/mangos/src/game/GameObject.cpp b/Core/src/game/GameObject.cpp
index a446784..59adc59 100644
--- a/mangos/src/game/GameObject.cpp
+++ b/Core/src/game/GameObject.cpp
@@ -35,10 +35,11 @@
 #include "InstanceData.h"
 #include "BattleGround.h"
 #include "BattleGroundAV.h"
+#include "OutdoorPvPMgr.h"
 #include "Util.h"
 #include "ScriptCalls.h"
 
-GameObject::GameObject() : WorldObject()
+GameObject::GameObject() : WorldObject(), m_goValue(new GameObjectValue)
 {
     m_objectType |= TYPEMASK_GAMEOBJECT;
     m_objectTypeId = TYPEID_GAMEOBJECT;
@@ -54,20 +55,30 @@ GameObject::GameObject() : WorldObject()
     m_spellId = 0;
     m_cooldownTime = 0;
     m_goInfo = NULL;
+    m_goData = NULL;
 
     m_DBTableGuid = 0;
     m_rotation = 0;
+    
+    m_groupLootTimer = 0;
+    m_groupLootId = 0;
 }
 
 GameObject::~GameObject()
 {
+    delete m_goValue;
 }
 
 void GameObject::AddToWorld()
 {
     ///- Register the gameobject for guid lookup
     if(!IsInWorld())
+    {
+        if(m_zoneScript)
+            m_zoneScript->OnGameObjectCreate(this, true);
+
         GetMap()->GetObjectsStore().insert<GameObject>(GetGUID(), (GameObject*)this);
+    }
 
     Object::AddToWorld();
 }
@@ -77,6 +88,9 @@ void GameObject::RemoveFromWorld()
     ///- Remove the gameobject from the accessor
     if(IsInWorld())
     {
+        if(m_zoneScript)
+            m_zoneScript->OnGameObjectCreate(this, false);
+
         // Remove GO from owner
         ObjectGuid owner_guid = GetOwnerGUID();
         if (!owner_guid.IsEmpty())
@@ -96,7 +110,7 @@ void GameObject::RemoveFromWorld()
     Object::RemoveFromWorld();
 }
 
-bool GameObject::Create(uint32 guidlow, uint32 name_id, Map *map, uint32 phaseMask, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint32 animprogress, GOState go_state)
+bool GameObject::Create(uint32 guidlow, uint32 name_id, Map *map, uint32 phaseMask, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint32 animprogress, GOState go_state, uint32 artKit)
 {
     ASSERT(map);
     Relocate(x,y,z,ang);
@@ -145,19 +159,34 @@ bool GameObject::Create(uint32 guidlow, uint32 name_id, Map *map, uint32 phaseMa
     SetGoType(GameobjectTypes(goinfo->type));
     SetGoArtKit(0);                                         // unknown what this is
     SetGoAnimProgress(animprogress);
+    
+    if (goinfo->type == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+        m_goValue->destructibleBuilding.health = goinfo->destructibleBuilding.intactNumHits + goinfo->destructibleBuilding.damagedNumHits;
+
+    SetByteValue(GAMEOBJECT_BYTES_1, 2, artKit);
+
+    if (goinfo->type == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+        m_goValue->destructibleBuilding.health = goinfo->destructibleBuilding.intactNumHits + goinfo->destructibleBuilding.damagedNumHits;
 
     //Notify the map's instance data.
     //Only works if you create the object in it, not if it is moves to that map.
     //Normally non-players do not teleport to other maps.
     if(map->IsDungeon() && ((InstanceMap*)map)->GetInstanceData())
-    {
         ((InstanceMap*)map)->GetInstanceData()->OnObjectCreate(this);
+
+    SetZoneScript();
+
+    if (goinfo->type == GAMEOBJECT_TYPE_TRANSPORT)
+    {
+        SetUInt32Value(GAMEOBJECT_LEVEL, goinfo->transport.pause);
+        if (goinfo->transport.startOpen)
+            SetGoState(GO_STATE_ACTIVE);
     }
 
     return true;
 }
 
-void GameObject::Update(uint32 /*p_time*/)
+void GameObject::Update(uint32 p_time)
 {
     if (GetObjectGuid().IsMOTransport())
     {
@@ -363,6 +392,22 @@ void GameObject::Update(uint32 /*p_time*/)
                         m_cooldownTime = 0;
                     }
                     break;
+                case GAMEOBJECT_TYPE_CHEST:
+                    if (m_groupLootTimer && m_groupLootId)
+                    {
+                        if(p_time <= m_groupLootTimer)
+                        {
+                            m_groupLootTimer -= p_time;
+                        }
+                        else
+                        {
+                            if (Group* group = sObjectMgr.GetGroupById(m_groupLootId))
+                                group->EndRoll();
+                            m_groupLootTimer = 0;
+                            m_groupLootId = 0;
+                        }
+                    }
+                    break;
                 default:
                     break;
             }
@@ -421,6 +466,10 @@ void GameObject::Update(uint32 /*p_time*/)
             if(!m_spawnedByDefault)
             {
                 m_respawnTime = 0;
+
+                if (IsInWorld())
+                    UpdateObjectVisibility();
+
                 return;
             }
 
@@ -449,6 +498,9 @@ void GameObject::Refresh()
     // not refresh despawned not casted GO (despawned casted GO destroyed in all cases anyway)
     if(m_respawnTime > 0 && m_spawnedByDefault)
         return;
+        
+    m_groupLootTimer = 0;
+    m_groupLootId = 0;
 
     if(isSpawned())
         GetMap()->Add(this);
@@ -618,6 +670,7 @@ bool GameObject::LoadFromDB(uint32 guid, Map *map)
         }
     }
 
+    m_goData = data;
     return true;
 }
 
@@ -630,10 +683,6 @@ void GameObject::DeleteFromDB()
     WorldDatabase.PExecuteLog("DELETE FROM gameobject_battleground WHERE guid = '%u'", m_DBTableGuid);
 }
 
-GameObjectInfo const *GameObject::GetGOInfo() const
-{
-    return m_goInfo;
-}
 
 /*********************************************************/
 /***                    QUEST SYSTEM                   ***/
@@ -668,6 +717,15 @@ bool GameObject::IsTransport() const
     return gInfo->type == GAMEOBJECT_TYPE_TRANSPORT || gInfo->type == GAMEOBJECT_TYPE_MO_TRANSPORT;
 }
 
+// is Dynamic transport = non-stop Transport
+bool GameObject::IsDynTransport() const
+{
+    // If something is marked as a transport, don't transmit an out of range packet for it.
+    GameObjectInfo const * gInfo = GetGOInfo();
+    if(!gInfo) return false;
+    return gInfo->type == GAMEOBJECT_TYPE_MO_TRANSPORT || (gInfo->type == GAMEOBJECT_TYPE_TRANSPORT && !gInfo->transport.pause);
+}
+
 Unit* GameObject::GetOwner() const
 {
     return ObjectAccessor::GetUnit(*this, GetOwnerGUID());
@@ -675,7 +733,7 @@ Unit* GameObject::GetOwner() const
 
 void GameObject::SaveRespawnTime()
 {
-    if(m_respawnTime > time(NULL) && m_spawnedByDefault)
+    if(m_goData && m_goData->dbData && m_respawnTime > time(NULL) && m_spawnedByDefault)
         sObjectMgr.SaveGORespawnTime(m_DBTableGuid,GetInstanceId(),m_respawnTime);
 }
 
@@ -701,12 +759,21 @@ bool GameObject::isVisibleForInState(Player const* u, WorldObject const* viewPoi
             return false;
 
         // special invisibility cases
-        /* TODO: implement trap stealth, take look at spell 2836
-        if(GetGOInfo()->type == GAMEOBJECT_TYPE_TRAP && GetGOInfo()->trap.stealthed && u->IsHostileTo(GetOwner()))
+        // TODO: implement trap stealth, take look at spell 2836
+        if(GetOwner() && GetOwner()->IsInWorld() && GetGOInfo()->type == GAMEOBJECT_TYPE_TRAP && GetGOInfo()->trap.stealthed && u->IsHostileTo(GetOwner()))
         {
-            if(check stuff here)
+            if(u->GetGUID() == GetOwner()->GetGUID() || u->HasAura(2836) && u->isInFront(this, 15.0f, M_PI_F/2))   // hack, maybe values are wrong
+                return true;
+
+            if(m_lootState == GO_READY)
                 return false;
-        }*/
+            
+            if (Unit* TrapOwner = GetOwner())
+                if (TrapOwner->GetTypeId() == TYPEID_PLAYER && ((Player*)TrapOwner)->IsInSameRaidWith(u))
+                    return true;
+
+            return true;
+        }
     }
 
     // check distance
@@ -738,7 +805,7 @@ bool GameObject::ActivateToQuest( Player *pTarget)const
                 //look for battlegroundAV for some objects which are only activated after mine gots captured by own team
                 if (GetEntry() == BG_AV_OBJECTID_MINE_N || GetEntry() == BG_AV_OBJECTID_MINE_S)
                     if (BattleGround *bg = pTarget->GetBattleGround())
-                        if (bg->GetTypeID() == BATTLEGROUND_AV && !(((BattleGroundAV*)bg)->PlayerCanDoMineQuest(GetEntry(),pTarget->GetTeam())))
+                        if (bg->GetTypeID(true) == BATTLEGROUND_AV && !(((BattleGroundAV*)bg)->PlayerCanDoMineQuest(GetEntry(),pTarget->GetTeam())))
                             return false;
                 return true;
             }
@@ -847,6 +914,29 @@ void GameObject::UseDoorOrButton(uint32 time_to_restore, bool alternative /* = f
     m_cooldownTime = time(NULL) + time_to_restore;
 }
 
+void GameObject::SetGoArtKit(uint8 kit)
+{
+    SetByteValue(GAMEOBJECT_BYTES_1, 2, kit);
+    GameObjectData *data = const_cast<GameObjectData*>(sObjectMgr.GetGOData(m_DBTableGuid));
+    if(data)
+        data->artKit = kit;
+}
+
+void GameObject::SetGoArtKit(uint8 artkit, GameObject *go, uint32 lowguid)
+{
+    const GameObjectData *data = NULL;
+    if(go)
+    {
+        go->SetGoArtKit(artkit);
+        data = go->GetGOData();
+    }
+    else if(lowguid)
+        data = sObjectMgr.GetGOData(lowguid);
+
+    if(data)
+        const_cast<GameObjectData*>(data)->artKit = artkit;
+}
+
 void GameObject::SwitchDoorOrButton(bool activate, bool alternative /* = false */)
 {
     if(activate)
@@ -1321,15 +1411,15 @@ void GameObject::Use(Unit* user)
                     {
                         case 179785:                        // Silverwing Flag
                             // check if it's correct bg
-                            if(bg->GetTypeID() == BATTLEGROUND_WS)
+                            if(bg->GetTypeID(true) == BATTLEGROUND_WS)
                                 bg->EventPlayerClickedOnFlag(player, this);
                             break;
                         case 179786:                        // Warsong Flag
-                            if(bg->GetTypeID() == BATTLEGROUND_WS)
+                            if(bg->GetTypeID(true) == BATTLEGROUND_WS)
                                 bg->EventPlayerClickedOnFlag(player, this);
                             break;
                         case 184142:                        // Netherstorm Flag
-                            if(bg->GetTypeID() == BATTLEGROUND_EY)
+                            if(bg->GetTypeID(true) == BATTLEGROUND_EY)
                                 bg->EventPlayerClickedOnFlag(player, this);
                             break;
                     }
@@ -1371,7 +1461,10 @@ void GameObject::Use(Unit* user)
     SpellEntry const *spellInfo = sSpellStore.LookupEntry( spellId );
     if (!spellInfo)
     {
-        sLog.outError("WORLD: unknown spell id %u at use action for gameobject (Entry: %u GoType: %u )", spellId,GetEntry(),GetGoType());
+        if(user->GetTypeId() != TYPEID_PLAYER || !sOutdoorPvPMgr.HandleCustomSpell((Player*)user,spellId,this))
+            sLog.outError("WORLD: unknown spell id %u at use action for gameobject (Entry: %u GoType: %u )", spellId,GetEntry(),GetGoType());
+        else
+            DEBUG_LOG("WORLD: %u non-dbc spell was handled by OutdoorPvP", spellId);
         return;
     }
 
@@ -1430,6 +1523,63 @@ void GameObject::UpdateRotationFields(float rotation2 /*=0.0f*/, float rotation3
     SetFloatValue(GAMEOBJECT_PARENTROTATION+3, rotation3);
 }
 
+void GameObject::TakenDamage(uint32 damage, Unit *who)
+{
+    GameObjectInfo const* info = GetGOInfo();
+    if (!m_goValue->destructibleBuilding.health)
+        return;
+
+    Player* pwho = NULL;
+    if(who && who->GetTypeId() == TYPEID_PLAYER)
+      pwho = (Player*)who;
+
+    if(who && who->GetTypeId() == TYPEID_UNIT && ((Creature*)who)->isVehicle())
+      pwho = (Player*)who->GetCharmerOrOwner();
+
+    if (m_goValue->destructibleBuilding.health > damage)
+        m_goValue->destructibleBuilding.health -= damage;
+    else
+        m_goValue->destructibleBuilding.health = 0;
+
+    if (HasFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED)) // from damaged to destroyed
+    {
+        if(!m_goValue->destructibleBuilding.health)
+        {
+            RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
+            SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            SetUInt32Value(GAMEOBJECT_DISPLAYID, m_goInfo->destructibleBuilding.destroyedDisplayId);
+            //EventInform(m_goInfo->destructibleBuilding.destroyedEvent);
+            if(pwho)
+            {
+                /*if(BattleGround* bg = pwho->GetBattleGround())
+                    bg->EventPlayerDamagedGO(pwho, this, m_goInfo->destructibleBuilding.destroyedEvent);*/
+            }
+        }
+    }
+    else // from intact to damaged
+    {
+        if (m_goValue->destructibleBuilding.health <= m_goInfo->destructibleBuilding.damagedNumHits)
+        {
+            if (!info->destructibleBuilding.destroyedDisplayId)
+                m_goValue->destructibleBuilding.health = 0;
+            else if (!m_goValue->destructibleBuilding.health)
+                m_goValue->destructibleBuilding.health = 1;
+
+            SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
+            SetUInt32Value(GAMEOBJECT_DISPLAYID, m_goInfo->destructibleBuilding.damagedDisplayId);
+            //EventInform(m_goInfo->destructibleBuilding.damagedEvent);
+        }
+    }
+}
+
+void GameObject::Rebuild()
+{
+    RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED + GO_FLAG_DESTROYED);
+    SetUInt32Value(GAMEOBJECT_DISPLAYID, m_goInfo->displayId);
+    m_goValue->destructibleBuilding.health = m_goInfo->destructibleBuilding.intactNumHits + m_goInfo->destructibleBuilding.damagedNumHits;
+    //EventInform(m_goInfo->destructibleBuilding.rebuildingEvent);
+}
+
 bool GameObject::IsHostileTo(Unit const* unit) const
 {
     // always non-hostile to GM in GM mode
@@ -1515,3 +1665,15 @@ bool GameObject::IsFriendlyTo(Unit const* unit) const
     // common faction based case (GvC,GvP)
     return tester_faction->IsFriendlyTo(*target_faction);
 }
+
+void GameObject::DealSiegeDamage(uint32 damage)
+{
+    m_actualHealth -= damage;
+
+    // TODO : there are a lot of thinghts to do here
+    if(m_actualHealth < 0)
+    {
+        m_actualHealth = GetGOInfo()->destructibleBuilding.intactNumHits;
+        SetLootState(GO_JUST_DEACTIVATED);
+    }
+}
diff --git a/mangos/src/game/GameObject.h b/Core/src/game/GameObject.h
index 0e48cb7..7d5ce36 100644
--- a/mangos/src/game/GameObject.h
+++ b/Core/src/game/GameObject.h
@@ -358,15 +358,15 @@ struct GameObjectInfo
         {
             uint32 intactNumHits;                           //0
             uint32 creditProxyCreature;                     //1
-            uint32 empty1;                                  //2
+            uint32 state1Name;                                  //2
             uint32 intactEvent;                             //3
-            uint32 empty2;                                  //4
+            uint32 damagedDisplayId;                                  //4
             uint32 damagedNumHits;                          //5
             uint32 empty3;                                  //6
             uint32 empty4;                                  //7
             uint32 empty5;                                  //8
             uint32 damagedEvent;                            //9
-            uint32 empty6;                                  //10
+            uint32 destroyedDisplayId;                                  //10
             uint32 empty7;                                  //11
             uint32 empty8;                                  //12
             uint32 empty9;                                  //13
@@ -516,6 +516,16 @@ struct GameObjectInfo
     }
 };
 
+union GameObjectValue
+{
+    //33 GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING
+    struct
+    {
+        uint32 health;
+    }
+    destructibleBuilding;
+};
+
 // GCC have alternative #pragma pack() syntax and old gcc version not support pack(pop), also any gcc version not support it at some platform
 #if defined( __GNUC__ )
 #pragma pack()
@@ -542,6 +552,7 @@ enum GOState
 // from `gameobject`
 struct GameObjectData
 {
+    explicit GameObjectData() : dbData(true) {}
     uint32 id;                                              // entry in gamobject_template
     uint16 mapid;
     uint16 phaseMask;
@@ -557,6 +568,8 @@ struct GameObjectData
     uint32 animprogress;
     GOState go_state;
     uint8 spawnMask;
+    uint8 artKit;
+    bool dbData;
 };
 
 // For containers:  [GO_NOT_READY]->GO_READY (close)->GO_ACTIVATED (open) ->GO_JUST_DEACTIVATED->GO_READY        -> ...
@@ -585,11 +598,14 @@ class MANGOS_DLL_SPEC GameObject : public WorldObject
         void AddToWorld();
         void RemoveFromWorld();
 
-        bool Create(uint32 guidlow, uint32 name_id, Map *map, uint32 phaseMask, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint32 animprogress, GOState go_state);
+        bool Create(uint32 guidlow, uint32 name_id, Map *map, uint32 phaseMask, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint32 animprogress, GOState go_state, uint32 artKit = 0);
         void Update(uint32 p_time);
-        GameObjectInfo const* GetGOInfo() const;
+        GameObjectInfo const* GetGOInfo() const { return m_goInfo; }
+        GameObjectData const* GetGOData() const { return m_goData; }
+        GameObjectValue * GetGOValue() const { return m_goValue; }
 
         bool IsTransport() const;
+        bool IsDynTransport() const;
 
         uint32 GetDBTableGUIDLow() const { return m_DBTableGuid; }
 
@@ -656,7 +672,9 @@ class MANGOS_DLL_SPEC GameObject : public WorldObject
         GOState GetGoState() const { return GOState(GetByteValue(GAMEOBJECT_BYTES_1, 0)); }
         void SetGoState(GOState state) { SetByteValue(GAMEOBJECT_BYTES_1, 0, state); }
         uint8 GetGoArtKit() const { return GetByteValue(GAMEOBJECT_BYTES_1, 2); }
-        void SetGoArtKit(uint8 artkit) { SetByteValue(GAMEOBJECT_BYTES_1, 2, artkit); }
+        //void SetGoArtKit(uint8 artkit) { SetByteValue(GAMEOBJECT_BYTES_1, 2, artkit); }
+        void SetGoArtKit(uint8 artkit);
+        static void SetGoArtKit(uint8 artkit, GameObject *go, uint32 lowguid = 0);
         uint8 GetGoAnimProgress() const { return GetByteValue(GAMEOBJECT_BYTES_1, 3); }
         void SetGoAnimProgress(uint8 animprogress) { SetByteValue(GAMEOBJECT_BYTES_1, 3, animprogress); }
 
@@ -684,6 +702,9 @@ class MANGOS_DLL_SPEC GameObject : public WorldObject
 
         Loot        loot;
 
+        uint32 m_groupLootTimer;                            // (msecs)timer used for group loot
+        uint32 m_groupLootId;                               // used to find group which is looting corpse
+        
         bool hasQuest(uint32 quest_id) const;
         bool hasInvolvedQuest(uint32 quest_id) const;
         bool ActivateToQuest(Player *pTarget) const;
@@ -701,16 +722,21 @@ class MANGOS_DLL_SPEC GameObject : public WorldObject
 
         GameObject* LookupFishingHoleAround(float range);
 
+        void TakenDamage(uint32 damage, Unit* who = NULL);
+        void Rebuild();
+
         GridReference<GameObject> &GetGridRef() { return m_gridRef; }
 
         bool isActiveObject() const { return false; }
         uint64 GetRotation() const { return m_rotation; }
+        void DealSiegeDamage(uint32 damage);
     protected:
         uint32      m_spellId;
         time_t      m_respawnTime;                          // (secs) time of next respawn (or despawn if GO have owner()),
         uint32      m_respawnDelayTime;                     // (secs) if 0 then current GO state no dependent from timer
         LootState   m_lootState;
         bool        m_spawnedByDefault;
+        int32       m_actualHealth;                         // current health state
         time_t      m_cooldownTime;                         // used as internal reaction delay time store (not state change reaction).
                                                             // For traps this: spell casting cooldown, for doors/buttons: reset time.
         std::list<uint32> m_SkillupList;
@@ -720,6 +746,8 @@ class MANGOS_DLL_SPEC GameObject : public WorldObject
 
         uint32 m_DBTableGuid;                               ///< For new or temporary gameobjects is 0 for saved it is lowguid
         GameObjectInfo const* m_goInfo;
+        GameObjectData const* m_goData;
+        GameObjectValue * const m_goValue;
         uint64 m_rotation;
     private:
         void SwitchDoorOrButton(bool activate, bool alternative = false);
diff --git a/mangos/src/game/GossipDef.h b/Core/src/game/GossipDef.h
index 68744db..1140151 100644
--- a/mangos/src/game/GossipDef.h
+++ b/Core/src/game/GossipDef.h
@@ -48,6 +48,8 @@ enum Gossip_Option
     GOSSIP_OPTION_ARMORER           = 15,                   //UNIT_NPC_FLAG_ARMORER             (4096)
     GOSSIP_OPTION_UNLEARNTALENTS    = 16,                   //UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
     GOSSIP_OPTION_UNLEARNPETSKILLS  = 17,                   //UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
+    GOSSIP_OPTION_LEARNDUALSPEC     = 18,                   //UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
+    GOSSIP_OPTION_OUTDOORPVP        = 19,                   //added by code (option for outdoor pvp creatures)
     GOSSIP_OPTION_MAX
 };
 
diff --git a/mangos/src/game/GridNotifiers.cpp b/Core/src/game/GridNotifiers.cpp
index 30d977c..57a89ee 100644
--- a/mangos/src/game/GridNotifiers.cpp
+++ b/Core/src/game/GridNotifiers.cpp
@@ -94,7 +94,12 @@ VisibleNotifier::Notify()
     {
         // target aura duration for caster show only if target exist at caster client
         if((*vItr)!=&i_player && (*vItr)->isType(TYPEMASK_UNIT))
+        {
             i_player.SendAurasForTarget((Unit*)(*vItr));
+            WorldPacket data;
+            ((Unit*)(*vItr))->BuildHeartBeatMsg(&data);
+            i_player.GetSession()->SendPacket(&data);
+        }
 
         // non finished movements show to player
         if((*vItr)->GetTypeId()==TYPEID_UNIT && ((Creature*)(*vItr))->isAlive())
@@ -152,6 +157,7 @@ MessageDistDeliverer::Visit(PlayerMapType &m)
     {
         if ((i_toSelf || iter->getSource() != &i_player ) &&
             (!i_ownTeamOnly || iter->getSource()->GetTeam() == i_player.GetTeam() ) &&
+            (!i_enemyTeamOnly || iter->getSource()->GetTeam() != i_player.GetTeam()) &&
             (!i_dist || iter->getSource()->IsWithinDist(&i_player,i_dist)))
         {
             if (!i_player.InSamePhase(iter->getSource()))
diff --git a/mangos/src/game/GridNotifiers.h b/Core/src/game/GridNotifiers.h
index cd76143..84f0573 100644
--- a/mangos/src/game/GridNotifiers.h
+++ b/Core/src/game/GridNotifiers.h
@@ -115,10 +115,11 @@ namespace MaNGOS
         WorldPacket *i_message;
         bool i_toSelf;
         bool i_ownTeamOnly;
+        bool i_enemyTeamOnly;
         float i_dist;
 
-        MessageDistDeliverer(Player &pl, WorldPacket *msg, float dist, bool to_self, bool ownTeamOnly)
-            : i_player(pl), i_message(msg), i_toSelf(to_self), i_ownTeamOnly(ownTeamOnly), i_dist(dist) {}
+        MessageDistDeliverer(Player &pl, WorldPacket *msg, float dist, bool to_self, bool ownTeamOnly, bool enemyTeamOnly = false)
+            : i_player(pl), i_message(msg), i_toSelf(to_self), i_ownTeamOnly(ownTeamOnly), i_enemyTeamOnly(enemyTeamOnly), i_dist(dist) {}
         void Visit(PlayerMapType &m);
         template<class SKIP> void Visit(GridRefManager<SKIP> &) {}
     };
diff --git a/mangos/src/game/Group.cpp b/Core/src/game/Group.cpp
index 7aa97e1..27e3a52 100644
--- a/mangos/src/game/Group.cpp
+++ b/Core/src/game/Group.cpp
@@ -28,10 +28,12 @@
 #include "Formulas.h"
 #include "ObjectAccessor.h"
 #include "BattleGround.h"
+#include "BattleGroundMgr.h"
 #include "MapManager.h"
 #include "InstanceSaveMgr.h"
 #include "MapInstanced.h"
 #include "Util.h"
+#include "PlayerbotMgr.h"
 #include "LootMgr.h"
 
 #define LOOT_ROLL_TIMEOUT  (1*MINUTE*IN_MILLISECONDS)
@@ -308,8 +310,16 @@ bool Group::AddMember(const uint64 &guid, const char* name)
 
 uint32 Group::RemoveMember(const uint64 &guid, const uint8 &method)
 {
+    //Playerbot mod - if master leaves group, all bots leave group
+    {
+        Player* const player = sObjectMgr.GetPlayer(guid);
+        if (player && player->GetPlayerbotMgr())
+            player->GetPlayerbotMgr()->RemoveAllBotsFromGroup();
+    }
+    //END Playerbot mod
+
     // remove member and change leader (if need) only if strong more 2 members _before_ member remove
-    if(GetMembersCount() > uint32(isBGGroup() ? 1 : 2))           // in BG group case allow 1 members group
+    if(GetMembersCount() > uint32(isBGGroup() ? 1 : 2))         // in BG group case allow 1 members group
     {
         bool leaderChanged = _removeMember(guid);
 
@@ -1403,7 +1413,7 @@ void Group::ChangeMembersGroup(Player *player, uint8 group)
     }
 }
 
-void Group::UpdateLooterGuid( Creature* creature, bool ifneed )
+void Group::UpdateLooterGuid( WorldObject* object, bool ifneed )
 {
     switch (GetLootMethod())
     {
@@ -1423,7 +1433,7 @@ void Group::UpdateLooterGuid( Creature* creature, bool ifneed )
         {
             // not update if only update if need and ok
             Player* looter = ObjectAccessor::FindPlayer(guid_itr->guid);
-            if(looter && looter->IsWithinDist(creature, sWorld.getConfig(CONFIG_FLOAT_GROUP_XP_DISTANCE), false))
+            if(looter && looter->IsWithinDist(object, sWorld.getConfig(CONFIG_FLOAT_GROUP_XP_DISTANCE), false))
                 return;
         }
         ++guid_itr;
@@ -1436,16 +1446,16 @@ void Group::UpdateLooterGuid( Creature* creature, bool ifneed )
         {
             if(Player* pl = ObjectAccessor::FindPlayer(itr->guid))
             {
-                if (pl->IsWithinDist(creature, sWorld.getConfig(CONFIG_FLOAT_GROUP_XP_DISTANCE), false))
+                if (pl->IsWithinDist(object, sWorld.getConfig(CONFIG_FLOAT_GROUP_XP_DISTANCE), false))
                 {
-                    bool refresh = pl->GetLootGUID() == creature->GetGUID();
+                    bool refresh = pl->GetLootGUID() == object->GetGUID();
 
                     //if(refresh)                             // update loot for new looter
                     //    pl->GetSession()->DoLootRelease(pl->GetLootGUID());
                     SetLooterGuid(pl->GetGUID());
                     SendUpdate();
                     if(refresh)                             // update loot for new looter
-                        pl->SendLoot(creature->GetGUID(), LOOT_CORPSE);
+                        pl->SendLoot(object->GetGUID(), LOOT_CORPSE);
                     return;
                 }
             }
@@ -1457,16 +1467,16 @@ void Group::UpdateLooterGuid( Creature* creature, bool ifneed )
     {
         if(Player* pl = ObjectAccessor::FindPlayer(itr->guid))
         {
-            if (pl->IsWithinDist(creature, sWorld.getConfig(CONFIG_FLOAT_GROUP_XP_DISTANCE), false))
+            if (pl->IsWithinDist(object, sWorld.getConfig(CONFIG_FLOAT_GROUP_XP_DISTANCE), false))
             {
-                bool refresh = pl->GetLootGUID()==creature->GetGUID();
+                bool refresh = pl->GetLootGUID()==object->GetGUID();
 
                 //if(refresh)                               // update loot for new looter
                 //    pl->GetSession()->DoLootRelease(pl->GetLootGUID());
                 SetLooterGuid(pl->GetGUID());
                 SendUpdate();
                 if(refresh)                                 // update loot for new looter
-                    pl->SendLoot(creature->GetGUID(), LOOT_CORPSE);
+                    pl->SendLoot(object->GetGUID(), LOOT_CORPSE);
                 return;
             }
         }
@@ -1505,6 +1515,10 @@ GroupJoinBattlegroundResult Group::CanJoinBattleGroundQueue(BattleGround const*
     uint32 arenaTeamId = reference->GetArenaTeamId(arenaSlot);
     uint32 team = reference->GetTeam();
 
+    uint32 allowedPlayerCount = 0;
+
+    BattleGroundQueueTypeId bgQueueTypeIdRandom = BattleGroundMgr::BGQueueTypeId(BATTLEGROUND_RB, 0);
+
     // check every member of the group to be able to join
     for(GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
     {
@@ -1525,13 +1539,25 @@ GroupJoinBattlegroundResult Group::CanJoinBattleGroundQueue(BattleGround const*
         // don't let join if someone from the group is already in that bg queue
         if(member->InBattleGroundQueueForBattleGroundQueueType(bgQueueTypeId))
             return ERR_BATTLEGROUND_JOIN_FAILED;            // not blizz-like
+        // don't let join if someone from the group is in bg queue random
+        if(member->InBattleGroundQueueForBattleGroundQueueType(bgQueueTypeIdRandom))
+            return ERR_IN_RANDOM_BG;
+        // don't let join to bg queue random if someone from the group is already in bg queue
+        if(bgOrTemplate->GetTypeID() == BATTLEGROUND_RB && member->InBattleGroundQueue())
+            return ERR_IN_NON_RANDOM_BG;
         // check for deserter debuff in case not arena queue
         if(bgOrTemplate->GetTypeID() != BATTLEGROUND_AA && !member->CanJoinToBattleground())
             return ERR_GROUP_JOIN_BATTLEGROUND_DESERTERS;
         // check if member can join any more battleground queues
         if(!member->HasFreeBattleGroundQueueId())
             return ERR_BATTLEGROUND_TOO_MANY_QUEUES;        // not blizz-like
+        ++allowedPlayerCount;
     }
+
+    if(bgOrTemplate->GetTypeID() == BATTLEGROUND_AA)
+        if(allowedPlayerCount < MinPlayerCount || allowedPlayerCount > MaxPlayerCount)
+            return ERR_ARENA_TEAM_PARTY_SIZE;
+
     return GroupJoinBattlegroundResult(bgOrTemplate->GetTypeID());
 }
 
@@ -1577,13 +1603,22 @@ void Group::SetRaidDifficulty(Difficulty difficulty)
     }
 }
 
-bool Group::InCombatToInstance(uint32 instanceId)
+bool Group::InCombatToInstance(uint32 instanceId, bool bossOnly)
 {
     for(GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
     {
         Player *pPlayer = itr->getSource();
-        if(pPlayer->getAttackers().size() && pPlayer->GetInstanceId() == instanceId)
-            return true;
+        if(!pPlayer->getAttackers().empty() && pPlayer->GetInstanceId() == instanceId)
+        {
+            if(!bossOnly)
+                return true;
+
+            for(std::set<Unit*>::const_iterator itr = pPlayer->getAttackers().begin(); itr != pPlayer->getAttackers().end(); itr++)
+            {
+                if((*itr)->GetTypeId() != TYPEID_PLAYER && ((Creature*)(*itr))->isWorldBoss())
+                    return true;
+            }
+        }
     }
     return false;
 }
@@ -1780,12 +1815,12 @@ static void RewardGroupAtKill_helper(Player* pGroupGuy, Unit* pVictim, uint32 co
 }
 
 /** Provide rewards to group members at unit kill
- *
- * @param pVictim       Killed unit
- * @param player_tap    Player who tap unit if online, it can be group member or can be not if leaved after tap but before kill target
- *
- * Rewards received by group members and player_tap
- */
+*
+* @param pVictim Killed unit
+* @param player_tap Player who tap unit if online, it can be group member or can be not if leaved after tap but before kill target
+*
+* Rewards received by group members and player_tap
+*/
 void Group::RewardGroupAtKill(Unit* pVictim, Player* player_tap)
 {
     bool PvP = pVictim->isCharmedOwnedByPlayerOrPlayer();
@@ -1821,7 +1856,7 @@ void Group::RewardGroupAtKill(Unit* pVictim, Player* player_tap)
                 continue;
 
             if(!pGroupGuy->IsAtGroupRewardDistance(pVictim))
-                continue;                               // member (alive or dead) or his corpse at req. distance
+                continue; // member (alive or dead) or his corpse at req. distance
 
             RewardGroupAtKill_helper(pGroupGuy, pVictim, count, PvP, group_rate, sum_level, is_dungeon, not_gray_member_with_max_level, member_with_max_level, xp);
         }
diff --git a/mangos/src/game/Group.h b/Core/src/game/Group.h
index c9cffe3..77e4aba 100644
--- a/mangos/src/game/Group.h
+++ b/Core/src/game/Group.h
@@ -115,7 +115,8 @@ enum GroupUpdateFlags
     GROUP_UPDATE_FLAG_PET_AURAS         = 0x00040000,       // uint64 mask, for each bit set uint32 spellid + uint8 unk, pet auras...
     GROUP_UPDATE_FLAG_VEHICLE_SEAT      = 0x00080000,       // uint32 vehicle_seat_id (index from VehicleSeat.dbc)
     GROUP_UPDATE_PET                    = 0x0007FC00,       // all pet flags
-    GROUP_UPDATE_FULL                   = 0x0007FFFF,       // all known flags
+    GROUP_UPDATE_VEHICLE                = 0x000FFC00,       // all vehicle flags
+    GROUP_UPDATE_FULL                   = 0x000FFFFF,       // all known flags
 };
 
 #define GROUP_UPDATE_FLAGS_COUNT          20
@@ -198,7 +199,7 @@ class MANGOS_DLL_SPEC Group
         void   ChangeLeader(const uint64 &guid);
         void   SetLootMethod(LootMethod method) { m_lootMethod = method; }
         void   SetLooterGuid(const uint64 &guid) { m_looterGuid = guid; }
-        void   UpdateLooterGuid( Creature* creature, bool ifneed = false );
+        void   UpdateLooterGuid( WorldObject* object, bool ifneed = false );
         void   SetLootThreshold(ItemQualities threshold) { m_lootThreshold = threshold; }
         void   Disband(bool hideDestroy=false);
 
@@ -321,7 +322,7 @@ class MANGOS_DLL_SPEC Group
         void SetDungeonDifficulty(Difficulty difficulty);
         void SetRaidDifficulty(Difficulty difficulty);
         uint16 InInstance();
-        bool InCombatToInstance(uint32 instanceId);
+        bool InCombatToInstance(uint32 instanceId, bool bossOnly = false);
         void ResetInstances(uint8 method, bool isRaid, Player* SendMsgTo);
 
         void SendTargetIconList(WorldSession *session);
diff --git a/mangos/src/game/GroupHandler.cpp b/Core/src/game/GroupHandler.cpp
index d73b233..1d2e126 100644
--- a/mangos/src/game/GroupHandler.cpp
+++ b/Core/src/game/GroupHandler.cpp
@@ -28,6 +28,7 @@
 #include "Group.h"
 #include "SocialMgr.h"
 #include "Util.h"
+#include "Vehicle.h"
 
 /* differeces from off:
     -you can uninvite yourself - is is useful
@@ -166,7 +167,7 @@ void WorldSession::HandleGroupInviteOpcode( WorldPacket & recv_data )
 
 void WorldSession::HandleGroupAcceptOpcode( WorldPacket & recv_data )
 {
-    recv_data.read_skip<uint32>();                          // roles mask?
+    //recv_data.read_skip<uint32>();                          // roles mask?
 
     Group *group = GetPlayer()->GetGroupInvite();
     if (!group)
@@ -711,7 +712,7 @@ void WorldSession::BuildPartyMemberStatsChangedPacket(Player *player, WorldPacke
         }
     }
 
-    Pet *pet = player->GetPet();
+    Unit *pet = player->GetCharmOrPet();
     if (mask & GROUP_UPDATE_FLAG_PET_GUID)
     {
         if(pet)
@@ -794,6 +795,11 @@ void WorldSession::BuildPartyMemberStatsChangedPacket(Player *player, WorldPacke
         else
             *data << uint64(0);
     }
+
+    if (mask & GROUP_UPDATE_FLAG_VEHICLE_SEAT)
+    {
+        *data << (uint32) player->m_movementInfo.GetTransportDBCSeat();
+    }
 }
 
 /*this procedure handles clients CMSG_REQUEST_PARTY_MEMBER_STATS request*/
@@ -815,7 +821,7 @@ void WorldSession::HandleRequestPartyMemberStatsOpcode( WorldPacket &recv_data )
         return;
     }
 
-    Pet *pet = player->GetPet();
+    Unit *pet = player->GetCharmOrPet();
 
     WorldPacket data(SMSG_PARTY_MEMBER_STATS_FULL, 4+2+2+2+1+2*6+8+1+8);
     data << uint8(0);                                       // only for SMSG_PARTY_MEMBER_STATS_FULL, probably arena/bg related
@@ -823,7 +829,7 @@ void WorldSession::HandleRequestPartyMemberStatsOpcode( WorldPacket &recv_data )
 
     uint32 mask1 = 0x00040BFF;                              // common mask, real flags used 0x000040BFF
     if(pet)
-        mask1 = 0x7FFFFFFF;                                 // for hunters and other classes with pets
+        mask1 = 0xFFFFFFFF;                                 // for hunters and other classes with pets
 
     Powers powerType = player->getPowerType();
     data << uint32(mask1);                                  // group update mask
@@ -877,6 +883,7 @@ void WorldSession::HandleRequestPartyMemberStatsOpcode( WorldPacket &recv_data )
             }
         }
         data.put<uint64>(petMaskPos, petauramask);          // GROUP_UPDATE_FLAG_PET_AURAS
+        data << (uint32) player->m_movementInfo.GetTransportDBCSeat();
     }
     else
     {
diff --git a/mangos/src/game/GuardAI.cpp b/Core/src/game/GuardAI.cpp
index ba08c7d..153d2e1 100644
--- a/mangos/src/game/GuardAI.cpp
+++ b/Core/src/game/GuardAI.cpp
@@ -50,7 +50,6 @@ void GuardAI::MoveInLineOfSight(Unit *u)
         {
             //Need add code to let guard support player
             AttackStart(u);
-            u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
         }
     }
 }
diff --git a/mangos/src/game/Guild.cpp b/Core/src/game/Guild.cpp
index 814ab02..b2a12eb 100644
--- a/mangos/src/game/Guild.cpp
+++ b/Core/src/game/Guild.cpp
@@ -155,7 +155,7 @@ bool Guild::AddMember(uint64 plGuid, uint32 plRank)
         if (newmember.Level < 1 || newmember.Level > STRONG_MAX_LEVEL ||
             newmember.Class < CLASS_WARRIOR || newmember.Class >= MAX_CLASSES)
         {
-            sLog.outError("Player (GUID: %u) has a broken data in field `characters` table, cannot add him to guild.",GUID_LOPART(plGuid));
+            DEBUG_LOG("Player (GUID: %u) has a broken data in field `characters` table, cannot add him to guild.",GUID_LOPART(plGuid));
             return false;
         }
     }
@@ -263,7 +263,7 @@ bool Guild::LoadRanksFromDB(QueryResult *guildRanksResult)
 {
     if (!guildRanksResult)
     {
-        sLog.outError("Guild %u has broken `guild_rank` data, creating new...",m_Id);
+        DEBUG_LOG("Guild %u has broken `guild_rank` data, creating new...",m_Id);
         CreateDefaultGuildRanks(0);
         return true;
     }
@@ -313,14 +313,14 @@ bool Guild::LoadRanksFromDB(QueryResult *guildRanksResult)
     if (m_Ranks.size() < GUILD_RANKS_MIN_COUNT)             // if too few ranks, renew them
     {
         m_Ranks.clear();
-        sLog.outError("Guild %u has broken `guild_rank` data, creating new...", m_Id);
+        DEBUG_LOG("Guild %u has broken `guild_rank` data, creating new...", m_Id);
         CreateDefaultGuildRanks(0);                         // 0 is default locale_idx
         broken_ranks = false;
     }
     // guild_rank have wrong numbered ranks, repair
     if (broken_ranks)
     {
-        sLog.outError("Guild %u has broken `guild_rank` data, repairing...", m_Id);
+        DEBUG_LOG("Guild %u has broken `guild_rank` data, repairing...", m_Id);
         CharacterDatabase.BeginTransaction();
         CharacterDatabase.PExecute("DELETE FROM guild_rank WHERE guildid='%u'", m_Id);
         for(size_t i = 0; i < m_Ranks.size(); ++i)
@@ -386,20 +386,20 @@ bool Guild::LoadMembersFromDB(QueryResult *guildMembersResult)
         // this code will remove not existing character guids from guild
         if (newmember.Level < 1 || newmember.Level > STRONG_MAX_LEVEL) // can be at broken `data` field
         {
-            sLog.outError("Player (GUID: %u) has a broken data in field `characters`.`data`, deleting him from guild!",GUID_LOPART(guid));
+            DEBUG_LOG("Player (GUID: %u) has a broken data in field `characters`.`data`, deleting him from guild!",GUID_LOPART(guid));
             CharacterDatabase.PExecute("DELETE FROM guild_member WHERE guid = '%u'", GUID_LOPART(guid));
             continue;
         }
         if (!newmember.ZoneId)
         {
-            sLog.outError("Player (GUID: %u) has broken zone-data", GUID_LOPART(guid));
+            DEBUG_LOG("Player (GUID: %u) has broken zone-data", GUID_LOPART(guid));
             // here it will also try the same, to get the zone from characters-table, but additional it tries to find
             // the zone through xy coords .. this is a bit redundant, but shouldn't be called often
             newmember.ZoneId = Player::GetZoneIdFromDB(guid);
         }
         if (newmember.Class < CLASS_WARRIOR || newmember.Class >= MAX_CLASSES) // can be at broken `class` field
         {
-            sLog.outError("Player (GUID: %u) has a broken data in field `characters`.`class`, deleting him from guild!",GUID_LOPART(guid));
+            DEBUG_LOG("Player (GUID: %u) has a broken data in field `characters`.`class`, deleting him from guild!",GUID_LOPART(guid));
             CharacterDatabase.PExecute("DELETE FROM guild_member WHERE guid = '%u'", GUID_LOPART(guid));
             continue;
         }
@@ -1135,13 +1135,13 @@ void Guild::LoadGuildBankFromDB()
 
         if (TabId >= m_PurchasedTabs || TabId >= GUILD_BANK_MAX_TABS)
         {
-            sLog.outError( "Guild::LoadGuildBankFromDB: Invalid tab for item (GUID: %u id: #%u) in guild bank, skipped.", ItemGuid,ItemEntry);
+            DEBUG_LOG( "Guild::LoadGuildBankFromDB: Invalid tab for item (GUID: %u id: #%u) in guild bank, skipped.", ItemGuid,ItemEntry);
             continue;
         }
 
         if (SlotId >= GUILD_BANK_MAX_SLOTS)
         {
-            sLog.outError( "Guild::LoadGuildBankFromDB: Invalid slot for item (GUID: %u id: #%u) in guild bank, skipped.", ItemGuid,ItemEntry);
+            DEBUG_LOG( "Guild::LoadGuildBankFromDB: Invalid slot for item (GUID: %u id: #%u) in guild bank, skipped.", ItemGuid,ItemEntry);
             continue;
         }
 
@@ -1149,7 +1149,7 @@ void Guild::LoadGuildBankFromDB()
 
         if (!proto)
         {
-            sLog.outError( "Guild::LoadGuildBankFromDB: Unknown item (GUID: %u id: #%u) in guild bank, skipped.", ItemGuid,ItemEntry);
+            DEBUG_LOG( "Guild::LoadGuildBankFromDB: Unknown item (GUID: %u id: #%u) in guild bank, skipped.", ItemGuid,ItemEntry);
             continue;
         }
 
diff --git a/mangos/src/game/InstanceSaveMgr.cpp b/Core/src/game/InstanceSaveMgr.cpp
index 81ebb01..e4003d5 100644
--- a/mangos/src/game/InstanceSaveMgr.cpp
+++ b/Core/src/game/InstanceSaveMgr.cpp
@@ -505,6 +505,8 @@ void InstanceSaveManager::LoadResetTimes()
             if(t - tim[type-1] > now)
                 break;
 
+        ScheduleReset(true, t - tim[type-1], InstResetEvent(type, mapid, difficulty, -1));
+
         for(ResetTimeMapDiffInstances::const_iterator in_itr = mapDiffResetInstances.lower_bound(map_diff_pair);
             in_itr != mapDiffResetInstances.upper_bound(map_diff_pair); ++in_itr)
         {
@@ -610,6 +612,7 @@ void InstanceSaveManager::_ResetOrWarnAll(uint32 mapid, Difficulty difficulty, b
         return;
 
     time_t now = time(NULL);
+    time_t today = (now / DAY) * DAY;
 
     if (!warn)
     {
@@ -638,10 +641,14 @@ void InstanceSaveManager::_ResetOrWarnAll(uint32 mapid, Difficulty difficulty, b
 
         // calculate the next reset time
         uint32 diff = sWorld.getConfig(CONFIG_UINT32_INSTANCE_RESET_TIME_HOUR) * HOUR;
-        uint32 period = mapDiff->resetTime * DAY;
-        time_t next_reset = ((now + timeLeft + MINUTE) / DAY * DAY) + period + diff;
+        uint32 period = (mapDiff->resetTime / DAY * sWorld.getConfig(CONFIG_FLOAT_RATE_INSTANCE_RESET_TIME)) * DAY;
+        time_t next_reset = today + period + diff;
+
         // update it in the DB
         CharacterDatabase.PExecute("UPDATE instance_reset SET resettime = '"UI64FMTD"' WHERE mapid = '%d' AND difficulty = '%d'", (uint64)next_reset, mapid, difficulty);
+
+        SetResetTimeFor(mapid,difficulty,(uint64)next_reset);
+        ScheduleReset(true, next_reset-3600, InstResetEvent(1, mapid, difficulty, -1));
     }
 
     // note: this isn't fast but it's meant to be executed very rarely
diff --git a/mangos/src/game/Item.cpp b/Core/src/game/Item.cpp
index b8d71b7..6834723 100644
--- a/mangos/src/game/Item.cpp
+++ b/Core/src/game/Item.cpp
@@ -244,6 +244,8 @@ Item::Item( )
     m_container = NULL;
     m_lootGenerated = false;
     mb_in_trade = false;
+    m_ExtendedCostId = 0;
+    m_price = 0;
 }
 
 bool Item::Create( uint32 guidlow, uint32 itemid, Player const* owner)
@@ -288,6 +290,11 @@ void Item::UpdateDuration(Player* owner, uint32 diff)
 
     SetUInt32Value(ITEM_FIELD_DURATION, GetUInt32Value(ITEM_FIELD_DURATION) - diff);
     SetState(ITEM_CHANGED, owner);                          // save new time in database
+
+    //Remove refundable flag for next time if item is no logner refundable
+    if(HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_REFUNDABLE))
+        if(!GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME) || (GetOwner() && GetOwner()->m_Played_time[0] > (GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME) + 2*60*60)))
+            RemoveFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_REFUNDABLE);
 }
 
 void Item::SaveToDB()
@@ -301,10 +308,10 @@ void Item::SaveToDB()
             CharacterDatabase.escape_string(text);
             CharacterDatabase.PExecute( "DELETE FROM item_instance WHERE guid = '%u'", guid );
             std::ostringstream ss;
-            ss << "INSERT INTO item_instance (guid,owner_guid,data,text) VALUES (" << guid << "," << GUID_LOPART(GetOwnerGUID()) << ",'";
+            ss << "INSERT INTO item_instance (guid,owner_guid,data,text, ExtendedCost, price) VALUES (" << guid << "," << GUID_LOPART(GetOwnerGUID()) << ",'";
             for(uint16 i = 0; i < m_valuesCount; ++i )
                 ss << GetUInt32Value(i) << " ";
-            ss << "', '" << text << "')";
+            ss << "', '" << text << "', '" << m_ExtendedCostId << "', '" << m_price << "')";
             CharacterDatabase.Execute( ss.str().c_str() );
         } break;
         case ITEM_CHANGED:
@@ -316,7 +323,7 @@ void Item::SaveToDB()
             for(uint16 i = 0; i < m_valuesCount; ++i )
                 ss << GetUInt32Value(i) << " ";
             ss << "', owner_guid = '" << GUID_LOPART(GetOwnerGUID());
-            ss << "', text = '" << text << "' WHERE guid = '" << guid << "'";
+            ss << "', text = '" << text << "', ExtendedCost = '" << m_ExtendedCostId << "', price = '" << m_price << "' WHERE guid = '" << guid << "'";
 
             CharacterDatabase.Execute( ss.str().c_str() );
 
@@ -430,6 +437,17 @@ bool Item::LoadFromDB(uint32 guid, uint64 owner_guid, QueryResult *result)
         CharacterDatabase.Execute( ss.str().c_str() );
     }
 
+    //Set extended cost for refundable item
+    if(HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_REFUNDABLE))
+    {
+        QueryResult *result_ext = CharacterDatabase.PQuery("SELECT ExtendedCost, price FROM item_instance WHERE guid = '%u'", guid);
+        if(result_ext)
+        {
+            m_ExtendedCostId = result_ext->Fetch()[0].GetUInt32();
+            m_price = result_ext->Fetch()[1].GetUInt32();
+            delete result_ext;
+        }
+    }
     return true;
 }
 
@@ -715,6 +733,9 @@ bool Item::CanBeTraded(bool mail) const
     if (m_lootGenerated)
         return false;
 
+    if(!mail && IsBoundAccountWide()) // Dirty hack, because trade window is closing
+        return false;
+
     if ((!mail || !IsBoundAccountWide()) && IsSoulBound())
         return false;
 
@@ -758,6 +779,21 @@ bool Item::IsFitToSpellRequirements(SpellEntry const* spellInfo) const
 {
     ItemPrototype const* proto = GetProto();
 
+    // Enchant spells only use Effect[0] (patch 3.3.2)
+    if(proto->IsVellum() && spellInfo->Effect[EFFECT_INDEX_0] == SPELL_EFFECT_ENCHANT_ITEM)
+    {
+        // EffectItemType[0] is the associated scroll itemID, if a scroll can be made
+        if(spellInfo->EffectItemType[EFFECT_INDEX_0] == 0)
+            return false;
+        // Other checks do not apply to vellum enchants, so return final result
+        return ((proto->SubClass == ITEM_SUBCLASS_WEAPON_ENCHANTMENT && spellInfo->EquippedItemClass == ITEM_CLASS_WEAPON) ||
+                (proto->SubClass == ITEM_SUBCLASS_ARMOR_ENCHANTMENT && spellInfo->EquippedItemClass == ITEM_CLASS_ARMOR));
+    }
+
+    //Lava Lash
+    if (spellInfo->Id==60103 && spellInfo->EquippedItemClass==ITEM_CLASS_WEAPON)
+         return true;
+
     if (spellInfo->EquippedItemClass != -1)                 // -1 == any item class
     {
         if(spellInfo->EquippedItemClass != int32(proto->Class))
@@ -871,6 +907,7 @@ bool Item::GemsFitSockets() const
             }
         }
 
+        SocketColor = SocketColor ? SocketColor : PRISMATIC_SOCKET;
         fits &= (GemColor & SocketColor) ? true : false;
     }
     return fits;
diff --git a/mangos/src/game/Item.h b/Core/src/game/Item.h
index b5e47ec..025cc75 100644
--- a/mangos/src/game/Item.h
+++ b/Core/src/game/Item.h
@@ -174,7 +174,7 @@ enum EnchantmentSlot
 };
 
 #define MAX_VISIBLE_ITEM_OFFSET       2                     // 2 fields per visible item (entry+enchantment)
-
+#define PRISMATIC_SOCKET              14                    // 1110 mask = blue(1) yellow(1) red(1) meta(0)
 #define MAX_GEM_SOCKETS               MAX_ITEM_PROTO_SOCKETS// (BONUS_ENCHANTMENT_SLOT-SOCK_ENCHANTMENT_SLOT) and item proto size, equal value expected
 
 enum EnchantmentOffset
@@ -328,6 +328,12 @@ class MANGOS_DLL_SPEC Item : public Object
         void AddToClientUpdateList();
         void RemoveFromClientUpdateList();
         void BuildUpdateData(UpdateDataMapType& update_players);
+
+        // Item refund data only
+        void SetExtCostId(uint32 id) { m_ExtendedCostId = id; };
+        uint32 GetExtCostId() { return m_ExtendedCostId; };
+        void SetPrice(uint32 price) { m_price = price; };
+        uint32 GetPrice() { return m_price; };
     private:
         std::string m_text;
         uint8 m_slot;
@@ -335,5 +341,7 @@ class MANGOS_DLL_SPEC Item : public Object
         ItemUpdateState uState;
         int16 uQueuePos;
         bool mb_in_trade;                                   // true if item is currently in trade-window
+        uint32 m_price;
+        uint32 m_ExtendedCostId;
 };
 #endif
diff --git a/mangos/src/game/ItemHandler.cpp b/Core/src/game/ItemHandler.cpp
index 41796a7..4220a30 100644
--- a/mangos/src/game/ItemHandler.cpp
+++ b/Core/src/game/ItemHandler.cpp
@@ -1343,6 +1343,10 @@ void WorldSession::HandleSocketOpcode(WorldPacket& recv_data)
         //it is not displayed, client has an inbuilt system to determine if the bonus is activated
     }
 
+    //Gems should remove refundable flag
+    if(itemTarget->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_REFUNDABLE))
+        itemTarget->RemoveFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_REFUNDABLE);
+
     _player->ToggleMetaGemsActive(slot, true);              // turn on all metagems (except for target item)
 }
 
@@ -1370,14 +1374,44 @@ void WorldSession::HandleCancelTempEnchantmentOpcode(WorldPacket& recv_data)
     item->ClearEnchantment(TEMP_ENCHANTMENT_SLOT);
 }
 
+/**
+ * Handles the packet sent by the client when requesting information about item text.
+ *
+ * This function is called when player clicks on item which has some flag set
+ */
+
+void WorldSession::HandleItemTextQuery(WorldPacket & recv_data )
+{
+    uint64 itemGuid;
+    recv_data >> itemGuid;
+
+	DEBUG_LOG("CMSG_ITEM_TEXT_QUERY item guid: %u", GUID_LOPART(itemGuid));
+
+    WorldPacket data(SMSG_ITEM_TEXT_QUERY_RESPONSE, (4+10));    // guess size
+
+    if(Item *item = _player->GetItemByGuid(itemGuid))
+    {
+        data << uint8(0);                                       // has text
+        data << uint64(itemGuid);                               // item guid
+        data << item->GetText();
+    }
+    else
+    {
+        data << uint8(1);                                       // no text
+    }
+    SendPacket(&data);
+}
+
+// Item refund system
 void WorldSession::HandleItemRefundInfoRequest(WorldPacket& recv_data)
 {
     DEBUG_LOG("WORLD: CMSG_ITEM_REFUND_INFO_REQUEST");
+    recv_data.hexlike();
 
-    uint64 guid;
+    ObjectGuid guid;
     recv_data >> guid;                                      // item guid
 
-    Item *item = _player->GetItemByGuid(guid);
+    Item *item = _player->GetItemByGuid(guid.GetRawValue());
 
     if(!item)
     {
@@ -1385,38 +1419,127 @@ void WorldSession::HandleItemRefundInfoRequest(WorldPacket& recv_data)
         return;
     }
 
-    if(!item->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_REFUNDABLE))
+    if(!item->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_REFUNDABLE) || item->GetExtCostId() == 0)
     {
         DEBUG_LOG("Item refund: item not refundable!");
         return;
     }
+    uint32 honor_points = 0;
+    uint32 arena_points = 0;
+    uint32 ExtendedCostId[5] = {0,0,0,0,0};
+    uint32 ExtendedCostCount[5]= {0,0,0,0,0};
+    uint32 playedTime = _player->m_Played_time[0] > (item->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME) + 2*60*60) ? 0 : item->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME);
+
+    ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(item->GetExtCostId());
+    if (!iece)
+        return;
+        
+    honor_points = iece->reqhonorpoints;
+    arena_points = iece->reqarenapoints;
+    for (uint8 i = 0; i < 5; ++i)
+    {          
+        ExtendedCostId[i] = iece->reqitem[i];
+        ExtendedCostCount[i] = iece->reqitemcount[i];
+    }
 
-    // item refund system not implemented yet
+    WorldPacket data(SMSG_ITEM_REFUND_INFO_RESPONSE, 68); // guess size
+    data << guid;                                         // item guid
+    data << uint32(item->GetPrice());           // price
+    data << uint32(honor_points);                         // honor point cost
+    data << uint32(arena_points);                         // arena point cost
+    for(uint32 i = 0; i < 5; ++i)                         // extended cost data
+    {
+        data << uint32(ExtendedCostId[i]);
+        data << uint32(ExtendedCostCount[i]);
+    }
+    data << uint32(0);
+    data << uint32(playedTime);                           // buy time in played time
+    SendPacket(&data);
 }
 
-/**
- * Handles the packet sent by the client when requesting information about item text.
- *
- * This function is called when player clicks on item which has some flag set
- */
-void WorldSession::HandleItemTextQuery(WorldPacket & recv_data )
+void WorldSession::HandleItemRefund(WorldPacket& recv_data)
 {
-    uint64 itemGuid;
-    recv_data >> itemGuid;
+    sLog.outDebug("WORLD: CMSG_ITEM_REFUND");
+    recv_data.hexlike();
 
-    DEBUG_LOG("CMSG_ITEM_TEXT_QUERY item guid: %u", GUID_LOPART(itemGuid));
+    ObjectGuid guid;
+    recv_data >> guid;                                   // item guid
+    Item *item = _player->GetItemByGuid(guid.GetRawValue());
 
-    WorldPacket data(SMSG_ITEM_TEXT_QUERY_RESPONSE, (4+10));    // guess size
+    if(!item)
+    {
+        sLog.outDebug("Item refund: item not found!");
+        return;
+    }
 
-    if(Item *item = _player->GetItemByGuid(itemGuid))
+    if(!item->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_REFUNDABLE) || !item->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME)
+        || _player->m_Played_time[0] > (item->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME) + 2*60*60))  // can be refunded only two hours after buy
     {
-        data << uint8(0);                                       // has text
-        data << uint64(itemGuid);                               // item guid
-        data << item->GetText();
+        sLog.outDebug("Item refund: item not refundable!");
+        return;
     }
-    else
+    uint32 honor_points = 0;
+    uint32 arena_points = 0;
+    uint32 ExtendedCostId[5] = {0,0,0,0,0};
+    uint32 ExtendedCostCount[5]= {0,0,0,0,0};
+    uint32 playedTime = _player->m_Played_time[0] > (item->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME) + 2*60*60) ? 0 : item->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME);
+
+    ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(item->GetExtCostId());
+    if (!iece)
+        return;
+        
+    honor_points = iece->reqhonorpoints;
+    arena_points = iece->reqarenapoints;
+    for (uint8 i = 0; i < 5; ++i)
+    {          
+        ExtendedCostId[i] = iece->reqitem[i];
+        ExtendedCostCount[i] = iece->reqitemcount[i];
+        //need to check for free slot
+        ItemPosCountVec dest;
+        uint8 msg = _player->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, iece->reqitem[i], iece->reqitemcount[i]);
+        if (msg != EQUIP_ERR_OK && iece->reqitem[i] != 0 && msg != EQUIP_ERR_ITEM_NOT_FOUND)
+        {
+            //Cant make refund
+            _player->SendEquipError(msg, NULL, NULL, iece->reqitem[i]);
+            WorldPacket packet( SMSG_ITEM_REFUND_RESULT,  12);
+            packet << guid;
+            packet << uint32(1);
+            SendPacket(&packet);
+            return;
+        }
+    }
+    
+    //Refund money, honor and arena points and items
+    _player->ModifyMoney(item->GetPrice());
+    _player->ModifyHonorPoints(honor_points);
+    _player->ModifyArenaPoints(arena_points);
+    for (uint8 i = 0; i < 5; ++i)
     {
-        data << uint8(1);                                       // no text
+        if(ExtendedCostId[i] == 0)
+            continue;
+
+        ItemPosCountVec dest;
+        if(_player->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, ExtendedCostId[i], ExtendedCostCount[i] ) == EQUIP_ERR_OK)
+        {
+            Item *refundItem = _player->StoreNewItem(dest, ExtendedCostId[i], true, Item::GenerateItemRandomPropertyId(ExtendedCostId[i]));
+            _player->SendNewItem(refundItem, ExtendedCostCount[i], true, false);
+        }else sLog.outError("Cant store refunded item! Player guid: %u, refund item entry: %u, want to refund item : %u", _player->GetGUID(), ExtendedCostId[i], item->GetEntry());
     }
-    SendPacket(&data);
-}
+
+    //send refund packet
+    WorldPacket data(SMSG_ITEM_REFUND_RESULT, 60);        // guess size
+    data << guid;                                         // item guid
+    data << uint32(0);                                    // Error msg
+	data << uint32(item->GetPrice());                      // price
+    data << uint32(honor_points);                         // honor point cost
+    data << uint32(arena_points);                         // arena point cost
+    for(uint32 i = 0; i < 5; ++i)                         // extended cost data
+    {
+        data << uint32(ExtendedCostId[i]);
+        data << uint32(ExtendedCostCount[i]);
+    }
+    SendPacket(&data);	
+
+    //Remove item
+    _player->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+}
\ No newline at end of file
diff --git a/mangos/src/game/ItemPrototype.h b/Core/src/game/ItemPrototype.h
index 053c68e..108553e 100644
--- a/mangos/src/game/ItemPrototype.h
+++ b/Core/src/game/ItemPrototype.h
@@ -646,6 +646,10 @@ struct ItemPrototype
 
     bool IsPotion() const { return Class==ITEM_CLASS_CONSUMABLE && SubClass==ITEM_SUBCLASS_POTION; }
     bool IsConjuredConsumable() const { return Class == ITEM_CLASS_CONSUMABLE && (Flags & ITEM_FLAGS_CONJURED); }
+    bool IsVellum() const
+    {
+        return (Class == ITEM_CLASS_TRADE_GOODS && (1 << SubClass) & (1 << ITEM_SUBCLASS_ARMOR_ENCHANTMENT | 1 << ITEM_SUBCLASS_WEAPON_ENCHANTMENT));
+    }
 };
 
 struct ItemLocale
diff --git a/mangos/src/game/Language.h b/Core/src/game/Language.h
index 38ec346..38c1352 100644
--- a/mangos/src/game/Language.h
+++ b/Core/src/game/Language.h
@@ -21,6 +21,42 @@
 
 enum MangosStrings
 {
+        // Added by WarHead for the Jail
+    LANG_JAIL_YOURE_JAILED              = 950,  // "You are jailed by %s for %u hour(s)!"
+    LANG_JAIL_REASON                    = 951,  // "%s wrote this as reason: %s"
+    LANG_JAIL_WAS_JAILED                = 952,  // "%s was jailed by you for %u hour(s)!"
+    LANG_JAIL_YOURE_UNJAILED            = 953,  // "You was released out of the jail by %s."
+    LANG_JAIL_WAS_UNJAILED              = 954,  // "You have released %s out of the jail."
+    LANG_JAIL_NOREASON                  = 955,  // "No reason given or reason is < %u chars!"
+    LANG_JAIL_NONAME                    = 956,  // "No name given!"
+    LANG_JAIL_NOTIME                    = 957,  // "No time given!"
+    LANG_JAIL_VALUE                     = 958,  // "The jailtime must be between 1 and %u hours!"
+    LANG_JAIL_CHAR_NOTJAILED            = 959,  // "The character (%s) is not jailed!"
+    LANG_JAIL_DENIED                    = 960,  // "Command forbidden for jailed characters!"
+    LANG_JAIL_JAILED_H_INFO             = 961,  // "You have %u hour(s) left in the jail."
+    LANG_JAIL_JAILED_M_INFO             = 962,  // "You have %u minute(s) left in the jail."
+    LANG_JAIL_NOTJAILED_INFO            = 963,  // "You're a free woman / man. ;-)"
+    LANG_JAIL_GM_INFO                   = 964,  // "%s was %u times jailed and has %u minute(s) left. Last time jailed by %s. Last reason was: '%s'"
+    LANG_JAIL_GM_NOINFO                 = 965,  // "%s was never jailed."
+    LANG_JAIL_NO_JAIL                   = 966,  // "You can't jail yourself!"
+    LANG_JAIL_NO_UNJAIL                 = 967,  // "You can't unjail yourself!"
+    LANG_JAIL_WARNING                   = 968,  // "Be carefull! Only one more jailtime and your current character will be deleted!"
+    LANG_JAIL_ANNOUNCE1                 = 969,  // "The character '"
+    LANG_JAIL_ANNOUNCE2                 = 970,  // "' was jailed for "
+    LANG_JAIL_ANNOUNCE3                 = 971,  // " hour(s) by the GM character '"
+    LANG_JAIL_ANNOUNCE4                 = 972,  // "'. The reason is: "
+    LANG_JAIL_RELOAD                    = 973,  // "The jail configuration was reloaded."
+    LANG_JAIL_CONF_LOADED               = 974,  // ">> Jail config loaded."
+    LANG_JAIL_CONF_ERR1                 = 975,  // "Can't load jail config! Table empty or missed! Use jail_conf.sql!"
+    LANG_JAIL_CONF_ERR2                 = 976,  // "Set all jail config settings to default..."
+    LANG_JAIL_CHAR_TELE                 = 977,  // "The Character '%s' (GUID %u) is jailed and teleportet into the jail."
+    LANG_JAIL_CHAR_FREE                 = 978,  // "The Character '%s' (GUID %u) was released out of the jail."
+    LANG_JAIL_WRONG_NAME                = 979,  // "A character with this name doesn't exists!"
+    LANG_JAIL_WARNING_BAN               = 980,  // "Be carefull! Only one more jailtime and your account will be banned!"
+    LANG_JAIL_BAN_REASON                = 981,  // "Max. jailtimes reached!"
+    LANG_JAIL_BAN_BY                    = 982,  // "Robotron"
+    LANG_JAIL_AMNESTII					= 983,  // "AMNESTII"
+
     // for chat commands
     LANG_SELECT_CHAR_OR_CREATURE        = 1,
     LANG_SELECT_CREATURE                = 2,
@@ -86,8 +122,13 @@ enum MangosStrings
     //LANG_RA_BUSY                      = 60, not used
     LANG_RA_USER                        = 61,
     LANG_RA_PASS                        = 62,
-    // Room for more level 0              63-99 not used
-
+    // Name Announce
+    LANG_SYSTEMMESSAGE_MODERATOR        = 63,
+    LANG_SYSTEMMESSAGE_GAMEMASTER       = 64,
+    LANG_SYSTEMMESSAGE_ADMINISTRATOR    = 65,
+    
+    // Room for more level 0              65-99 not used
+    
     // level 1 chat
     LANG_GLOBAL_NOTIFY                  = 100,
     LANG_MAP_POSITION                   = 101,
@@ -849,11 +890,98 @@ enum MangosStrings
 
     // FREE IDS                           1300-9999
 
+    // Broadcaster
+    LANG_AUTO_BROADCAST                 = 1300,
+
     // Use for not-in-offcial-sources patches
     //                                    10000-10999
 
-    // Use for custom patches             11000-11999
+    // opvp hp
+    LANG_OPVP_HP_CAPTURE_OVERLOOK_H     = 10001,
+    LANG_OPVP_HP_CAPTURE_OVERLOOK_A     = 10002,
+    LANG_OPVP_HP_CAPTURE_STADIUM_H      = 10003,
+    LANG_OPVP_HP_CAPTURE_STADIUM_A      = 10004,
+    LANG_OPVP_HP_CAPTURE_BROKENHILL_H   = 10005,
+    LANG_OPVP_HP_CAPTURE_BROKENHILL_A   = 10006,
+    LANG_OPVP_HP_LOOSE_OVERLOOK_H       = 10007,
+    LANG_OPVP_HP_LOOSE_OVERLOOK_A       = 10008,
+    LANG_OPVP_HP_LOOSE_STADIUM_H        = 10009,
+    LANG_OPVP_HP_LOOSE_STADIUM_A        = 10010,
+    LANG_OPVP_HP_LOOSE_BROKENHILL_H     = 10011,
+    LANG_OPVP_HP_LOOSE_BROKENHILL_A     = 10012,
+    // opvp zm
+    LANG_OPVP_ZM_CAPTURE_WEST_H         = 10013,
+    LANG_OPVP_ZM_CAPTURE_WEST_A         = 10014,
+    LANG_OPVP_ZM_CAPTURE_EAST_H         = 10015,
+    LANG_OPVP_ZM_CAPTURE_EAST_A         = 10016,
+    LANG_OPVP_ZM_CAPTURE_GY_H           = 10017,
+    LANG_OPVP_ZM_CAPTURE_GY_A           = 10018,
+    LANG_OPVP_ZM_LOOSE_WEST_H           = 10019,
+    LANG_OPVP_ZM_LOOSE_WEST_A           = 10020,
+    LANG_OPVP_ZM_LOOSE_EAST_H           = 10021,
+    LANG_OPVP_ZM_LOOSE_EAST_A           = 10022,
+    LANG_OPVP_ZM_LOOSE_GY_H             = 10023,
+    LANG_OPVP_ZM_LOOSE_GY_A             = 10024,
+    // opvp na
+    LANG_OPVP_NA_CAPTURE_H              = 10025,
+    LANG_OPVP_NA_CAPTURE_A              = 10026,
+    LANG_OPVP_NA_LOOSE_H                = 10027,
+    LANG_OPVP_NA_LOOSE_A                = 10028,
+    // opvp tf
+    LANG_OPVP_TF_CAPTURE_H              = 10029,
+    LANG_OPVP_TF_CAPTURE_A              = 10030,
+    LANG_OPVP_TF_LOOSE_H                = 10031,
+    LANG_OPVP_TF_LOOSE_A                = 10032,
+    // opvp ep
+    LANG_OPVP_EP_CAPTURE_NPT_H          = 10033,
+    LANG_OPVP_EP_CAPTURE_NPT_A          = 10034,
+    LANG_OPVP_EP_CAPTURE_EWT_H          = 10035,
+    LANG_OPVP_EP_CAPTURE_EWT_A          = 10036,
+    LANG_OPVP_EP_CAPTURE_CGT_H          = 10037,
+    LANG_OPVP_EP_CAPTURE_CGT_A          = 10038,
+    LANG_OPVP_EP_CAPTURE_PWT_H          = 10039,
+    LANG_OPVP_EP_CAPTURE_PWT_A          = 10040,
+    LANG_OPVP_EP_LOOSE_NPT_H            = 10041,
+    LANG_OPVP_EP_LOOSE_NPT_A            = 10042,
+    LANG_OPVP_EP_LOOSE_EWT_H            = 10043,
+    LANG_OPVP_EP_LOOSE_EWT_A            = 10044,
+    LANG_OPVP_EP_LOOSE_CGT_H            = 10045,
+    LANG_OPVP_EP_LOOSE_CGT_A            = 10046,
+    LANG_OPVP_EP_LOOSE_PWT_H            = 10047,
+    LANG_OPVP_EP_LOOSE_PWT_A            = 10048,
+    // opvp si
+    LANG_OPVP_SI_CAPTURE_H              = 10049,
+    LANG_OPVP_SI_CAPTURE_A              = 10050,
+    // opvp gossips
+    LANG_OPVP_EP_FLIGHT_NPT             = 10051,
+    LANG_OPVP_EP_FLIGHT_EWT             = 10052,
+    LANG_OPVP_EP_FLIGHT_CGT             = 10053,
+    LANG_OPVP_ZM_GOSSIP_ALLIANCE        = 10054,
+    LANG_OPVP_ZM_GOSSIP_HORDE           = 10055,
+
+    LANG_BG_WG_BATTLE_STARTS            = 10100,
+    LANG_BG_WG_DEFENDED                 = 10101,
+    LANG_BG_WG_CAPTURED                 = 10102,
+    LANG_BG_WG_WORKSHOP_DAMAGED         = 10103,
+    LANG_BG_WG_WORKSHOP_DESTROYED       = 10104,
+    LANG_BG_WG_TOWER_DAMAGED            = 10105,
+    LANG_BG_WG_TOWER_DESTROYED          = 10106,
+    LANG_BG_WG_FORTRESS_UNDER_ATTACK    = 10107,
+    LANG_BG_WG_SWITCH_FACTION           = 10108,
+    LANG_BG_WG_CHANGE_TIMER             = 10109,
+    LANG_BG_WG_BATTLE_FORCE_START       = 10110,
+    LANG_BG_WG_BATTLE_FORCE_STOP        = 10111,
+    LANG_BG_WG_STATUS                   = 10112,
+    LANG_BG_WG_DISABLE                  = 10113,
+    LANG_BG_WG_ENABLE                   = 10114,
+    LANG_BG_WG_RANK1                    = 10115,
+    LANG_BG_WG_RANK2                    = 10116,
 
+    // Use for custom patches             11000-11999
+    LANG_ANNOUNCE_CHEAT                 = 11000,
+    LANG_YOU_RECEIVE_TOKEN        		= 11050,
+    
+    
     // NOT RESERVED IDS                   12000-1999999999
     // `db_script_string` table index     2000000000-2000009999 (MIN_DB_SCRIPT_STRING_ID-MAX_DB_SCRIPT_STRING_ID)
     // For other tables maybe             2000010000-2147483647 (max index)
diff --git a/mangos/src/game/Level0.cpp b/Core/src/game/Level0.cpp
index d950439..e3e49c6 100644
--- a/mangos/src/game/Level0.cpp
+++ b/Core/src/game/Level0.cpp
@@ -29,6 +29,8 @@
 #include "revision.h"
 #include "revision_nr.h"
 #include "Util.h"
+#include "GameEventMgr.h"
+#include "math.h"
 
 bool ChatHandler::HandleHelpCommand(const char* args)
 {
@@ -61,7 +63,14 @@ bool ChatHandler::HandleAccountCommand(const char* /*args*/)
 }
 
 bool ChatHandler::HandleStartCommand(const char* /*args*/)
-{
+{   
+    // Jail by WarHead
+    if (m_session->GetPlayer()->m_jail_isjailed)
+    {
+        SendSysMessage(LANG_JAIL_DENIED);
+        return true;
+    }
+    
     Player *chr = m_session->GetPlayer();
 
     if(chr->isInFlight())
@@ -103,7 +112,10 @@ bool ChatHandler::HandleServerInfoCommand(const char* /*args*/)
     PSendSysMessage(LANG_USING_EVENT_AI,sWorld.GetCreatureEventAIVersion());
     PSendSysMessage(LANG_CONNECTED_USERS, activeClientsNum, maxActiveClientsNum, queuedClientsNum, maxQueuedClientsNum);
     PSendSysMessage(LANG_UPTIME, str.c_str());
-
+    PSendSysMessage("Diff time: %u", sWorld.GetDiffTime());
+    SendSysMessage("Hellscreamcore, The core brought to you straight from hell");
+    SendSysMessage("GIT: http://github.com/Hellscream/Core/commits");
+    SendSysMessage("A heavily modified MaNGOS core");
     return true;
 }
 
@@ -132,6 +144,13 @@ bool ChatHandler::HandleDismountCommand(const char* /*args*/)
 bool ChatHandler::HandleSaveCommand(const char* /*args*/)
 {
     Player *player=m_session->GetPlayer();
+    
+    // Jail by WarHead
+    if (player->m_jail_isjailed)
+    {
+        SendSysMessage(LANG_JAIL_DENIED);
+        return true;
+    }
 
     // save GM account without delay and output message (testing, etc)
     if(GetAccessLevel() > SEC_PLAYER)
@@ -234,6 +253,40 @@ bool ChatHandler::HandleAccountPasswordCommand(const char* args)
     return true;
 }
 
+bool ChatHandler::HandleJailInfoCommand(const char* args)
+{
+    time_t localtime;
+    localtime = time(NULL);
+    Player *chr = m_session->GetPlayer();
+
+    if (chr->m_jail_release > 0)
+    {
+        uint32 min_left = (uint32)floor(float(chr->m_jail_release - localtime) / 60);
+
+        if (min_left <= 0)
+        {
+            chr->m_jail_release = 0;
+            chr->_SaveJail();
+            SendSysMessage(LANG_JAIL_NOTJAILED_INFO);
+            return true;
+        }
+        else
+        {
+            if (min_left >= 60) PSendSysMessage(LANG_JAIL_JAILED_H_INFO, (uint32)floor(float(chr->m_jail_release - localtime) / 60 / 60));
+            else PSendSysMessage(LANG_JAIL_JAILED_M_INFO, min_left);
+            PSendSysMessage(LANG_JAIL_REASON, chr->m_jail_gmchar.c_str(), chr->m_jail_reason.c_str());
+
+            return true;
+        }
+    }
+    else
+    {
+        SendSysMessage(LANG_JAIL_NOTJAILED_INFO);
+        return true;
+    }
+    return false;
+}
+
 bool ChatHandler::HandleAccountLockCommand(const char* args)
 {
     // allow use from RA, but not from console (not have associated account id)
diff --git a/mangos/src/game/Level1.cpp b/Core/src/game/Level1.cpp
index 603032f..631da8c 100644
--- a/mangos/src/game/Level1.cpp
+++ b/Core/src/game/Level1.cpp
@@ -123,7 +123,7 @@ bool ChatHandler::HandleNpcWhisperCommand(const char* args)
 }
 //----------------------------------------------------------
 
-// global announce
+// Administrator .announce [System Message] command
 bool ChatHandler::HandleAnnounceCommand(const char* args)
 {
     if(!*args)
@@ -133,6 +133,32 @@ bool ChatHandler::HandleAnnounceCommand(const char* args)
     return true;
 }
 
+// Moderator .nameannounce Command with colored name and GM rank
+bool ChatHandler::HandleNameAnnounceCommand(const char* args)
+{
+    int32 strid = 0;
+
+    if(!*args)
+        return false;
+
+    switch(m_session->GetSecurity())
+    {
+      case SEC_MODERATOR:
+        strid = LANG_SYSTEMMESSAGE_MODERATOR;
+        break;
+      case SEC_GAMEMASTER:
+        strid = LANG_SYSTEMMESSAGE_GAMEMASTER;
+        break;
+      case SEC_ADMINISTRATOR:
+        strid = LANG_SYSTEMMESSAGE_ADMINISTRATOR;
+        break;
+      default:
+        return false;
+    }
+    sWorld.SendWorldText(strid, m_session->GetPlayerName(), args);
+    return true;
+}
+
 //notification player at the screen
 bool ChatHandler::HandleNotifyCommand(const char* args)
 {
@@ -1327,7 +1353,7 @@ bool ChatHandler::HandleModifyScaleCommand(const char* args)
         return false;
 
     float Scale = (float)atof((char*)args);
-    if (Scale > 10.0f || Scale <= 0.0f)
+    if (Scale > 15.0f || Scale <= 0.0f)
     {
         SendSysMessage(LANG_BAD_VALUE);
         SetSentErrorMessage(true);
@@ -1946,6 +1972,302 @@ bool ChatHandler::HandleSaveAllCommand(const char* /*args*/)
     return true;
 }
 
+// Jail by WarHead
+bool ChatHandler::HandleJailCommand(const char *args)
+{
+    std::string cname, announce, ban_reason, ban_by;
+    time_t localtime;
+    localtime = time(NULL);
+
+    char *charname = strtok((char*)args, " ");
+    if (charname == NULL)
+    {
+        SendSysMessage(LANG_JAIL_NONAME);
+        return true;
+    } else cname = charname;
+
+    char *timetojail = strtok(NULL, " ");
+    if (timetojail == NULL)
+    {
+        SendSysMessage(LANG_JAIL_NOTIME);
+        return true;
+    }
+
+    uint32 jailtime = (uint32) atoi((char*)timetojail);
+    if (jailtime < 1 || jailtime > sObjectMgr.m_jailconf_max_duration)
+    {
+        PSendSysMessage(LANG_JAIL_VALUE, sObjectMgr.m_jailconf_max_duration);
+        return true;
+    }
+
+    char *reason = strtok(NULL, "\0");
+    std::string jailreason;
+    if (reason == NULL || strlen((const char*)reason) < sObjectMgr.m_jailconf_min_reason)
+    {
+        PSendSysMessage(LANG_JAIL_NOREASON, sObjectMgr.m_jailconf_min_reason);
+        return true;
+    } else jailreason = reason;
+
+    uint64 GUID = sObjectMgr.GetPlayerGUIDByName(cname.c_str());
+    if (GUID == 0)
+    {
+        SendSysMessage(LANG_JAIL_WRONG_NAME);
+        return true;
+    }
+
+    Player *chr = sObjectMgr.GetPlayer(GUID);
+    if (!chr)
+    {
+        uint32 jail_guid = GUID_LOPART(GUID);
+        std::string jail_char = cname;
+        bool jail_isjailed = true;
+        uint32 jail_release = localtime + (jailtime * 60 * 60);
+        uint32 jail_amnestietime = localtime +(60* 60 * 24 * sObjectMgr.m_jailconf_amnestie);
+        std::string jail_reason = jailreason;
+        uint32 jail_times = 0;
+
+        CharacterDatabase.BeginTransaction();
+        QueryResult *result = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", jail_guid);
+        CharacterDatabase.CommitTransaction();
+
+        if (!result)
+        {
+            jail_times = 1;
+        }
+        else
+        {
+            Field *fields = result->Fetch();
+            jail_times = fields[4].GetUInt32()+1;
+        }
+
+        uint32 jail_gmacc = m_session->GetAccountId();
+        std::string jail_gmchar = m_session->GetPlayerName();
+
+        CharacterDatabase.BeginTransaction();
+        if (!result) CharacterDatabase.PExecute("INSERT INTO `jail` VALUES ('%u','%s','%u','%u','%s','%u','%u','%s',CURRENT_TIMESTAMP,'%u')", jail_guid, jail_char.c_str(), jail_release, jail_amnestietime, jail_reason.c_str(), jail_times, jail_gmacc, jail_gmchar.c_str(), jailtime);
+        else CharacterDatabase.PExecute("UPDATE `jail` SET `release`='%u', `amnestietime`='%u',`reason`='%s',`times`='%u',`gmacc`='%u',`gmchar`='%s',`duration`='%u' WHERE `guid`='%u' LIMIT 1", jail_release, jail_amnestietime, jail_reason.c_str(), jail_times, jail_gmacc, jail_gmchar.c_str(), jailtime, jail_guid);
+        CharacterDatabase.CommitTransaction();
+
+        PSendSysMessage(LANG_JAIL_WAS_JAILED, cname.c_str(), jailtime);
+
+        announce = GetMangosString(LANG_JAIL_ANNOUNCE1);
+        announce += cname;
+        announce += GetMangosString(LANG_JAIL_ANNOUNCE2);
+        announce += timetojail;
+        announce += GetMangosString(LANG_JAIL_ANNOUNCE3);
+        announce += m_session->GetPlayerName();
+        announce += GetMangosString(LANG_JAIL_ANNOUNCE4);
+        announce += jail_reason;
+
+        HandleAnnounceCommand(announce.c_str());
+
+        if (result) delete result;
+
+        if ((sObjectMgr.m_jailconf_max_jails == jail_times) && !sObjectMgr.m_jailconf_ban)
+        {
+            CharacterDatabase.BeginTransaction();
+            QueryResult *result = CharacterDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(GUID));
+            CharacterDatabase.CommitTransaction();
+
+            if (!result)
+            {
+                PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+
+            Field *fields = result->Fetch();
+
+            Player::DeleteFromDB(GUID, fields[1].GetUInt32());
+
+            delete result;
+        }
+        else if ((sObjectMgr.m_jailconf_max_jails == jail_times) && sObjectMgr.m_jailconf_ban)
+        {
+            CharacterDatabase.BeginTransaction();
+            QueryResult *result = CharacterDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(GUID));
+            CharacterDatabase.CommitTransaction();
+
+            if (!result)
+            {
+                PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+            Field *fields = result->Fetch();
+            uint32 acc_id = fields[1].GetUInt32();
+
+            loginDatabase.BeginTransaction();
+            result = loginDatabase.PQuery("SELECT * FROM `account` WHERE `id`='%u' LIMIT 1", acc_id);
+            loginDatabase.CommitTransaction();
+
+            if (!result)
+            {
+                PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+            ban_reason = GetMangosString(LANG_JAIL_BAN_REASON);
+            ban_by = GetMangosString(LANG_JAIL_BAN_BY);
+
+            loginDatabase.BeginTransaction();
+            loginDatabase.PExecute("INSERT IGNORE INTO `account_banned` (`id`,`bandate`,`bannedby`,`banreason`) VALUES ('%u',UNIX_TIMESTAMP,'%s','%s')", acc_id, ban_by.c_str(), ban_reason.c_str());
+            loginDatabase.CommitTransaction();
+
+            delete result;
+        }
+        return true;
+    }
+
+    CharacterDatabase.BeginTransaction();
+    QueryResult *result = CharacterDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", chr->GetGUIDLow());
+    CharacterDatabase.CommitTransaction();
+
+    if (!result)
+    {
+        PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+        return true;
+    }
+
+    Field *fields = result->Fetch();
+
+    if(chr->GetName() == m_session->GetPlayerName())
+    {
+        SendSysMessage(LANG_JAIL_NO_JAIL);
+        delete result;
+        return true;
+    }
+
+    chr->SaveToDB();
+
+    chr->m_jail_guid = fields[0].GetUInt32();
+    chr->m_jail_char = fields[3].GetCppString();
+    chr->m_jail_isjailed = true;
+    chr->m_jail_release = localtime + (jailtime * 60 * 60);
+    chr->m_jail_amnestietime = localtime +(60* 60 * 24 * sObjectMgr.m_jailconf_amnestie);
+    chr->m_jail_reason = jailreason;
+    chr->m_jail_times = chr->m_jail_times+1;
+    chr->m_jail_gmacc = m_session->GetAccountId();
+    chr->m_jail_gmchar = m_session->GetPlayerName();
+    chr->m_jail_duration = jailtime;
+
+    chr->_SaveJail();
+
+    PSendSysMessage(LANG_JAIL_WAS_JAILED, fields[3].GetCppString().c_str(), jailtime);
+    ChatHandler(chr).PSendSysMessage(LANG_JAIL_YOURE_JAILED, m_session->GetPlayerName(), jailtime);
+    ChatHandler(chr).PSendSysMessage(LANG_JAIL_REASON, m_session->GetPlayerName(), jailreason.c_str());
+
+    announce = GetMangosString(LANG_JAIL_ANNOUNCE1);
+    announce += fields[3].GetCppString();
+    announce += GetMangosString(LANG_JAIL_ANNOUNCE2);
+    announce += timetojail;
+    announce += GetMangosString(LANG_JAIL_ANNOUNCE3);
+    announce += m_session->GetPlayerName();
+    announce += GetMangosString(LANG_JAIL_ANNOUNCE4);
+    announce += chr->m_jail_reason;
+
+    HandleAnnounceCommand(announce.c_str());
+
+    if (sObjectMgr.m_jailconf_max_jails == chr->m_jail_times)
+    {
+        chr->GetSession()->KickPlayer();
+        chr->DeleteFromDB(fields[0].GetUInt64(), fields[1].GetUInt32());
+    }
+    else if ((sObjectMgr.m_jailconf_max_jails == chr->m_jail_times) && sObjectMgr.m_jailconf_ban)
+    {
+        uint32 acc_id = chr->GetSession()->GetAccountId();
+        ban_reason = GetMangosString(LANG_JAIL_BAN_REASON);
+        ban_by = GetMangosString(LANG_JAIL_BAN_BY);
+
+        loginDatabase.BeginTransaction();
+        loginDatabase.PExecute("INSERT IGNORE INTO `account_banned` (`id`,`bandate`,`bannedby`,`banreason`) VALUES ('%u',UNIX_TIMESTAMP,'%s','%s')", acc_id, ban_by.c_str(), ban_reason.c_str());
+        loginDatabase.CommitTransaction();
+
+        chr->GetSession()->LogoutPlayer(false);
+    }
+    else chr->GetSession()->LogoutPlayer(false);
+
+    delete result;
+    return true;
+}
+
+bool ChatHandler::HandleUnJailCommand(const char *args)
+{
+    char *charname = strtok((char*)args, " ");
+    std::string cname;
+
+    if (charname == NULL) return false;
+    else cname = charname;
+
+    uint64 GUID = sObjectMgr.GetPlayerGUIDByName(cname.c_str());
+    Player *chr = sObjectMgr.GetPlayer(GUID);
+
+    if (chr)
+    {
+        if (chr->GetName() == m_session->GetPlayerName())
+        {
+            SendSysMessage(LANG_JAIL_NO_UNJAIL);
+            return true;
+        }
+
+        if (chr->m_jail_isjailed)
+        {
+            chr->m_jail_isjailed = false;
+            chr->m_jail_release = 0;
+            chr->m_jail_times = chr->m_jail_times-1;
+
+            chr->_SaveJail();
+
+            if (chr->m_jail_times == 0)
+            {
+                CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("DELETE FROM `jail` WHERE `guid`='%u' LIMIT 1", chr->GetGUIDLow());
+                CharacterDatabase.CommitTransaction();
+            }
+
+            PSendSysMessage(LANG_JAIL_WAS_UNJAILED, cname.c_str());
+            ChatHandler(chr).PSendSysMessage(LANG_JAIL_YOURE_UNJAILED, m_session->GetPlayerName());    
+            chr->CastSpell(chr,8690,false);
+            //chr->GetSession()->LogoutPlayer(false);
+        } else PSendSysMessage(LANG_JAIL_CHAR_NOTJAILED, cname.c_str());
+        return true;
+    }
+    else
+    {
+        CharacterDatabase.BeginTransaction();
+        QueryResult *jresult = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(GUID));
+        CharacterDatabase.CommitTransaction();
+
+        if (!jresult)
+        {
+            PSendSysMessage(LANG_JAIL_CHAR_NOTJAILED, cname.c_str());
+            return true;
+        }
+        else
+        {
+            Field *fields = jresult->Fetch();
+            uint32 jail_times = fields[4].GetUInt32()-1;
+
+            if (jail_times == 0)
+            {
+                CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("DELETE FROM `jail` WHERE `guid`='%u' LIMIT 1", fields[0].GetUInt32());
+                CharacterDatabase.CommitTransaction();
+            }
+            else
+            {
+                CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("UPDATE `jail` SET `release`='0',`times`='%u' WHERE `guid`='%u' LIMIT 1", jail_times, fields[0].GetUInt32());
+                CharacterDatabase.CommitTransaction();
+            }
+
+            PSendSysMessage(LANG_JAIL_WAS_UNJAILED, cname.c_str());
+
+            delete jresult;
+            return true;
+        }
+
+    }
+    return true;
+}
+
 //Send mail by command
 bool ChatHandler::HandleSendMailCommand(const char* args)
 {
diff --git a/mangos/src/game/Level2.cpp b/Core/src/game/Level2.cpp
index bba39a0..90703a3 100644
--- a/mangos/src/game/Level2.cpp
+++ b/Core/src/game/Level2.cpp
@@ -36,6 +36,8 @@
 #include "AccountMgr.h"
 #include "GMTicketMgr.h"
 #include "WaypointManager.h"
+#include "WaypointMovementGenerator.h"
+#include "math.h"
 #include "Util.h"
 #include <cctype>
 #include <iostream>
@@ -1102,6 +1104,118 @@ bool ChatHandler::HandleNpcAddCommand(const char* args)
     return true;
 }
 
+bool ChatHandler::HandleNpcAddAsPetCommand(const char* args)
+{
+    if(!*args)
+        return false;
+    char* charID = extractKeyFromLink((char*)args,"Hcreature_entry");
+    if(!charID)
+        return false;
+
+    char* team = strtok(NULL, " ");
+    int32 teamval = 0;
+    if (team) { teamval = atoi(team); }
+    if (teamval < 0) { teamval = 0; }
+
+    uint32 id  = atoi(charID);
+
+    Player *chr = m_session->GetPlayer();
+    float x = chr->GetPositionX();
+    float y = chr->GetPositionY();
+    float z = chr->GetPositionZ();
+    float o = chr->GetOrientation();
+    Map *map = chr->GetMap();
+
+    Creature* pCreature = new Creature;
+    if (!pCreature->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_UNIT), map, chr->GetPhaseMaskForSpawn(), id, (uint32)teamval))
+    {
+        delete pCreature;
+        return false;
+    }
+
+    pCreature->Relocate(x,y,z,o);
+
+    if(!pCreature->IsPositionValid())
+    {
+        sLog.outError("Creature (guidlow %d, entry %d) not created. Suggested coordinates isn't valid (X: %f Y: %f)",pCreature->GetGUIDLow(),pCreature->GetEntry(),pCreature->GetPositionX(),pCreature->GetPositionY());
+        delete pCreature;
+        return false;
+    }
+
+    Creature *creatureTarget = pCreature;
+	Player *player = m_session->GetPlayer ();
+    CreatureInfo const* cInfo = creatureTarget->GetCreatureInfo();
+
+    if (!cInfo->isTameable (player->CanTameExoticPets()))
+    {
+        PSendSysMessage (LANG_CREATURE_NON_TAMEABLE,cInfo->Entry);
+        SetSentErrorMessage (true);
+        return false;
+    }
+
+    pCreature->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), chr->GetPhaseMaskForSpawn());
+
+    uint32 db_guid = pCreature->GetDBTableGUIDLow();
+
+    // To call _LoadGoods(); _LoadQuests(); CreateTrainerSpells();
+    pCreature->LoadFromDB(db_guid, map);
+
+    map->Add(pCreature);
+    sObjectMgr.AddCreatureToGrid(db_guid, sObjectMgr.GetCreatureData(db_guid));
+
+    if (!creatureTarget || creatureTarget->isPet ())
+    {
+        PSendSysMessage (LANG_SELECT_CREATURE);
+        SetSentErrorMessage (true);
+        return false;
+    }
+
+    if(player->GetPetGUID ())
+    {
+        SendSysMessage (LANG_YOU_ALREADY_HAVE_PET);
+        SetSentErrorMessage (true);
+        return false;
+    }
+
+    
+
+    // Everything looks OK, create new pet
+    Pet* pet = player->CreateTamedPetFrom (creatureTarget);
+    if (!pet)
+    {
+        PSendSysMessage (LANG_CREATURE_NON_TAMEABLE,cInfo->Entry);
+        SetSentErrorMessage (true);
+        return false;
+    }
+
+    // place pet before player
+    player->GetClosePoint (x,y,z,creatureTarget->GetObjectSize (),CONTACT_DISTANCE);
+    pet->Relocate (x,y,z,M_PI_F-player->GetOrientation ());
+
+    // set pet to defensive mode by default (some classes can't control controlled pets in fact).
+    pet->GetCharmInfo()->SetReactState(REACT_DEFENSIVE);
+
+    // calculate proper level
+    uint32 level = (creatureTarget->getLevel() < (player->getLevel() - 5)) ? (player->getLevel() - 5) : creatureTarget->getLevel();
+
+    // prepare visual effect for levelup
+    pet->SetUInt32Value(UNIT_FIELD_LEVEL, level - 1);
+
+    // add to world
+    pet->GetMap()->Add((Creature*)pet);
+
+    // visual effect for levelup
+    pet->SetUInt32Value(UNIT_FIELD_LEVEL, level);
+
+    // caster have pet now
+    player->SetPet(pet);
+
+    pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+    player->PetSpellInitialize();
+
+    return true;
+}
+
 //add item in vendorlist
 bool ChatHandler::HandleNpcAddVendorItemCommand(const char* args)
 {
@@ -2112,6 +2226,7 @@ bool ChatHandler::HandleModifyPhaseCommand(const char* args)
 bool ChatHandler::HandlePInfoCommand(const char* args)
 {
     Player* target;
+    char* py = NULL;
     uint64 target_guid;
     std::string target_name;
     if(!extractPlayerTarget((char*)args,&target,&target_guid,&target_name))
@@ -2122,6 +2237,7 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
     uint32 total_player_time = 0;
     uint32 level = 0;
     uint32 latency = 0;
+    int32  security = 0;
 
     // get additional information from Player object
     if(target)
@@ -2135,6 +2251,7 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
         total_player_time = target->GetTotalPlayedTime();
         level = target->getLevel();
         latency = target->GetSession()->GetLatency();
+        security = target->GetSession()->GetSecurity();
     }
     // get additional information from DB
     else
@@ -2144,7 +2261,7 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
             return false;
 
         //                                                     0          1      2      3
-        QueryResult *result = CharacterDatabase.PQuery("SELECT totaltime, level, money, account FROM characters WHERE guid = '%u'", GUID_LOPART(target_guid));
+        QueryResult *result = CharacterDatabase.PQuery("SELECT totaltime, level, money, account, gmlevel FROM characters WHERE guid = '%u'", GUID_LOPART(target_guid));
         if (!result)
             return false;
 
@@ -2153,12 +2270,13 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
         level = fields[1].GetUInt32();
         money = fields[2].GetUInt32();
         accId = fields[3].GetUInt32();
+        security = fields[4].GetInt32();
         delete result;
     }
 
     std::string username = GetMangosString(LANG_ERROR);
     std::string last_ip = GetMangosString(LANG_ERROR);
-    AccountTypes security = SEC_PLAYER;
+    //AccountTypes security = SEC_PLAYER;
     std::string last_login = GetMangosString(LANG_ERROR);
 
     QueryResult* result = loginDatabase.PQuery("SELECT username,gmlevel,last_ip,last_login FROM account WHERE id = '%u'",accId);
@@ -2166,7 +2284,10 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
     {
         Field* fields = result->Fetch();
         username = fields[0].GetCppString();
-        security = (AccountTypes)fields[1].GetUInt32();
+        if (security == 0)
+        {
+            security = (AccountTypes)fields[1].GetUInt32();
+        }
 
         if(GetAccessLevel() >= security)
         {
@@ -2192,7 +2313,43 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
     uint32 copp = (money % GOLD) % SILVER;
     PSendSysMessage(LANG_PINFO_LEVEL,  timeStr.c_str(), level, gold,silv,copp );
 
+    if (py && strncmp(py, "jail", 4) == 0)
+    {
+        if (target->m_jail_times > 0)
+        {
+            if(target->m_jail_release > 0)
+            {
+                time_t localtime;
+                localtime = time(NULL);
+                uint32 min_left = (uint32)floor(float(target->m_jail_release - localtime) / 60);
+ 
+               if (min_left <= 0)
+                {
+                    target->m_jail_release = 0;
+                    target->_SaveJail();
+                    PSendSysMessage(LANG_JAIL_GM_INFO, target->m_jail_char.c_str(), target->m_jail_times, 0, target->m_jail_gmchar.c_str(), target->m_jail_reason.c_str());
+                    return true;
+                }
+                else
+                {
+                    PSendSysMessage(LANG_JAIL_GM_INFO, target->m_jail_char.c_str(), target->m_jail_times, min_left, target->m_jail_gmchar.c_str(), target->m_jail_reason.c_str());
+                    return true;
+                }
+            }
+            else
+            {
+                PSendSysMessage(LANG_JAIL_GM_INFO, target->m_jail_char.c_str(), target->m_jail_times, 0, target->m_jail_gmchar.c_str(), target->m_jail_reason.c_str());
+                return true;
+            }
+        }
+        else
+        {
+            PSendSysMessage(LANG_JAIL_GM_NOINFO, target->GetName());
+            return true;
+        }
     return true;
+    }
+return true;
 }
 
 //show tickets
@@ -3610,6 +3767,62 @@ bool ChatHandler::HandleCharacterCustomizeCommand(const char* args)
     return true;
 }
 
+// change player faction
+bool ChatHandler::HandleCharacterChangeFactionCommand(const char* args)
+{
+    Player* target;
+    uint64 target_guid;
+    std::string target_name;
+    if(!extractPlayerTarget((char*)args,&target,&target_guid,&target_name))
+        return false;
+
+    if(target)
+    {
+        // TODO : add text into database
+        PSendSysMessage(LANG_CUSTOMIZE_PLAYER, GetNameLink(target).c_str());
+        target->SetAtLoginFlag(AT_LOGIN_CHANGE_FACTION);
+        CharacterDatabase.PExecute("UPDATE characters SET at_login = at_login | '64' WHERE guid = '%u'", target->GetGUIDLow());
+    }
+    else
+    {
+        std::string oldNameLink = playerLink(target_name);
+
+        // TODO : add text into database
+        PSendSysMessage(LANG_CUSTOMIZE_PLAYER_GUID, oldNameLink.c_str(), GUID_LOPART(target_guid));
+        CharacterDatabase.PExecute("UPDATE characters SET at_login = at_login | '64' WHERE guid = '%u'", GUID_LOPART(target_guid));
+    }
+
+    return true;
+}
+
+// change player race
+bool ChatHandler::HandleCharacterChangeRaceCommand(const char* args)
+{
+    Player* target;
+    uint64 target_guid;
+    std::string target_name;
+    if(!extractPlayerTarget((char*)args,&target,&target_guid,&target_name))
+        return false;
+
+    if(target)
+    {
+        // TODO : add text into database
+        PSendSysMessage(LANG_CUSTOMIZE_PLAYER, GetNameLink(target).c_str());
+        target->SetAtLoginFlag(AT_LOGIN_CHANGE_RACE);
+        CharacterDatabase.PExecute("UPDATE characters SET at_login = at_login | '128' WHERE guid = '%u'", target->GetGUIDLow());
+    }
+    else
+    {
+        std::string oldNameLink = playerLink(target_name);
+
+        // TODO : add text into database
+        PSendSysMessage(LANG_CUSTOMIZE_PLAYER_GUID, oldNameLink.c_str(), GUID_LOPART(target_guid));
+        CharacterDatabase.PExecute("UPDATE characters SET at_login = at_login | '128' WHERE guid = '%u'", GUID_LOPART(target_guid));
+    }
+
+    return true;
+}
+
 bool ChatHandler::HandleCharacterReputationCommand(const char* args)
 {
     Player* target;
diff --git a/mangos/src/game/Level3.cpp b/Core/src/game/Level3.cpp
index 6ed7809..972b1ae 100644
--- a/mangos/src/game/Level3.cpp
+++ b/Core/src/game/Level3.cpp
@@ -52,8 +52,493 @@
 #include "InstanceData.h"
 #include "CreatureEventAIMgr.h"
 #include "DBCEnums.h"
+#include "AuctionHouseBot.h"
+#include "BattleGround.h"
+
+bool ChatHandler::HandleAHBotOptionsCommand(const char* args)
+{
+    uint32 ahMapID = 0;
+    char * opt = strtok((char*)args, " ");
+    char * ahMapIdStr = strtok(NULL, " ");
+    if (ahMapIdStr)
+    {
+        ahMapID = (uint32) strtoul(ahMapIdStr, NULL, 0);
+    }
+    if (!opt)
+    {
+        PSendSysMessage("Syntax is: ahbotoptions $option $ahMapID (2, 6 or 7) $parameter");
+        PSendSysMessage("Try ahbotoptions help to see a list of options.");
+        return false;
+    }
+    int l = strlen(opt);
+
+    if (strncmp(opt,"help",l) == 0)
+    {
+        PSendSysMessage("AHBot commands:");
+        PSendSysMessage("ahexpire");
+        PSendSysMessage("minitems");
+        PSendSysMessage("maxitems");
+        PSendSysMessage("mintime");
+        PSendSysMessage("maxtime");
+        PSendSysMessage("percentages");
+        PSendSysMessage("minprice");
+        PSendSysMessage("maxprice");
+        PSendSysMessage("minbidprice");
+        PSendSysMessage("maxbidprice");
+        PSendSysMessage("maxstack");
+        PSendSysMessage("buyerprice");
+        PSendSysMessage("bidinterval");
+        PSendSysMessage("bidsperinterval");
+        PSendSysMessage("reloaddbconfig");
+        return true;
+    }
+    else if (strncmp(opt,"ahexpire",l) == 0)
+    {
+        if (!ahMapIdStr)
+        {
+            PSendSysMessage("Syntax is: ahbotoptions ahexpire $ahMapID (2, 6 or 7)");
+            return false;
+        }
+        auctionbot.Commands(0, ahMapID, NULL, NULL);
+    }
+    else if (strncmp(opt,"minitems",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minitems $ahMapID (2, 6 or 7) $minItems");
+            return false;
+        }
+        auctionbot.Commands(1, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"maxitems",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxitems $ahMapID (2, 6 or 7) $maxItems");
+            return false;
+        }
+        auctionbot.Commands(2, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"mintime",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions mintime $ahMapID (2, 6 or 7) $mintime");
+            return false;
+        }
+        auctionbot.Commands(3, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"maxtime",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxtime $ahMapID (2, 6 or 7) $maxtime");
+            return false;
+        }
+        auctionbot.Commands(4, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"percentages",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        char * param3 = strtok(NULL, " ");
+        char * param4 = strtok(NULL, " ");
+        char * param5 = strtok(NULL, " ");
+        char * param6 = strtok(NULL, " ");
+        char * param7 = strtok(NULL, " ");
+        char * param8 = strtok(NULL, " ");
+        char * param9 = strtok(NULL, " ");
+        char * param10 = strtok(NULL, " ");
+        char * param11 = strtok(NULL, " ");
+        char * param12 = strtok(NULL, " ");
+        char * param13 = strtok(NULL, " ");
+        char * param14 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param14))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions percentages $ahMapID (2, 6 or 7) $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14");
+            PSendSysMessage("1 GreyTradeGoods 2 WhiteTradeGoods 3 GreenTradeGoods 4 BlueTradeGoods 5 PurpleTradeGoods");
+            PSendSysMessage("6 OrangeTradeGoods 7 YellowTradeGoods 8 GreyItems 9 WhiteItems 10 GreenItems 11 BlueItems");
+            PSendSysMessage("12 PurpleItems 13 OrangeItems 14 YellowItems");
+            PSendSysMessage("The total must add up to 100%");
+            return false;
+        }
+        uint32 greytg = (uint32) strtoul(param1, NULL, 0);
+        uint32 whitetg = (uint32) strtoul(param2, NULL, 0);
+        uint32 greentg = (uint32) strtoul(param3, NULL, 0);
+        uint32 bluetg = (uint32) strtoul(param3, NULL, 0);
+        uint32 purpletg = (uint32) strtoul(param5, NULL, 0);
+        uint32 orangetg = (uint32) strtoul(param6, NULL, 0);
+        uint32 yellowtg = (uint32) strtoul(param7, NULL, 0);
+        uint32 greyi = (uint32) strtoul(param8, NULL, 0);
+        uint32 whitei = (uint32) strtoul(param9, NULL, 0);
+        uint32 greeni = (uint32) strtoul(param10, NULL, 0);
+        uint32 bluei = (uint32) strtoul(param11, NULL, 0);
+        uint32 purplei = (uint32) strtoul(param12, NULL, 0);
+        uint32 orangei = (uint32) strtoul(param13, NULL, 0);
+        uint32 yellowi = (uint32) strtoul(param14, NULL, 0);
+        uint32 totalPercent = greytg + whitetg + greentg + bluetg + purpletg + orangetg + yellowtg + greyi + whitei + greeni + bluei + purplei + orangei + yellowi;
+        if ((totalPercent == 0) || (totalPercent != 100))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions percentages $ahMapID (2, 6 or 7) $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14");
+            PSendSysMessage("1 GreyTradeGoods 2 WhiteTradeGoods 3 GreenTradeGoods 4 BlueTradeGoods 5 PurpleTradeGoods");
+            PSendSysMessage("6 OrangeTradeGoods 7 YellowTradeGoods 8 GreyItems 9 WhiteItems 10 GreenItems 11 BlueItems");
+            PSendSysMessage("12 PurpleItems 13 OrangeItems 14 YellowItems");
+            PSendSysMessage("The total must add up to 100%");
+            return false;
+        }
+        char param[100];
+        param[0] = '\0';
+        strcat(param, param1);
+        strcat(param, " ");
+        strcat(param, param2);
+        strcat(param, " ");
+        strcat(param, param3);
+        strcat(param, " ");
+        strcat(param, param4);
+        strcat(param, " ");
+        strcat(param, param5);
+        strcat(param, " ");
+        strcat(param, param6);
+        strcat(param, " ");
+        strcat(param, param7);
+        strcat(param, " ");
+        strcat(param, param8);
+        strcat(param, " ");
+        strcat(param, param9);
+        strcat(param, " ");
+        strcat(param, param10);
+        strcat(param, " ");
+        strcat(param, param11);
+        strcat(param, " ");
+        strcat(param, param12);
+        strcat(param, " ");
+        strcat(param, param13);
+        strcat(param, " ");
+        strcat(param, param14);
+        auctionbot.Commands(5, ahMapID, NULL, param);
+    }
+    else if (strncmp(opt,"minprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_BLUE, param2);
+        }
+        else if	(strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_PURPLE, param2);
+        }
+        else if	(strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_ORANGE, param2);
+        }
+        else if	(strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"maxprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_BLUE, param2);
+        }
+        else if	(strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_PURPLE, param2);
+        }
+        else if	(strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_ORANGE, param2);
+        }
+        else if	(strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"minbidprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        uint32 minBidPrice = (uint32) strtoul(param2, NULL, 0);
+        if ((minBidPrice < 1) || (minBidPrice > 100))
+        {
+            PSendSysMessage("The min bid price multiplier must be between 1 and 100");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_BLUE, param2);
+        }
+        else if	(strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_PURPLE, param2);
+        }
+        else if	(strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_ORANGE, param2);
+        }
+        else if	(strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"maxbidprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        uint32 maxBidPrice = (uint32) strtoul(param2, NULL, 0);
+        if ((maxBidPrice < 1) || (maxBidPrice > 100))
+        {
+            PSendSysMessage("The max bid price multiplier must be between 1 and 100");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_BLUE, param2);
+        }
+        else if	(strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_PURPLE, param2);
+        }
+        else if	(strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_ORANGE, param2);
+        }
+        else if	(strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions max bidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"maxstack",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxstack $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $value");
+            return false;
+        }
+        uint32 maxStack = (uint32) strtoul(param2, NULL, 0);
+        if (maxStack < 0)
+        {
+            PSendSysMessage("maxstack can't be a negative number.");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_BLUE, param2);
+        }
+        else if	(strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_PURPLE, param2);
+        }
+        else if	(strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_ORANGE, param2);
+        }
+        else if	(strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxstack $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $value");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"buyerprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions buyerprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue or purple) $price");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_BLUE, param2);
+        }
+        else if	(strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_PURPLE, param2);
+        }
+        else if	(strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_ORANGE, param2);
+        }
+        else if	(strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions buyerprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue or purple) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"bidinterval",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions bidinterval $ahMapID (2, 6 or 7) $interval(in minutes)");
+            return false;
+        }
+        auctionbot.Commands(12, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"bidsperinterval",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions bidsperinterval $ahMapID (2, 6 or 7) $bids");
+            return false;
+        }
+        auctionbot.Commands(13, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"reloaddbconfig",l) == 0)
+    {
+        auctionbot.LoadDbConfig();
+        PSendSysMessage("AHBOT> DB Config reloaded");
+    }
+    else
+    {
+        PSendSysMessage("Syntax is: ahbotoptions $option $ahMapID (2, 6 or 7) $parameter");
+        PSendSysMessage("Try ahbotoptions help to see a list of options.");
+        return false;
+    }
+    return true;
+}
 
 //reload commands
+bool ChatHandler::HandleJailReloadCommand(const char* arg)
+{
+    sObjectMgr.LoadJailConf();
+    SendSysMessage(LANG_JAIL_RELOAD);
+    return true;
+}
+
 bool ChatHandler::HandleReloadAllCommand(const char*)
 {
     HandleReloadSkillFishingBaseLevelCommand("");
@@ -74,6 +559,9 @@ bool ChatHandler::HandleReloadAllCommand(const char*)
     HandleReloadReservedNameCommand("");
     HandleReloadMangosStringCommand("");
     HandleReloadGameTeleCommand("");
+
+    HandleReloadVehicleDataCommand("");
+    HandleReloadVehicleSeatDataCommand("");
     return true;
 }
 
@@ -168,6 +656,7 @@ bool ChatHandler::HandleReloadAllSpellCommand(const char*)
     HandleReloadSpellTargetPositionCommand("a");
     HandleReloadSpellThreatsCommand("a");
     HandleReloadSpellPetAurasCommand("a");
+    HandleReloadSpellDisabledCommand("a");
     return true;
 }
 
@@ -891,6 +1380,30 @@ bool ChatHandler::HandleReloadMailLevelRewardCommand(const char* /*arg*/)
     return true;
 }
 
+bool ChatHandler::HandleReloadSpellDisabledCommand(const char* /*arg*/)
+{
+    sLog.outString( "Re-Loading spell disabled table...");
+    sObjectMgr.LoadSpellDisabledEntrys();
+    SendGlobalSysMessage("DB table `spell_disabled` reloaded.");
+    return true;
+}
+
+bool ChatHandler::HandleReloadVehicleDataCommand(const char*)
+{
+    sLog.outString( "Re-Loading `vehicle_data` Table!" );
+    sObjectMgr.LoadVehicleData();
+    SendGlobalSysMessage("DB table `vehicle_data` reloaded.");
+    return true;
+}
+
+bool ChatHandler::HandleReloadVehicleSeatDataCommand(const char*)
+{
+    sLog.outString( "Re-Loading `vehicle_seat_data` Table!" );
+    sObjectMgr.LoadVehicleSeatData();
+    SendGlobalSysMessage("DB table `vehicle_seat_data` reloaded.");
+    return true;
+}
+
 bool ChatHandler::HandleLoadScriptsCommand(const char* args)
 {
     if(!LoadScriptingModule(args)) return true;
@@ -2173,6 +2686,68 @@ bool ChatHandler::HandleAddItemCommand(const char* args)
     return true;
 }
 
+bool ChatHandler::HandleDeleteItemCommand(const char* args)
+{
+    if (!*args)
+        return false;
+
+    uint32 itemId = 0;
+
+    if(args[0]=='[')                                        // [name] manual form
+    {
+        char* citemName = strtok((char*)args, "]");
+
+        if(citemName && citemName[0])
+        {
+            std::string itemName = citemName+1;
+            WorldDatabase.escape_string(itemName);
+            QueryResult *result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+            if (!result)
+            {
+                PSendSysMessage(LANG_COMMAND_COULDNOTFIND, citemName+1);
+                SetSentErrorMessage(true);
+                return false;
+            }
+            itemId = result->Fetch()->GetUInt16();
+            delete result;
+        }
+        else
+            return false;
+    }
+    else                                                    // item_id or [name] Shift-click form |color|Hitem:item_id:0:0:0|h[name]|h|r
+    {
+        char* cId = extractKeyFromLink((char*)args,"Hitem");
+        if(!cId)
+            return false;
+        itemId = atol(cId);
+    }
+
+    char* ccount = strtok(NULL, " ");
+
+    int32 count = 1;
+
+    if (ccount)
+        count = strtol(ccount, NULL, 10);
+
+    if (count == 0)
+        count = 1;
+
+    Player* pl = m_session->GetPlayer();
+    Player* plTarget = getSelectedPlayer();
+    if(!plTarget)
+        plTarget = pl;
+
+    //Remove the item
+    if (count > 0)
+    {
+        plTarget->DestroyItemCount(itemId, -count, true, false);
+        PSendSysMessage(LANG_REMOVEITEM, itemId, -count, GetNameLink(plTarget).c_str());
+        return true;
+    }
+
+    return true;
+}
+
 bool ChatHandler::HandleAddItemSetCommand(const char* args)
 {
     if (!*args)
@@ -4029,6 +4604,51 @@ bool ChatHandler::HandleCharacterLevelCommand(const char* args)
     return true;
 }
 
+bool ChatHandler::HandleCharacterGMLevelCommand(const char* args)
+{
+    char* nameStr;
+    char* levelStr;
+    extractOptFirstArg((char*)args,&nameStr,&levelStr);
+    if(!levelStr)
+        return false;
+
+    // exception opt second arg: .character gmlevel $name
+    if(isalpha(levelStr[0]))
+    {
+        nameStr = levelStr;
+        levelStr = NULL;                                    // current level will used
+    }
+
+    Player* target;
+    uint64 target_guid;
+    std::string target_name;
+    if(!extractPlayerTarget(nameStr,&target,&target_guid,&target_name))
+        return false;
+
+    int32 oldlevel = target ? target->GetSecurity() : Player::GetGMLevelFromDB(target_guid);
+    int32 newlevel = levelStr ? atoi(levelStr) : oldlevel;
+
+    if(newlevel < 0)
+        return false;                                       // invalid level
+
+    if (oldlevel >= m_session->GetSecurity())
+    {
+        PSendSysMessage("You too low level to affect this player");
+        return true;
+    }
+
+    if (newlevel >= m_session->GetSecurity())
+    {
+        PSendSysMessage("You cannot set a level equal to or greater than your own");
+        return true;
+    }
+
+    target->SetSecurity(newlevel);
+    target->SaveToDB();
+
+    return true;
+}
+
 bool ChatHandler::HandleLevelUpCommand(const char* args)
 {
     char* nameStr;
@@ -5432,9 +6052,15 @@ bool ChatHandler::HandleGMFlyCommand(const char* args)
 
     WorldPacket data(12);
     if (strncmp(args, "on", 3) == 0)
+    {
         data.SetOpcode(SMSG_MOVE_SET_CAN_FLY);
+        ((Player*)(target))->SetCanFly(true);
+    }
     else if (strncmp(args, "off", 4) == 0)
+    {
         data.SetOpcode(SMSG_MOVE_UNSET_CAN_FLY);
+        ((Player*)(target))->SetCanFly(false);
+    }
     else
     {
         SendSysMessage(LANG_USE_BOL);
@@ -6082,6 +6708,26 @@ bool ChatHandler::HandleInstanceStatsCommand(const char* /*args*/)
     return true;
 }
 
+bool ChatHandler::HandleInstanceStartCommand(const char * /*args*/)
+{
+    Player* pl = m_session->GetPlayer();
+	BattleGround *bg = pl->GetBattleGround();
+    if(!bg)
+        return false;
+    if(bg->GetTypeID(true))
+    {
+        bg->StartBattleGround();
+        bg->AddPlayer(pl);
+		return true;
+    }
+    else
+    {
+        PSendSysMessage("Map is not a battleground.");
+        SetSentErrorMessage(true);
+        return false;
+    }
+}
+
 bool ChatHandler::HandleInstanceSaveDataCommand(const char * /*args*/)
 {
     Player* pl = m_session->GetPlayer();
diff --git a/mangos/src/game/Mail.cpp b/Core/src/game/Mail.cpp
index f143862..5785530 100644
--- a/mangos/src/game/Mail.cpp
+++ b/Core/src/game/Mail.cpp
@@ -37,6 +37,7 @@
 #include "UpdateMask.h"
 #include "Unit.h"
 #include "Language.h"
+#include "AuctionHouseBot.h"
 #include "DBCStores.h"
 #include "BattleGroundMgr.h"
 #include "Item.h"
@@ -201,7 +202,7 @@ void WorldSession::HandleSendMail(WorldPacket & recv_data )
             return;
         }
 
-        if (item->IsBoundAccountWide() && item->IsSoulBound() && pl->GetSession()->GetAccountId() != rc_account)
+        if (item->IsBoundAccountWide() /*&& item->IsSoulBound() */&& pl->GetSession()->GetAccountId() != rc_account)
         {
             pl->SendMailResult(0, MAIL_SEND, MAIL_ERR_EQUIP_ERROR, EQUIP_ERR_ARTEFACTS_ONLY_FOR_OWN_CHARACTERS);
             return;
@@ -218,6 +219,13 @@ void WorldSession::HandleSendMail(WorldPacket & recv_data )
             pl->SendMailResult(0, MAIL_SEND, MAIL_ERR_CANT_SEND_WRAPPED_COD);
             return;
         }
+        
+        //When you send an item through the mailsystem, its no longer refundable
+        if (sWorld.getConfig(CONFIG_BOOL_MAIL_ITEM_REFUNDABLE))
+        {
+            if(item->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_REFUNDABLE))
+                item->RemoveFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_REFUNDABLE);
+        }
 
         items[i] = item;
     }
@@ -959,7 +967,10 @@ void MailDraft::SendReturnToSender(uint32 sender_acc, uint32 sender_guid, uint32
     uint32 deliver_delay = needItemDelay ? sWorld.getConfig(CONFIG_UINT32_MAIL_DELIVERY_DELAY) : 0;
 
     // will delete item or place to receiver mail list
-    SendMailTo(MailReceiver(receiver,receiver_guid), MailSender(MAIL_NORMAL, sender_guid), MAIL_CHECK_MASK_RETURNED, deliver_delay);
+    if (sender_guid == auctionbot.GetAHBplayerGUID())
+        SendMailTo(MailReceiver(receiver,receiver_guid), MailSender(MAIL_CREATURE, sender_guid), MAIL_CHECK_MASK_RETURNED, deliver_delay);
+    else
+        SendMailTo(MailReceiver(receiver,receiver_guid), MailSender(MAIL_NORMAL, sender_guid), MAIL_CHECK_MASK_RETURNED, deliver_delay);
 }
 /**
  * Sends a mail.
@@ -973,6 +984,14 @@ void MailDraft::SendMailTo(MailReceiver const& receiver, MailSender const& sende
 {
     Player* pReceiver = receiver.GetPlayer();               // can be NULL
 
+    if (receiver.GetPlayerGUIDLow() == auctionbot.GetAHBplayerGUID())
+    {
+        if (sender.GetMailMessageType() == MAIL_AUCTION && !m_items.empty())
+            deleteIncludedItems(true);
+
+        return;
+    }
+
     if (pReceiver)
         prepareItems(pReceiver);                            // generate mail template items
 
diff --git a/mangos/src/game/Makefile.am b/Core/src/game/Makefile.am
index f4ef789..7e400a3 100644
--- a/mangos/src/game/Makefile.am
+++ b/Core/src/game/Makefile.am
@@ -7,7 +7,7 @@
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
@@ -19,7 +19,7 @@
 ## Sub-directories to parse
 
 ## CPP flags for includes, defines, etc.
-AM_CPPFLAGS = $(MANGOS_INCLUDES) -I$(top_builddir)/src/shared -I$(srcdir) -I$(srcdir)/../../dep/include -I$(srcdir)/../framework -I$(srcdir)/../shared -I$(srcdir)/../shared/vmap -I$(srcdir)/../realmd -DSYSCONFDIR=\"$(sysconfdir)/\"
+AM_CPPFLAGS = $(MANGOS_INCLUDES) -I$(top_builddir)/src/shared -I$(srcdir) -I$(srcdir)/../../dep/tbb/include -I$(srcdir)/../../dep/include -I$(srcdir)/../framework -I$(srcdir)/../shared -I$(srcdir)/../shared/vmap -I$(srcdir)/../realmd -DSYSCONFDIR=\"$(sysconfdir)/\"
 
 ## Build MaNGOS game library as convenience library.
 #  All libraries will be convenience libraries. Might be changed to shared
@@ -37,6 +37,8 @@ libmangosgame_a_SOURCES = \
 	ArenaTeam.cpp \
 	ArenaTeam.h \
 	ArenaTeamHandler.cpp \
+	AuctionHouseBot.cpp \
+	AuctionHouseBot.h \
 	AuctionHouseHandler.cpp \
 	AuctionHouseMgr.cpp \
 	AuctionHouseMgr.h \
@@ -89,6 +91,10 @@ libmangosgame_a_SOURCES = \
 	Chat.cpp \
 	Chat.h \
 	ChatHandler.cpp \
+	ChatLexicsCutter.cpp \
+	ChatLexicsCutter.h \
+	ChatLog.cpp \
+	ChatLog.h \
 	CombatHandler.cpp \
 	ConfusedMovementGenerator.cpp \
 	ConfusedMovementGenerator.h \
@@ -180,6 +186,8 @@ libmangosgame_a_SOURCES = \
 	MapInstanced.h \
 	MapManager.cpp \
 	MapManager.h \
+    MapUpdater.cpp \
+    MapUpdater.h \
 	MapReference.h \
 	MapRefManager.h \
 	MiscHandler.cpp \
@@ -207,6 +215,23 @@ libmangosgame_a_SOURCES = \
 	ObjectPosSelector.h \
 	Opcodes.cpp \
 	Opcodes.h \
+	OutdoorPvP.cpp \
+	OutdoorPvP.h \
+	OutdoorPvPEP.cpp \
+	OutdoorPvPEP.h \
+	OutdoorPvPHP.cpp \
+	OutdoorPvPHP.h \
+	OutdoorPvPImpl.h \
+	OutdoorPvPMgr.cpp \
+	OutdoorPvPMgr.h \
+	OutdoorPvPNA.cpp \
+	OutdoorPvPNA.h \
+	OutdoorPvPSI.cpp \
+	OutdoorPvPSI.h \
+	OutdoorPvPTF.cpp \
+	OutdoorPvPTF.h \
+	OutdoorPvPZM.cpp \
+	OutdoorPvPZM.h \
 	Path.h \
 	PetAI.cpp \
 	PetAI.h \
@@ -216,6 +241,32 @@ libmangosgame_a_SOURCES = \
 	PetitionsHandler.cpp \
 	Player.cpp \
 	Player.h \
+	PlayerbotMgr.cpp \
+	PlayerbotMgr.h \
+	PlayerbotAI.cpp \
+	PlayerbotAI.h \
+	PlayerbotClassAI.cpp \
+	PlayerbotClassAI.h \
+	PlayerbotDeathKnightAI.cpp \
+	PlayerbotDeathKnightAI.h \
+	PlayerbotDruidAI.cpp \
+	PlayerbotDruidAI.h \
+	PlayerbotHunterAI.cpp \
+	PlayerbotHunterAI.h \
+	PlayerbotMageAI.cpp \
+	PlayerbotMageAI.h \
+	PlayerbotPaladinAI.cpp \
+	PlayerbotPaladinAI.h \
+	PlayerbotPriestAI.cpp \
+	PlayerbotPriestAI.h \
+	PlayerbotRogueAI.cpp \
+	PlayerbotRogueAI.h \
+	PlayerbotShamanAI.cpp \
+	PlayerbotShamanAI.h \
+	PlayerbotWarlockAI.cpp \
+	PlayerbotWarlockAI.h \
+	PlayerbotWarriorAI.cpp \
+	PlayerbotWarriorAI.h \
 	PlayerDump.cpp \
 	PlayerDump.h \
 	PointMovementGenerator.cpp \
@@ -240,6 +291,7 @@ libmangosgame_a_SOURCES = \
 	SpellAuras.cpp \
 	SpellAuras.h \
 	Spell.cpp \
+	SpellDBCHacks.cpp \
 	SpellEffects.cpp \
 	Spell.h \
 	SkillDiscovery.cpp \
@@ -296,7 +348,8 @@ libmangosgame_a_SOURCES = \
 	FollowerRefManager.h \
 	GroupReference.cpp \
 	GroupReference.h \
-	GroupRefManager.h
+	GroupRefManager.h \
+	ZoneScript.h
 
 ## Additional files to include when running 'make dist'
 #  Precompiled Headers for WIN
diff --git a/mangos/src/game/Map.cpp b/Core/src/game/Map.cpp
index bca4cca..b3bb009 100644
--- a/mangos/src/game/Map.cpp
+++ b/Core/src/game/Map.cpp
@@ -156,18 +156,27 @@ void Map::InitVisibilityDistance()
 template<class T>
 void Map::AddToGrid(T* obj, NGridType *grid, Cell const& cell)
 {
+    if (!grid)
+        return;
+
     (*grid)(cell.CellX(), cell.CellY()).template AddGridObject<T>(obj);
 }
 
 template<>
 void Map::AddToGrid(Player* obj, NGridType *grid, Cell const& cell)
 {
+    if (!grid)
+        return;
+
     (*grid)(cell.CellX(), cell.CellY()).AddWorldObject(obj);
 }
 
 template<>
 void Map::AddToGrid(Corpse *obj, NGridType *grid, Cell const& cell)
 {
+    if (!grid)
+        return;
+
     // add to world object registry in grid
     if(obj->GetType()!=CORPSE_BONES)
     {
@@ -183,6 +192,9 @@ void Map::AddToGrid(Corpse *obj, NGridType *grid, Cell const& cell)
 template<>
 void Map::AddToGrid(Creature* obj, NGridType *grid, Cell const& cell)
 {
+    if (!grid)
+        return;
+
     // add to world object registry in grid
     if(obj->isPet() || obj->isVehicle())
     {
@@ -200,18 +212,27 @@ void Map::AddToGrid(Creature* obj, NGridType *grid, Cell const& cell)
 template<class T>
 void Map::RemoveFromGrid(T* obj, NGridType *grid, Cell const& cell)
 {
+    if (!grid)
+        return;
+
     (*grid)(cell.CellX(), cell.CellY()).template RemoveGridObject<T>(obj);
 }
 
 template<>
 void Map::RemoveFromGrid(Player* obj, NGridType *grid, Cell const& cell)
 {
+    if (!grid)
+        return;
+
     (*grid)(cell.CellX(), cell.CellY()).RemoveWorldObject(obj);
 }
 
 template<>
 void Map::RemoveFromGrid(Corpse *obj, NGridType *grid, Cell const& cell)
 {
+    if (!grid)
+        return;
+
     // remove from world object registry in grid
     if(obj->GetType()!=CORPSE_BONES)
     {
@@ -457,7 +478,7 @@ void Map::MessageBroadcast(WorldObject *obj, WorldPacket *msg)
     cell.Visit(p, message, *this, *obj, GetVisibilityDistance());
 }
 
-void Map::MessageDistBroadcast(Player *player, WorldPacket *msg, float dist, bool to_self, bool own_team_only)
+void Map::MessageDistBroadcast(Player *player, WorldPacket *msg, float dist, bool to_self, bool own_team_only, bool enemyTeamOnly)
 {
     CellPair p = MaNGOS::ComputeCellPair(player->GetPositionX(), player->GetPositionY());
 
@@ -474,7 +495,7 @@ void Map::MessageDistBroadcast(Player *player, WorldPacket *msg, float dist, boo
     if( !loaded(GridPair(cell.data.Part.grid_x, cell.data.Part.grid_y)) )
         return;
 
-    MaNGOS::MessageDistDeliverer post_man(*player, msg, dist, to_self, own_team_only);
+    MaNGOS::MessageDistDeliverer post_man(*player, msg, dist, to_self, own_team_only, enemyTeamOnly);
     TypeContainerVisitor<MaNGOS::MessageDistDeliverer , WorldTypeMapContainer > message(post_man);
     cell.Visit(p, message, *this, *player, dist);
 }
@@ -503,6 +524,10 @@ void Map::MessageDistBroadcast(WorldObject *obj, WorldPacket *msg, float dist)
 
 bool Map::loaded(const GridPair &p) const
 {
+  // crash guard if x, y coordinates are outside grids
+  if ( (p.x_coord >= MAX_NUMBER_OF_GRIDS) || (p.y_coord >= MAX_NUMBER_OF_GRIDS) )
+    return false;  // consider already loaded, skip
+
     return ( getNGrid(p.x_coord, p.y_coord) && isGridObjectDataLoaded(p.x_coord, p.y_coord) );
 }
 
@@ -547,9 +572,9 @@ void Map::Update(const uint32 &t_diff)
         CellArea area = Cell::CalculateCellArea(*plr, GetVisibilityDistance());
         area.ResizeBorders(begin_cell, end_cell);
 
-        for(uint32 x = begin_cell.x_coord; x <= end_cell.x_coord; ++x)
+        for(uint32 x = begin_cell.x_coord; x < end_cell.x_coord; ++x)
         {
-            for(uint32 y = begin_cell.y_coord; y <= end_cell.y_coord; ++y)
+            for(uint32 y = begin_cell.y_coord; y < end_cell.y_coord; ++y)
             {
                 // marked cells are those that have been visited
                 // don't visit the same cell twice
@@ -595,9 +620,9 @@ void Map::Update(const uint32 &t_diff)
             begin_cell << 1; begin_cell -= 1;               // upper left
             end_cell >> 1; end_cell += 1;                   // lower right
 
-            for(uint32 x = begin_cell.x_coord; x <= end_cell.x_coord; ++x)
+            for(uint32 x = begin_cell.x_coord; x < end_cell.x_coord; ++x)
             {
-                for(uint32 y = begin_cell.y_coord; y <= end_cell.y_coord; ++y)
+                for(uint32 y = begin_cell.y_coord; y < end_cell.y_coord; ++y)
                 {
                     // marked cells are those that have been visited
                     // don't visit the same cell twice
@@ -684,7 +709,7 @@ void Map::Remove(Player *player, bool remove)
     UpdateObjectVisibility(player,cell,p);
     UpdateObjectsVisibilityFor(player,cell,p);
 
-    player->ResetMap();
+    // player->ResetMap();
     if( remove )
         DeleteFromWorld(player);
 }
@@ -789,6 +814,17 @@ Map::CreatureRelocation(Creature *creature, float x, float y, float z, float ang
     {
         DEBUG_FILTER_LOG(LOG_FILTER_CREATURE_MOVES, "Creature (GUID: %u Entry: %u) added to moving list from grid[%u,%u]cell[%u,%u] to grid[%u,%u]cell[%u,%u].", creature->GetGUIDLow(), creature->GetEntry(), old_cell.GridX(), old_cell.GridY(), old_cell.CellX(), old_cell.CellY(), new_cell.GridX(), new_cell.GridY(), new_cell.CellX(), new_cell.CellY());
 
+        // hack for eye of acherus part 1
+        if(creature->isCharmed())
+        {
+            NGridType* oldGrid = getNGrid(old_cell.GridX(), old_cell.GridY());
+            RemoveFromGrid(creature->GetCharmerOrOwnerPlayerOrPlayerItself(), oldGrid, old_cell);
+            if(!old_cell.DiffGrid(new_cell))
+                AddToGrid(creature->GetCharmerOrOwnerPlayerOrPlayerItself(), oldGrid, new_cell);
+            else
+                EnsureGridLoadedAtEnter(new_cell, creature->GetCharmerOrOwnerPlayerOrPlayerItself());
+        }
+
         // do move or do move to respawn or remove creature if previous all fail
         if(CreatureCellRelocation(creature,new_cell))
         {
@@ -797,6 +833,23 @@ Map::CreatureRelocation(Creature *creature, float x, float y, float z, float ang
 
             // in diffcell/diffgrid case notifiers called in Creature::Update
             creature->SetNeedNotify();
+
+        // hack for eye of acherus part 2
+        if(creature->isCharmed())
+        {
+            creature->InterruptSpell(CURRENT_CHANNELED_SPELL);
+            UpdateObjectVisibility(creature->GetCharmerOrOwnerPlayerOrPlayerItself(), new_cell, new_val);
+            UpdateObjectsVisibilityFor(creature->GetCharmerOrOwnerPlayerOrPlayerItself(), new_cell, new_val);
+            PlayerRelocationNotify(creature->GetCharmerOrOwnerPlayerOrPlayerItself(), new_cell, new_val);
+
+            bool same_cell = (new_cell == old_cell);
+            NGridType* newGrid = getNGrid(new_cell.GridX(), new_cell.GridY());
+            if(!same_cell && newGrid->GetGridState()!= GRID_STATE_ACTIVE)
+            {
+                ResetGridExpiry(*newGrid, 0.1f);
+                newGrid->SetGridState(GRID_STATE_ACTIVE);
+            }
+        }
         }
         else
         {
@@ -1110,10 +1163,13 @@ uint16 Map::GetAreaFlag(float x, float y, float z) const
             if (x > 5568.0f && x < 6116.0f && y > 282.0f && y < 982.0f && z > 563.0f)
             {
                 // Krasus' Landing (Dalaran), fast check
-                if (x > 5758.77f && x < 5869.03f && y < 510.46f)
+                if (x > 5758.77f && x < 5869.03f && y < 555.75f)
                 {
                     // Krasus' Landing (Dalaran), with open east side
-                    if (y < 449.33f || (x-5813.9f)*(x-5813.9f)+(y-449.33f)*(y-449.33f) < 1864.0f)
+                    if (y < 449.33f ||
+                       (x-5813.90f)*(x-5813.90f)+(y-449.33f)*(y-449.33f) < 1864.0f ||
+                       (x-5824.10f)*(x-5824.10f)+(y-532.27f)*(y-532.27f) < 600.00f ||
+                       (x-5825.84f)*(x-5825.84f)+(y-493.00f)*(y-493.00f) < 462.00f)
                     {
                         areaflag = 2531;                    // Note: also 2633, possible one flight allowed and other not allowed case
                         break;
@@ -1793,7 +1849,7 @@ bool InstanceMap::Add(Player *player)
                 if(playerBind->save != mapSave)
                 {
                     sLog.outError("InstanceMap::Add: player %s(%d) is permanently bound to instance %d,%d,%d,%d,%d,%d but he is being put in instance %d,%d,%d,%d,%d,%d", player->GetName(), player->GetGUIDLow(), playerBind->save->GetMapId(), playerBind->save->GetInstanceId(), playerBind->save->GetDifficulty(), playerBind->save->GetPlayerCount(), playerBind->save->GetGroupCount(), playerBind->save->CanReset(), mapSave->GetMapId(), mapSave->GetInstanceId(), mapSave->GetDifficulty(), mapSave->GetPlayerCount(), mapSave->GetGroupCount(), mapSave->CanReset());
-                    ASSERT(false);
+                    player->RepopAtGraveyard();
                 }
             }
             else
@@ -1826,7 +1882,7 @@ bool InstanceMap::Add(Player *player)
                                 sLog.outError("GroupBind save players: %d, group count: %d", groupBind->save->GetPlayerCount(), groupBind->save->GetGroupCount());
                             else
                                 sLog.outError("GroupBind save NULL");
-                            ASSERT(false);
+                            player->RepopAtGraveyard();
                         }
                         // if the group/leader is permanently bound to the instance
                         // players also become permanently bound when they enter
@@ -3007,23 +3063,42 @@ WorldObject* Map::GetWorldObject(ObjectGuid guid)
 void Map::SendObjectUpdates()
 {
     UpdateDataMapType update_players;
+    for(std::set<Object*>::const_iterator it = i_objectsToClientUpdate.begin();it!= i_objectsToClientUpdate.end();++it)
+        (*it)->BuildUpdateData(update_players);
 
-    while(!i_objectsToClientUpdate.empty())
-    {
-        Object* obj = *i_objectsToClientUpdate.begin();
-        i_objectsToClientUpdate.erase(i_objectsToClientUpdate.begin());
-        obj->BuildUpdateData(update_players);
-    }
+    i_objectsToClientUpdate.clear();
 
     WorldPacket packet;                                     // here we allocate a std::vector with a size of 0x10000
     for(UpdateDataMapType::iterator iter = update_players.begin(); iter != update_players.end(); ++iter)
     {
-        iter->second.BuildPacket(&packet);
-        iter->first->GetSession()->SendPacket(&packet);
+        if (iter->second.BuildPacket(&packet))
+            iter->first->GetSession()->SendPacket(&packet);
         packet.clear();                                     // clean the string
     }
 }
 
+bool Map::IsNextZcoordOK(float x, float y, float oldZ, float maxDiff) const
+{
+    // The fastest way to get an accurate result 90% of the time.
+    // Better result can be obtained like 99% accuracy with a ray light, but the cost is too high and the code is too long.
+    maxDiff = maxDiff >= 100.0f ? 10.0f : sqrtf(maxDiff);
+    bool useVmaps = false;
+    if( GetHeight(x, y, oldZ+2.0f, false) <  GetHeight(x, y, oldZ+2.0f, true) ) // check use of vmaps
+        useVmaps = true;
+
+    float newZ = GetHeight(x, y, oldZ+2.0f, useVmaps);
+
+    if (fabs(newZ-oldZ) > maxDiff)                              // bad...
+    {
+        useVmaps = !useVmaps;                                     // try change vmap use
+        newZ = GetHeight(x, y, oldZ+2.0f, useVmaps);
+
+        if (fabs(newZ-oldZ) > maxDiff)
+            return false;
+    }
+    return true;
+}
+
 uint32 Map::GenerateLocalLowGuid(HighGuid guidhigh)
 {
     // TODO: for map local guid counters possible force reload map instead shutdown server at guid counter overflow
diff --git a/mangos/src/game/Map.h b/Core/src/game/Map.h
index 5193d2c..cc86834 100644
--- a/mangos/src/game/Map.h
+++ b/Core/src/game/Map.h
@@ -38,7 +38,6 @@
 #include <bitset>
 #include <list>
 
-class Creature;
 class Unit;
 class WorldPacket;
 class InstanceData;
@@ -106,7 +105,7 @@ class MANGOS_DLL_SPEC Map : public GridRefManager<NGridType>, public MaNGOS::Obj
 
         void MessageBroadcast(Player *, WorldPacket *, bool to_self);
         void MessageBroadcast(WorldObject *, WorldPacket *);
-        void MessageDistBroadcast(Player *, WorldPacket *, float dist, bool to_self, bool own_team_only = false);
+        void MessageDistBroadcast(Player *, WorldPacket *, float dist, bool to_self, bool own_team_only = false, bool enemyTeamOnly = false);
         void MessageDistBroadcast(WorldObject *, WorldPacket *, float dist);
 
         float GetVisibilityDistance() const { return m_VisibleDistance; }
@@ -121,7 +120,8 @@ class MANGOS_DLL_SPEC Map : public GridRefManager<NGridType>, public MaNGOS::Obj
         bool IsRemovalGrid(float x, float y) const
         {
             GridPair p = MaNGOS::ComputeGridPair(x, y);
-            return( !getNGrid(p.x_coord, p.y_coord) || getNGrid(p.x_coord, p.y_coord)->GetGridState() == GRID_STATE_REMOVAL );
+            NGridType* grid = getNGrid(p.x_coord, p.y_coord);
+            return !grid || grid->GetGridState() == GRID_STATE_REMOVAL;
         }
 
         bool IsLoaded(float x, float y) const
@@ -131,7 +131,13 @@ class MANGOS_DLL_SPEC Map : public GridRefManager<NGridType>, public MaNGOS::Obj
         }
 
         bool GetUnloadLock(const GridPair &p) const { return getNGrid(p.x_coord, p.y_coord)->getUnloadLock(); }
-        void SetUnloadLock(const GridPair &p, bool on) { getNGrid(p.x_coord, p.y_coord)->setUnloadExplicitLock(on); }
+        void SetUnloadLock(const GridPair &p, bool on)
+        {
+            NGridType *grid = getNGrid(p.x_coord, p.y_coord);
+
+            if (grid)
+                grid->setUnloadExplicitLock(on);
+        }
         void LoadGrid(const Cell& cell, bool no_unload = false);
         bool UnloadGrid(const uint32 &x, const uint32 &y, bool pForce);
         virtual void UnloadAll(bool pForce);
@@ -207,6 +213,7 @@ class MANGOS_DLL_SPEC Map : public GridRefManager<NGridType>, public MaNGOS::Obj
         bool IsBattleGround() const { return i_mapEntry && i_mapEntry->IsBattleGround(); }
         bool IsBattleArena() const { return i_mapEntry && i_mapEntry->IsBattleArena(); }
         bool IsBattleGroundOrArena() const { return i_mapEntry && i_mapEntry->IsBattleGroundOrArena(); }
+        bool IsNextZcoordOK(float x, float y, float oldZ, float maxDiff = 5.0f) const;
 
         void AddObjectToRemoveList(WorldObject *obj);
 
@@ -294,21 +301,38 @@ class MANGOS_DLL_SPEC Map : public GridRefManager<NGridType>, public MaNGOS::Obj
 
         NGridType* getNGrid(uint32 x, uint32 y) const
         {
-            ASSERT(x < MAX_NUMBER_OF_GRIDS);
-            ASSERT(y < MAX_NUMBER_OF_GRIDS);
+            if (x >= MAX_NUMBER_OF_GRIDS || y >= MAX_NUMBER_OF_GRIDS)
+                return NULL;
+
             return i_grids[x][y];
         }
 
-        bool isGridObjectDataLoaded(uint32 x, uint32 y) const { return getNGrid(x,y)->isGridObjectDataLoaded(); }
-        void setGridObjectDataLoaded(bool pLoaded, uint32 x, uint32 y) { getNGrid(x,y)->setGridObjectDataLoaded(pLoaded); }
+        bool isGridObjectDataLoaded(uint32 x, uint32 y) const
+        {
+            NGridType* grid = getNGrid(x, y);
+            return grid ? grid->isGridObjectDataLoaded() : false;
+        }
+
+        void setGridObjectDataLoaded(bool pLoaded, uint32 x, uint32 y)
+        {
+           NGridType* grid = getNGrid(x, y);
 
+           if (grid)
+               grid->setGridObjectDataLoaded(pLoaded);
+        }
         void setNGrid(NGridType* grid, uint32 x, uint32 y);
         void ScriptsProcess();
 
         void SendObjectUpdates();
         std::set<Object *> i_objectsToClientUpdate;
     protected:
-        void SetUnloadReferenceLock(const GridPair &p, bool on) { getNGrid(p.x_coord, p.y_coord)->setUnloadReferenceLock(on); }
+        void SetUnloadReferenceLock(const GridPair &p, bool on)
+        { 
+           NGridType* grid = getNGrid(p.x_coord, p.y_coord);
+      
+           if (grid)
+               grid->setUnloadReferenceLock(on);
+        }
 
         typedef MaNGOS::ObjectLevelLockable<Map, ACE_Thread_Mutex>::Lock Guard;
 
diff --git a/mangos/src/game/MapManager.cpp b/Core/src/game/MapManager.cpp
index 5f9622d..584f3a7 100644
--- a/mangos/src/game/MapManager.cpp
+++ b/Core/src/game/MapManager.cpp
@@ -16,6 +16,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#include <omp.h>
 #include "MapManager.h"
 #include "InstanceSaveMgr.h"
 #include "Policies/SingletonImp.h"
@@ -24,6 +25,7 @@
 #include "Transports.h"
 #include "GridDefines.h"
 #include "MapInstanced.h"
+#include "Config/ConfigEnv.h"
 #include "DestinationHolderImp.h"
 #include "World.h"
 #include "CellImpl.h"
@@ -51,8 +53,7 @@ MapManager::~MapManager()
     DeleteStateMachine();
 }
 
-void
-MapManager::Initialize()
+void MapManager::Initialize()
 {
     InitStateMachine();
     InitMaxInstanceId();
@@ -89,8 +90,7 @@ void MapManager::InitializeVisibilityDistanceInfo()
         (*iter).second->InitVisibilityDistance();
 }
 
-Map*
-MapManager::_createBaseMap(uint32 id)
+Map* MapManager::_createBaseMap(uint32 id)
 {
     Map *m = _findMap(id);
 
@@ -233,20 +233,30 @@ bool MapManager::CanPlayerEnter(uint32 mapid, Player* player)
 
 void MapManager::DeleteInstance(uint32 mapid, uint32 instanceId)
 {
+    Guard guard(*this);
+    
     Map *m = _createBaseMap(mapid);
     if (m && m->Instanceable())
         ((MapInstanced*)m)->DestroyInstance(instanceId);
 }
 
-void
-MapManager::Update(uint32 diff)
+void MapManager::Update(uint32 diff)
 {
     i_timer.Update(diff);
     if( !i_timer.Passed() )
         return;
 
-    for(MapMapType::iterator iter=i_maps.begin(); iter != i_maps.end(); ++iter)
-        iter->second->Update((uint32)i_timer.GetCurrent());
+    MapMapType::iterator iter = i_maps.begin();
+    std::vector<Map*> update_queue(i_maps.size());
+
+    int omp_set_num_threads(sWorld.getConfig(CONFIG_UINT32_NUMTHREADS));
+
+    for (uint32 i = 0; iter != i_maps.end(); ++iter, ++i)
+    update_queue[i] = iter->second;
+
+    #pragma omp parallel for schedule(dynamic) private(i) shared(update_queue)
+    for (uint32 i = 0; i < i_maps.size(); ++i)
+        update_queue[i]->Update(i_timer.GetCurrent());
 
     for (TransportSet::iterator iter = m_Transports.begin(); iter != m_Transports.end(); ++iter)
         (*iter)->Update(i_timer.GetCurrent());
@@ -303,6 +313,8 @@ void MapManager::InitMaxInstanceId()
 
 uint32 MapManager::GetNumInstances()
 {
+    Guard guard(*this);
+    
     uint32 ret = 0;
     for(MapMapType::iterator itr = i_maps.begin(); itr != i_maps.end(); ++itr)
     {
@@ -317,6 +329,8 @@ uint32 MapManager::GetNumInstances()
 
 uint32 MapManager::GetNumPlayersInInstances()
 {
+    Guard guard(*this);
+    
     uint32 ret = 0;
     for(MapMapType::iterator itr = i_maps.begin(); itr != i_maps.end(); ++itr)
     {
diff --git a/mangos/src/game/MapManager.h b/Core/src/game/MapManager.h
index c48f821..3a15f80 100644
--- a/mangos/src/game/MapManager.h
+++ b/Core/src/game/MapManager.h
@@ -25,6 +25,7 @@
 #include "Common.h"
 #include "Map.h"
 #include "GridStates.h"
+#include "MapUpdater.h"
 
 class Transport;
 class BattleGround;
@@ -161,6 +162,7 @@ class MANGOS_DLL_DECL MapManager : public MaNGOS::Singleton<MapManager, MaNGOS::
         IntervalTimer i_timer;
 
         uint32 i_MaxInstanceId;
+        MapUpdater m_updater;
 };
 
 #define sMapMgr MapManager::Instance()
diff --git a/Core/src/game/MapUpdater.cpp b/Core/src/game/MapUpdater.cpp
new file mode 100644
index 0000000..c94246c
--- /dev/null
+++ b/Core/src/game/MapUpdater.cpp
@@ -0,0 +1,130 @@
+#include "MapUpdater.h"
+
+#include "DelayExecutor.h"
+#include "Map.h"
+#include "Database/DatabaseEnv.h"
+
+#include <ace/Guard_T.h>
+#include <ace/Method_Request.h>
+
+//the reason this things are here is that i want to make
+//the netcode patch and the multithreaded maps independant
+//once they are merged 1 class should be used
+class  WDBThreadStartReq1 : public ACE_Method_Request
+{
+  public:
+    WDBThreadStartReq1 () { }
+    virtual int
+    call (void)
+    {
+        WorldDatabase.ThreadStart ();
+        return 0;
+    }
+};
+
+class  WDBThreadEndReq1 : public ACE_Method_Request
+{
+  public:
+    WDBThreadEndReq1 () { }
+    virtual int
+    call (void)
+    {
+        WorldDatabase.ThreadEnd ();
+        return 0;
+    }
+};
+
+class MapUpdateRequest : public ACE_Method_Request
+{
+  public:
+    Map& m_map;
+    MapUpdater& m_updater;
+    ACE_UINT32 m_diff;
+    MapUpdateRequest (Map& m,MapUpdater& u,ACE_UINT32 d) : m_map(m),m_updater(u),m_diff(d) { }
+    virtual int
+    call (void)
+    {
+        m_map.Update (m_diff);
+        m_updater.update_finished ();
+        return 0;
+    }
+};
+
+MapUpdater::MapUpdater () :
+m_mutex (),
+m_condition (m_mutex),
+m_executor (),
+pedning_requests (0)
+{
+    return;
+}
+
+MapUpdater::~MapUpdater ()
+{
+    this->deactivate ();
+}
+
+int MapUpdater::activate (size_t num_threads)
+{
+    return this->m_executor.activate (static_cast<int> (num_threads), new WDBThreadStartReq1, new WDBThreadEndReq1);
+}
+
+int MapUpdater::deactivate (void)
+{
+    this->wait ();
+
+    return this->m_executor.deactivate ();
+}
+
+int MapUpdater::wait ()
+{
+    ACE_GUARD_RETURN(ACE_Thread_Mutex,guard,this->m_mutex,-1);
+
+    while(this->pedning_requests > 0)
+        this->m_condition.wait ();
+
+    return 0;
+}
+
+int MapUpdater::schedule_update(Map& map, ACE_UINT32 diff)
+{
+    ACE_GUARD_RETURN(ACE_Thread_Mutex,guard,this->m_mutex,-1);
+
+    ++this->pedning_requests;
+
+    if( this->m_executor.execute (new MapUpdateRequest(map,*this,diff)) == -1)
+    {
+        ACE_DEBUG ((LM_ERROR, ACE_TEXT ("(%t) \n"), ACE_TEXT ("Failed to schedule Map Update")));
+
+        --this->pedning_requests;
+        return -1;
+    }
+
+    return 0;
+}
+
+bool MapUpdater::activated ()
+{
+    return m_executor.activated();
+}
+
+void MapUpdater::update_finished ()
+{
+    ACE_GUARD (ACE_Thread_Mutex, guard, this->m_mutex);
+
+    if (this->pedning_requests == 0)
+    {
+      ACE_ERROR ((LM_ERROR,
+                  ACE_TEXT ("(%t)\n"),
+                  ACE_TEXT ("MapUpdater::update_finished BUG, report to devs")));
+
+      return;
+    }
+
+  --this->pedning_requests;
+
+  //TODO can more than one thread call wait (), it shouldnt happen
+  //however I ensure if in future more than 1 thread call it by
+  //using broadcast instead of signal ()
+  this->m_condition.broadcast ();
+}
diff --git a/Core/src/game/MapUpdater.h b/Core/src/game/MapUpdater.h
new file mode 100644
index 0000000..9d402f9
--- /dev/null
+++ b/Core/src/game/MapUpdater.h
@@ -0,0 +1,46 @@
+#ifndef _MAP_UPDATER_H_INCLUDED
+#define _MAP_UPDATER_H_INCLUDED
+
+
+#include <ace/Thread_Mutex.h>
+#include <ace/Condition_Thread_Mutex.h>
+
+#include "DelayExecutor.h"
+
+class Map;
+
+class MapUpdater
+{
+  public:
+    MapUpdater ();
+    virtual ~MapUpdater ();
+
+    friend class MapUpdateRequest;
+
+    /// schedule update on a map, the update will start
+    /// as soon as possible ,
+    /// it may even start before the call returns
+    int schedule_update(Map& map, ACE_UINT32 diff);
+
+    /// Wait untill all pending updates finish
+    int wait ();
+
+    /// Start the worker threads
+    int activate (size_t num_threads);
+
+    /// Stop the worker threads
+    int deactivate (void);
+
+    bool activated ();
+
+  private:
+    /// hook called by worker threads
+    void update_finished ();
+
+    DelayExecutor m_executor;
+    ACE_Condition_Thread_Mutex m_condition;
+    ACE_Thread_Mutex m_mutex;
+    size_t pedning_requests;
+};
+
+#endif //_MAP_UPDATER_H_INCLUDED
diff --git a/mangos/src/game/MiscHandler.cpp b/Core/src/game/MiscHandler.cpp
index bf03a30..eb8a6d0 100644
--- a/mangos/src/game/MiscHandler.cpp
+++ b/Core/src/game/MiscHandler.cpp
@@ -38,6 +38,7 @@
 #include "ObjectAccessor.h"
 #include "Object.h"
 #include "BattleGround.h"
+#include "OutdoorPvP.h"
 #include "Pet.h"
 #include "SocialMgr.h"
 #include "DBCEnums.h"
@@ -267,6 +268,7 @@ void WorldSession::HandleLogoutRequestOpcode( WorldPacket & /*recv_data*/ )
     //Can not logout if...
     if( GetPlayer()->isInCombat() ||                        //...is in combat
         GetPlayer()->duel         ||                        //...is in Duel
+        GetPlayer()->GetVehicleGUID() ||                    //...is in vehicle
                                                             //...is jumping ...is falling
         GetPlayer()->m_movementInfo.HasMovementFlag(MovementFlags(MOVEFLAG_FALLING | MOVEFLAG_FALLINGFAR)))
     {
@@ -737,6 +739,12 @@ void WorldSession::HandleAreaTriggerOpcode(WorldPacket & recv_data)
         return;
     }
 
+    if(OutdoorPvP * pvp = GetPlayer()->GetOutdoorPvP())
+    {
+        if(pvp->HandleAreaTrigger(_player, Trigger_ID))
+            return;
+    }
+
     // NULL if all values default (non teleport trigger)
     AreaTrigger const* at = sObjectMgr.GetAreaTrigger(Trigger_ID);
     if(!at)
@@ -1391,6 +1399,14 @@ void WorldSession::HandleSetDungeonDifficultyOpcode( WorldPacket & recv_data )
     {
         if(pGroup->IsLeader(_player->GetGUID()))
         {
+            //do not let set dungeon difficulty if any one in this group in dungeon
+            Group::MemberSlotList g_members = pGroup->GetMemberSlots();
+            for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+            {
+                Player *gm_member = sObjectMgr.GetPlayer(itr->guid);
+                if (gm_member && gm_member->GetMap() && gm_member->GetMap()->IsDungeon())
+                    return;
+            }
             // the difficulty is set even if the instances can't be reset
             //_player->SendDungeonDifficulty(true);
             pGroup->ResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, false, _player);
@@ -1435,6 +1451,14 @@ void WorldSession::HandleSetRaidDifficultyOpcode( WorldPacket & recv_data )
     {
         if(pGroup->IsLeader(_player->GetGUID()))
         {
+            //do not let set dungeon difficulty if any one in this group in dungeon
+            Group::MemberSlotList g_members = pGroup->GetMemberSlots();
+            for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+            {
+                Player *gm_member = sObjectMgr.GetPlayer(itr->guid);
+                if (gm_member && gm_member->GetMap() && gm_member->GetMap()->IsDungeon())
+                    return;
+            }
             // the difficulty is set even if the instances can't be reset
             //_player->SendDungeonDifficulty(true);
             pGroup->ResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, true, _player);
@@ -1465,8 +1489,14 @@ void WorldSession::HandleCancelMountAuraOpcode( WorldPacket & /*recv_data*/ )
         return;
     }
 
-    _player->Unmount();
-    _player->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
+    if ((sWorld.getConfig(CONFIG_BOOL_ALLOW_FLYING_MOUNTS_EVERYWHERE))
+        && _player->HasAuraTypeFlyingSpell())
+        _player->SetFlyingMountTimer();
+    else
+    {
+        _player->Unmount();
+        _player->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
+    }
 }
 
 void WorldSession::HandleMoveSetCanFlyAckOpcode( WorldPacket & recv_data )
diff --git a/mangos/src/game/MotionMaster.cpp b/Core/src/game/MotionMaster.cpp
index c43ce0f..233ba16 100644
--- a/mangos/src/game/MotionMaster.cpp
+++ b/Core/src/game/MotionMaster.cpp
@@ -65,7 +65,10 @@ MotionMaster::UpdateMotion(uint32 diff)
 {
     if( i_owner->hasUnitState(UNIT_STAT_CAN_NOT_MOVE) )
         return;
-    ASSERT( !empty() );
+    //ASSERT( !empty() );
+	if(empty())
+	    return;
+		
     m_cleanFlag |= MMCF_UPDATE;
     if (!top()->Update(*i_owner, diff))
     {
@@ -112,7 +115,9 @@ MotionMaster::DirectClean(bool reset, bool all)
 
     if (!all && reset)
     {
-        ASSERT( !empty() );
+        //ASSERT( !empty() );
+		if(empty())
+		    return;
         top()->Reset(*i_owner);
     }
 }
@@ -144,7 +149,7 @@ MotionMaster::DelayedClean(bool reset, bool all)
 void
 MotionMaster::DirectExpire(bool reset)
 {
-    if (empty() || size() == 1)
+    if (size() <= 1)
         return;
 
     MovementGenerator *curr = top();
diff --git a/mangos/src/game/MovementHandler.cpp b/Core/src/game/MovementHandler.cpp
index b4601e9..b9a0da0 100644
--- a/mangos/src/game/MovementHandler.cpp
+++ b/Core/src/game/MovementHandler.cpp
@@ -31,6 +31,183 @@
 #include "WaypointMovementGenerator.h"
 #include "InstanceSaveMgr.h"
 #include "ObjectMgr.h"
+#include "World.h"
+#include "Language.h"
+
+//#define __ANTI_DEBUG__
+
+#ifdef __ANTI_DEBUG__
+#include "Chat.h"
+std::string FlagsToStr(const uint32 Flags)
+{
+    std::string Ret="";
+    if(Flags==0)
+    {
+        Ret="None";
+        return Ret;
+    }
+
+    if(Flags & MOVEMENTFLAG_FORWARD)
+    {   Ret+="FW "; }
+    if(Flags & MOVEMENTFLAG_BACKWARD)
+    {   Ret+="BW "; }
+    if(Flags & MOVEMENTFLAG_STRAFE_LEFT)
+    {   Ret+="STL ";    }
+    if(Flags & MOVEMENTFLAG_STRAFE_RIGHT)
+    {   Ret+="STR ";    }
+    if(Flags & MOVEMENTFLAG_LEFT)
+    {   Ret+="LF "; }
+    if(Flags & MOVEMENTFLAG_RIGHT)
+    {   Ret+="RI "; }
+    if(Flags & MOVEMENTFLAG_PITCH_UP)
+    {   Ret+="PTUP ";   }
+    if(Flags & MOVEMENTFLAG_PITCH_DOWN)
+    {   Ret+="PTDW ";   }
+    if(Flags & MOVEMENTFLAG_WALK_MODE)
+    {   Ret+="WALK ";   }
+    if(Flags & MOVEMENTFLAG_ONTRANSPORT)
+    {   Ret+="TRANS ";  }
+    if(Flags & MOVEMENTFLAG_LEVITATING)
+    {   Ret+="LEVI ";   }
+    if(Flags & MOVEMENTFLAG_FLY_UNK1)
+    {   Ret+="FLYUNK1 ";    }
+    if(Flags & MOVEMENTFLAG_JUMPING)
+    {   Ret+="JUMP ";   }
+    if(Flags & MOVEMENTFLAG_UNK4)
+    {   Ret+="UNK4 ";   }
+    if(Flags & MOVEMENTFLAG_FALLING)
+    {   Ret+="FALL ";   }
+    if(Flags & MOVEMENTFLAG_SWIMMING)
+    {   Ret+="SWIM ";   }
+    if(Flags & MOVEMENTFLAG_FLY_UP)
+    {   Ret+="FLYUP ";  }
+    if(Flags & MOVEMENTFLAG_CAN_FLY)
+    {   Ret+="CFLY ";   }
+    if(Flags & MOVEMENTFLAG_FLYING)
+    {   Ret+="FLY ";    }
+    if(Flags & MOVEMENTFLAG_FLYING2)
+    {   Ret+="FLY2 ";   }
+    if(Flags & MOVEMENTFLAG_WATERWALKING)
+    {   Ret+="WTWALK "; }
+    if(Flags & MOVEMENTFLAG_SAFE_FALL)
+    {   Ret+="SAFE ";   }
+   if(Flags & MOVEMENTFLAG_UNK3)
+    {   Ret+="UNK3 ";   }
+    if(Flags & MOVEMENTFLAG_SPLINE)
+    {   Ret+="SPLINE ";     }
+    if(Flags & MOVEMENTFLAG_SPLINE2)
+    {   Ret+="SPLINE2 ";    }
+
+    return Ret;
+}
+#endif // __ANTI_DEBUG__
+
+bool WorldSession::Anti__ReportCheat(const char* Reason,float Speed,const char* Op,float Val1,uint32 Val2)
+{
+    if(!Reason)
+    {
+        sLog.outError("Anti__ReportCheat: Missing Reason parameter!");
+        return false;
+    }
+    const char* Player=GetPlayer()->GetName();
+    uint32 Acc=GetPlayer()->GetSession()->GetAccountId();
+    uint32 Map=GetPlayer()->GetMapId();
+    if(!Player)
+    {
+        sLog.outError("Anti__ReportCheat: Player with no name?!?");
+        return false;
+    }
+
+    QueryResult *Res=CharacterDatabase.PQuery("SELECT speed,Val1 FROM cheaters WHERE player='%s' AND reason LIKE '%s' AND Map='%u' AND last_date >= NOW()-300",Player,Reason,Map);
+    if(Res)
+    {
+        Field* Fields = Res->Fetch();
+
+        std::stringstream Query;
+        Query << "UPDATE cheaters SET count=count+1,last_date=NOW()";
+        Query.precision(5);
+        if(Speed>0.0f && Speed > Fields[0].GetFloat())
+        {
+            Query << ",speed='";
+            Query << std::fixed << Speed;
+            Query << "'";
+        }
+
+        if(Val1>0.0f && Val1 > Fields[1].GetFloat())
+        {
+            Query << ",Val1='";
+            Query << std::fixed << Val1;
+            Query << "'";
+        }
+
+        Query << " WHERE player='" << Player << "' AND reason='" << Reason << "' AND Map='" << Map << "' AND last_date >= NOW()-300 ORDER BY entry DESC LIMIT 1";
+
+        CharacterDatabase.Execute(Query.str().c_str());
+        delete Res;
+    }
+    else
+    {
+        if(!Op)
+        {   Op="";  }
+        std::stringstream Pos;
+        Pos << "OldPos: " << GetPlayer()->GetPositionX() << " " << GetPlayer()->GetPositionY() << " "
+            << GetPlayer()->GetPositionZ();
+        CharacterDatabase.PExecute("INSERT INTO cheaters (player,acctid,reason,speed,count,first_date,last_date,`Op`,Val1,Val2,Map,Pos,Level) "
+                                   "VALUES ('%s','%u','%s','%f','1',NOW(),NOW(),'%s','%f','%u','%u','%s','%u')",
+                                   Player,Acc,Reason,Speed,Op,Val1,Val2,Map,
+                                   Pos.str().c_str(),GetPlayer()->getLevel());
+    }
+
+    if(sWorld.GetMvAnticheatKill() && GetPlayer()->isAlive())
+    {
+        GetPlayer()->DealDamage(GetPlayer(), GetPlayer()->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+    }
+    if(sWorld.GetMvAnticheatKick())
+    {
+        GetPlayer()->GetSession()->KickPlayer();
+    }
+    if(sWorld.GetMvAnticheatBan() & 1)
+    {
+        sWorld.BanAccount(BAN_CHARACTER,Player,sWorld.GetMvAnticheatBanTime(),"Cheat","Anticheat");
+    }
+    if(sWorld.GetMvAnticheatBan() & 2)
+    {
+        QueryResult *result = loginDatabase.PQuery("SELECT last_ip FROM account WHERE id=%u", Acc);
+        if(result)
+        {
+
+            Field *fields = result->Fetch();
+            std::string LastIP = fields[0].GetCppString();
+            if(!LastIP.empty())
+            {
+                sWorld.BanAccount(BAN_IP,LastIP,sWorld.GetMvAnticheatBanTime(),"Cheat","Anticheat");
+            }
+            delete result;
+        }
+    }
+    return true;
+}
+
+bool WorldSession::Anti__CheatOccurred(uint32 CurTime,const char* Reason,float Speed,const char* Op, float Val1,uint32 Val2)
+{
+    if(!Reason)
+    {
+        sLog.outError("Anti__CheatOccurred: Missing Reason parameter!");
+        return false;
+    }
+
+    GetPlayer()->m_anti_lastalarmtime = CurTime;
+    GetPlayer()->m_anti_alarmcount = GetPlayer()->m_anti_alarmcount + 1;
+
+    if (GetPlayer()->m_anti_alarmcount > sWorld.GetMvAnticheatAlarmCount())
+    {
+        Anti__ReportCheat(Reason,Speed,Op,Val1,Val2);
+        if (sWorld.GetMvAnticheatAnnounce())
+            sWorld.SendWorldText(LANG_ANNOUNCE_CHEAT, GetPlayer()->GetName(), Reason);
+        return true;
+    }
+    return false;
+}
 
 void WorldSession::HandleMoveWorldportAckOpcode( WorldPacket & /*recv_data*/ )
 {
@@ -72,6 +249,7 @@ void WorldSession::HandleMoveWorldportAckOpcode()
     // relocate the player to the teleport destination
     GetPlayer()->SetMap(sMapMgr.CreateMap(loc.mapid, GetPlayer()));
     GetPlayer()->Relocate(loc.coord_x, loc.coord_y, loc.coord_z, loc.orientation);
+    GetPlayer()->m_anti_TeleTime=time(NULL);
 
     GetPlayer()->SendInitialPacketsBeforeAddToMap();
     // the CanEnter checks are done in TeleporTo but conditions may change
@@ -163,6 +341,8 @@ void WorldSession::HandleMoveWorldportAckOpcode()
 
     // resummon pet
     GetPlayer()->ResummonPetTemporaryUnSummonedIfAny();
+    GetPlayer()->Anti__SetLastTeleTime(::time(NULL));
+    GetPlayer()->m_anti_BeginFallZ=INVALID_HEIGHT;
 
     //lets process all delayed operations on successful teleport
     GetPlayer()->ProcessDelayedOperations();
@@ -212,6 +392,11 @@ void WorldSession::HandleMoveTeleportAck(WorldPacket& recv_data)
 
     // resummon pet
     GetPlayer()->ResummonPetTemporaryUnSummonedIfAny();
+    if(plMover)
+    {
+        plMover->Anti__SetLastTeleTime(::time(NULL));
+        plMover->m_anti_BeginFallZ=INVALID_HEIGHT;
+    }
 
     //lets process all delayed operations on successful teleport
     GetPlayer()->ProcessDelayedOperations();
@@ -248,7 +433,7 @@ void WorldSession::HandleMovementOpcodes( WorldPacket & recv_data )
     }
 
     /* handle special cases */
-    if (movementInfo.HasMovementFlag(MOVEFLAG_ONTRANSPORT))
+    if (movementInfo.HasMovementFlag(MOVEFLAG_ONTRANSPORT) && !mover->GetVehicleGUID())
     {
         // transports size limited
         // (also received at zeppelin/lift leave by some reason with t_* as absolute in continent coordinates, can be safely skipped)
@@ -268,6 +453,11 @@ void WorldSession::HandleMovementOpcodes( WorldPacket & recv_data )
         // if we boarded a transport, add us to it
         if (plMover && !plMover->m_transport)
         {
+            float trans_rad = movementInfo.GetTransportPos()->x*movementInfo.GetTransportPos()->x + movementInfo.GetTransportPos()->y*movementInfo.GetTransportPos()->y + movementInfo.GetTransportPos()->z*movementInfo.GetTransportPos()->z;
+            if (trans_rad > 3600.0f) // transport radius = 60 yards //cheater with on_transport_flag
+            {
+                 return;
+            }
             // elevators also cause the client to send MOVEFLAG_ONTRANSPORT - just unmount if the guid can be found in the transport list
             for (MapManager::TransportSet::const_iterator iter = sMapMgr.m_Transports.begin(); iter != sMapMgr.m_Transports.end(); ++iter)
             {
@@ -295,22 +485,184 @@ void WorldSession::HandleMovementOpcodes( WorldPacket & recv_data )
     {
         // now client not include swimming flag in case jumping under water
         plMover->SetInWater( !plMover->IsInWater() || plMover->GetBaseMap()->IsUnderWater(movementInfo.GetPos()->x, movementInfo.GetPos()->y, movementInfo.GetPos()->z) );
+        if(plMover->GetBaseMap()->IsUnderWater(movementInfo.GetPos()->x, movementInfo.GetPos()->y, movementInfo.GetPos()->z-7.0f))
+        {
+            plMover->m_anti_BeginFallZ=INVALID_HEIGHT;
+        }
+    }
+    if (movementInfo.HasMovementFlag(MOVEFLAG_SWIMMING))
+    {
+        if(mover->GetTypeId() == TYPEID_UNIT)
+        {
+            if(((Creature*)mover)->isVehicle() && !((Creature*)mover)->canSwim())
+            {
+                // NOTE : we should enter evade mode here, but...
+                ((Vehicle*)mover)->SetSpawnDuration(1);
+            }
+        }
     }
 
-    /*----------------------*/
+    // ---- anti-cheat features -->>>
+    uint32 Anti_TeleTimeDiff=plMover ? time(NULL) - plMover->Anti__GetLastTeleTime() : time(NULL);
+    static const uint32 Anti_TeleTimeIgnoreDiff=sWorld.GetMvAnticheatIgnoreAfterTeleport();
+    if (plMover && (plMover->m_transport == 0) && sWorld.GetMvAnticheatEnable() &&
+        GetPlayer()->GetSession()->GetSecurity() <= sWorld.GetMvAnticheatGmLevel() &&
+        GetPlayer()->GetMotionMaster()->GetCurrentMovementGeneratorType()!=FLIGHT_MOTION_TYPE &&
+        Anti_TeleTimeDiff>Anti_TeleTimeIgnoreDiff)
+    {
+        const uint32 CurTime=getMSTime();
+        if (getMSTimeDiff(GetPlayer()->m_anti_lastalarmtime,CurTime) > sWorld.GetMvAnticheatAlarmPeriod())
+        {
+            GetPlayer()->m_anti_alarmcount = 0;
+        }
+        /* I really don't care about movement-type yet (todo)
+        UnitMoveType move_type;
+
+        if (movementInfo.flags & MOVEMENTFLAG_FLYING) move_type = MOVE_FLY;
+        else if (movementInfo.flags & MOVEMENTFLAG_SWIMMING) move_type = MOVE_SWIM;
+        else if (movementInfo.flags & MOVEMENTFLAG_WALK_MODE) move_type = MOVE_WALK;
+        else move_type = MOVE_RUN;*/
+
+        float delta_x = GetPlayer()->GetPositionX() - movementInfo.GetPos()->x;
+        float delta_y = GetPlayer()->GetPositionY() - movementInfo.GetPos()->y;
+        float delta_z = GetPlayer()->GetPositionZ() - movementInfo.GetPos()->z;
+        float delta = sqrt(delta_x * delta_x + delta_y * delta_y); // Len of movement-vector via Pythagoras (a^2+b^2=Len^2)
+        float tg_z = 0.0f; //tangens
+        float delta_t = getMSTimeDiff(GetPlayer()->m_anti_lastmovetime,CurTime);
+
+        GetPlayer()->m_anti_lastmovetime = CurTime;
+        GetPlayer()->m_anti_MovedLen += delta;
+
+        if (delta_t > 15000.0f)
+        {   delta_t = 15000.0f;   }
+
+        // Tangens of walking angel
+        if (!(movementInfo.GetMovementFlags() & (MOVEFLAG_FLYING | MOVEFLAG_SWIMMING)))
+        {
+            tg_z = ((delta !=0.0f) && (delta_z > 0.0f)) ? (atan((delta_z*delta_z) / delta) * 180.0f / M_PI) : 0.0f;
+        }
+
+        //antiOFF fall-damage, MOVEMENTFLAG_UNK4 seted by client if player try movement when falling and unset in this case the MOVEMENTFLAG_FALLING flag. 
+        if ((!GetPlayer()->CanFly() && GetPlayer()->m_anti_BeginFallZ == INVALID_HEIGHT) &&
+            (movementInfo.GetMovementFlags() & (MOVEFLAG_FALLING | MOVEFLAG_FALLINGFAR)) != 0)
+        {
+            GetPlayer()->m_anti_BeginFallZ=(float)(movementInfo.GetPos()->z);
+        }
+
+        if (GetPlayer()->m_anti_NextLenCheck <= CurTime)
+        {
+            // Check every 500ms is a lot more advisable then 1000ms, because normal movment packet arrives every 500ms
+            uint32 OldNextLenCheck=GetPlayer()->m_anti_NextLenCheck;
+            float delta_xyt=GetPlayer()->m_anti_MovedLen/(float)(getMSTimeDiff(OldNextLenCheck-500,CurTime));
+            GetPlayer()->m_anti_NextLenCheck = CurTime+500;
+            GetPlayer()->m_anti_MovedLen = 0.0f;
+            static const float MaxDeltaXYT = sWorld.GetMvAnticheatMaxXYT();
+            if (delta_xyt > MaxDeltaXYT && delta<=100.0f && GetPlayer()->GetZoneId() != 2257)
+            {
+                if (sWorld.GetMvAnticheatSpeedCheck())
+                    Anti__CheatOccurred(CurTime,"Speed hack",delta_xyt,LookupOpcodeName(opcode),
+                    (float)(GetPlayer()->GetMotionMaster()->GetCurrentMovementGeneratorType()),
+                    (float)(getMSTimeDiff(OldNextLenCheck-500,CurTime)));
+            }
+        }
+
+        if (delta > 100.0f && GetPlayer()->GetZoneId() != 2257)
+        {
+            if (sWorld.GetMvAnticheatTeleportCheck())
+                Anti__ReportCheat("Tele hack",delta,LookupOpcodeName(opcode));
+        }
+
+        // Check for waterwalking . Fix new way of checking for waterwalking by Darky88
+        if (movementInfo.HasMovementFlag(MOVEFLAG_WATERWALKING) &&
+            !(GetPlayer()->HasAuraType(SPELL_AURA_WATER_WALK) || GetPlayer()->HasAuraType(SPELL_AURA_GHOST)))
+        {
+            if(sWorld.GetMvAnticheatWaterCheck())
+                Anti__CheatOccurred(CurTime,"Water walking",0.0f,NULL,0.0f,(uint32)(movementInfo.GetMovementFlags()));
+        }
+
+        // Check for walking upwards a mountain while not beeing able to do that, New check by Darky88 
+        if ((delta_z < -2.3f) && (tg_z > 2.37f))
+        {
+            if (sWorld.GetMvAnticheatMountainCheck())
+                Anti__CheatOccurred(CurTime,"Mountain hack",tg_z,NULL,delta,delta_z);
+        }
+
+        static const float DIFF_OVERGROUND = 10.0f;
+        float Anti__GroundZ = GetPlayer()->GetMap()->GetHeight(GetPlayer()->GetPositionX(),GetPlayer()->GetPositionY(),MAX_HEIGHT);
+        float Anti__FloorZ  = GetPlayer()->GetMap()->GetHeight(GetPlayer()->GetPositionX(),GetPlayer()->GetPositionY(),GetPlayer()->GetPositionZ());
+        float Anti__MapZ = ((Anti__FloorZ <= (INVALID_HEIGHT+5.0f)) ? Anti__GroundZ : Anti__FloorZ) + DIFF_OVERGROUND;
+         
+        if (!GetPlayer()->CanFly() &&
+            !GetPlayer()->GetBaseMap()->IsUnderWater(movementInfo.GetPos()->x, movementInfo.GetPos()->y, movementInfo.GetPos()->z-7.0f) &&
+            Anti__MapZ < GetPlayer()->GetPositionZ() && Anti__MapZ > (INVALID_HEIGHT+DIFF_OVERGROUND + 5.0f))
+        {
+            static const float DIFF_AIRJUMP=25.0f; // 25 is realy high, but to many false positives...
+
+            // Air-Jump-Detection definitively needs a better way to be detected...
+            if ((movementInfo.GetMovementFlags() & (MOVEFLAG_CAN_FLY | MOVEFLAG_FLYING | MOVEFLAG_ROOT)) != 0) // Fly Hack
+            {
+                // Fix Aura 55164
+                if (!GetPlayer()->HasAura(55164) || !GetPlayer()->HasAuraType(SPELL_AURA_FEATHER_FALL))
+                    if (sWorld.GetMvAnticheatFlyCheck())
+                        Anti__CheatOccurred(CurTime,"Fly hack",
+                            ((uint8)(GetPlayer()->HasAuraType(SPELL_AURA_FLY))) +
+                            ((uint8)(GetPlayer()->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED))*2),
+                            NULL,GetPlayer()->GetPositionZ()-Anti__MapZ);
+            }
+
+            // Need a better way to do that - currently a lot of fake alarms
+            else if ((Anti__MapZ+DIFF_AIRJUMP < GetPlayer()->GetPositionZ() &&
+                    (movementInfo.GetMovementFlags() & (MOVEFLAG_FALLINGFAR | MOVEFLAG_PENDINGSTOP))==0) ||
+                    (Anti__MapZ < GetPlayer()->GetPositionZ() && opcode==MSG_MOVE_JUMP) &&
+                    !GetPlayer()->HasAuraType(SPELL_AURA_FEATHER_FALL))
+            {
+                if (sWorld.GetMvAnticheatJumpCheck())
+                    Anti__CheatOccurred(CurTime,"Possible Air Jump Hack",0.0f,LookupOpcodeName(opcode),0.0f,movementInfo.GetMovementFlags());
+            }
+        }
+
+        /*if(Anti__FloorZ < -199900.0f && Anti__GroundZ >= -199900.0f &&
+           GetPlayer()->GetPositionZ()+5.0f < Anti__GroundZ)
+        {
+            Anti__CheatOccurred(CurTime,"Teleport2Plane hack",
+                                GetPlayer()->GetPositionZ(),NULL,Anti__GroundZ);
+        }*/
+
+        //Teleport To Plane checks
+        if (movementInfo.GetPos()->z < 0.0001f && movementInfo.GetPos()->z > -0.0001f && (!movementInfo.HasMovementFlag(MovementFlags(MOVEFLAG_SWIMMING | MOVEFLAG_CAN_FLY | MOVEFLAG_FLYING))))
+        {
+            if(sWorld.GetMvAnticheatTeleport2PlaneCheck())
+            {
+                // Prevent using TeleportToPlan.
+                Map *map = GetPlayer()->GetMap();
+                if (map)
+                {
+                    float plane_z = map->GetHeight(movementInfo.GetPos()->x, movementInfo.GetPos()->y, MAX_HEIGHT) - movementInfo.GetPos()->z;
+                    plane_z = (plane_z < -500.0f) ? 0 : plane_z; //check holes in heigth map
+                    if(plane_z > 0.1f || plane_z < -0.1f)
+                    {
+                        if(sWorld.GetMvAnticheatTeleport2PlaneCheck())
+                            Anti__CheatOccurred(CurTime,"Teleport2Plane hack",GetPlayer()->GetPositionZ(),NULL,plane_z);
+                    }
+                }
+            }
+        }
+    }
+    // <<---- anti-cheat features
 
     /* process position-change */
     movementInfo.UpdateTime(getMSTime());
 
     WorldPacket data(opcode, recv_data.size());
-    data.appendPackGUID(mover->GetGUID());                  // write guid
-    movementInfo.Write(data);                               // write data
-    mover->SendMessageToSetExcept(&data, _player);
-
+    
     if(plMover)                                             // nothing is charmed, or player charmed
     {
-        plMover->SetPosition(movementInfo.GetPos()->x, movementInfo.GetPos()->y, movementInfo.GetPos()->z, movementInfo.GetPos()->o);
+        data.appendPackGUID(mover->GetGUID());                  // write guid
+        movementInfo.Write(data);                               // write data
+        mover->SendMessageToSetExcept(&data, _player);
+
         plMover->m_movementInfo = movementInfo;
+        plMover->SetPosition(movementInfo.GetPos()->x, movementInfo.GetPos()->y, movementInfo.GetPos()->z, movementInfo.GetPos()->o);
         plMover->UpdateFallInformationIfNeed(movementInfo, opcode);
 
         // after move info set
@@ -354,7 +706,11 @@ void WorldSession::HandleMovementOpcodes( WorldPacket & recv_data )
     else                                                    // creature charmed
     {
         if(mover->IsInWorld())
+        {
             mover->GetMap()->CreatureRelocation((Creature*)mover, movementInfo.GetPos()->x, movementInfo.GetPos()->y, movementInfo.GetPos()->z, movementInfo.GetPos()->o);
+            if(((Creature*)mover)->isVehicle())
+                ((Vehicle*)mover)->RelocatePassengers(mover->GetMap());
+        }
     }
 }
 
@@ -399,7 +755,7 @@ void WorldSession::HandleForceSpeedChangeAck(WorldPacket &recv_data)
         case CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK:   move_type = MOVE_FLIGHT_BACK;   force_move_type = MOVE_FLIGHT_BACK; break;
         case CMSG_FORCE_PITCH_RATE_CHANGE_ACK:          move_type = MOVE_PITCH_RATE;    force_move_type = MOVE_PITCH_RATE;  break;
         default:
-            sLog.outError("WorldSession::HandleForceSpeedChangeAck: Unknown move type opcode: %u", opcode);
+            DEBUG_LOG("WorldSession::HandleForceSpeedChangeAck: Unknown move type opcode: %u", opcode);
             return;
     }
 
@@ -436,12 +792,18 @@ void WorldSession::HandleSetActiveMoverOpcode(WorldPacket &recv_data)
 
     uint64 guid;
     recv_data >> guid;
+    
+    if(_player->m_mover_in_queve && _player->m_mover_in_queve->GetGUID() == guid)
+    {
+        _player->m_mover = _player->m_mover_in_queve;
+        _player->m_mover_in_queve = NULL;
+    }
 
-    if(_player->m_mover->GetGUID() != guid)
+    /*if(_player->m_mover->GetGUID() != guid)
     {
         sLog.outError("HandleSetActiveMoverOpcode: incorrect mover guid: mover is " I64FMT " and should be " I64FMT, _player->m_mover->GetGUID(), guid);
         return;
-    }
+    }*/
 }
 
 void WorldSession::HandleMoveNotActiveMover(WorldPacket &recv_data)
@@ -454,18 +816,18 @@ void WorldSession::HandleMoveNotActiveMover(WorldPacket &recv_data)
 
     recv_data >> old_mover_guid.ReadAsPacked();
     recv_data >> mi;
-
+/*
     if(_player->m_mover->GetObjectGuid() == old_mover_guid)
     {
-        sLog.outError("HandleMoveNotActiveMover: incorrect mover guid: mover is " I64FMT " and should be " I64FMT " instead of " UI64FMTD, _player->m_mover->GetGUID(), _player->GetGUID(), old_mover_guid.GetRawValue());
+        DEBUG_LOG("HandleMoveNotActiveMover: incorrect mover guid: mover is " I64FMT " and should be " I64FMT " instead of " UI64FMTD, _player->m_mover->GetGUID(), _player->GetGUID(), old_mover_guid.GetRawValue());
         recv_data.rpos(recv_data.wpos());                   // prevent warnings spam
         return;
     }
-
+*/
     _player->m_movementInfo = mi;
 }
 
-void WorldSession::HandleDismissControlledVehicle(WorldPacket &recv_data)
+void WorldSession::HandleDismissControlledVehicle(WorldPacket & recv_data)
 {
     DEBUG_LOG("WORLD: Recvd CMSG_DISMISS_CONTROLLED_VEHICLE");
     recv_data.hexlike();
@@ -476,18 +838,124 @@ void WorldSession::HandleDismissControlledVehicle(WorldPacket &recv_data)
     recv_data >> guid.ReadAsPacked();
     recv_data >> mi;
 
-    uint64 vehicleGUID = _player->GetCharmGUID();
+    uint64 vehicleGUID = _player->GetVehicleGUID();
 
     if(!vehicleGUID)                                        // something wrong here...
         return;
 
     _player->m_movementInfo = mi;
 
-    // using charm guid, because we don't have vehicle guid...
-    if(Vehicle *vehicle = _player->GetMap()->GetVehicle(vehicleGUID))
+    if(Vehicle *vehicle = ObjectAccessor::GetVehicle(vehicleGUID))
     {
-        // Aura::HandleAuraControlVehicle will call Player::ExitVehicle
-        vehicle->RemoveSpellsCausingAura(SPELL_AURA_CONTROL_VEHICLE);
+        if(vehicle->GetVehicleFlags() & VF_DESPAWN_AT_LEAVE)
+            vehicle->Dismiss();
+        else
+            _player->ExitVehicle();
+    }
+}
+
+void WorldSession::HandleRequestVehicleExit(WorldPacket &recv_data)
+{
+    DEBUG_LOG("WORLD: Recvd CMSG_REQUEST_VEHICLE_EXIT");
+    recv_data.hexlike();
+
+    uint64 vehicleGUID = _player->GetVehicleGUID();
+
+    if(!vehicleGUID)                                        // something wrong here...
+        return;
+
+    if(Vehicle *vehicle = ObjectAccessor::GetVehicle(vehicleGUID))
+    {
+        _player->ExitVehicle();
+    }
+}
+
+void WorldSession::HandleRequestVehicleSwitchSeat(WorldPacket &recv_data)
+{
+    DEBUG_LOG("WORLD: Recvd CMSG_REQUEST_VEHICLE_SWITCH_SEAT");
+    recv_data.hexlike();
+
+    uint64 vehicleGUID = _player->GetVehicleGUID();
+
+    if(!vehicleGUID)                                        // something wrong here...
+        return;
+
+    if(Vehicle *vehicle = ObjectAccessor::GetVehicle(vehicleGUID))
+    {
+        ObjectGuid guid;
+        recv_data >> guid.ReadAsPacked();
+
+        int8 seatId = 0;
+        recv_data >> seatId;
+
+        if(!guid.IsEmpty())
+        {
+            if(vehicleGUID != guid.GetRawValue())
+            {
+                if(Vehicle *veh = ObjectAccessor::GetVehicle(guid.GetRawValue()))
+                {
+                    if(!_player->IsWithinDistInMap(veh, 10))
+                        return;
+
+                    if(Vehicle *v = veh->FindFreeSeat(&seatId, false))
+                    {
+                        vehicle->RemovePassenger(_player);
+                        _player->EnterVehicle(v, seatId, false);
+                    }
+                }
+                return;
+            }
+        }
+        if(Vehicle *v = vehicle->FindFreeSeat(&seatId, false))
+        {
+            vehicle->RemovePassenger(_player);
+            _player->EnterVehicle(v, seatId, false);
+        }
+    }
+}
+
+void WorldSession::HandleChangeSeatsOnControlledVehicle(WorldPacket &recv_data)
+{
+    DEBUG_LOG("WORLD: Recvd CMSG_CHANGE_SEATS_ON_CONTROLLED_VEHICLE");
+    recv_data.hexlike();
+
+    uint64 vehicleGUID = _player->GetVehicleGUID();
+
+    if(!vehicleGUID)                                        // something wrong here...
+        return;
+
+    if(recv_data.GetOpcode() == CMSG_REQUEST_VEHICLE_PREV_SEAT)
+    {
+        _player->ChangeSeat(-1, false);
+        return;
+    }
+    else if(recv_data.GetOpcode() == CMSG_REQUEST_VEHICLE_NEXT_SEAT)
+    {
+        _player->ChangeSeat(-1, true);
+        return;
+    }
+
+    ObjectGuid guid, guid2;
+    recv_data >> guid.ReadAsPacked();
+
+    MovementInfo mi;
+    recv_data >> mi;
+    _player->m_movementInfo = mi;
+
+    recv_data >> guid2.ReadAsPacked(); //guid of vehicle or of vehicle in target seat
+
+    int8 seatId;
+    recv_data >> seatId;
+
+    if(guid.GetRawValue() == guid2.GetRawValue())
+        _player->ChangeSeat(seatId, false);
+    else if(Vehicle *vehicle = ObjectAccessor::GetVehicle(guid2.GetRawValue()))
+    {
+        if(vehicle->HasEmptySeat(seatId))
+        {
+            _player->ExitVehicle();
+            _player->EnterVehicle(vehicle, seatId);
+        }
     }
 }
 
@@ -510,6 +978,7 @@ void WorldSession::HandleMoveKnockBackAck( WorldPacket & recv_data )
 
     recv_data >> guid.ReadAsPacked();
     recv_data >> Unused<uint32>();                          // unk
+
     recv_data >> movementInfo;
 }
 
@@ -550,4 +1019,4 @@ void WorldSession::HandleSummonResponseOpcode(WorldPacket& recv_data)
     recv_data >> agree;
 
     _player->SummonIfPossible(agree);
-}
+}
\ No newline at end of file
diff --git a/mangos/src/game/Object.cpp b/Core/src/game/Object.cpp
index 55fc2d0..3700099 100644
--- a/mangos/src/game/Object.cpp
+++ b/Core/src/game/Object.cpp
@@ -44,6 +44,7 @@
 #include "ObjectPosSelector.h"
 
 #include "TemporarySummon.h"
+#include "OutdoorPvPMgr.h"
 
 uint32 GuidHigh2TypeId(uint32 guid_hi)
 {
@@ -268,12 +269,12 @@ void Object::BuildMovementUpdate(ByteBuffer * data, uint16 updateFlags) const
                 if (((Creature*)unit)->canFly())
                 {
                     // (ok) most seem to have this
-                    unit->m_movementInfo.AddMovementFlag(MOVEFLAG_LEVITATING);
+                    unit->m_movementInfo.AddMovementFlag(MOVEFLAG_CAN_FLY);
 
                     if (!((Creature*)unit)->hasUnitState(UNIT_STAT_MOVING))
                     {
                         // (ok) possibly some "hover" mode
-                        unit->m_movementInfo.AddMovementFlag(MOVEFLAG_ROOT);
+                        //unit->m_movementInfo.AddMovementFlag(MOVEFLAG_ROOT);
                     }
                     else
                     {
@@ -284,6 +285,8 @@ void Object::BuildMovementUpdate(ByteBuffer * data, uint16 updateFlags) const
                         }
                     }
                 }
+                if(unit->GetVehicleGUID())
+                   unit->m_movementInfo.AddMovementFlag(MOVEFLAG_ONTRANSPORT);
             }
             break;
             case TYPEID_PLAYER:
@@ -298,7 +301,10 @@ void Object::BuildMovementUpdate(ByteBuffer * data, uint16 updateFlags) const
                 // remove unknown, unused etc flags for now
                 player->m_movementInfo.RemoveMovementFlag(MOVEFLAG_SPLINE_ENABLED);
 
-                if(player->isInFlight())
+                if(((Unit*)this)->GetVehicleGUID())
+                    player->m_movementInfo.AddMovementFlag(MOVEFLAG_ONTRANSPORT);
+
+                if(((Player*)this)->isInFlight())
                 {
                     ASSERT(player->GetMotionMaster()->GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE);
                     player->m_movementInfo.AddMovementFlag(MOVEFLAG_FORWARD);
@@ -541,7 +547,7 @@ void Object::BuildValuesUpdate(uint8 updatetype, ByteBuffer * data, UpdateMask *
     bool IsPerCasterAuraState = false;
     if (updatetype == UPDATETYPE_CREATE_OBJECT || updatetype == UPDATETYPE_CREATE_OBJECT2)
     {
-        if (isType(TYPEMASK_GAMEOBJECT) && !((GameObject*)this)->IsTransport())
+        if (isType(TYPEMASK_GAMEOBJECT) && !((GameObject*)this)->IsDynTransport())
         {
             if ( ((GameObject*)this)->ActivateToQuest(target) || target->isGameMaster())
                 IsActivateToQuest = true;
@@ -559,7 +565,7 @@ void Object::BuildValuesUpdate(uint8 updatetype, ByteBuffer * data, UpdateMask *
     }
     else                                                    // case UPDATETYPE_VALUES
     {
-        if (isType(TYPEMASK_GAMEOBJECT) && !((GameObject*)this)->IsTransport())
+        if (isType(TYPEMASK_GAMEOBJECT) && !((GameObject*)this)->IsDynTransport())
         {
             if ( ((GameObject*)this)->ActivateToQuest(target) || target->isGameMaster())
             {
@@ -593,7 +599,7 @@ void Object::BuildValuesUpdate(uint8 updatetype, ByteBuffer * data, UpdateMask *
                 if( index == UNIT_NPC_FLAGS )
                 {
                     // remove custom flag before sending
-                    uint32 appendValue = m_uint32Values[ index ] & ~UNIT_NPC_FLAG_GUARD;
+                    uint32 appendValue = m_uint32Values[ index ] & ~(UNIT_NPC_FLAG_GUARD + UNIT_NPC_FLAG_OUTDOORPVP);
 
                     if (GetTypeId() == TYPEID_UNIT)
                     {
@@ -1084,7 +1090,7 @@ void Object::BuildUpdateData( UpdateDataMapType& /*update_players */)
 }
 
 WorldObject::WorldObject()
-    : m_currMap(NULL), m_mapId(0), m_InstanceId(0), m_phaseMask(PHASEMASK_NORMAL),
+    : m_currMap(NULL), m_zoneScript(NULL), m_mapId(0), m_InstanceId(0), m_phaseMask(PHASEMASK_NORMAL),
     m_positionX(0.0f), m_positionY(0.0f), m_positionZ(0.0f), m_orientation(0.0f)
 {
 }
@@ -1108,7 +1114,11 @@ void WorldObject::Relocate(float x, float y, float z, float orientation)
     m_orientation = orientation;
 
     if(isType(TYPEMASK_UNIT))
+    {
         ((Unit*)this)->m_movementInfo.ChangePosition(x, y, z, orientation);
+        if(((Creature*)this)->isVehicle())
+            ((Vehicle*)this)->RelocatePassengers(GetMap());
+    }
 }
 
 void WorldObject::Relocate(float x, float y, float z)
@@ -1118,7 +1128,11 @@ void WorldObject::Relocate(float x, float y, float z)
     m_positionZ = z;
 
     if(isType(TYPEMASK_UNIT))
+    {
         ((Unit*)this)->m_movementInfo.ChangePosition(x, y, z, GetOrientation());
+        if(((Creature*)this)->isVehicle())
+            ((Vehicle*)this)->RelocatePassengers(GetMap());
+    }
 }
 
 uint32 WorldObject::GetZoneId() const
@@ -1242,8 +1256,32 @@ bool WorldObject::IsWithinLOS(float ox, float oy, float oz) const
 {
     float x,y,z;
     GetPosition(x,y,z);
+    z += 2.0f;
+    oz += 2.0f;
+
+    // check for line of sight because of terrain height differences
+    Map const *map = GetBaseMap();
+    float dx = ox - x, dy = oy - y, dz = oz - z;
+    float dist = sqrt(dx*dx + dy*dy + dz*dz);
+    if (dist > ATTACK_DISTANCE && dist < MAX_VISIBILITY_DISTANCE)
+    {
+        uint32 steps = uint32(dist / TERRAIN_LOS_STEP_DISTANCE);
+        float step_dist = dist / (float)steps;  // to make sampling intervals symmetric in both directions
+        float inc_factor = step_dist / dist;
+        float incx = dx*inc_factor, incy = dy*inc_factor, incz = dz*inc_factor;
+        float px = x, py = y, pz = z;
+        for (; steps; --steps)
+        {
+            if (map->GetHeight(px, py, pz, false) > pz)
+                return false;  // found intersection with ground
+            px += incx;
+            py += incy;
+            pz += incz;
+        }
+    }
+
     VMAP::IVMapManager *vMapManager = VMAP::VMapFactory::createOrGetVMapManager();
-    return vMapManager->isInLineOfSight(GetMapId(), x, y, z+2.0f, ox, oy, oz+2.0f);
+    return vMapManager->isInLineOfSight(GetMapId(), x, y, z, ox, oy, oz);
 }
 
 bool WorldObject::GetDistanceOrder(WorldObject const* obj1, WorldObject const* obj2, bool is3D /* = true */) const
@@ -1423,11 +1461,23 @@ void WorldObject::GetRandomPoint( float x, float y, float z, float distance, flo
     UpdateGroundPositionZ(rand_x,rand_y,rand_z);            // update to LOS height if available
 }
 
-void WorldObject::UpdateGroundPositionZ(float x, float y, float &z) const
+void WorldObject::UpdateGroundPositionZ(float x, float y, float &z, float maxDiff) const
 {
-    float new_z = GetBaseMap()->GetHeight(x,y,z,true);
-    if(new_z > INVALID_HEIGHT)
-        z = new_z+ 0.05f;                                   // just to be sure that we are not a few pixel under the surface
+    maxDiff = maxDiff >= 100.0f ? 10.0f : sqrtf(maxDiff);
+    bool useVmaps = false;
+    if( GetBaseMap()->GetHeight(x, y, z+2.0f, false) <  GetBaseMap()->GetHeight(x, y, z+2.0f, true) ) // check use of vmaps
+        useVmaps = true;
+
+    float normalizedZ = GetBaseMap()->GetHeight(x, y, z+2.0f, useVmaps);
+    // check if its reacheable
+    if(normalizedZ <= INVALID_HEIGHT || fabs(normalizedZ-z) > maxDiff)
+    {
+        useVmaps = !useVmaps;                                // try change vmap use
+        normalizedZ = GetBaseMap()->GetHeight(x, y, z+2.0f, useVmaps);
+        if(normalizedZ <= INVALID_HEIGHT || fabs(normalizedZ-z) > maxDiff)
+            return;                                        // Do nothing in case of another bad result 
+    }
+    z = normalizedZ + 0.1f;                                // just to be sure that we are not a few pixel under the surface
 }
 
 bool WorldObject::IsPositionValid() const
@@ -1628,6 +1678,16 @@ void WorldObject::AddObjectToRemoveList()
     GetMap()->AddObjectToRemoveList(this);
 }
 
+void WorldObject::SetZoneScript()
+{
+    if(Map *map = FindMap())
+    {
+        if(!map->IsBattleGroundOrArena() && !map->IsDungeon())
+            m_zoneScript = sOutdoorPvPMgr.GetZoneScript(GetZoneId());
+    }
+}
+
+
 Creature* WorldObject::SummonCreature(uint32 id, float x, float y, float z, float ang,TempSummonType spwtype,uint32 despwtime)
 {
     TemporarySummon* pCreature = new TemporarySummon(GetObjectGuid());
@@ -1664,6 +1724,62 @@ Creature* WorldObject::SummonCreature(uint32 id, float x, float y, float z, floa
     return pCreature;
 }
 
+GameObject* WorldObject::SummonGameobject(uint32 id, float x, float y, float z, float angle, uint32 despwtime)
+{
+    GameObject* pGameObj = new GameObject;
+
+    Map *map = GetMap();
+
+    if(!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), id, map,
+        GetPhaseMask(), x, y, z, angle, 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
+    {
+        delete pGameObj;
+        return NULL;
+    }
+
+    pGameObj->SetRespawnTime(despwtime/IN_MILLISECONDS);
+
+    map->Add(pGameObj);
+
+    return pGameObj;
+}
+
+Vehicle* WorldObject::SummonVehicle(uint32 id, float x, float y, float z, float ang, uint32 vehicleId)
+{
+    Vehicle *v = new Vehicle;
+
+    Map *map = GetMap();
+    uint32 team = 0;
+    if (GetTypeId()==TYPEID_PLAYER)
+        team = ((Player*)this)->GetTeam();
+
+    if(!v->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_VEHICLE), map, GetPhaseMask(), id, vehicleId, team))
+    {
+        delete v;
+        return NULL;
+    }
+
+    if (x == 0.0f && y == 0.0f && z == 0.0f)
+        GetClosePoint(x, y, z, v->GetObjectSize());
+
+    v->Relocate(x, y, z, ang);
+
+    if(!v->IsPositionValid())
+    {
+        sLog.outError("ERROR: Vehicle (guidlow %d, entry %d) not created. Suggested coordinates isn't valid (X: %f Y: %f)",
+            v->GetGUIDLow(), v->GetEntry(), v->GetPositionX(), v->GetPositionY());
+        delete v;
+        return NULL;
+    }
+    map->Add((Creature*)v);
+    v->AIM_Initialize();
+
+    if(GetTypeId()==TYPEID_UNIT && ((Creature*)this)->AI())
+        ((Creature*)this)->AI()->JustSummoned((Creature*)v);
+
+    return v;
+}
+
 namespace MaNGOS
 {
     class NearUsedPosDo
@@ -1945,4 +2061,4 @@ bool WorldObject::IsControlledByPlayer() const
         default:
             return false;
     }
-}
\ No newline at end of file
+}
diff --git a/mangos/src/game/Object.h b/Core/src/game/Object.h
index 04c31f0..3b62080 100644
--- a/mangos/src/game/Object.h
+++ b/Core/src/game/Object.h
@@ -39,6 +39,7 @@
 
 #define DEFAULT_WORLD_OBJECT_SIZE   0.388999998569489f      // player size, also currently used (correctly?) for any non Unit world objects
 #define MAX_STEALTH_DETECT_RANGE    45.0f
+#define TERRAIN_LOS_STEP_DISTANCE   3.0f
 
 uint32 GuidHigh2TypeId(uint32 guid_hi);
 
@@ -64,11 +65,15 @@ class WorldPacket;
 class UpdateData;
 class WorldSession;
 class Creature;
+class GameObject;
 class Player;
 class Unit;
+class Group;
 class Map;
 class UpdateMask;
 class InstanceData;
+class ZoneScript;
+class Vehicle;
 
 typedef UNORDERED_MAP<Player*, UpdateData> UpdateDataMapType;
 
@@ -364,7 +369,7 @@ class MANGOS_DLL_SPEC WorldObject : public Object
             return ( m_valuesCount > UNIT_FIELD_BOUNDINGRADIUS ) ? m_floatValues[UNIT_FIELD_BOUNDINGRADIUS] : DEFAULT_WORLD_OBJECT_SIZE;
         }
         bool IsPositionValid() const;
-        void UpdateGroundPositionZ(float x, float y, float &z) const;
+        void UpdateGroundPositionZ(float x, float y, float &z, float maxDiff = 30.0f) const;
 
         void GetRandomPoint( float x, float y, float z, float distance, float &rand_x, float &rand_y, float &rand_z ) const;
 
@@ -465,17 +470,24 @@ class MANGOS_DLL_SPEC WorldObject : public Object
 
         void SetMap(Map * map);
         Map * GetMap() const { ASSERT(m_currMap); return m_currMap; }
+        Map * FindMap() const { return m_currMap; }
         //used to check all object's GetMap() calls when object is not in world!
         void ResetMap() { m_currMap = NULL; }
 
         //this function should be removed in nearest time...
         Map const* GetBaseMap() const;
 
+        void SetZoneScript();
+        ZoneScript *GetZoneScript() const { return m_zoneScript; }
+
         void AddToClientUpdateList();
         void RemoveFromClientUpdateList();
         void BuildUpdateData(UpdateDataMapType &);
 
         Creature* SummonCreature(uint32 id, float x, float y, float z, float ang,TempSummonType spwtype,uint32 despwtime);
+        GameObject* SummonGameobject(uint32 id, float x, float y, float z, float angle, uint32 despwtime);
+        Vehicle* SummonVehicle(uint32 id, float x, float y, float z, float ang, uint32 vehicleId = NULL);
+
     protected:
         explicit WorldObject();
 
@@ -485,6 +497,7 @@ class MANGOS_DLL_SPEC WorldObject : public Object
         void SetLocationMapId(uint32 _mapId) { m_mapId = _mapId; }
         void SetLocationInstanceId(uint32 _instanceId) { m_InstanceId = _instanceId; }
 
+        ZoneScript *m_zoneScript;
         std::string m_name;
 
     private:
diff --git a/mangos/src/game/ObjectAccessor.cpp b/Core/src/game/ObjectAccessor.cpp
index 6b12b85..63976e1 100644
--- a/mangos/src/game/ObjectAccessor.cpp
+++ b/Core/src/game/ObjectAccessor.cpp
@@ -43,6 +43,8 @@
 INSTANTIATE_SINGLETON_2(ObjectAccessor, CLASS_LOCK);
 INSTANTIATE_CLASS_MUTEX(ObjectAccessor, ACE_Thread_Mutex);
 
+ACE_Thread_Mutex ObjectAccessor::m_Lock;
+
 ObjectAccessor::ObjectAccessor() {}
 ObjectAccessor::~ObjectAccessor()
 {
@@ -53,6 +55,21 @@ ObjectAccessor::~ObjectAccessor()
     }
 }
 
+Creature*
+ObjectAccessor::GetCreatureOrPetOrVehicle(WorldObject const &u, ObjectGuid guid)
+{
+    if(guid.IsPlayer() || !u.IsInWorld())
+        return NULL;
+ 
+    if(guid.IsPet())
+        return u.GetMap()->GetPet(guid);
+ 
+    if(guid.IsVehicle())
+        return u.GetMap()->GetVehicle(guid);
+ 
+    return u.GetMap()->GetCreature(guid);
+}
+
 Unit*
 ObjectAccessor::GetUnit(WorldObject const &u, ObjectGuid guid)
 {
@@ -62,10 +79,7 @@ ObjectAccessor::GetUnit(WorldObject const &u, ObjectGuid guid)
     if(guid.IsPlayer())
         return FindPlayer(guid);
 
-    if (!u.IsInWorld())
-        return NULL;
-
-    return u.GetMap()->GetCreatureOrPetOrVehicle(guid);
+    return GetCreatureOrPetOrVehicle(u, guid);
 }
 
 Corpse* ObjectAccessor::GetCorpseInMap(ObjectGuid guid, uint32 mapid)
@@ -92,9 +106,9 @@ ObjectAccessor::FindPlayer(ObjectGuid guid)
 Player*
 ObjectAccessor::FindPlayerByName(const char *name)
 {
-    HashMapHolder<Player>::ReadGuard g(HashMapHolder<Player>::GetLock());
-    HashMapHolder<Player>::MapType& m = sObjectAccessor.GetPlayers();
-    for(HashMapHolder<Player>::MapType::iterator iter = m.begin(); iter != m.end(); ++iter)
+    HashMapHolder<Player>::MapType& m = HashMapHolder<Player>::GetContainer();
+    HashMapHolder<Player>::MapType::iterator iter = m.begin();
+    for(; iter != m.end(); ++iter)
         if(iter->second->IsInWorld() && ( ::strcmp(name, iter->second->GetName()) == 0 ))
             return iter->second;
 
@@ -104,10 +118,13 @@ ObjectAccessor::FindPlayerByName(const char *name)
 void
 ObjectAccessor::SaveAllPlayers()
 {
-    HashMapHolder<Player>::ReadGuard g(HashMapHolder<Player>::GetLock());
-    HashMapHolder<Player>::MapType& m = sObjectAccessor.GetPlayers();
-    for(HashMapHolder<Player>::MapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+    HashMapHolder<Player>::MapType& m = HashMapHolder<Player>::GetContainer();
+    HashMapHolder<Player>::MapType::iterator itr = m.begin();
+    for(; itr != m.end(); ++itr)
+    {
+        if (itr->second->m_jail_isjailed) continue; // Prevent jailed players to be saved
         itr->second->SaveToDB();
+    }   
 }
 
 void ObjectAccessor::KickPlayer(uint64 guid)
diff --git a/mangos/src/game/ObjectAccessor.h b/Core/src/game/ObjectAccessor.h
index 161deb6..d177548 100644
--- a/mangos/src/game/ObjectAccessor.h
+++ b/Core/src/game/ObjectAccessor.h
@@ -39,6 +39,7 @@
 class Creature;
 class Unit;
 class GameObject;
+class Vehicle;
 class WorldObject;
 class Map;
 
@@ -99,12 +100,20 @@ class MANGOS_DLL_DECL ObjectAccessor : public MaNGOS::Singleton<ObjectAccessor,
         // global (obj used for map only location local guid objects (pets currently)
         static Unit*   GetUnitInWorld(WorldObject const& obj, ObjectGuid guid);
 
-        // FIXME: map local object with global search
+        // map local object with global search
         static Creature*   GetCreatureInWorld(ObjectGuid guid)   { return FindHelper<Creature>(guid); }
         static GameObject* GetGameObjectInWorld(ObjectGuid guid) { return FindHelper<GameObject>(guid); }
+        static Pet*        GetGameObjectInWorld(uint64 guid, Pet*        /*fake*/) { return FindHelper<Pet>(guid); }
+        static Vehicle*    GetGameObjectInWorld(uint64 guid, Vehicle*    /*fake*/) { return FindHelper<Vehicle>(guid); }
 
         // possible local search for specific object map
         static Unit* GetUnit(WorldObject const &, ObjectGuid guid);
+        static Creature* GetCreatureOrPetOrVehicle(WorldObject const &, ObjectGuid guid);
+        //static Player* GetPlayer(Unit const &, uint64 guid) { return FindPlayer(guid); }
+        //static Corpse* GetCorpse(WorldObject const &u, uint64 guid);
+        //static Pet* GetPet(uint64 guid) { return GetObjectInWorld(guid, (Pet*)NULL); }
+        static Vehicle* GetVehicle(uint64 guid) { return GetGameObjectInWorld(guid, (Vehicle*)NULL); }
+        //static Player* FindPlayer(uint64);
 
         // Player access
         static Player* FindPlayer(ObjectGuid guid);
@@ -134,14 +143,16 @@ class MANGOS_DLL_DECL ObjectAccessor : public MaNGOS::Singleton<ObjectAccessor,
         void RemoveObject(Player *object) { HashMapHolder<Player>::Remove(object); }
 
         // TODO: This methods will need lock in MT environment
-        static void LinkMap(Map* map)   { i_mapList.push_back(map); }
-        static void DelinkMap(Map* map) { i_mapList.remove(map); }
+        static void LinkMap(Map* map)   { ACE_Guard<ACE_Thread_Mutex> guard(m_Lock); i_mapList.push_back(map); }
+        static void DelinkMap(Map* map) { ACE_Guard<ACE_Thread_Mutex> guard(m_Lock); i_mapList.remove(map); }
     private:
         // TODO: This methods will need lock in MT environment
         // Theoreticaly multiple threads can enter and search in this method but
         // in that case linking/delinking other map should be guarded
+        static ACE_Thread_Mutex  m_Lock;
         template <class OBJECT> static OBJECT* FindHelper(ObjectGuid guid)
         {
+            ACE_Guard<ACE_Thread_Mutex> guard(m_Lock);
             for (std::list<Map*>::const_iterator i = i_mapList.begin() ; i != i_mapList.end(); ++i)
             {
                 if (OBJECT* ret = (*i)->GetObjectsStore().find(guid.GetRawValue(), (OBJECT*)NULL))
@@ -173,6 +184,9 @@ inline Unit* ObjectAccessor::GetUnitInWorld(WorldObject const& obj, ObjectGuid g
     if (guid.IsPet())
         return obj.IsInWorld() ? obj.GetMap()->GetPet(guid) : NULL;
 
+     if (guid.IsVehicle())
+        return obj.IsInWorld() ? ((Unit*)obj.GetMap()->GetVehicle(guid)) : NULL;
+
     return GetCreatureInWorld(guid);
 }
 
diff --git a/mangos/src/game/ObjectMgr.cpp b/Core/src/game/ObjectMgr.cpp
index dad5410..1e9ffea 100644
--- a/mangos/src/game/ObjectMgr.cpp
+++ b/Core/src/game/ObjectMgr.cpp
@@ -800,7 +800,7 @@ void ObjectMgr::ConvertCreatureAddonAuras(CreatureDataAddon* addon, char const*
     // replace by new structures array
     const_cast<CreatureDataAddonAura*&>(addon->auras) = new CreatureDataAddonAura[val.size()/2+1];
 
-    uint32 i=0;
+    int i=0;
     for(uint32 j = 0; j < val.size()/2; ++j)
     {
         CreatureDataAddonAura& cAura = const_cast<CreatureDataAddonAura&>(addon->auras[i]);
@@ -833,6 +833,93 @@ void ObjectMgr::ConvertCreatureAddonAuras(CreatureDataAddon* addon, char const*
     endAura.effect_idx = EFFECT_INDEX_0;
 }
 
+void ObjectMgr::ConvertCreatureAddonPassengers(CreatureDataAddon* addon, char const* table, char const* guidEntryStr)
+{
+    // Now add the passengers, format "creature_entry/guid seatindex creature_entry/guid seatindex..."
+    char *p,*s;
+    std::vector<int> val;
+    s=p=(char*)reinterpret_cast<char const*>(addon->passengers);
+    if(p)
+    {
+        while (p[0]!=0)
+        {
+            ++p;
+            if (p[0]==' ')
+            {
+                val.push_back(atoi(s));
+                s=++p;
+            }
+        }
+        if (p!=s)
+            val.push_back(atoi(s));
+
+        // free char* loaded memory
+        delete[] (char*)reinterpret_cast<char const*>(addon->passengers);
+
+        // wrong list
+        if (val.size()%2)
+        {
+            addon->auras = NULL;
+            sLog.outErrorDb("Creature (%s: %u) has wrong `passengers` data in `%s`.",guidEntryStr,addon->guidOrEntry,table);
+            return;
+        }
+    }
+
+    // empty list
+    if(val.empty())
+    {
+        addon->passengers = NULL;
+        return;
+    }
+
+    // replace by new structures array
+    const_cast<CreatureDataAddonPassengers*&>(addon->passengers) = new CreatureDataAddonPassengers[val.size()/2+1];
+
+    int i=0;
+    for(uint32 j=0;j<val.size()/2;++j)
+    {
+        CreatureDataAddonPassengers& cPas = const_cast<CreatureDataAddonPassengers&>(addon->passengers[i]);
+        if(guidEntryStr == "Entry")
+            cPas.entry = (uint32)val[2*j+0];
+        else
+            cPas.guid = (uint32)val[2*j+0];
+        cPas.seat_idx = (int8)val[2*j+1];
+        if ( cPas.seat_idx > 7 )
+        {
+            sLog.outErrorDb("Creature (%s: %u) has wrong seat %u for creature %u in `passengers` field in `%s`.",guidEntryStr,addon->guidOrEntry,cPas.seat_idx,cPas.entry,table);
+            continue;
+        }
+        if(cPas.entry == 0 && cPas.guid == 0)
+        {
+            sLog.outErrorDb("Creature (%s: %u) has NULL creature entry/guid in `passengers` field in `%s`.",guidEntryStr,addon->guidOrEntry,table);
+            continue;
+        }
+        if(cPas.entry > 0)
+        {
+            if(!sCreatureStorage.LookupEntry<CreatureInfo>(cPas.entry))
+            {
+                sLog.outErrorDb("Creature (%s: %u) has wrong creature entry/guid %u `passengers` field in `%s`.",guidEntryStr,addon->guidOrEntry,cPas.entry,table);
+                continue;
+            }
+        }
+        else
+        {
+            if(mCreatureDataMap.find(cPas.guid)==mCreatureDataMap.end())
+            {
+                sLog.outErrorDb("Creature (%s: %u) has wrong creature entry/guid %u `passengers` field in `%s`.",guidEntryStr,addon->guidOrEntry,cPas.guid,table);
+                continue;
+            }
+        }
+        ++i;
+    }
+
+    // fill terminator element (after last added)
+    CreatureDataAddonPassengers& endPassenger = const_cast<CreatureDataAddonPassengers&>(addon->passengers[i]);
+    endPassenger.entry = 0;
+    endPassenger.guid = 0;
+    endPassenger.seat_idx = -1;
+}
+
 void ObjectMgr::LoadCreatureAddons(SQLStorage& creatureaddons, char const* entryName, char const* comment)
 {
     creatureaddons.Load();
@@ -869,6 +956,7 @@ void ObjectMgr::LoadCreatureAddons(SQLStorage& creatureaddons, char const* entry
         }
 
         ConvertCreatureAddonAuras(const_cast<CreatureDataAddon*>(addon), creatureaddons.GetTableName(), entryName);
+        ConvertCreatureAddonPassengers(const_cast<CreatureDataAddon*>(addon), creatureaddons.GetTableName(), entryName);
     }
 }
 
@@ -1233,6 +1321,106 @@ void ObjectMgr::RemoveCreatureFromGrid(uint32 guid, CreatureData const* data)
     }
 }
 
+uint32 ObjectMgr::AddGOData(uint32 entry, uint32 mapId, float x, float y, float z, float o, uint32 spawntimedelay, float rotation0, float rotation1, float rotation2, float rotation3)
+{
+    GameObjectInfo const* goinfo = GetGameObjectInfo(entry);
+    if (!goinfo)
+        return 0;
+
+    Map * map = const_cast<Map*>(sMapMgr.CreateBaseMap(mapId));
+    if(!map)
+        return 0;
+
+    uint32 guid = GenerateLowGuid(HIGHGUID_GAMEOBJECT);
+    GameObjectData& data = NewGOData(guid);
+    data.id             = entry;
+    data.mapid          = mapId;
+    data.posX           = x;
+    data.posY           = y;
+    data.posZ           = z;
+    data.orientation    = o;
+    data.rotation0      = rotation0;
+    data.rotation1      = rotation1;
+    data.rotation2      = rotation2;
+    data.rotation3      = rotation3;
+    data.spawntimesecs  = spawntimedelay;
+    data.animprogress   = 100;
+    data.spawnMask      = 1;
+    data.go_state       = GO_STATE_READY;
+    data.phaseMask      = PHASEMASK_NORMAL;
+    data.artKit         = goinfo->type == GAMEOBJECT_TYPE_CAPTURE_POINT ? 21 : 0;
+    data.dbData = false;
+
+    AddGameobjectToGrid(guid, &data);
+
+    // Spawn if necessary (loaded grids only)
+    // We use spawn coords to spawn
+    if(!map->Instanceable() && map->IsLoaded(x, y))
+    {
+        GameObject *go = new GameObject;
+        if (!go->LoadFromDB(guid, map))
+        {
+            sLog.outError("AddGOData: cannot add gameobject entry %u to map", entry);
+            delete go;
+            return 0;
+        }
+        map->Add(go);
+    }
+
+    sLog.outDebug("AddGOData: dbguid %u entry %u map %u x %f y %f z %f o %f", guid, entry, mapId, x, y, z, o);
+
+    return guid;
+}
+
+uint32 ObjectMgr::AddCreData(uint32 entry, uint32 team, uint32 mapId, float x, float y, float z, float o, uint32 spawntimedelay)
+{
+    CreatureInfo const *cInfo = GetCreatureTemplate(entry);
+    if(!cInfo)
+        return 0;
+
+    uint32 guid = GenerateLowGuid(HIGHGUID_UNIT);
+    CreatureData& data = NewOrExistCreatureData(guid);
+    data.id = entry;
+    data.mapid = mapId;
+    data.displayid = 0;
+    data.equipmentId = cInfo->equipmentId;
+    data.posX = x;
+    data.posY = y;
+    data.posZ = z;
+    data.orientation = o;
+    data.spawntimesecs = spawntimedelay;
+    data.spawndist = 0;
+    data.currentwaypoint = 0;
+    data.curhealth = 1;
+    data.curmana = 1;
+    data.is_dead = false;
+    data.movementType = cInfo->MovementType;
+    data.spawnMask = 1;
+    data.phaseMask = PHASEMASK_NORMAL;
+    data.dbData = false;
+
+    AddCreatureToGrid(guid, &data);
+
+    // Spawn if necessary (loaded grids only)
+    if(Map * map = const_cast<Map*>(sMapMgr.CreateBaseMap(mapId)))
+    {
+        // We use spawn coords to spawn
+        if(!map->Instanceable() && !map->IsRemovalGrid(x, y))
+        {
+            Creature* creature = new Creature;
+            if(!creature->LoadFromDB(guid, map))
+            {
+                sLog.outError("AddCreature: cannot add creature entry %u to map", entry);
+                delete creature;
+                return 0;
+            }
+            map->Add(creature);
+        }
+    }
+
+    return guid;
+}
+
 void ObjectMgr::LoadGameobjects()
 {
     uint32 count = 0;
@@ -1320,8 +1508,8 @@ void ObjectMgr::LoadGameobjects()
             continue;
         }
 
-        if (data.spawnMask & ~spawnMasks[data.mapid])
-            sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) that have wrong spawn mask %u including not supported difficulty modes for map (Id: %u), skip", guid, data.id, data.spawnMask, data.mapid);
+        /*if (data.spawnMask & ~spawnMasks[data.mapid])
+            sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) that have wrong spawn mask %u including not supported difficulty modes for map (Id: %u), skip", guid, data.id, data.spawnMask, data.mapid);*/
 
         if (data.spawntimesecs == 0 && gInfo->IsDespawnAtAction())
         {
@@ -5199,7 +5387,7 @@ uint32 ObjectMgr::GetNearestTaxiNode( float x, float y, float z, uint32 mapid, u
         if(!node || node->map_id != mapid || !node->MountCreatureID[team == ALLIANCE ? 1 : 0])
             continue;
 
-        uint8  field   = (uint8)((i - 1) / 32);
+        uint8 field = (uint8)((i - 1) / 32);
         uint32 submask = 1<<((i-1)%32);
 
         // skip not taxi network nodes
@@ -5504,6 +5692,53 @@ bool ObjectMgr::AddGraveYardLink(uint32 id, uint32 zoneId, uint32 team, bool inD
     return true;
 }
 
+void ObjectMgr::RemoveGraveYardLink(uint32 id, uint32 zoneId, uint32 team, bool inDB)
+{
+    GraveYardMap::iterator graveLow  = mGraveYardMap.lower_bound(zoneId);
+    GraveYardMap::iterator graveUp   = mGraveYardMap.upper_bound(zoneId);
+    if(graveLow==graveUp)
+    {
+        //sLog.outErrorDb("Table `game_graveyard_zone` incomplete: Zone %u Team %u does not have a linked graveyard.",zoneId,team);
+        return;
+    }
+
+    bool found = false;
+
+    GraveYardMap::iterator itr;
+
+    for (itr = graveLow; itr != graveUp; ++itr)
+    {
+        GraveYardData & data = itr->second;
+
+        // skip not matching safezone id
+        if(data.safeLocId != id)
+            continue;
+
+        // skip enemy faction graveyard at same map (normal area, city, or battleground)
+        // team == 0 case can be at call from .neargrave
+        if(data.team != 0 && team != 0 && data.team != team)
+            continue;
+
+        found = true;
+        break;
+    }
+
+    // no match, return
+    if(!found)
+        return;
+
+    // remove from links
+    mGraveYardMap.erase(itr);
+
+    // remove link from DB
+    if(inDB)
+    {
+        WorldDatabase.PExecute("DELETE FROM game_graveyard_zone WHERE id = '%u' AND ghost_zone = '%u' AND faction = '%u'",id,zoneId,team);
+    }
+
+    return;
+}
+
 void ObjectMgr::LoadAreaTriggerTeleports()
 {
     mAreaTriggers.clear();                                  // need for reload case
@@ -5828,6 +6063,8 @@ uint32 ObjectMgr::GenerateLowGuid(HighGuid guidhigh)
             return m_ItemGuids.Generate();
         case HIGHGUID_UNIT:
             return m_CreatureGuids.Generate();
+        case HIGHGUID_VEHICLE:
+            return m_VehicleGuids.Generate();
         case HIGHGUID_PLAYER:
             return m_CharGuids.Generate();
         case HIGHGUID_GAMEOBJECT:
@@ -6272,6 +6509,122 @@ std::string ObjectMgr::GeneratePetName(uint32 entry)
     return *(list0.begin()+urand(0, list0.size()-1)) + *(list1.begin()+urand(0, list1.size()-1));
 }
 
+// Loads the jail conf out of the database
+void ObjectMgr::LoadJailConf(void)
+{
+    CharacterDatabase.BeginTransaction();
+    QueryResult *result = CharacterDatabase.PQuery("SELECT * FROM `jail_conf`");
+    CharacterDatabase.CommitTransaction();
+
+    if (!result)
+    {
+        sLog.outError(GetMangosStringForDBCLocale(LANG_JAIL_CONF_ERR1));
+        sLog.outError(GetMangosStringForDBCLocale(LANG_JAIL_CONF_ERR2));
+
+        m_jailconf_max_jails    = 3;
+        m_jailconf_max_duration = 672;
+        m_jailconf_min_reason   = 25;
+        m_jailconf_warn_player  = 1;
+        m_jailconf_amnestie     = 180;
+
+        m_jailconf_ally_x       = -8673.43f;
+        m_jailconf_ally_y       = 631.795f;
+        m_jailconf_ally_z       = 96.9406f;
+        m_jailconf_ally_o       = 2.1785f;
+        m_jailconf_ally_m       = 0;
+
+        m_jailconf_horde_x      = 2179.85f;
+        m_jailconf_horde_y      = -4763.96f;
+        m_jailconf_horde_z      = 54.911f;
+        m_jailconf_horde_o      = 4.44216f;
+        m_jailconf_horde_m      = 1;
+
+        m_jailconf_ban          = 0;
+        m_jailconf_radius       = 10;
+
+        return;
+    }
+    do
+    {
+        Field *fields = result->Fetch();
+        m_jail_obt = fields[1].GetString();
+        if(m_jail_obt == "m_jailconf_max_jails")
+        {
+            m_jailconf_max_jails    = fields[2].GetUInt32();
+        }
+        if(m_jail_obt == "m_jailconf_max_duration")
+        {
+            m_jailconf_max_duration = fields[2].GetUInt32();
+        }
+        if(m_jail_obt == "m_jailconf_min_reason")
+        {
+            m_jailconf_min_reason   = fields[2].GetUInt32();
+        }
+        if(m_jail_obt == "m_jailconf_warn_player")
+        {
+            m_jailconf_warn_player  = fields[2].GetUInt32();
+        }
+        if(m_jail_obt == "m_jailconf_amnestie")
+        {
+            m_jailconf_amnestie     = fields[2].GetUInt32();
+        }
+        if(m_jail_obt == "m_jailconf_ally_x")
+        {
+            m_jailconf_ally_x       = fields[3].GetFloat();
+        }
+        if(m_jail_obt == "m_jailconf_ally_y")
+        {
+            m_jailconf_ally_y       = fields[3].GetFloat();
+        }
+        if(m_jail_obt == "m_jailconf_ally_z")
+        {
+            m_jailconf_ally_z       = fields[3].GetFloat();
+        }
+        if(m_jail_obt == "m_jailconf_ally_o")
+        {
+            m_jailconf_ally_o       = fields[3].GetFloat();
+        }
+        if(m_jail_obt == "m_jailconf_ally_m")
+        {
+            m_jailconf_ally_m       = fields[2].GetUInt32();
+        }
+        if(m_jail_obt == "m_jailconf_horde_x")
+        {
+            m_jailconf_horde_x      = fields[3].GetFloat();
+        }
+        if(m_jail_obt == "m_jailconf_horde_y")
+        {
+            m_jailconf_horde_y      = fields[3].GetFloat();
+        }
+        if(m_jail_obt == "m_jailconf_horde_z")
+         {
+            m_jailconf_horde_z      = fields[3].GetFloat();
+        }
+        if(m_jail_obt == "m_jailconf_horde_o")
+        {
+            m_jailconf_horde_o      = fields[3].GetFloat();
+        }
+        if(m_jail_obt == "m_jailconf_horde_m")
+        {
+            m_jailconf_horde_m      = fields[2].GetUInt32();
+        }
+        if(m_jail_obt == "m_jailconf_ban")
+        {
+            m_jailconf_ban = fields[2].GetUInt32();
+        }
+        if(m_jail_obt == "m_jailconf_radius")
+        {
+            m_jailconf_radius = fields[2].GetUInt32();
+        }
+    }
+    while (result->NextRow());
+    delete result;
+
+    sLog.outString("");
+    sLog.outString(GetMangosStringForDBCLocale(LANG_JAIL_CONF_LOADED));
+    sLog.outString("");
+}
+
 void ObjectMgr::LoadCorpses()
 {
     uint32 count = 0;
@@ -6327,8 +6680,8 @@ void ObjectMgr::LoadReputationOnKill()
 
     //                                                0            1                     2
     QueryResult *result = WorldDatabase.Query("SELECT creature_id, RewOnKillRepFaction1, RewOnKillRepFaction2,"
-    //   3             4             5                   6             7             8                   9
-        "IsTeamAward1, MaxStanding1, RewOnKillRepValue1, IsTeamAward2, MaxStanding2, RewOnKillRepValue2, TeamDependent "
+    //   3             4             5                   6             7             8                   9              10
+        "IsTeamAward1, MaxStanding1, RewOnKillRepValue1, IsTeamAward2, MaxStanding2, RewOnKillRepValue2, TeamDependent, ChampioningAura "
         "FROM creature_onkill_reputation");
 
     if(!result)
@@ -6361,6 +6714,7 @@ void ObjectMgr::LoadReputationOnKill()
         repOnKill.reputation_max_cap2  = fields[7].GetUInt32();
         repOnKill.repvalue2            = fields[8].GetInt32();
         repOnKill.team_dependent       = fields[9].GetUInt8();
+        repOnKill.championingAura      = fields[10].GetUInt32();
 
         if(!GetCreatureTemplate(creature_id))
         {
@@ -7276,6 +7630,46 @@ const char *ObjectMgr::GetMangosString(int32 entry, int locale_idx) const
     return "<error>";
 }
 
+void ObjectMgr::LoadSpellDisabledEntrys()
+{
+    m_spell_disabled.clear();                                // need for reload case
+    QueryResult *result = WorldDatabase.Query("SELECT entry, ischeat_spell FROM spell_disabled where active=1");
+
+    uint32 total_count = 0;
+    uint32 cheat_spell_count=0;
+
+    if( !result )
+    {
+        barGoLink bar( 1 );
+        bar.step();
+
+        sLog.outString();
+        sLog.outString( ">> Loaded %u disabled spells", total_count );
+        return;
+    }
+
+    barGoLink bar( result->GetRowCount() );
+
+    Field* fields;
+    do
+    {
+        bar.step();
+        fields = result->Fetch();
+        uint32 spellid = fields[0].GetUInt32();
+        bool ischeater = fields[1].GetBool();
+        m_spell_disabled[spellid] = ischeater;
+        ++total_count;
+        if(ischeater)
+        ++cheat_spell_count;
+
+    } while ( result->NextRow() );
+
+    delete result;
+
+    sLog.outString();
+    sLog.outString( ">> Loaded %u disabled spells ( %u - is cheaters spells)", total_count, cheat_spell_count);
+}
+
 void ObjectMgr::LoadFishingBaseSkillLevel()
 {
     mFishingBaseForArea.clear();                            // for reload case
@@ -7344,8 +7738,14 @@ uint16 ObjectMgr::GetConditionId( ConditionType condition, uint32 value1, uint32
     return mConditions.size() - 1;
 }
 
-bool ObjectMgr::CheckDeclinedNames( std::wstring mainpart, DeclinedName const& names )
+bool ObjectMgr::CheckDeclinedNames( std::wstring w_ownname, DeclinedName const& names )
 {
+    // get main part of the name
+    std::wstring mainpart = GetMainPartOfName(w_ownname, 0);
+    // prepare flags
+    bool x = true;
+    bool y = true;
+    // check declined names
     for(int i =0; i < MAX_DECLINED_NAME_CASES; ++i)
     {
         std::wstring wname;
@@ -7353,9 +7753,12 @@ bool ObjectMgr::CheckDeclinedNames( std::wstring mainpart, DeclinedName const& n
             return false;
 
         if(mainpart!=GetMainPartOfName(wname,i+1))
-            return false;
+            x = false;
+
+        if(w_ownname!=wname)
+            y = false;
     }
-    return true;
+    return (x||y);
 }
 
 uint32 ObjectMgr::GetAreaTriggerScriptId(uint32 trigger_id)
@@ -8612,6 +9015,126 @@ CreatureInfo const* GetCreatureTemplateStore(uint32 entry)
     return sCreatureStorage.LookupEntry<CreatureInfo>(entry);
 }
 
+void ObjectMgr::LoadVehicleData()
+{
+    mVehicleData.clear();
+
+    QueryResult *result = WorldDatabase.Query("SELECT entry, flags, Spell1, Spell2, Spell3, Spell4, Spell5, Spell6, Spell7, Spell8, Spell9, Spell10, req_aura FROM vehicle_data");
+    if(!result)
+    {
+        barGoLink bar( 1 );
+        bar.step();
+
+        sLog.outString();
+        sLog.outString( ">> Loaded 0 vehicle data" );
+        sLog.outErrorDb("`vehicle_data` table is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    barGoLink bar( result->GetRowCount() );
+    do
+    {
+        bar.step();
+
+        Field* fields = result->Fetch();
+
+        VehicleDataStructure VDS;
+        // NOTE : we can use spellid or creature id
+        uint32 v_entry      = fields[0].GetUInt32();
+        VDS.v_flags         = fields[1].GetUInt32();
+        for(uint8 j = 0; j < MAX_VEHICLE_SPELLS; j++)
+        {
+            VDS.v_spells[j] = fields[j+2].GetUInt32();
+        }
+        VDS.req_aura        = fields[12].GetUInt32();
+
+        VehicleEntry const *vehicleInfo = sVehicleStore.LookupEntry(v_entry);
+        if(!vehicleInfo)
+        {
+            sLog.outErrorDb("Vehicle id %u listed in `vehicle_data` does not exist",v_entry);
+            continue;
+        }
+        for(uint8 j = 0; j < MAX_VEHICLE_SPELLS; j++)
+        {
+            if(VDS.v_spells[j])
+            {
+                SpellEntry const* j_spell = sSpellStore.LookupEntry(VDS.v_spells[j]);
+                if(!j_spell)
+                {
+                    sLog.outErrorDb("Spell %u listed in `vehicle_data` does not exist, skipped",VDS.v_spells[j]);
+                    VDS.v_spells[j] = 0;
+                }
+            }
+        }
+        if(VDS.req_aura)
+        {
+            SpellEntry const* i_spell = sSpellStore.LookupEntry(VDS.req_aura);
+            if(!i_spell)
+            {
+                sLog.outErrorDb("Spell %u listed in `vehicle_data` does not exist, skipped",VDS.req_aura);
+                VDS.req_aura = 0;
+            }
+        }
+
+        mVehicleData[v_entry] = VDS;
+        ++count;
+    }
+    while (result->NextRow());
+
+    delete result;
+
+    sLog.outString();
+    sLog.outString( ">> Loaded %u vehicle data", count );
+}
+
+void ObjectMgr::LoadVehicleSeatData()
+{
+    mVehicleSeatData.clear();
+
+    QueryResult *result = WorldDatabase.Query("SELECT seat,flags FROM vehicle_seat_data");
+
+    if( !result )
+    {
+        barGoLink bar( 1 );
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString( ">> Loaded 0 vehicle seat data" );
+        sLog.outErrorDb("`vehicle_seat_data` table is empty!");
+        return;
+    }
+    uint32 count = 0;
+
+    barGoLink bar( result->GetRowCount() );
+    do
+    {
+        bar.step();
+
+        Field *fields = result->Fetch();
+        uint32 entry  = fields[0].GetUInt32();
+        uint32 flag   = fields[1].GetUInt32();
+
+        VehicleSeatEntry const *vsInfo = sVehicleSeatStore.LookupEntry(entry);
+        if(!vsInfo)
+        {
+            sLog.outErrorDb("Vehicle seat %u listed in `vehicle_seat_data` does not exist",entry);
+            continue;
+        }
+
+        mVehicleSeatData[entry] = flag;
+        ++count;
+    }
+    while (result->NextRow());
+
+    delete result;
+
+    sLog.outString();
+    sLog.outString( ">> Loaded %u vehicle seat data", count );
+}
+
 Quest const* GetQuestTemplateStore(uint32 entry)
 {
     return sObjectMgr.GetQuestTemplate(entry);
diff --git a/mangos/src/game/ObjectMgr.h b/Core/src/game/ObjectMgr.h
index 7e51ba9..00982c7 100644
--- a/mangos/src/game/ObjectMgr.h
+++ b/Core/src/game/ObjectMgr.h
@@ -204,6 +204,7 @@ struct ReputationOnKillEntry
     uint32 reputation_max_cap2;
     int32 repvalue2;
     bool team_dependent;
+    uint32 championingAura;
 };
 
 struct PointOfInterest
@@ -375,6 +376,8 @@ extern LanguageDesc lang_description[LANGUAGES_COUNT];
 MANGOS_DLL_SPEC LanguageDesc const* GetLanguageDescByID(uint32 lang);
 
 class PlayerDumpReader;
+// vehicle system
+#define MAX_VEHICLE_SPELLS 6
 
 template<typename T>
 class IdGenerator
@@ -394,6 +397,16 @@ class IdGenerator
         T m_nextGuid;
 };
 
+struct VehicleDataStructure
+{
+    uint32 v_flags;                                         // vehicle flags, see enum CustomVehicleFLags
+    uint32 v_spells[MAX_VEHICLE_SPELLS];                    // spells
+    uint32 req_aura;                                        // requieres aura on player to enter (eg. in wintergrasp)
+};
+
+typedef UNORDERED_MAP<uint32, VehicleDataStructure> VehicleDataMap;
+typedef std::map<uint32,uint32> VehicleSeatDataMap;
+
 class ObjectMgr
 {
     friend class PlayerDumpReader;
@@ -530,6 +543,7 @@ class ObjectMgr
 
         WorldSafeLocsEntry const *GetClosestGraveYard(float x, float y, float z, uint32 MapId, uint32 team);
         bool AddGraveYardLink(uint32 id, uint32 zone, uint32 team, bool inDB = true);
+        void RemoveGraveYardLink(uint32 id, uint32 zone, uint32 team, bool inDB = false);
         void LoadGraveyardZones();
         GraveYardData const* FindGraveYardData(uint32 id, uint32 zone);
 
@@ -658,6 +672,32 @@ class ObjectMgr
         void LoadVendors();
         void LoadTrainerSpell();
 
+        void LoadVehicleData();
+        void LoadVehicleSeatData();
+        
+        // Loads the jail conf out of the database
+        void LoadJailConf(void);
+
+        // Jail Config...
+        std::string m_jail_obt;
+        uint32 m_jailconf_max_jails;    // Jail times when the char will be deleted
+        uint32 m_jailconf_max_duration; // Max. jail duration in hours
+        uint32 m_jailconf_min_reason;   // Min. char length of the reason
+        uint32 m_jailconf_warn_player;  // Warn player every login if max_jails is nearly reached?
+        uint32 m_jailconf_amnestie;     // player amnestie
+        float m_jailconf_ally_x;        // Coords of the jail for the allies
+        float m_jailconf_ally_y;
+        float m_jailconf_ally_z;
+        float m_jailconf_ally_o;
+        uint32 m_jailconf_ally_m;
+        float m_jailconf_horde_x;       // Coords of the jail for the horde
+        float m_jailconf_horde_y;
+        float m_jailconf_horde_z;
+        float m_jailconf_horde_o;
+        uint32 m_jailconf_horde_m;
+        uint32 m_jailconf_ban;          // Ban acc if max. jailtimes is reached?
+        uint32 m_jailconf_radius;       // Radius in which a jailed char can walk
+
         std::string GeneratePetName(uint32 entry);
         uint32 GetBaseXP(uint32 level) const;
         uint32 GetXPForLevel(uint32 level) const;
@@ -803,6 +843,8 @@ class ObjectMgr
         void RemoveCreatureFromGrid(uint32 guid, CreatureData const* data);
         void AddGameobjectToGrid(uint32 guid, GameObjectData const* data);
         void RemoveGameobjectFromGrid(uint32 guid, GameObjectData const* data);
+        uint32 AddGOData(uint32 entry, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay = 0, float rotation0 = 0, float rotation1 = 0, float rotation2 = 0, float rotation3 = 0);
+        uint32 AddCreData(uint32 entry, uint32 team, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay = 0);
 
         // reserved names
         void LoadReservedPlayersNames();
@@ -813,7 +855,21 @@ class ObjectMgr
         static PetNameInvalidReason CheckPetName( const std::string& name );
         static bool IsValidCharterName( const std::string& name );
 
-        static bool CheckDeclinedNames(std::wstring mainpart, DeclinedName const& names);
+        static bool CheckDeclinedNames(std::wstring w_ownname, DeclinedName const& names);
+
+        void LoadSpellDisabledEntrys();
+        uint8 IsSpellDisabled(uint32 spellid)
+        {
+            uint8 result=0;
+            SpellDisabledMap::const_iterator itr = m_spell_disabled.find(spellid);
+            if(itr != m_spell_disabled.end())
+            {
+                result=1;
+                if(itr->second != 0)
+                    result=2;
+            }
+            return result;
+        }
 
         int GetIndexForLocale(LocaleConstant loc);
         LocaleConstant GetLocaleForIndex(int i);
@@ -875,6 +931,24 @@ class ObjectMgr
 
         int GetOrNewIndexForLocale(LocaleConstant loc);
 
+        VehicleDataMap mVehicleData;
+        VehicleSeatDataMap mVehicleSeatData;
+
+        uint32 GetSeatFlags(uint32 seatid)
+        {
+            VehicleSeatDataMap::iterator i = mVehicleSeatData.find(seatid);
+            if(i == mVehicleSeatData.end())
+                return NULL;
+            else
+                return i->second;
+        }
+        VehicleDataStructure const* GetVehicleData(uint32 entry) const
+        {
+            VehicleDataMap::const_iterator itr = mVehicleData.find(entry);
+            if(itr==mVehicleData.end()) return NULL;
+            return &itr->second;
+        }
+
         SpellClickInfoMapBounds GetSpellClickInfoMapBounds(uint32 creature_id) const
         {
             return SpellClickInfoMapBounds(mSpellClickInfoMap.lower_bound(creature_id),mSpellClickInfoMap.upper_bound(creature_id));
@@ -912,6 +986,7 @@ class ObjectMgr
         ObjectGuidGenerator<HIGHGUID_ITEM>       m_ItemGuids;
         ObjectGuidGenerator<HIGHGUID_GAMEOBJECT> m_GameobjectGuids;
         ObjectGuidGenerator<HIGHGUID_CORPSE>     m_CorpseGuids;
+        ObjectGuidGenerator<HIGHGUID_VEHICLE>    m_VehicleGuids;
 
         QuestMap            mQuestTemplates;
 
@@ -945,6 +1020,9 @@ class ObjectMgr
         typedef std::set<std::wstring> ReservedNamesMap;
         ReservedNamesMap    m_ReservedNames;
 
+        typedef UNORDERED_MAP<uint32, uint32> SpellDisabledMap;
+        SpellDisabledMap  m_spell_disabled;
+
         GraveYardMap        mGraveYardMap;
 
         GameTeleMap         m_GameTeleMap;
@@ -965,6 +1043,7 @@ class ObjectMgr
         void CheckScriptTexts(ScriptMapMap const& scripts,std::set<int32>& ids);
         void LoadCreatureAddons(SQLStorage& creatureaddons, char const* entryName, char const* comment);
         void ConvertCreatureAddonAuras(CreatureDataAddon* addon, char const* table, char const* guidEntryStr);
+        void ConvertCreatureAddonPassengers(CreatureDataAddon* addon, char const* table, char const* guidEntryStr);
         void LoadQuestRelationsHelper(QuestRelations& map,char const* table);
 
         MailLevelRewardMap m_mailLevelRewardMap;
diff --git a/mangos/src/game/Opcodes.cpp b/Core/src/game/Opcodes.cpp
index e1c0c7d..c09a410 100644
--- a/mangos/src/game/Opcodes.cpp
+++ b/Core/src/game/Opcodes.cpp
@@ -1051,8 +1051,8 @@ OpcodeHandler opcodeTable[NUM_MSG_TYPES] =
     /*0x3FE*/ { "MSG_GUILD_BANK_MONEY_WITHDRAWN",               STATUS_LOGGEDIN, &WorldSession::HandleGuildBankMoneyWithdrawn   },
     /*0x3FF*/ { "MSG_GUILD_EVENT_LOG_QUERY",                    STATUS_LOGGEDIN, &WorldSession::HandleGuildEventLogQueryOpcode  },
     /*0x400*/ { "CMSG_MAELSTROM_RENAME_GUILD",                  STATUS_NEVER,    &WorldSession::Handle_NULL                     },
-    /*0x401*/ { "CMSG_GET_MIRRORIMAGE_DATA",                    STATUS_NEVER,    &WorldSession::Handle_NULL                     },
-    /*0x402*/ { "SMSG_MIRRORIMAGE_DATA",                        STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
+    /*0x401*/ { "CMSG_GET_MIRRORIMAGE_DATA",                    STATUS_LOGGEDIN, &WorldSession::HandleMirrorImageDataRequest    },
+    /*0x402*/ { "SMSG_MIRRORIMAGE_DATA",                        STATUS_LOGGEDIN, &WorldSession::Handle_ServerSide               },
     /*0x403*/ { "SMSG_FORCE_DISPLAY_UPDATE",                    STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x404*/ { "SMSG_SPELL_CHANCE_RESIST_PUSHBACK",            STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x405*/ { "CMSG_IGNORE_DIMINISHING_RETURNS_CHEAT",        STATUS_NEVER,    &WorldSession::Handle_NULL                     },
@@ -1168,10 +1168,10 @@ OpcodeHandler opcodeTable[NUM_MSG_TYPES] =
     /*0x473*/ { "CMSG_CHAR_CUSTOMIZE",                          STATUS_AUTHED,   &WorldSession::HandleCharCustomize             },
     /*0x474*/ { "SMSG_CHAR_CUSTOMIZE",                          STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x475*/ { "SMSG_PET_RENAMEABLE",                          STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
-    /*0x476*/ { "CMSG_REQUEST_VEHICLE_EXIT",                    STATUS_NEVER,    &WorldSession::Handle_NULL                     },
-    /*0x477*/ { "CMSG_REQUEST_VEHICLE_PREV_SEAT",               STATUS_NEVER,    &WorldSession::Handle_NULL                     },
-    /*0x478*/ { "CMSG_REQUEST_VEHICLE_NEXT_SEAT",               STATUS_NEVER,    &WorldSession::Handle_NULL                     },
-    /*0x479*/ { "CMSG_REQUEST_VEHICLE_SWITCH_SEAT",             STATUS_NEVER,    &WorldSession::Handle_NULL                     },
+    /*0x476*/ { "CMSG_REQUEST_VEHICLE_EXIT",                    STATUS_LOGGEDIN, &WorldSession::HandleRequestVehicleExit        },
+    /*0x477*/ { "CMSG_REQUEST_VEHICLE_PREV_SEAT",               STATUS_LOGGEDIN, &WorldSession::HandleChangeSeatsOnControlledVehicle},
+    /*0x478*/ { "CMSG_REQUEST_VEHICLE_NEXT_SEAT",               STATUS_LOGGEDIN, &WorldSession::HandleChangeSeatsOnControlledVehicle},
+    /*0x479*/ { "CMSG_REQUEST_VEHICLE_SWITCH_SEAT",             STATUS_LOGGEDIN, &WorldSession::HandleRequestVehicleSwitchSeat  },
     /*0x47A*/ { "CMSG_PET_LEARN_TALENT",                        STATUS_LOGGEDIN, &WorldSession::HandlePetLearnTalent            },
     /*0x47B*/ { "CMSG_PET_UNLEARN_TALENTS",                     STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x47C*/ { "SMSG_SET_PHASE_SHIFT",                         STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
@@ -1205,7 +1205,7 @@ OpcodeHandler opcodeTable[NUM_MSG_TYPES] =
     /*0x498*/ { "SMSG_SERVER_FIRST_ACHIEVEMENT",                STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x499*/ { "SMSG_PET_LEARNED_SPELL",                       STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x49A*/ { "SMSG_PET_REMOVED_SPELL",                       STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
-    /*0x49B*/ { "CMSG_CHANGE_SEATS_ON_CONTROLLED_VEHICLE",      STATUS_NEVER,    &WorldSession::Handle_NULL                     },
+    /*0x49B*/ { "CMSG_CHANGE_SEATS_ON_CONTROLLED_VEHICLE",      STATUS_LOGGEDIN, &WorldSession::HandleChangeSeatsOnControlledVehicle}, 
     /*0x49C*/ { "CMSG_HEARTH_AND_RESURRECT",                    STATUS_LOGGEDIN, &WorldSession::HandleHearthandResurrect        },
     /*0x49D*/ { "SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA",    STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x49E*/ { "SMSG_CRITERIA_DELETED",                        STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
@@ -1230,7 +1230,7 @@ OpcodeHandler opcodeTable[NUM_MSG_TYPES] =
     /*0x4B1*/ { "UMSG_UNKNOWN_1201",                            STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x4B2*/ { "SMSG_ITEM_REFUND_INFO_RESPONSE",               STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x4B3*/ { "CMSG_ITEM_REFUND_INFO",                        STATUS_LOGGEDIN, &WorldSession::HandleItemRefundInfoRequest     },
-    /*0x4B4*/ { "CMSG_ITEM_REFUND",                             STATUS_NEVER,    &WorldSession::Handle_NULL                     },
+    /*0x4B4*/ { "CMSG_ITEM_REFUND",                             STATUS_LOGGEDIN, &WorldSession::HandleItemRefund                },
     /*0x4B5*/ { "SMSG_ITEM_REFUND_RESULT",                      STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x4B6*/ { "CMSG_CORPSE_MAP_POSITION_QUERY",               STATUS_LOGGEDIN, &WorldSession::HandleCorpseMapPositionQuery    },
     /*0x4B7*/ { "SMSG_CORPSE_MAP_POSITION_QUERY_RESPONSE",      STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
@@ -1267,7 +1267,7 @@ OpcodeHandler opcodeTable[NUM_MSG_TYPES] =
     /*0x4D6*/ { "SMSG_EQUIPMENT_SET_USE_RESULT",                STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x4D7*/ { "UMSG_UNKNOWN_1239",                            STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x4D8*/ { "SMSG_UNKNOWN_1240",                            STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
-    /*0x4D9*/ { "CMSG_CHAR_FACTION_CHANGE",                     STATUS_NEVER,    &WorldSession::Handle_NULL                     },
+    /*0x4D9*/ { "CMSG_CHAR_FACTION_CHANGE",                     STATUS_AUTHED,   &WorldSession::HandleCharFactionOrRaceChange   },
     /*0x4DA*/ { "SMSG_CHAR_FACTION_CHANGE",                     STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x4DB*/ { "UMSG_UNKNOWN_1243",                            STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x4DC*/ { "UMSG_UNKNOWN_1244",                            STATUS_NEVER,    &WorldSession::Handle_NULL                     },
@@ -1298,7 +1298,7 @@ OpcodeHandler opcodeTable[NUM_MSG_TYPES] =
     /*0x4F5*/ { "UMSG_UNKNOWN_1269",                            STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x4F6*/ { "CMSG_WORLD_STATE_UI_TIMER_UPDATE",             STATUS_LOGGEDIN, &WorldSession::HandleWorldStateUITimerUpdate   },
     /*0x4F7*/ { "SMSG_WORLD_STATE_UI_TIMER_UPDATE",             STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
-    /*0x4F8*/ { "CMSG_CHAR_RACE_CHANGE",                        STATUS_NEVER,    &WorldSession::Handle_NULL                     },
+    /*0x4F8*/ { "CMSG_CHAR_RACE_CHANGE",                        STATUS_AUTHED,   &WorldSession::HandleCharFactionOrRaceChange   },
     /*0x4F9*/ { "UMSG_UNKNOWN_1273",                            STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x4FA*/ { "SMSG_TALENTS_INVOLUNTARILY_RESET",             STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x4FB*/ { "UMSG_UNKNOWN_1275",                            STATUS_NEVER,    &WorldSession::Handle_NULL                     },
diff --git a/Core/src/game/OutdoorPvP.cpp b/Core/src/game/OutdoorPvP.cpp
new file mode 100644
index 0000000..e9c19d0
--- /dev/null
+++ b/Core/src/game/OutdoorPvP.cpp
@@ -0,0 +1,683 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvP.h"
+#include "OutdoorPvPImpl.h"
+#include "OutdoorPvPMgr.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "Map.h"
+#include "MapManager.h"
+#include "Group.h"
+#include "WorldPacket.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "CellImpl.h"
+
+#include "Database/DatabaseEnv.h"
+#include "World.h"
+#include "Player.h"
+#include "Opcodes.h"
+#include "Chat.h"
+#include "ObjectAccessor.h"
+#include "Language.h"
+#include "AccountMgr.h"
+#include "SystemConfig.h"
+#include "revision.h"
+#include "revision_nr.h"
+#include "Util.h"
+
+OPvPCapturePoint::OPvPCapturePoint(OutdoorPvP * pvp)
+: m_PvP(pvp), m_value(0), m_maxValue(0), m_team(TEAM_NEUTRAL),
+m_State(OBJECTIVESTATE_NEUTRAL), m_OldState(OBJECTIVESTATE_NEUTRAL), m_capturePointGUID(0), m_neutralValuePct(0),
+m_maxSpeed(0), m_capturePoint(NULL)
+{
+}
+
+bool OPvPCapturePoint::HandlePlayerEnter(Player * plr)
+{
+    if(m_capturePoint)
+    {
+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32)ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
+    }
+    return m_activePlayers[plr->GetTeamId()].insert(plr).second;
+}
+
+void OPvPCapturePoint::HandlePlayerLeave(Player * plr)
+{
+    if(m_capturePoint)
+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 0);
+    m_activePlayers[plr->GetTeamId()].erase(plr);
+}
+
+void OPvPCapturePoint::SendChangePhase()
+{
+    if(!m_capturePoint)
+        return;
+
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
+    // send these updates to only the ones in this objective
+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32)ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
+}
+
+void OPvPCapturePoint::AddGO(uint32 type, uint32 guid, uint32 entry)
+{
+    if(!entry)
+    {
+        const GameObjectData *data = sObjectMgr.GetGOData(guid);
+        if(!data)
+            return;
+        entry = data->id;
+    }
+    m_Objects[type] = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+    m_ObjectTypes[m_Objects[type]]=type;
+}
+
+void OPvPCapturePoint::AddCre(uint32 type, uint32 guid, uint32 entry)
+{
+    if(!entry)
+    {
+        const CreatureData *data = sObjectMgr.GetCreatureData(guid);
+        if(!data)
+            return;
+        entry = data->id;
+    }
+    m_Creatures[type] = MAKE_NEW_GUID(guid, entry, HIGHGUID_UNIT);
+    m_CreatureTypes[m_Creatures[type]] = type;
+}
+
+bool OPvPCapturePoint::AddObject(uint32 type, uint32 entry, uint32 mapId, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3)
+{
+    GameObjectInfo const* goinfo = sObjectMgr.GetGameObjectInfo(entry);
+    if (!goinfo)
+        return 0;
+
+    uint32 guid = sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT);
+    GameObjectData& data = sObjectMgr.NewGOData(guid);
+    data.id             = entry;
+    data.mapid          = mapId;
+    data.posX           = x;
+    data.posY           = y;
+    data.posZ           = z;
+    data.orientation    = o;
+    data.rotation0      = rotation0;
+    data.rotation1      = rotation1;
+    data.rotation2      = rotation2;
+    data.rotation3      = rotation3;
+    data.spawntimesecs  = 0;
+    data.animprogress   = 100;
+    data.spawnMask      = 1;
+    data.go_state       = GO_STATE_READY;
+    data.phaseMask      = PHASEMASK_NORMAL;
+    data.artKit         = goinfo->type == GAMEOBJECT_TYPE_CAPTURE_POINT ? 21 : 0;
+    data.dbData = false;
+
+    Map * map = const_cast<Map*>(sMapMgr.CreateBaseMap(mapId));
+    if(!map)
+    {
+        sLog.outError("Map (Id: %i) for AddObject cannot be initialized.", mapId);
+        return false;
+    }
+
+    //SetMap(newMap);
+
+    sObjectMgr.AddGameobjectToGrid(guid, &data);
+
+    // Spawn if necessary (loaded grids only)
+    // We use spawn coords to spawn
+    if(!map->Instanceable() && map->IsLoaded(x, y))
+    {
+        GameObject *go = new GameObject;
+        if (!go->LoadFromDB(guid, map))
+        {
+            sLog.outError("AddGOData: cannot add gameobject entry %u to map", entry);
+            delete go;
+            return 0;
+        }
+        map->Add(go);
+    }
+
+    sLog.outDebug("AddGOData: dbguid %u entry %u map %u x %f y %f z %f o %f", guid, entry, mapId, x, y, z, o);
+
+    //return guid;
+ //   if(uint32 guid = sObjectMgr.AddGOData(entry, map, x, y, z, o, 0, rotation0, rotation1, rotation2, rotation3))
+    if(guid)
+    {
+        AddGO(type, guid, entry);
+        return true;
+    }
+
+    return false;
+}
+
+bool OPvPCapturePoint::AddCreature(uint32 type, uint32 entry, uint32 team, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay)
+{
+    if(uint32 guid = sObjectMgr.AddCreData(entry, team, map, x, y, z, o, spawntimedelay))
+    {
+        AddCre(type, guid, entry);
+        return true;
+    }
+
+    return false;
+}
+
+
+bool OPvPCapturePoint::SetCapturePointData(uint32 entry, uint32 map, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3)
+{
+    sLog.outDebug("Creating capture point %u", entry);
+
+    // check info existence
+    GameObjectInfo const* goinfo = sObjectMgr.GetGameObjectInfo(entry);
+    if(!goinfo || goinfo->type != GAMEOBJECT_TYPE_CAPTURE_POINT)
+    {
+        sLog.outError("OutdoorPvP: GO %u is not capture point!", entry);
+        return false;
+    }
+
+    m_capturePointGUID = sObjectMgr.AddGOData(entry, map, x, y, z, o, 0, rotation0, rotation1, rotation2, rotation3);
+    if(!m_capturePointGUID)
+        return false;
+
+    // get the needed values from goinfo
+    m_maxValue = goinfo->capturePoint.maxTime;
+    m_maxSpeed = m_maxValue / (goinfo->capturePoint.minTime ? goinfo->capturePoint.minTime : 60);
+    m_neutralValuePct = goinfo->capturePoint.neutralPercent;
+    m_minValue = m_maxValue * goinfo->capturePoint.neutralPercent / 100;
+
+    return true;
+}
+
+bool OPvPCapturePoint::DelCreature(uint32 type)
+{
+    if(!m_Creatures[type])
+    {
+        sLog.outDebug("opvp creature type %u was already deleted",type);
+        return false;
+    }
+
+    Creature * cr = ObjectAccessor::GetCreatureInWorld(m_Creatures[type]);
+    if(!cr)
+    {
+        // can happen when closing the core
+        m_Creatures[type] = 0;
+        return false;
+    }
+    sLog.outDebug("deleting opvp creature type %u",type);
+    uint32 guid = cr->GetDBTableGUIDLow();
+    // Don't save respawn time
+    cr->SetRespawnTime(0);
+    cr->RemoveCorpse();
+    // explicit removal from map
+    // beats me why this is needed, but with the recent removal "cleanup" some creatures stay in the map if "properly" deleted
+    // so this is a big fat workaround, if AddObjectToRemoveList and DoDelayedMovesAndRemoves worked correctly, this wouldn't be needed
+    //if(Map * map = MapManager::Instance().FindMap(cr->GetMapId()))
+    //    map->Remove(cr,false);
+    // delete respawn time for this creature
+    WorldDatabase.PExecute("DELETE FROM creature_respawn WHERE guid = '%u'", guid);
+    cr->AddObjectToRemoveList();
+    sObjectMgr.DeleteCreatureData(guid);
+    m_CreatureTypes[m_Creatures[type]] = 0;
+    m_Creatures[type] = 0;
+    return true;
+}
+
+bool OPvPCapturePoint::DelObject(uint32 type)
+{
+    if(!m_Objects[type])
+        return false;
+
+    GameObject * obj = ObjectAccessor::GetGameObjectInWorld(m_Objects[type]);
+    if(!obj)
+    {
+        m_Objects[type] = 0;
+        return false;
+    }
+    uint32 guid = obj->GetDBTableGUIDLow();
+    obj->SetRespawnTime(0);                                 // not save respawn time
+    obj->Delete();
+    sObjectMgr.DeleteGOData(guid);
+    m_ObjectTypes[m_Objects[type]] = 0;
+    m_Objects[type] = 0;
+    return true;
+}
+
+bool OPvPCapturePoint::DelCapturePoint()
+{
+    sObjectMgr.DeleteGOData(m_capturePointGUID);
+    m_capturePointGUID = 0;
+
+    if(m_capturePoint)
+    {
+        m_capturePoint->SetRespawnTime(0);                                 // not save respawn time
+        m_capturePoint->Delete();
+    }
+
+    return true;
+}
+
+void OPvPCapturePoint::DeleteSpawns()
+{
+    for (std::map<uint32,uint64>::iterator i = m_Objects.begin(); i != m_Objects.end(); ++i)
+        DelObject(i->first);
+    for (std::map<uint32,uint64>::iterator i = m_Creatures.begin(); i != m_Creatures.end(); ++i)
+        DelCreature(i->first);
+    DelCapturePoint();
+}
+
+void OutdoorPvP::DeleteSpawns()
+{
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        itr->second->DeleteSpawns();
+}
+
+OutdoorPvP::OutdoorPvP() : m_sendUpdate(true)
+{
+}
+
+OutdoorPvP::~OutdoorPvP()
+{
+    DeleteSpawns();
+}
+
+void OutdoorPvP::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    m_players[plr->GetTeamId()].insert(plr);
+}
+
+void OutdoorPvP::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // inform the objectives of the leaving
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        itr->second->HandlePlayerLeave(plr);
+    // remove the world state information from the player (we can't keep everyone up to date, so leave out those who are not in the concerning zones)
+    if(!plr->GetSession()->PlayerLogout())
+        SendRemoveWorldStates(plr);
+    m_players[plr->GetTeamId()].erase(plr);
+    sLog.outDebug("Player %s left an outdoorpvp zone", plr->GetName());
+}
+
+void OutdoorPvP::HandlePlayerResurrects(Player * plr, uint32 zone)
+{
+}
+
+bool OutdoorPvP::Update(uint32 diff)
+{
+    bool objective_changed = false;
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+    {
+        if(itr->second->Update(diff))
+            objective_changed = true;
+    }
+    return objective_changed;
+}
+
+bool OPvPCapturePoint::Update(uint32 diff)
+{
+    if(!m_capturePoint)
+        return false;
+
+    float radius = m_capturePoint->GetGOInfo()->capturePoint.radius;
+
+    for (uint32 team = 0; team < 2; ++team)
+    {
+        for (PlayerSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end();)
+        {
+            Player *player = *itr;
+            ++itr;
+            if(!m_capturePoint->IsWithinDistInMap(player, radius) || !player->IsOutdoorPvPActive())
+                HandlePlayerLeave(player);
+        }
+    }
+
+    std::list<Player*> players;
+    std::list<Unit *> targets;
+
+    CellPair p(MaNGOS::ComputeCellPair(m_capturePoint->GetPositionX(), m_capturePoint->GetPositionY()));
+    Cell cell(p);
+    cell.data.Part.reserved = ALL_DISTRICT;
+    cell.SetNoCreate();   
+
+    {
+    MaNGOS::AnyUnitInObjectRangeCheck u_check(m_capturePoint, radius);
+    MaNGOS::UnitListSearcher<MaNGOS::AnyUnitInObjectRangeCheck> searcher( m_capturePoint, targets, u_check);
+
+    TypeContainerVisitor<MaNGOS::UnitListSearcher<MaNGOS::AnyUnitInObjectRangeCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<MaNGOS::UnitListSearcher<MaNGOS::AnyUnitInObjectRangeCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *m_capturePoint->GetMap());
+    cell.Visit(p, grid_unit_searcher, *m_capturePoint->GetMap());
+    }
+
+    for( std::list<Unit *>::iterator itr = targets.begin(); itr != targets.end(); ++itr )
+				if( (*itr)->GetTypeId() == TYPEID_PLAYER )
+                    players.push_back((Player*)(*itr));
+
+    for (std::list<Player*>::iterator itr = players.begin(); itr != players.end(); ++itr)
+    {
+        if((*itr)->IsOutdoorPvPActive())
+        {
+            if(m_activePlayers[(*itr)->GetTeamId()].insert(*itr).second)
+                HandlePlayerEnter(*itr);
+        }
+    }
+
+    // get the difference of numbers
+    float fact_diff = ((float)m_activePlayers[0].size() - (float)m_activePlayers[1].size()) * diff / OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL;
+    if(!fact_diff)
+        return false;
+
+    uint32 Challenger = 0;
+    float maxDiff = m_maxSpeed * diff;
+
+    if(fact_diff < 0)
+    {
+        // horde is in majority, but it's already horde-controlled -> no change
+        if(m_State == OBJECTIVESTATE_HORDE && m_value <= -m_maxValue)
+            return false;
+
+        if(fact_diff < -maxDiff)
+            fact_diff = -maxDiff;
+
+        Challenger = HORDE;
+    }
+    else
+    {
+        // ally is in majority, but it's already ally-controlled -> no change
+        if(m_State == OBJECTIVESTATE_ALLIANCE && m_value >= m_maxValue)
+            return false;
+
+        if(fact_diff > maxDiff)
+            fact_diff = maxDiff;
+
+        Challenger = ALLIANCE;
+    }
+
+    float oldValue = m_value;
+    TeamId oldTeam = m_team;
+
+    m_OldState = m_State;
+
+    m_value += fact_diff;
+
+    if(m_value < -m_minValue) // red
+    {
+        if(m_value < -m_maxValue)
+            m_value = -m_maxValue;
+        m_State = OBJECTIVESTATE_HORDE;
+        m_team = TEAM_HORDE;
+    }
+    else if(m_value > m_minValue) // blue
+    {
+        if(m_value > m_maxValue)
+            m_value = m_maxValue;
+        m_State = OBJECTIVESTATE_ALLIANCE;
+        m_team = TEAM_ALLIANCE;
+    }
+    else if(oldValue * m_value <= 0) // grey, go through mid point
+    {
+        // if challenger is ally, then n->a challenge
+        if(Challenger == ALLIANCE)
+            m_State = OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE;
+        // if challenger is horde, then n->h challenge
+        else if(Challenger == HORDE)
+            m_State = OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE;
+        m_team = TEAM_NEUTRAL;
+    }
+    else // grey, did not go through mid point
+    {
+        // old phase and current are on the same side, so one team challenges the other
+        if(Challenger == ALLIANCE && (m_OldState == OBJECTIVESTATE_HORDE || m_OldState == OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE))
+            m_State = OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE;
+        else if(Challenger == HORDE && (m_OldState == OBJECTIVESTATE_ALLIANCE || m_OldState == OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE))
+            m_State = OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE;
+        m_team = TEAM_NEUTRAL;
+    }
+
+    if(m_value != oldValue)
+        SendChangePhase();
+
+    if(m_OldState != m_State)
+    {
+        //sLog.outError("%u->%u", m_OldState, m_State);
+        if(oldTeam != m_team)
+            ChangeTeam(oldTeam);
+        ChangeState();
+        return true;
+    }
+
+    return false;
+}
+
+void OutdoorPvP::SendUpdateWorldState(uint32 field, uint32 value)
+{
+    if(m_sendUpdate)
+        for (int i = 0; i < 2; ++i)
+            for (PlayerSet::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+                (*itr)->SendUpdateWorldState(field, value);
+}
+
+void OPvPCapturePoint::SendUpdateWorldState(uint32 field, uint32 value)
+{
+    for (uint32 team = 0; team < 2; ++team)
+    {
+        // send to all players present in the area
+        for (PlayerSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+        {
+            (*itr)->SendUpdateWorldState(field,value);
+        }
+    }
+}
+
+void OPvPCapturePoint::SendObjectiveComplete(uint32 id,uint64 guid)
+{
+    uint32 team;
+    switch(m_State)
+    {
+    case OBJECTIVESTATE_ALLIANCE:
+        team = 0;
+        break;
+    case OBJECTIVESTATE_HORDE:
+        team = 1;
+        break;
+    default:
+        return;
+    }
+
+    // send to all players present in the area
+    for (PlayerSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+        (*itr)->KilledMonsterCredit(id, guid);
+}
+
+void OutdoorPvP::HandleKill(Player *killer, Unit * killed)
+{
+    if(Group * pGroup = killer->GetGroup())
+    {
+        for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player *pGroupGuy = itr->getSource();
+
+            if(!pGroupGuy)
+                continue;
+
+            // skip if too far away
+            if(!pGroupGuy->IsAtGroupRewardDistance(killed))
+                continue;
+
+            // creature kills must be notified, even if not inside objective / not outdoor pvp active
+            // player kills only count if active and inside objective
+            if(( pGroupGuy->IsOutdoorPvPActive() && IsInsideObjective(pGroupGuy) ) || killed->GetTypeId() == TYPEID_UNIT)
+            {
+                HandleKillImpl(pGroupGuy, killed);
+            }
+        }
+    }
+    else
+    {
+        // creature kills must be notified, even if not inside objective / not outdoor pvp active
+        if(killer && (( killer->IsOutdoorPvPActive() && IsInsideObjective(killer) ) || killed->GetTypeId() == TYPEID_UNIT))
+        {
+            HandleKillImpl(killer, killed);
+        }
+    }
+}
+
+bool OutdoorPvP::IsInsideObjective(Player *plr) const
+{
+    for (OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if(itr->second->IsInsideObjective(plr))
+            return true;
+
+    return false;
+}
+
+bool OPvPCapturePoint::IsInsideObjective(Player *plr) const
+{
+    return m_activePlayers[plr->GetTeamId()].find(plr) != m_activePlayers[plr->GetTeamId()].end();
+}
+
+bool OutdoorPvP::HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go)
+{
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if(itr->second->HandleCustomSpell(plr,spellId,go))
+            return true;
+
+    return false;
+}
+
+bool OPvPCapturePoint::HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go)
+{
+    if(!plr->IsOutdoorPvPActive())
+        return false;
+    return false;
+}
+
+bool OutdoorPvP::HandleOpenGo(Player *plr, uint64 guid)
+{
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if(itr->second->HandleOpenGo(plr,guid) >= 0)
+            return true;
+
+    return false;
+}
+
+bool OutdoorPvP::HandleGossipOption(Player * plr, uint64 guid, uint32 id)
+{
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if(itr->second->HandleGossipOption(plr, guid, id))
+            return true;
+
+    return false;
+}
+
+bool OutdoorPvP::CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso)
+{
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if(itr->second->CanTalkTo(plr, c, gso))
+            return true;
+
+    return false;
+}
+
+bool OutdoorPvP::HandleDropFlag(Player * plr, uint32 id)
+{
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if(itr->second->HandleDropFlag(plr, id))
+            return true;
+
+    return false;
+}
+
+bool OPvPCapturePoint::HandleGossipOption(Player * plr, uint64 guid, uint32 id)
+{
+    return false;
+}
+
+bool OPvPCapturePoint::CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso)
+{
+    return false;
+}
+
+bool OPvPCapturePoint::HandleDropFlag(Player * plr, uint32 id)
+{
+    return false;
+}
+
+int32 OPvPCapturePoint::HandleOpenGo(Player *plr, uint64 guid)
+{
+    std::map<uint64,uint32>::iterator itr = m_ObjectTypes.find(guid);
+    if(itr != m_ObjectTypes.end())
+    {
+        return itr->second;
+    }
+    return -1;
+}
+
+bool OutdoorPvP::HandleAreaTrigger(Player *plr, uint32 trigger)
+{
+    return false;
+}
+
+void OutdoorPvP::BroadcastPacket(WorldPacket &data) const
+{
+    // This is faster than sWorld.SendZoneMessage
+    for (uint32 team = 0; team < 2; ++team)
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            (*itr)->GetSession()->SendPacket(&data);
+}
+
+void OutdoorPvP::RegisterZone(uint32 zoneId)
+{
+    sOutdoorPvPMgr.AddZone(zoneId, this);
+}
+
+bool OutdoorPvP::HasPlayer(Player *plr) const
+{
+    return m_players[plr->GetTeamId()].find(plr) != m_players[plr->GetTeamId()].end();
+}
+
+void OutdoorPvP::TeamCastSpell(TeamId team, int32 spellId)
+{
+    if(spellId > 0)
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            (*itr)->CastSpell(*itr, (uint32)spellId, true);
+    else
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            (*itr)->RemoveAurasDueToSpell((uint32)-spellId); // by stack?
+}
+
+void OutdoorPvP::TeamApplyBuff(TeamId team, uint32 spellId, uint32 spellId2)
+{
+    TeamCastSpell(team, spellId);
+    TeamCastSpell(OTHER_TEAM(team), spellId2 ? -(int32)spellId2 : -(int32)spellId);
+}
+
+void OutdoorPvP::OnGameObjectCreate(GameObject *go, bool add)
+{
+    if(go->GetGoType() != GAMEOBJECT_TYPE_CAPTURE_POINT)
+        return;
+
+    if(OPvPCapturePoint *cp = GetCapturePoint(go->GetDBTableGUIDLow()))
+        cp->m_capturePoint = add ? go : NULL;
+}
diff --git a/Core/src/game/OutdoorPvP.h b/Core/src/game/OutdoorPvP.h
new file mode 100644
index 0000000..8611a59
--- /dev/null
+++ b/Core/src/game/OutdoorPvP.h
@@ -0,0 +1,260 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_H_
+#define OUTDOOR_PVP_H_
+
+#include "Util.h"
+#include "SharedDefines.h"
+#include "ZoneScript.h"
+
+class GameObject;
+
+enum OutdoorPvPTypes
+{
+    OUTDOOR_PVP_HP = 1,
+    OUTDOOR_PVP_NA,
+    OUTDOOR_PVP_TF,
+    OUTDOOR_PVP_ZM,
+    OUTDOOR_PVP_SI,
+    OUTDOOR_PVP_EP,
+    OUTDOOR_PVP_WG,
+    OUTDOOR_PVP_NR,
+};
+
+const uint8 CapturePointArtKit[3] = {2, 1, 21};
+
+enum ObjectiveStates
+{
+    OBJECTIVESTATE_NEUTRAL = 0,
+    OBJECTIVESTATE_ALLIANCE,
+    OBJECTIVESTATE_HORDE,
+    OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE,
+    OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE,
+    OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE,
+    OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE,
+};
+
+// struct for go spawning
+struct go_type{
+    uint32 entry;
+    uint32 map;
+    float x;
+    float y;
+    float z;
+    float o;
+    float rot0;
+    float rot1;
+    float rot2;
+    float rot3;
+};
+
+// struct for creature spawning
+struct creature_type{
+    uint32 entry;
+    uint32 teamval;
+    uint32 map;
+    float x;
+    float y;
+    float z;
+    float o;
+};
+
+// some class predefs
+class Player;
+class GameObject;
+class WorldPacket;
+class Creature;
+class Unit;
+struct GossipMenuItems;
+
+typedef std::set<Player*> PlayerSet;
+
+class OutdoorPvP;
+class OPvPCapturePoint
+{
+public:
+    OPvPCapturePoint(OutdoorPvP * pvp);
+
+    virtual void FillInitialWorldStates(WorldPacket & data) {}
+
+    // send world state update to all players present
+    void SendUpdateWorldState(uint32 field, uint32 value);
+    // send kill notify to players in the controlling faction
+    void SendObjectiveComplete(uint32 id, uint64 guid);
+
+    // used when player is activated/inactivated in the area
+    virtual bool HandlePlayerEnter(Player * plr);
+    virtual void HandlePlayerLeave(Player * plr);
+    //virtual void HandlePlayerActivityChanged(Player * plr);
+
+    // checks if player is in range of a capture credit marker
+    bool IsInsideObjective(Player * plr) const;
+
+    virtual bool HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go);
+    virtual int32 HandleOpenGo(Player *plr, uint64 guid);
+
+    // returns true if the state of the objective has changed, in this case, the OutdoorPvP must send a world state ui update.
+    virtual bool Update(uint32 diff);
+    virtual void ChangeState() = 0;
+    virtual void ChangeTeam(TeamId oldTeam) {}
+    virtual void SendChangePhase();
+
+    virtual bool HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid);
+
+    virtual bool CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso);
+
+    virtual bool HandleDropFlag(Player * plr, uint32 spellId);
+
+    virtual void DeleteSpawns();
+
+    uint32 m_capturePointGUID;
+    GameObject *m_capturePoint;
+
+    void AddGO(uint32 type, uint32 guid, uint32 entry = 0);
+    void AddCre(uint32 type, uint32 guid, uint32 entry = 0);
+    bool SetCapturePointData(uint32 entry, uint32 map, float x, float y, float z, float o = 0, float rotation0 = 0, float rotation1 = 0, float rotation2 = 0, float rotation3 = 0);
+
+protected:
+
+    bool AddObject(uint32 type, uint32 entry, uint32 map, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3);
+    bool AddCreature(uint32 type, uint32 entry, uint32 teamval, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay = 0);
+
+    bool DelCreature(uint32 type);
+    bool DelObject(uint32 type);
+    bool DelCapturePoint();
+
+protected:
+    // active players in the area of the objective, 0 - alliance, 1 - horde
+    PlayerSet m_activePlayers[2];
+    // total shift needed to capture the objective
+    float m_maxValue;
+    float m_minValue;
+    // maximum speed of capture
+    float m_maxSpeed;
+    // the status of the objective
+    float m_value;
+    TeamId m_team;
+    // objective states
+    ObjectiveStates m_OldState;
+    ObjectiveStates m_State;
+    // neutral value on capture bar
+    uint32 m_neutralValuePct;
+
+    // pointer to the OutdoorPvP this objective belongs to
+    OutdoorPvP* m_PvP;
+
+    // map to store the various gameobjects and creatures spawned by the objective
+    //        type , guid
+    std::map<uint32,uint64> m_Objects;
+    std::map<uint32,uint64> m_Creatures;
+    std::map<uint64,uint32> m_ObjectTypes;
+    std::map<uint64,uint32> m_CreatureTypes;
+};
+
+// base class for specific outdoor pvp handlers
+class OutdoorPvP : public ZoneScript
+{
+    friend class OutdoorPvPMgr;
+public:
+    // ctor
+    OutdoorPvP();
+    // dtor
+    ~OutdoorPvP();
+    // deletes all gos/creatures spawned by the pvp
+    void DeleteSpawns();
+
+    typedef std::map<uint32/*lowguid*/, OPvPCapturePoint*> OPvPCapturePointMap;
+
+    virtual void FillInitialWorldStates(WorldPacket & data) {}
+    // called when a player triggers an areatrigger
+    virtual bool HandleAreaTrigger(Player * plr, uint32 trigger);
+    // called on custom spell
+    virtual bool HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go);
+    // called on go use
+    virtual bool HandleOpenGo(Player *plr, uint64 guid);
+
+    // setup stuff
+    virtual bool SetupOutdoorPvP() {return true;}
+
+    void OnGameObjectCreate(GameObject *go, bool add);
+    void OnCreatureCreate(Creature *, bool add) {}
+
+    // send world state update to all players present
+    void SendUpdateWorldState(uint32 field, uint32 value);
+
+    // called by OutdoorPvPMgr, updates the objectives and if needed, sends new worldstateui information
+    virtual bool Update(uint32 diff);
+
+    // handle npc/player kill
+    virtual void HandleKill(Player * killer, Unit * killed);
+    virtual void HandleKillImpl(Player * killer, Unit * killed) {}
+
+    // checks if player is in range of a capture credit marker
+    bool IsInsideObjective(Player * plr) const;
+
+    // awards rewards for player kill
+    virtual void AwardKillBonus(Player * plr) {}
+
+    uint32 GetTypeId() {return m_TypeId;}
+
+    virtual bool HandleDropFlag(Player * plr, uint32 spellId);
+
+    virtual bool HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid);
+
+    virtual bool CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso);
+
+    void TeamApplyBuff(TeamId team, uint32 spellId, uint32 spellId2 = 0);
+protected:
+    // the map of the objectives belonging to this outdoorpvp
+    OPvPCapturePointMap m_capturePoints;
+
+    PlayerSet m_players[2];
+    uint32 m_TypeId;
+
+    bool m_sendUpdate;
+
+    // world state stuff
+    virtual void SendRemoveWorldStates(Player * plr) {}
+
+    void BroadcastPacket(WorldPacket & data) const;
+
+    virtual void HandlePlayerEnterZone(Player * plr, uint32 zone);
+    virtual void HandlePlayerLeaveZone(Player * plr, uint32 zone);
+    virtual void HandlePlayerResurrects(Player * plr, uint32 zone);
+
+    void AddCapturePoint(OPvPCapturePoint* cp)
+    {
+        m_capturePoints[cp->m_capturePointGUID] = cp;
+    }
+
+    OPvPCapturePoint * GetCapturePoint(uint32 lowguid) const
+    {
+        OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.find(lowguid);
+        if(itr != m_capturePoints.end())
+            return itr->second;
+        return NULL;
+    }
+
+    void RegisterZone(uint32 zoneid);
+    bool HasPlayer(Player *plr) const;
+    void TeamCastSpell(TeamId team, int32 spellId);
+};
+
+#endif /*OUTDOOR_PVP_H_*/
+
diff --git a/Core/src/game/OutdoorPvPEP.cpp b/Core/src/game/OutdoorPvPEP.cpp
new file mode 100644
index 0000000..4c0daa4
--- /dev/null
+++ b/Core/src/game/OutdoorPvPEP.cpp
@@ -0,0 +1,765 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPEP.h"
+#include "WorldPacket.h"
+#include "Player.h"
+#include "GameObject.h"
+#include "ObjectMgr.h"
+#include "ObjectAccessor.h"
+#include "OutdoorPvPMgr.h"
+#include "Creature.h"
+#include "Language.h"
+#include "World.h"
+#include "GossipDef.h"
+
+OPvPCapturePointEP_EWT::OPvPCapturePointEP_EWT(OutdoorPvP *pvp)
+: OPvPCapturePoint(pvp), m_TowerState(EP_TS_N), m_UnitsSummonedSide(0)
+{
+    SetCapturePointData(EPCapturePoints[EP_EWT].entry,EPCapturePoints[EP_EWT].map,EPCapturePoints[EP_EWT].x,EPCapturePoints[EP_EWT].y,EPCapturePoints[EP_EWT].z,EPCapturePoints[EP_EWT].o,EPCapturePoints[EP_EWT].rot0,EPCapturePoints[EP_EWT].rot1,EPCapturePoints[EP_EWT].rot2,EPCapturePoints[EP_EWT].rot3);
+    AddObject(EP_EWT_FLAGS,EPTowerFlags[EP_EWT].entry,EPTowerFlags[EP_EWT].map,EPTowerFlags[EP_EWT].x,EPTowerFlags[EP_EWT].y,EPTowerFlags[EP_EWT].z,EPTowerFlags[EP_EWT].o,EPTowerFlags[EP_EWT].rot0,EPTowerFlags[EP_EWT].rot1,EPTowerFlags[EP_EWT].rot2,EPTowerFlags[EP_EWT].rot3);
+}
+
+void OPvPCapturePointEP_EWT::ChangeState()
+{
+    if(fabs(m_value) == m_maxValue)  // state won't change, only phase when maxed out!
+    {
+        // if changing from controlling alliance to horde or vice versa
+        if( m_OldState == OBJECTIVESTATE_ALLIANCE && m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_EWT_A));
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_EWT] = 0;
+        }
+        else if ( m_OldState == OBJECTIVESTATE_HORDE && m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_EWT_H));
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_EWT] = 0;
+        }
+
+        uint32 artkit = 21;
+
+        switch(m_State)
+        {
+        case OBJECTIVESTATE_ALLIANCE:
+            if(m_value == m_maxValue)
+                m_TowerState = EP_TS_A;
+            else
+                m_TowerState = EP_TS_A_P;
+            artkit = 2;
+            SummonSupportUnitAtNorthpassTower(ALLIANCE);
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_EWT] = ALLIANCE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_EWT_A));
+            break;
+        case OBJECTIVESTATE_HORDE:
+            if(m_value == -m_maxValue)
+                m_TowerState = EP_TS_H;
+            else
+                m_TowerState = EP_TS_H_P;
+            artkit = 1;
+            SummonSupportUnitAtNorthpassTower(HORDE);
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_EWT] = HORDE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_EWT_H));
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+            m_TowerState = EP_TS_N;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            m_TowerState = EP_TS_N_A;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            m_TowerState = EP_TS_N_H;
+            break;
+        }
+
+        GameObject * flag = ObjectAccessor::GetGameObjectInWorld(m_capturePointGUID);
+        GameObject * flag2 = ObjectAccessor::GetGameObjectInWorld(m_Objects[EP_EWT_FLAGS]);
+        if(flag)
+        {
+            flag->SetGoArtKit(artkit);
+        }
+        if(flag2)
+        {
+            flag2->SetGoArtKit(artkit);
+        }
+
+        UpdateTowerState();
+
+        // complete quest objective
+        if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+            SendObjectiveComplete(EP_EWT_CM, 0);
+    }
+}
+
+void OPvPCapturePointEP_EWT::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+}
+
+void OPvPCapturePointEP_EWT::FillInitialWorldStates(WorldPacket &data)
+{
+    data << EP_EWT_A << uint32(bool(m_TowerState & EP_TS_A));
+    data << EP_EWT_H << uint32(bool(m_TowerState & EP_TS_H));
+    data << EP_EWT_A_P << uint32(bool(m_TowerState & EP_TS_A_P));
+    data << EP_EWT_H_P << uint32(bool(m_TowerState & EP_TS_H_P));
+    data << EP_EWT_N_A << uint32(bool(m_TowerState & EP_TS_N_A));
+    data << EP_EWT_N_H << uint32(bool(m_TowerState & EP_TS_N_H));
+    data << EP_EWT_N << uint32(bool(m_TowerState & EP_TS_N));
+}
+
+void OPvPCapturePointEP_EWT::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(EP_EWT_A , bool(m_TowerState & EP_TS_A));
+    m_PvP->SendUpdateWorldState(EP_EWT_H , bool(m_TowerState & EP_TS_H));
+    m_PvP->SendUpdateWorldState(EP_EWT_A_P , bool(m_TowerState & EP_TS_A_P));
+    m_PvP->SendUpdateWorldState(EP_EWT_H_P , bool(m_TowerState & EP_TS_H_P));
+    m_PvP->SendUpdateWorldState(EP_EWT_N_A , bool(m_TowerState & EP_TS_N_A));
+    m_PvP->SendUpdateWorldState(EP_EWT_N_H , bool(m_TowerState & EP_TS_N_H));
+    m_PvP->SendUpdateWorldState(EP_EWT_N , bool(m_TowerState & EP_TS_N));
+}
+
+bool OPvPCapturePointEP_EWT::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointEP_EWT::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+void OPvPCapturePointEP_EWT::SummonSupportUnitAtNorthpassTower(uint32 team)
+{
+    if(m_UnitsSummonedSide != team)
+    {
+        m_UnitsSummonedSide = team;
+        const creature_type * ct = NULL;
+        if(team == ALLIANCE)
+            ct=EP_EWT_Summons_A;
+        else
+            ct=EP_EWT_Summons_H;
+
+        for (int i = 0; i < EP_EWT_NUM_CREATURES; ++i)
+        {
+            DelCreature(i);
+            AddCreature(i,ct[i].entry,ct[i].teamval,ct[i].map,ct[i].x,ct[i].y,ct[i].z,ct[i].o,1000000);
+        }
+    }
+}
+
+// NPT
+OPvPCapturePointEP_NPT::OPvPCapturePointEP_NPT(OutdoorPvP *pvp)
+: OPvPCapturePoint(pvp), m_TowerState(EP_TS_N), m_SummonedGOSide(0)
+{
+    SetCapturePointData(EPCapturePoints[EP_NPT].entry,EPCapturePoints[EP_NPT].map,EPCapturePoints[EP_NPT].x,EPCapturePoints[EP_NPT].y,EPCapturePoints[EP_NPT].z,EPCapturePoints[EP_NPT].o,EPCapturePoints[EP_NPT].rot0,EPCapturePoints[EP_NPT].rot1,EPCapturePoints[EP_NPT].rot2,EPCapturePoints[EP_NPT].rot3);
+    AddObject(EP_NPT_FLAGS,EPTowerFlags[EP_NPT].entry,EPTowerFlags[EP_NPT].map,EPTowerFlags[EP_NPT].x,EPTowerFlags[EP_NPT].y,EPTowerFlags[EP_NPT].z,EPTowerFlags[EP_NPT].o,EPTowerFlags[EP_NPT].rot0,EPTowerFlags[EP_NPT].rot1,EPTowerFlags[EP_NPT].rot2,EPTowerFlags[EP_NPT].rot3);
+}
+
+void OPvPCapturePointEP_NPT::ChangeState()
+{
+    if(fabs(m_value) == m_maxValue)  // state won't change, only phase when maxed out!
+    {
+        // if changing from controlling alliance to horde or vice versa
+        if( m_OldState == OBJECTIVESTATE_ALLIANCE && m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_NPT_A));
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_NPT] = 0;
+        }
+        else if ( m_OldState == OBJECTIVESTATE_HORDE && m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_NPT_H));
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_NPT] = 0;
+        }
+
+        uint32 artkit = 21;
+
+        switch(m_State)
+        {
+        case OBJECTIVESTATE_ALLIANCE:
+            if(m_value == m_maxValue)
+                m_TowerState = EP_TS_A;
+            else
+                m_TowerState = EP_TS_A_P;
+            artkit = 2;
+            SummonGO(ALLIANCE);
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_NPT] = ALLIANCE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_NPT_A));
+            break;
+        case OBJECTIVESTATE_HORDE:
+            if(m_value == -m_maxValue)
+                m_TowerState = EP_TS_H;
+            else
+                m_TowerState = EP_TS_H_P;
+            artkit = 1;
+            SummonGO(HORDE);
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_NPT] = HORDE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_NPT_H));
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+            m_TowerState = EP_TS_N;
+            m_SummonedGOSide = 0;
+            DelObject(EP_NPT_BUFF);
+            break;
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            m_TowerState = EP_TS_N_A;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            m_TowerState = EP_TS_N_H;
+            break;
+        }
+
+        GameObject * flag = ObjectAccessor::GetGameObjectInWorld(m_capturePointGUID);
+        GameObject * flag2 = ObjectAccessor::GetGameObjectInWorld(m_Objects[EP_NPT_FLAGS]);
+        if(flag)
+        {
+            flag->SetGoArtKit(artkit);
+        }
+        if(flag2)
+        {
+            flag2->SetGoArtKit(artkit);
+        }
+
+        UpdateTowerState();
+
+        // complete quest objective
+        if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+            SendObjectiveComplete(EP_NPT_CM, 0);
+    }
+}
+
+void OPvPCapturePointEP_NPT::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+}
+
+void OPvPCapturePointEP_NPT::FillInitialWorldStates(WorldPacket &data)
+{
+    data << EP_NPT_A << uint32(bool(m_TowerState & EP_TS_A));
+    data << EP_NPT_H << uint32(bool(m_TowerState & EP_TS_H));
+    data << EP_NPT_A_P << uint32(bool(m_TowerState & EP_TS_A_P));
+    data << EP_NPT_H_P << uint32(bool(m_TowerState & EP_TS_H_P));
+    data << EP_NPT_N_A << uint32(bool(m_TowerState & EP_TS_N_A));
+    data << EP_NPT_N_H << uint32(bool(m_TowerState & EP_TS_N_H));
+    data << EP_NPT_N << uint32(bool(m_TowerState & EP_TS_N));
+}
+
+void OPvPCapturePointEP_NPT::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(EP_NPT_A , bool(m_TowerState & EP_TS_A));
+    m_PvP->SendUpdateWorldState(EP_NPT_H , bool(m_TowerState & EP_TS_H));
+    m_PvP->SendUpdateWorldState(EP_NPT_A_P , bool(m_TowerState & EP_TS_A_P));
+    m_PvP->SendUpdateWorldState(EP_NPT_H_P , bool(m_TowerState & EP_TS_H_P));
+    m_PvP->SendUpdateWorldState(EP_NPT_N_A , bool(m_TowerState & EP_TS_N_A));
+    m_PvP->SendUpdateWorldState(EP_NPT_N_H , bool(m_TowerState & EP_TS_N_H));
+    m_PvP->SendUpdateWorldState(EP_NPT_N , bool(m_TowerState & EP_TS_N));
+}
+
+bool OPvPCapturePointEP_NPT::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointEP_NPT::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+void OPvPCapturePointEP_NPT::SummonGO(uint32 team)
+{
+    if(m_SummonedGOSide != team)
+    {
+        m_SummonedGOSide = team;
+        DelObject(EP_NPT_BUFF);
+        AddObject(EP_NPT_BUFF,EP_NPT_LordaeronShrine.entry,EP_NPT_LordaeronShrine.map,EP_NPT_LordaeronShrine.x,EP_NPT_LordaeronShrine.y,EP_NPT_LordaeronShrine.z,EP_NPT_LordaeronShrine.o,EP_NPT_LordaeronShrine.rot0,EP_NPT_LordaeronShrine.rot1,EP_NPT_LordaeronShrine.rot2,EP_NPT_LordaeronShrine.rot3);
+        GameObject * go = ObjectAccessor::GetGameObjectInWorld(m_Objects[EP_NPT_BUFF]);
+        if(go)
+            go->SetUInt32Value(GAMEOBJECT_FACTION,(team == ALLIANCE ? 84 : 83));
+    }
+}
+
+// CGT
+OPvPCapturePointEP_CGT::OPvPCapturePointEP_CGT(OutdoorPvP *pvp)
+: OPvPCapturePoint(pvp), m_TowerState(EP_TS_N), m_GraveyardSide(0)
+{
+    SetCapturePointData(EPCapturePoints[EP_CGT].entry,EPCapturePoints[EP_CGT].map,EPCapturePoints[EP_CGT].x,EPCapturePoints[EP_CGT].y,EPCapturePoints[EP_CGT].z,EPCapturePoints[EP_CGT].o,EPCapturePoints[EP_CGT].rot0,EPCapturePoints[EP_CGT].rot1,EPCapturePoints[EP_CGT].rot2,EPCapturePoints[EP_CGT].rot3);
+    AddObject(EP_CGT_FLAGS,EPTowerFlags[EP_CGT].entry,EPTowerFlags[EP_CGT].map,EPTowerFlags[EP_CGT].x,EPTowerFlags[EP_CGT].y,EPTowerFlags[EP_CGT].z,EPTowerFlags[EP_CGT].o,EPTowerFlags[EP_CGT].rot0,EPTowerFlags[EP_CGT].rot1,EPTowerFlags[EP_CGT].rot2,EPTowerFlags[EP_CGT].rot3);
+}
+
+void OPvPCapturePointEP_CGT::ChangeState()
+{
+    if(fabs(m_value) == m_maxValue)  // state won't change, only phase when maxed out!
+    {
+        // if changing from controlling alliance to horde or vice versa
+        if( m_OldState == OBJECTIVESTATE_ALLIANCE && m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_CGT_A));
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_CGT] = 0;
+        }
+        else if ( m_OldState == OBJECTIVESTATE_HORDE && m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_CGT_H));
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_CGT] = 0;
+        }
+
+        uint32 artkit = 21;
+
+        switch(m_State)
+        {
+        case OBJECTIVESTATE_ALLIANCE:
+            if(m_value == m_maxValue)
+                m_TowerState = EP_TS_A;
+            else
+                m_TowerState = EP_TS_A_P;
+            artkit = 2;
+            LinkGraveYard(ALLIANCE);
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_CGT] = ALLIANCE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_CGT_A));
+            break;
+        case OBJECTIVESTATE_HORDE:
+            if(m_value == -m_maxValue)
+                m_TowerState = EP_TS_H;
+            else
+                m_TowerState = EP_TS_H_P;
+            artkit = 1;
+            LinkGraveYard(HORDE);
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_CGT] = HORDE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_CGT_H));
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+            m_TowerState = EP_TS_N;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            m_TowerState = EP_TS_N_A;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            m_TowerState = EP_TS_N_H;
+            break;
+        }
+
+        GameObject * flag = ObjectAccessor::GetGameObjectInWorld(m_capturePointGUID);
+        GameObject * flag2 = ObjectAccessor::GetGameObjectInWorld(m_Objects[EP_CGT_FLAGS]);
+        if(flag)
+        {
+            flag->SetGoArtKit(artkit);
+        }
+        if(flag2)
+        {
+            flag2->SetGoArtKit(artkit);
+        }
+
+        UpdateTowerState();
+
+        // complete quest objective
+        if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+            SendObjectiveComplete(EP_CGT_CM, 0);
+    }
+}
+
+void OPvPCapturePointEP_CGT::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+}
+
+void OPvPCapturePointEP_CGT::FillInitialWorldStates(WorldPacket &data)
+{
+    data << EP_CGT_A << uint32(bool(m_TowerState & EP_TS_A));
+    data << EP_CGT_H << uint32(bool(m_TowerState & EP_TS_H));
+    data << EP_CGT_A_P << uint32(bool(m_TowerState & EP_TS_A_P));
+    data << EP_CGT_H_P << uint32(bool(m_TowerState & EP_TS_H_P));
+    data << EP_CGT_N_A << uint32(bool(m_TowerState & EP_TS_N_A));
+    data << EP_CGT_N_H << uint32(bool(m_TowerState & EP_TS_N_H));
+    data << EP_CGT_N << uint32(bool(m_TowerState & EP_TS_N));
+}
+
+void OPvPCapturePointEP_CGT::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(EP_CGT_A , bool(m_TowerState & EP_TS_A));
+    m_PvP->SendUpdateWorldState(EP_CGT_H , bool(m_TowerState & EP_TS_H));
+    m_PvP->SendUpdateWorldState(EP_CGT_A_P , bool(m_TowerState & EP_TS_A_P));
+    m_PvP->SendUpdateWorldState(EP_CGT_H_P , bool(m_TowerState & EP_TS_H_P));
+    m_PvP->SendUpdateWorldState(EP_CGT_N_A , bool(m_TowerState & EP_TS_N_A));
+    m_PvP->SendUpdateWorldState(EP_CGT_N_H , bool(m_TowerState & EP_TS_N_H));
+    m_PvP->SendUpdateWorldState(EP_CGT_N , bool(m_TowerState & EP_TS_N));
+}
+
+bool OPvPCapturePointEP_CGT::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointEP_CGT::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+void OPvPCapturePointEP_CGT::LinkGraveYard(uint32 team)
+{
+    if(m_GraveyardSide != team)
+    {
+        m_GraveyardSide = team;
+        sObjectMgr.RemoveGraveYardLink(EP_GraveYardId,EP_GraveYardZone,team,false);
+        sObjectMgr.AddGraveYardLink(EP_GraveYardId,EP_GraveYardZone,team,false);
+    }
+}
+
+// PWT
+OPvPCapturePointEP_PWT::OPvPCapturePointEP_PWT(OutdoorPvP *pvp)
+: OPvPCapturePoint(pvp), m_TowerState(EP_TS_N), m_FlightMasterSpawned(0)
+{
+    SetCapturePointData(EPCapturePoints[EP_PWT].entry,EPCapturePoints[EP_PWT].map,EPCapturePoints[EP_PWT].x,EPCapturePoints[EP_PWT].y,EPCapturePoints[EP_PWT].z,EPCapturePoints[EP_PWT].o,EPCapturePoints[EP_PWT].rot0,EPCapturePoints[EP_PWT].rot1,EPCapturePoints[EP_PWT].rot2,EPCapturePoints[EP_PWT].rot3);
+    AddObject(EP_PWT_FLAGS,EPTowerFlags[EP_PWT].entry,EPTowerFlags[EP_PWT].map,EPTowerFlags[EP_PWT].x,EPTowerFlags[EP_PWT].y,EPTowerFlags[EP_PWT].z,EPTowerFlags[EP_PWT].o,EPTowerFlags[EP_PWT].rot0,EPTowerFlags[EP_PWT].rot1,EPTowerFlags[EP_PWT].rot2,EPTowerFlags[EP_PWT].rot3);
+}
+
+void OPvPCapturePointEP_PWT::ChangeState()
+{
+    if(fabs(m_value) == m_maxValue)  // state won't change, only phase when maxed out!
+    {
+        // if changing from controlling alliance to horde or vice versa
+        if( m_OldState == OBJECTIVESTATE_ALLIANCE && m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_PWT_A));
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_PWT] = 0;
+        }
+        else if ( m_OldState == OBJECTIVESTATE_HORDE && m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_PWT_H));
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_PWT] = 0;
+        }
+
+        uint32 artkit = 21;
+
+        switch(m_State)
+        {
+        case OBJECTIVESTATE_ALLIANCE:
+            if(m_value == m_maxValue)
+                m_TowerState = EP_TS_A;
+            else
+                m_TowerState = EP_TS_A_P;
+            SummonFlightMaster(ALLIANCE);
+            artkit = 2;
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_PWT] = ALLIANCE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_PWT_A));
+            break;
+        case OBJECTIVESTATE_HORDE:
+            if(m_value == -m_maxValue)
+                m_TowerState = EP_TS_H;
+            else
+                m_TowerState = EP_TS_H_P;
+            SummonFlightMaster(HORDE);
+            artkit = 1;
+            ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_PWT] = HORDE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_PWT_H));
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+            m_TowerState = EP_TS_N;
+            DelCreature(EP_PWT_FLIGHTMASTER);
+            m_FlightMasterSpawned = 0;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            m_TowerState = EP_TS_N_A;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            m_TowerState = EP_TS_N_H;
+            break;
+        }
+
+        GameObject * flag = ObjectAccessor::GetGameObjectInWorld(m_capturePointGUID);
+        GameObject * flag2 = ObjectAccessor::GetGameObjectInWorld(m_Objects[EP_PWT_FLAGS]);
+        if(flag)
+        {
+            flag->SetGoArtKit(artkit);
+        }
+        if(flag2)
+        {
+            flag2->SetGoArtKit(artkit);
+        }
+
+        UpdateTowerState();
+
+        // complete quest objective
+        if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+            SendObjectiveComplete(EP_PWT_CM, 0);
+    }
+}
+
+void OPvPCapturePointEP_PWT::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+}
+
+void OPvPCapturePointEP_PWT::FillInitialWorldStates(WorldPacket &data)
+{
+    data << EP_PWT_A << uint32(bool(m_TowerState & EP_TS_A));
+    data << EP_PWT_H << uint32(bool(m_TowerState & EP_TS_H));
+    data << EP_PWT_A_P << uint32(bool(m_TowerState & EP_TS_A_P));
+    data << EP_PWT_H_P << uint32(bool(m_TowerState & EP_TS_H_P));
+    data << EP_PWT_N_A << uint32(bool(m_TowerState & EP_TS_N_A));
+    data << EP_PWT_N_H << uint32(bool(m_TowerState & EP_TS_N_H));
+    data << EP_PWT_N << uint32(bool(m_TowerState & EP_TS_N));
+}
+
+void OPvPCapturePointEP_PWT::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(EP_PWT_A , bool(m_TowerState & EP_TS_A));
+    m_PvP->SendUpdateWorldState(EP_PWT_H , bool(m_TowerState & EP_TS_H));
+    m_PvP->SendUpdateWorldState(EP_PWT_A_P , bool(m_TowerState & EP_TS_A_P));
+    m_PvP->SendUpdateWorldState(EP_PWT_H_P , bool(m_TowerState & EP_TS_H_P));
+    m_PvP->SendUpdateWorldState(EP_PWT_N_A , bool(m_TowerState & EP_TS_N_A));
+    m_PvP->SendUpdateWorldState(EP_PWT_N_H , bool(m_TowerState & EP_TS_N_H));
+    m_PvP->SendUpdateWorldState(EP_PWT_N , bool(m_TowerState & EP_TS_N));
+}
+
+bool OPvPCapturePointEP_PWT::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointEP_PWT::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+void OPvPCapturePointEP_PWT::SummonFlightMaster(uint32 team)
+{
+    if(m_FlightMasterSpawned != team)
+    {
+        m_FlightMasterSpawned = team;
+        DelCreature(EP_PWT_FLIGHTMASTER);
+        AddCreature(EP_PWT_FLIGHTMASTER,EP_PWT_FlightMaster.entry,team,EP_PWT_FlightMaster.map,EP_PWT_FlightMaster.x,EP_PWT_FlightMaster.y,EP_PWT_FlightMaster.z,EP_PWT_FlightMaster.o);
+    }
+}
+
+// ep
+OutdoorPvPEP::OutdoorPvPEP()
+{
+    m_TypeId = OUTDOOR_PVP_EP;
+    memset(EP_Controls,0,sizeof(EP_Controls));
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+}
+
+bool OutdoorPvPEP::SetupOutdoorPvP()
+{
+    for (int i = 0; i < EPBuffZonesNum; ++i)
+        RegisterZone(EPBuffZones[i]);
+
+    AddCapturePoint(new OPvPCapturePointEP_EWT(this));
+    AddCapturePoint(new OPvPCapturePointEP_PWT(this));
+    AddCapturePoint(new OPvPCapturePointEP_CGT(this));
+    AddCapturePoint(new OPvPCapturePointEP_NPT(this));
+    return true;
+}
+
+bool OutdoorPvPEP::Update(uint32 diff)
+{
+    if(OutdoorPvP::Update(diff))
+    {
+        m_AllianceTowersControlled = 0;
+        m_HordeTowersControlled = 0;
+        for (int i = 0; i < EP_TOWER_NUM; ++i)
+        {
+            if(EP_Controls[i] == ALLIANCE)
+                ++m_AllianceTowersControlled;
+            else if(EP_Controls[i] == HORDE)
+                ++m_HordeTowersControlled;
+            SendUpdateWorldState(EP_UI_TOWER_COUNT_A,m_AllianceTowersControlled);
+            SendUpdateWorldState(EP_UI_TOWER_COUNT_H,m_HordeTowersControlled);
+            BuffTeams();
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPEP::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    // add buffs
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        if(m_AllianceTowersControlled && m_AllianceTowersControlled < 5)
+            plr->CastSpell(plr,EP_AllianceBuffs[m_AllianceTowersControlled-1],true);
+    }
+    else
+    {
+        if(m_HordeTowersControlled && m_HordeTowersControlled < 5)
+            plr->CastSpell(plr,EP_HordeBuffs[m_HordeTowersControlled-1],true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPEP::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        for (int i = 0; i < 4; ++i)
+            plr->RemoveAurasDueToSpell(EP_AllianceBuffs[i]);
+    }
+    else
+    {
+        for (int i = 0; i < 4; ++i)
+            plr->RemoveAurasDueToSpell(EP_HordeBuffs[i]);
+    }
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+void OutdoorPvPEP::BuffTeams()
+{
+    for (PlayerSet::iterator itr = m_players[0].begin(); itr != m_players[0].end(); ++itr)
+    {
+        Player * plr = *itr;
+        {
+            for (int i = 0; i < 4; ++i)
+                plr->RemoveAurasDueToSpell(EP_AllianceBuffs[i]);
+            if(m_AllianceTowersControlled && m_AllianceTowersControlled < 5)
+                plr->CastSpell(plr,EP_AllianceBuffs[m_AllianceTowersControlled-1],true);
+        }
+    }
+    for (PlayerSet::iterator itr = m_players[1].begin(); itr != m_players[1].end(); ++itr)
+    {
+        Player * plr = *itr;
+        {
+            for (int i = 0; i < 4; ++i)
+                plr->RemoveAurasDueToSpell(EP_HordeBuffs[i]);
+            if(m_HordeTowersControlled && m_HordeTowersControlled < 5)
+                plr->CastSpell(plr,EP_HordeBuffs[m_HordeTowersControlled-1],true);
+        }
+    }
+}
+
+void OutdoorPvPEP::FillInitialWorldStates(WorldPacket & data)
+{
+    data << EP_UI_TOWER_COUNT_A << m_AllianceTowersControlled;
+    data << EP_UI_TOWER_COUNT_H << m_HordeTowersControlled;
+    data << EP_UI_TOWER_SLIDER_DISPLAY << uint32(0);
+    data << EP_UI_TOWER_SLIDER_POS << uint32(50);
+    data << EP_UI_TOWER_SLIDER_N << uint32(100);
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+    {
+        itr->second->FillInitialWorldStates(data);
+    }
+}
+
+void OutdoorPvPEP::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_COUNT_A,0);
+    plr->SendUpdateWorldState(EP_UI_TOWER_COUNT_H,0);
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY,0);
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS,0);
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N,0);
+
+    plr->SendUpdateWorldState(EP_EWT_A,0);
+    plr->SendUpdateWorldState(EP_EWT_H,0);
+    plr->SendUpdateWorldState(EP_EWT_N,0);
+    plr->SendUpdateWorldState(EP_EWT_A_P,0);
+    plr->SendUpdateWorldState(EP_EWT_H_P,0);
+    plr->SendUpdateWorldState(EP_EWT_N_A,0);
+    plr->SendUpdateWorldState(EP_EWT_N_H,0);
+
+    plr->SendUpdateWorldState(EP_PWT_A,0);
+    plr->SendUpdateWorldState(EP_PWT_H,0);
+    plr->SendUpdateWorldState(EP_PWT_N,0);
+    plr->SendUpdateWorldState(EP_PWT_A_P,0);
+    plr->SendUpdateWorldState(EP_PWT_H_P,0);
+    plr->SendUpdateWorldState(EP_PWT_N_A,0);
+    plr->SendUpdateWorldState(EP_PWT_N_H,0);
+
+    plr->SendUpdateWorldState(EP_NPT_A,0);
+    plr->SendUpdateWorldState(EP_NPT_H,0);
+    plr->SendUpdateWorldState(EP_NPT_N,0);
+    plr->SendUpdateWorldState(EP_NPT_A_P,0);
+    plr->SendUpdateWorldState(EP_NPT_H_P,0);
+    plr->SendUpdateWorldState(EP_NPT_N_A,0);
+    plr->SendUpdateWorldState(EP_NPT_N_H,0);
+
+    plr->SendUpdateWorldState(EP_CGT_A,0);
+    plr->SendUpdateWorldState(EP_CGT_H,0);
+    plr->SendUpdateWorldState(EP_CGT_N,0);
+    plr->SendUpdateWorldState(EP_CGT_A_P,0);
+    plr->SendUpdateWorldState(EP_CGT_H_P,0);
+    plr->SendUpdateWorldState(EP_CGT_N_A,0);
+    plr->SendUpdateWorldState(EP_CGT_N_H,0);
+}
+
diff --git a/Core/src/game/OutdoorPvPEP.h b/Core/src/game/OutdoorPvPEP.h
new file mode 100644
index 0000000..90c4e87
--- /dev/null
+++ b/Core/src/game/OutdoorPvPEP.h
@@ -0,0 +1,280 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_EP_
+#define OUTDOOR_PVP_EP_
+
+#include "OutdoorPvPImpl.h"
+
+#include "DBCStructure.h"
+
+const uint32 EP_AllianceBuffs[4] = {11413, 11414, 11415, 1386};
+
+const uint32 EP_HordeBuffs[4] = {30880, 30683, 30682, 29520};
+
+const uint32 EP_GraveYardZone = 139;
+
+const uint32 EP_GraveYardId = 927;
+
+const uint32 EPBuffZonesNum = 3;
+
+const uint32 EP_EWT_CM = 17690;
+const uint32 EP_CGT_CM = 17689;
+const uint32 EP_NPT_CM = 17696;
+const uint32 EP_PWT_CM = 17698;
+
+const uint32 EPBuffZones[EPBuffZonesNum] = {139, 2017, 2057};
+
+enum EP_TaxiNodes {
+    EP_CGT_Taxi = 87,
+    EP_EWT_Taxi = 86,
+    EP_NPT_Taxi = 85,
+    EP_PWT_Taxi = 84
+};
+
+enum EP_EastwallTowerWorldStates {
+    EP_EWT_A = 2354,
+    EP_EWT_H = 2356,
+    EP_EWT_A_P = 2357, // ally progressing
+    EP_EWT_H_P = 2358,
+    EP_EWT_N_A = 2359, // ally conquested
+    EP_EWT_N_H = 2360,
+    EP_EWT_N = 2361
+};
+
+enum EP_NorthpassTowerWorldStates {
+    EP_NPT_N = 2352,
+    EP_NPT_N_A = 2362,
+    EP_NPT_N_H = 2363,
+    EP_NPT_A_P = 2364,
+    EP_NPT_H_P = 2365,
+    EP_NPT_A = 2372,
+    EP_NPT_H = 2373
+};
+
+enum EP_PlagewoodTowerWorldStates {
+    EP_PWT_N_A = 2366,
+    EP_PWT_N_H = 2353, //2367 not present! use neutral!
+    EP_PWT_A_P = 2368,
+    EP_PWT_H_P = 2369,
+    EP_PWT_A = 2370,
+    EP_PWT_H = 2371,
+    EP_PWT_N = 2353
+};
+
+enum EP_CrownGuardTowerWorldStates {
+    EP_CGT_N_A = 2374,
+    EP_CGT_N_H = 2375,
+    EP_CGT_A_P = 2376,
+    EP_CGT_H_P = 2377,
+    EP_CGT_A = 2378,
+    EP_CGT_H = 2379,
+    EP_CGT_N = 2355
+};
+
+enum EP_WorldStates {
+    EP_UI_TOWER_SLIDER_DISPLAY = 2426,
+    EP_UI_TOWER_SLIDER_POS = 2427,
+    EP_UI_TOWER_SLIDER_N = 2428,
+
+    EP_UI_TOWER_COUNT_A = 2327,
+    EP_UI_TOWER_COUNT_H = 2328
+};
+
+enum EP_Summons {
+    EP_EWT_COMMANDER = 0,
+    EP_EWT_SOLDIER1,
+    EP_EWT_SOLDIER2,
+    EP_EWT_SOLDIER3,
+    EP_EWT_SOLDIER4,
+    EP_PWT_FLIGHTMASTER,
+};
+
+enum EP_GoSummons {
+    EP_NPT_BUFF = 0,
+    EP_NPT_FLAGS,
+    EP_EWT_FLAGS,
+    EP_CGT_FLAGS,
+    EP_PWT_FLAGS
+};
+
+enum EP_Towers {
+    EP_EWT = 0, // plaguelands 03
+    EP_NPT,// plaguelands 01
+    EP_PWT,// plaguelands 04
+    EP_CGT,// plaguelands 02
+    EP_TOWER_NUM
+};
+
+const go_type EPCapturePoints[EP_TOWER_NUM] = {
+    {182097,0,2574.51f,-4794.89f,144.704f,-1.45003f,-0.097056f,0.095578f,-0.656229f,0.742165f},
+    {181899,0,3181.08f,-4379.36f,174.123f,-2.03472f,-0.065392f,0.119494f,-0.842275f,0.521553f},
+    {182098,0,2962.71f,-3042.31f,154.789f,2.08426f,-0.074807f,-0.113837f,0.855928f,0.49883f},
+    {182096,0,1860.85f,-3731.23f,196.716f,-2.53214f,0.033967f,-0.131914f,0.944741f,-0.298177f}
+};
+
+const go_type EPTowerFlags[EP_TOWER_NUM] = {
+    {182106,0,2569.60f,-4772.93f,115.399f,2.72271f,0,0,0.978148f,0.207912f},
+    {182106,0,3148.17f,-4365.51f,145.029f,1.53589f,0,0,0.694658f,0.71934f},
+    {182106,0,2992.63f,-3022.95f,125.593f,3.03687f,0,0,0.99863f,0.052336f},
+    {182106,0,1838.42f,-3703.56f,167.713f,0.890118f,0,0,0.430511f,0.902585f}
+};
+
+const uint32 EPTowerPlayerEnterEvents[EP_TOWER_NUM] = {10691,10699,10701,10705};
+
+const uint32 EPTowerPlayerLeaveEvents[EP_TOWER_NUM] = {10692,10698,10700,10704};
+
+const uint32 EP_NUM_CREATURES = 6;
+const uint32 EP_EWT_NUM_CREATURES = 5;
+
+// one lordaeron commander, 4 soldiers
+// should be spawned at EWT and follow a path, but trans-grid pathing isn't safe, so summon them directly at NPT
+const creature_type EP_EWT_Summons_A[EP_EWT_NUM_CREATURES] = {
+    {17635,469,0, 3167.61f,-4352.09f,138.20f,4.5811f},
+    {17647,469,0, 3172.74f,-4352.99f,139.14f,4.9873f},
+    {17647,469,0, 3165.89f,-4354.46f,138.67f,3.7244f},
+    {17647,469,0, 3164.65f,-4350.26f,138.22f,2.4794f},
+    {17647,469,0, 3169.91f,-4349.68f,138.37f,0.7444f}
+};
+
+const creature_type EP_EWT_Summons_H[EP_EWT_NUM_CREATURES] = {
+    {17995,67,0, 3167.61f,-4352.09f,138.20f,4.5811f},
+    {17996,67,0, 3172.74f,-4352.99f,139.14f,4.9873f},
+    {17996,67,0, 3165.89f,-4354.46f,138.67f,3.7244f},
+    {17996,67,0, 3164.65f,-4350.26f,138.22f,2.4794f},
+    {17996,67,0, 3169.91f,-4349.68f,138.37f,0.7444f}
+};
+
+enum EP_TowerStates {
+    EP_TS_N = 1,
+    EP_TS_N_A = 2,
+    EP_TS_N_H = 4,
+    EP_TS_A_P = 8,
+    EP_TS_H_P = 16,
+    EP_TS_A = 32,
+    EP_TS_H = 64
+};
+
+// when spawning, pay attention at setting the faction manually!
+const creature_type EP_PWT_FlightMaster = {17209,0,0,2987.5f,-3049.11f,120.126f,5.75959f};
+
+// after spawning, modify the faction so that only the controller will be able to use it with SetUInt32Value(GAMEOBJECT_FACTION, faction_id);
+const go_type EP_NPT_LordaeronShrine = {181682,0,3167.72f,-4355.91f,138.785f,1.69297f,0,0,0.748956f,0.66262f};
+
+class OutdoorPvPEP;
+
+class OPvPCapturePointEP_EWT : public OPvPCapturePoint
+{
+friend class OutdoorPvPEP;
+public:
+    OPvPCapturePointEP_EWT(OutdoorPvP * pvp);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    void SummonSupportUnitAtNorthpassTower(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_TowerState;
+    uint32 m_UnitsSummonedSide;
+};
+
+class OPvPCapturePointEP_NPT : public OPvPCapturePoint
+{
+friend class OutdoorPvPEP;
+public:
+    OPvPCapturePointEP_NPT(OutdoorPvP * pvp);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    void SummonGO(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_TowerState;
+    uint32 m_SummonedGOSide;
+};
+
+class OPvPCapturePointEP_CGT : public OPvPCapturePoint
+{
+friend class OutdoorPvPEP;
+public:
+    OPvPCapturePointEP_CGT(OutdoorPvP * pvp);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    void LinkGraveYard(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_TowerState;
+    uint32 m_GraveyardSide;
+};
+
+class OPvPCapturePointEP_PWT : public OPvPCapturePoint
+{
+friend class OutdoorPvPEP;
+public:
+    OPvPCapturePointEP_PWT(OutdoorPvP * pvp);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    void SummonFlightMaster(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_FlightMasterSpawned;
+    uint32 m_TowerState;
+};
+
+class OutdoorPvPEP : public OutdoorPvP
+{
+friend class OPvPCapturePointEP_EWT;
+friend class OPvPCapturePointEP_NPT;
+friend class OPvPCapturePointEP_PWT;
+friend class OPvPCapturePointEP_CGT;
+public:
+    OutdoorPvPEP();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void BuffTeams();
+private:
+    // how many towers are controlled
+    uint32 EP_Controls[EP_TOWER_NUM];
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+};
+
+#endif
+
diff --git a/Core/src/game/OutdoorPvPHP.cpp b/Core/src/game/OutdoorPvPHP.cpp
new file mode 100644
index 0000000..e164d8d
--- /dev/null
+++ b/Core/src/game/OutdoorPvPHP.cpp
@@ -0,0 +1,332 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPHP.h"
+#include "OutdoorPvP.h"
+#include "OutdoorPvPMgr.h"
+#include "Player.h"
+#include "WorldPacket.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "Language.h"
+
+const uint32 HP_LANG_LOOSE_A[HP_TOWER_NUM] = {LANG_OPVP_HP_LOOSE_BROKENHILL_A,LANG_OPVP_HP_LOOSE_OVERLOOK_A,LANG_OPVP_HP_LOOSE_STADIUM_A};
+
+const uint32 HP_LANG_LOOSE_H[HP_TOWER_NUM] = {LANG_OPVP_HP_LOOSE_BROKENHILL_H,LANG_OPVP_HP_LOOSE_OVERLOOK_H,LANG_OPVP_HP_LOOSE_STADIUM_H};
+
+const uint32 HP_LANG_CAPTURE_A[HP_TOWER_NUM] = {LANG_OPVP_HP_CAPTURE_BROKENHILL_A,LANG_OPVP_HP_CAPTURE_OVERLOOK_A,LANG_OPVP_HP_CAPTURE_STADIUM_A};
+
+const uint32 HP_LANG_CAPTURE_H[HP_TOWER_NUM] = {LANG_OPVP_HP_CAPTURE_BROKENHILL_H,LANG_OPVP_HP_CAPTURE_OVERLOOK_H,LANG_OPVP_HP_CAPTURE_STADIUM_H};
+
+OPvPCapturePointHP::OPvPCapturePointHP(OutdoorPvP *pvp,OutdoorPvPHPTowerType type)
+: OPvPCapturePoint(pvp), m_TowerType(type)
+{
+    SetCapturePointData(HPCapturePoints[type].entry,
+        HPCapturePoints[type].map,
+        HPCapturePoints[type].x,
+        HPCapturePoints[type].y,
+        HPCapturePoints[type].z,
+        HPCapturePoints[type].o,
+        HPCapturePoints[type].rot0,
+        HPCapturePoints[type].rot1,
+        HPCapturePoints[type].rot2,
+        HPCapturePoints[type].rot3);
+    AddObject(type,
+        HPTowerFlags[type].entry,
+        HPTowerFlags[type].map,
+        HPTowerFlags[type].x,
+        HPTowerFlags[type].y,
+        HPTowerFlags[type].z,
+        HPTowerFlags[type].o,
+        HPTowerFlags[type].rot0,
+        HPTowerFlags[type].rot1,
+        HPTowerFlags[type].rot2,
+        HPTowerFlags[type].rot3);
+}
+
+OutdoorPvPHP::OutdoorPvPHP()
+{
+    m_TypeId = OUTDOOR_PVP_HP;
+}
+
+bool OutdoorPvPHP::SetupOutdoorPvP()
+{
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+    // add the zones affected by the pvp buff
+    for (int i = 0; i < OutdoorPvPHPBuffZonesNum; ++i)
+        RegisterZone(OutdoorPvPHPBuffZones[i]);
+
+    AddCapturePoint(new OPvPCapturePointHP(this,HP_TOWER_BROKEN_HILL));
+
+    AddCapturePoint(new OPvPCapturePointHP(this,HP_TOWER_OVERLOOK));
+
+    AddCapturePoint(new OPvPCapturePointHP(this,HP_TOWER_STADIUM));
+
+    return true;
+}
+
+void OutdoorPvPHP::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    // add buffs
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        if(m_AllianceTowersControlled >=3)
+            plr->CastSpell(plr,AllianceBuff,true);
+    }
+    else
+    {
+        if(m_HordeTowersControlled >=3)
+            plr->CastSpell(plr,HordeBuff,true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPHP::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        plr->RemoveAurasDueToSpell(AllianceBuff);
+    }
+    else
+    {
+        plr->RemoveAurasDueToSpell(HordeBuff);
+    }
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+bool OutdoorPvPHP::Update(uint32 diff)
+{
+    bool changed = false;
+    if(changed = OutdoorPvP::Update(diff))
+    {
+        if(m_AllianceTowersControlled == 3)
+            TeamApplyBuff(TEAM_ALLIANCE, AllianceBuff, HordeBuff);
+        else if(m_HordeTowersControlled == 3)
+            TeamApplyBuff(TEAM_HORDE, HordeBuff, AllianceBuff);
+        else
+        {
+            TeamCastSpell(TEAM_ALLIANCE, -AllianceBuff);
+            TeamCastSpell(TEAM_HORDE, -HordeBuff);
+        }
+        SendUpdateWorldState(HP_UI_TOWER_COUNT_A, m_AllianceTowersControlled);
+        SendUpdateWorldState(HP_UI_TOWER_COUNT_H, m_HordeTowersControlled);
+    }
+    return changed;
+}
+
+void OutdoorPvPHP::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(HP_UI_TOWER_DISPLAY_A,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_DISPLAY_H,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_COUNT_H,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_COUNT_A,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_N,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_POS,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY,0);
+    for (int i = 0; i < HP_TOWER_NUM; ++i)
+    {
+        plr->SendUpdateWorldState(HP_MAP_N[i],0);
+        plr->SendUpdateWorldState(HP_MAP_A[i],0);
+        plr->SendUpdateWorldState(HP_MAP_H[i],0);
+    }
+}
+
+void OutdoorPvPHP::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(HP_UI_TOWER_DISPLAY_A) << uint32(1);
+    data << uint32(HP_UI_TOWER_DISPLAY_H) << uint32(1);
+    data << uint32(HP_UI_TOWER_COUNT_A) << uint32(m_AllianceTowersControlled);
+    data << uint32(HP_UI_TOWER_COUNT_H) << uint32(m_HordeTowersControlled);
+    data << uint32(HP_UI_TOWER_SLIDER_DISPLAY) << uint32(0);
+    data << uint32(HP_UI_TOWER_SLIDER_POS) << uint32(50);
+    data << uint32(HP_UI_TOWER_SLIDER_N) << uint32(100);
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+    {
+        itr->second->FillInitialWorldStates(data);
+    }
+}
+
+void OPvPCapturePointHP::ChangeState()
+{
+    uint32 field = 0;
+    switch(m_OldState)
+    {
+    case OBJECTIVESTATE_NEUTRAL:
+        field = HP_MAP_N[m_TowerType];
+        break;
+    case OBJECTIVESTATE_ALLIANCE:
+        field = HP_MAP_A[m_TowerType];
+        if(((OutdoorPvPHP*)m_PvP)->m_AllianceTowersControlled)
+            ((OutdoorPvPHP*)m_PvP)->m_AllianceTowersControlled--;
+        sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(HP_LANG_LOOSE_A[m_TowerType]));
+        break;
+    case OBJECTIVESTATE_HORDE:
+        field = HP_MAP_H[m_TowerType];
+        if(((OutdoorPvPHP*)m_PvP)->m_HordeTowersControlled)
+            ((OutdoorPvPHP*)m_PvP)->m_HordeTowersControlled--;
+        sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(HP_LANG_LOOSE_H[m_TowerType]));
+        break;
+    case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        field = HP_MAP_N[m_TowerType];
+        break;
+    case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        field = HP_MAP_N[m_TowerType];
+        break;
+    case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+        field = HP_MAP_A[m_TowerType];
+        break;
+    case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+        field = HP_MAP_H[m_TowerType];
+        break;
+    }
+
+    // send world state update
+    if(field)
+    {
+        m_PvP->SendUpdateWorldState(field, 0);
+        field = 0;
+    }
+    uint32 artkit = 21;
+    uint32 artkit2 = HP_TowerArtKit_N[m_TowerType];
+    switch(m_State)
+    {
+    case OBJECTIVESTATE_NEUTRAL:
+        field = HP_MAP_N[m_TowerType];
+        break;
+    case OBJECTIVESTATE_ALLIANCE:
+        field = HP_MAP_A[m_TowerType];
+        artkit = 2;
+        artkit2 = HP_TowerArtKit_A[m_TowerType];
+        if(((OutdoorPvPHP*)m_PvP)->m_AllianceTowersControlled<3)
+            ((OutdoorPvPHP*)m_PvP)->m_AllianceTowersControlled++;
+        sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(HP_LANG_CAPTURE_A[m_TowerType]));
+        break;
+    case OBJECTIVESTATE_HORDE:
+        field = HP_MAP_H[m_TowerType];
+        artkit = 1;
+        artkit2 = HP_TowerArtKit_H[m_TowerType];
+        if(((OutdoorPvPHP*)m_PvP)->m_HordeTowersControlled<3)
+            ((OutdoorPvPHP*)m_PvP)->m_HordeTowersControlled++;
+        sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(HP_LANG_CAPTURE_H[m_TowerType]));
+        break;
+    case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        field = HP_MAP_N[m_TowerType];
+        break;
+    case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        field = HP_MAP_N[m_TowerType];
+        break;
+    case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+        field = HP_MAP_A[m_TowerType];
+        artkit = 2;
+        artkit2 = HP_TowerArtKit_A[m_TowerType];
+        break;
+    case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+        field = HP_MAP_H[m_TowerType];
+        artkit = 1;
+        artkit2 = HP_TowerArtKit_H[m_TowerType];
+        break;
+    }
+
+    GameObject * flag = ObjectAccessor::GetGameObjectInWorld(m_capturePointGUID);
+    GameObject * flag2 = ObjectAccessor::GetGameObjectInWorld(m_Objects[m_TowerType]);
+    if(flag)
+    {
+        flag->SetGoArtKit(artkit);
+    }
+    if(flag2)
+    {
+        flag2->SetGoArtKit(artkit2);
+    }
+
+    // send world state update
+    if(field)
+        m_PvP->SendUpdateWorldState(field, 1);
+
+    // complete quest objective
+    if(m_State == OBJECTIVESTATE_ALLIANCE || m_State == OBJECTIVESTATE_HORDE)
+        SendObjectiveComplete(HP_CREDITMARKER[m_TowerType], 0);
+}
+
+void OPvPCapturePointHP::SendChangePhase()
+{
+    SendUpdateWorldState(HP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(HP_UI_TOWER_SLIDER_POS, phase);
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY, 1);
+}
+
+void OPvPCapturePointHP::FillInitialWorldStates(WorldPacket &data)
+{
+    switch(m_State)
+    {
+        case OBJECTIVESTATE_ALLIANCE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            data << uint32(HP_MAP_N[m_TowerType]) << uint32(0);
+            data << uint32(HP_MAP_A[m_TowerType]) << uint32(1);
+            data << uint32(HP_MAP_H[m_TowerType]) << uint32(0);
+            break;
+        case OBJECTIVESTATE_HORDE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            data << uint32(HP_MAP_N[m_TowerType]) << uint32(0);
+            data << uint32(HP_MAP_A[m_TowerType]) << uint32(0);
+            data << uint32(HP_MAP_H[m_TowerType]) << uint32(1);
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        default:
+            data << uint32(HP_MAP_N[m_TowerType]) << uint32(1);
+            data << uint32(HP_MAP_A[m_TowerType]) << uint32(0);
+            data << uint32(HP_MAP_H[m_TowerType]) << uint32(0);
+            break;
+    }
+}
+
+bool OPvPCapturePointHP::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointHP::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+void OutdoorPvPHP::HandleKillImpl(Player *plr, Unit * killed)
+{
+    if(killed->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if(plr->GetTeam() == ALLIANCE && ((Player*)killed)->GetTeam() != ALLIANCE)
+        plr->CastSpell(plr,AlliancePlayerKillReward,true);
+    else if(plr->GetTeam() == HORDE && ((Player*)killed)->GetTeam() != HORDE)
+        plr->CastSpell(plr,HordePlayerKillReward,true);
+}
diff --git a/Core/src/game/OutdoorPvPHP.h b/Core/src/game/OutdoorPvPHP.h
new file mode 100644
index 0000000..0050615
--- /dev/null
+++ b/Core/src/game/OutdoorPvPHP.h
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_HP_
+#define OUTDOOR_PVP_HP_
+
+#include "OutdoorPvPImpl.h"
+
+#define OutdoorPvPHPBuffZonesNum 6
+                                                         //  HP, citadel, ramparts, blood furnace, shattered halls, mag's lair
+const uint32 OutdoorPvPHPBuffZones[OutdoorPvPHPBuffZonesNum] = { 3483, 3563, 3562, 3713, 3714, 3836 };
+
+enum OutdoorPvPHPSpells
+{
+    AlliancePlayerKillReward = 32155,
+    HordePlayerKillReward = 32158,
+    AllianceBuff = 32071,
+    HordeBuff = 32049
+};
+
+enum OutdoorPvPHPTowerType{
+    HP_TOWER_BROKEN_HILL = 0,
+    HP_TOWER_OVERLOOK = 1,
+    HP_TOWER_STADIUM = 2,
+    HP_TOWER_NUM = 3
+};
+
+const uint32 HP_CREDITMARKER[HP_TOWER_NUM] = {19032,19028,19029};
+
+const uint32 HP_CapturePointEvent_Enter[HP_TOWER_NUM] = {11404,11396,11388};
+
+const uint32 HP_CapturePointEvent_Leave[HP_TOWER_NUM] = {11403,11395,11387};
+
+enum OutdoorPvPHPWorldStates{
+    HP_UI_TOWER_DISPLAY_A = 0x9ba,
+    HP_UI_TOWER_DISPLAY_H = 0x9b9,
+
+    HP_UI_TOWER_COUNT_H = 0x9ae,
+    HP_UI_TOWER_COUNT_A = 0x9ac,
+
+    HP_UI_TOWER_SLIDER_N = 2475,
+    HP_UI_TOWER_SLIDER_POS = 2474,
+    HP_UI_TOWER_SLIDER_DISPLAY = 2473
+};
+
+const uint32 HP_MAP_N[HP_TOWER_NUM] = {0x9b5,0x9b2,0x9a8};
+
+const uint32 HP_MAP_A[HP_TOWER_NUM] = {0x9b3,0x9b0,0x9a7};
+
+const uint32 HP_MAP_H[HP_TOWER_NUM] = {0x9b4,0x9b1,0x9a6};
+
+const uint32 HP_TowerArtKit_A[HP_TOWER_NUM] = {65,62,67};
+
+const uint32 HP_TowerArtKit_H[HP_TOWER_NUM] = {64,61,68};
+
+const uint32 HP_TowerArtKit_N[HP_TOWER_NUM] = {66,63,69};
+
+const go_type HPCapturePoints[HP_TOWER_NUM] = {
+    {182175,530,-471.462f,3451.09f,34.6432f,0.174533f,0,0,0.087156f,0.996195f},      // 0 - Broken Hill
+    {182174,530,-184.889f,3476.93f,38.205f,-0.017453f,0,0,0.008727f,-0.999962f},     // 1 - Overlook
+    {182173,530,-290.016f,3702.42f,56.6729f,0.034907f,0,0,0.017452f,0.999848f}     // 2 - Stadium
+};
+
+const go_type HPTowerFlags[HP_TOWER_NUM] = {
+    {183514,530,-467.078f,3528.17f,64.7121f,3.14159f,0,0,1,0},  // 0 broken hill
+    {182525,530,-187.887f,3459.38f,60.0403f,-3.12414f,0,0,0.999962f,-0.008727f}, // 1 overlook
+    {183515,530,-289.610f,3696.83f,75.9447f,3.12414f,0,0,0.999962f,0.008727f} // 2 stadium
+};
+
+class OPvPCapturePointHP : public OPvPCapturePoint
+{
+public:
+    OPvPCapturePointHP(OutdoorPvP * pvp, OutdoorPvPHPTowerType type);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+private:
+    OutdoorPvPHPTowerType m_TowerType;
+};
+
+class OutdoorPvPHP : public OutdoorPvP
+{
+friend class OPvPCapturePointHP;
+public:
+    OutdoorPvPHP();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void HandleKillImpl(Player * plr, Unit * killed);
+private:
+    // how many towers are controlled
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+};
+
+#endif
+
diff --git a/Core/src/game/OutdoorPvPImpl.h b/Core/src/game/OutdoorPvPImpl.h
new file mode 100644
index 0000000..3d174fa
--- /dev/null
+++ b/Core/src/game/OutdoorPvPImpl.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef OUTDOORPVP_IMPL_H
+#define OUTDOORPVP_IMPL_H
+
+#include "SharedDefines.h"
+#include "OutdoorPvP.h"
+#include "Player.h"
+#include "WorldPacket.h"
+
+#define OTHER_TEAM(a) (a == TEAM_ALLIANCE ? TEAM_HORDE : TEAM_ALLIANCE)
+
+#endif
diff --git a/Core/src/game/OutdoorPvPMgr.cpp b/Core/src/game/OutdoorPvPMgr.cpp
new file mode 100644
index 0000000..9947017
--- /dev/null
+++ b/Core/src/game/OutdoorPvPMgr.cpp
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPHP.h"
+#include "OutdoorPvPNA.h"
+#include "OutdoorPvPTF.h"
+#include "OutdoorPvPZM.h"
+#include "OutdoorPvPSI.h"
+#include "OutdoorPvPEP.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "Policies/SingletonImp.h"
+
+INSTANTIATE_SINGLETON_1( OutdoorPvPMgr );
+
+OutdoorPvPMgr::OutdoorPvPMgr()
+{
+    m_UpdateTimer = 0;
+    //sLog.outDebug("Instantiating OutdoorPvPMgr");
+}
+
+OutdoorPvPMgr::~OutdoorPvPMgr()
+{
+    //sLog.outDebug("Deleting OutdoorPvPMgr");
+    for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        (*itr)->DeleteSpawns();
+        delete *itr;
+    }
+}
+
+void OutdoorPvPMgr::InitOutdoorPvP()
+{
+    // create new opvp
+    OutdoorPvP * pOP = new OutdoorPvPHP;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outError("OutdoorPvP : HP init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.push_back(pOP);
+        sLog.outString();
+        sLog.outString("OutdoorPvP : HP successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPNA;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : NA init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.push_back(pOP);
+        sLog.outString();
+        sLog.outString("OutdoorPvP : NA successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPTF;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : TF init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.push_back(pOP);
+        sLog.outString();
+        sLog.outString("OutdoorPvP : TF successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPZM;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : ZM init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.push_back(pOP);
+        sLog.outString();
+        sLog.outString("OutdoorPvP : ZM successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPSI;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : SI init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.push_back(pOP);
+        sLog.outString();
+        sLog.outString("OutdoorPvP : SI successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPEP;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : EP init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.push_back(pOP);
+        sLog.outString();
+        sLog.outString("OutdoorPvP : EP successfully initiated.");
+        sLog.outString();
+    }
+}
+
+void OutdoorPvPMgr::AddZone(uint32 zoneid, OutdoorPvP *handle)
+{
+    m_OutdoorPvPMap[zoneid] = handle;
+}
+
+void OutdoorPvPMgr::HandlePlayerEnterZone(Player *plr, uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+        return;
+
+    if(itr->second->HasPlayer(plr))
+        return;
+
+    itr->second->HandlePlayerEnterZone(plr, zoneid);
+    sLog.outDebug("Player %u entered outdoorpvp id %u", plr->GetGUIDLow(), itr->second->GetTypeId());
+}
+
+void OutdoorPvPMgr::HandlePlayerLeaveZone(Player *plr, uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+        return;
+
+    // teleport: remove once in removefromworld, once in updatezone
+    if(!itr->second->HasPlayer(plr))
+        return;
+
+    itr->second->HandlePlayerLeaveZone(plr, zoneid);
+    sLog.outDebug("Player %u left outdoorpvp id %u",plr->GetGUIDLow(), itr->second->GetTypeId());
+}
+
+OutdoorPvP * OutdoorPvPMgr::GetOutdoorPvPToZoneId(uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+    {
+        // no handle for this zone, return
+        return NULL;
+    }
+    return itr->second;
+}
+
+void OutdoorPvPMgr::Update(uint32 diff)
+{
+    m_UpdateTimer += diff;
+    if(m_UpdateTimer > OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL)
+    {
+        for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+            (*itr)->Update(m_UpdateTimer);
+        m_UpdateTimer = 0;
+    }
+}
+
+bool OutdoorPvPMgr::HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go)
+{
+    for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleCustomSpell(plr,spellId,go))
+            return true;
+    }
+    return false;
+}
+
+ZoneScript * OutdoorPvPMgr::GetZoneScript(uint32 zoneId)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneId);
+    if(itr != m_OutdoorPvPMap.end())
+        return itr->second;
+    else
+        return NULL;
+}
+
+bool OutdoorPvPMgr::HandleOpenGo(Player *plr, uint64 guid)
+{
+    for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleOpenGo(plr,guid))
+            return true;
+    }
+    return false;
+}
+
+void OutdoorPvPMgr::HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid)
+{
+    for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleGossipOption(plr,guid,gossipid))
+            return;
+    }
+}
+
+bool OutdoorPvPMgr::CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso)
+{
+    for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->CanTalkTo(plr,c,gso))
+            return true;
+    }
+    return false;
+}
+
+void OutdoorPvPMgr::HandleDropFlag(Player *plr, uint32 spellId)
+{
+    for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleDropFlag(plr,spellId))
+            return;
+    }
+}
+
+void OutdoorPvPMgr::HandlePlayerResurrects(Player *plr, uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+        return;
+
+    if(itr->second->HasPlayer(plr))
+        itr->second->HandlePlayerResurrects(plr, zoneid);
+}
diff --git a/Core/src/game/OutdoorPvPMgr.h b/Core/src/game/OutdoorPvPMgr.h
new file mode 100644
index 0000000..a192975
--- /dev/null
+++ b/Core/src/game/OutdoorPvPMgr.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_MGR_H_
+#define OUTDOOR_PVP_MGR_H_
+
+#define OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL 1000
+
+#include "OutdoorPvP.h"
+#include "Policies/Singleton.h"
+
+class Player;
+class GameObject;
+class Creature;
+class ZoneScript;
+struct GossipMenuItems;
+
+// class to handle player enter / leave / areatrigger / GO use events
+class OutdoorPvPMgr
+{
+public:
+    // ctor
+    OutdoorPvPMgr();
+    // dtor
+    ~OutdoorPvPMgr();
+
+    // create outdoor pvp events
+    void InitOutdoorPvP();
+    // called when a player enters an outdoor pvp area
+    void HandlePlayerEnterZone(Player * plr, uint32 areaflag);
+    // called when player leaves an outdoor pvp area
+    void HandlePlayerLeaveZone(Player * plr, uint32 areaflag);
+    // called when player resurrects
+    void HandlePlayerResurrects(Player * plr, uint32 areaflag);
+    // return assigned outdoor pvp
+    OutdoorPvP * GetOutdoorPvPToZoneId(uint32 zoneid);
+    // handle custom (non-exist in dbc) spell if registered
+    bool HandleCustomSpell(Player * plr, uint32 spellId, GameObject* go);
+    // handle custom go if registered
+    bool HandleOpenGo(Player * plr, uint64 guid);
+
+    ZoneScript * GetZoneScript(uint32 zoneId);
+
+    void AddZone(uint32 zoneid, OutdoorPvP * handle);
+
+    void Update(uint32 diff);
+
+    void HandleGossipOption(Player * player, uint64 guid, uint32 gossipid);
+
+    bool CanTalkTo(Player * player, Creature * creature, GossipMenuItems gso);
+
+    void HandleDropFlag(Player * plr, uint32 spellId);
+
+    typedef std::vector<OutdoorPvP*> OutdoorPvPSet;
+    typedef std::map<uint32 /* zoneid */, OutdoorPvP*> OutdoorPvPMap;
+private:
+    // contains all initiated outdoor pvp events
+    // used when initing / cleaning up
+    OutdoorPvPSet  m_OutdoorPvPSet;
+    // maps the zone ids to an outdoor pvp event
+    // used in player event handling
+    OutdoorPvPMap   m_OutdoorPvPMap;
+    // update interval
+    uint32 m_UpdateTimer;
+};
+
+#define sOutdoorPvPMgr MaNGOS::Singleton<OutdoorPvPMgr>::Instance()
+
+#endif /*OUTDOOR_PVP_MGR_H_*/
+
diff --git a/Core/src/game/OutdoorPvPNA.cpp b/Core/src/game/OutdoorPvPNA.cpp
new file mode 100644
index 0000000..9cfb2cb
--- /dev/null
+++ b/Core/src/game/OutdoorPvPNA.cpp
@@ -0,0 +1,664 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPNA.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "WorldPacket.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPNA::OutdoorPvPNA()
+{
+    m_TypeId = OUTDOOR_PVP_NA;
+}
+
+void OutdoorPvPNA::HandleKillImpl(Player *plr, Unit * killed)
+{
+    if(killed->GetTypeId() == TYPEID_PLAYER && plr->GetTeam() != ((Player*)killed)->GetTeam())
+    {
+        plr->KilledMonsterCredit(NA_CREDIT_MARKER,0); // 0 guid, btw it isn't even used in killedmonster function :S
+        if(plr->GetTeam() == ALLIANCE)
+            plr->CastSpell(plr,NA_KILL_TOKEN_ALLIANCE,true);
+        else
+            plr->CastSpell(plr,NA_KILL_TOKEN_HORDE,true);
+    }
+}
+
+uint32 OPvPCapturePointNA::GetAliveGuardsCount()
+{
+    uint32 cnt = 0;
+    for (std::map<uint32, uint64>::iterator itr = m_Creatures.begin(); itr != m_Creatures.end(); ++itr)
+    {
+        switch(itr->first)
+        {
+        case NA_NPC_GUARD_01:
+        case NA_NPC_GUARD_02:
+        case NA_NPC_GUARD_03:
+        case NA_NPC_GUARD_04:
+        case NA_NPC_GUARD_05:
+        case NA_NPC_GUARD_06:
+        case NA_NPC_GUARD_07:
+        case NA_NPC_GUARD_08:
+        case NA_NPC_GUARD_09:
+        case NA_NPC_GUARD_10:
+        case NA_NPC_GUARD_11:
+        case NA_NPC_GUARD_12:
+        case NA_NPC_GUARD_13:
+        case NA_NPC_GUARD_14:
+        case NA_NPC_GUARD_15:
+            {
+                if(Creature * cr = ObjectAccessor::GetCreatureInWorld(itr->second))
+                {
+                    if(cr->isAlive())
+                        ++cnt;
+                }
+                else if (CreatureData const * cd = sObjectMgr.GetCreatureData(GUID_LOPART(itr->second)))
+                {
+                    if(!cd->is_dead)
+                        ++cnt;
+                }
+            }
+            break;
+        default:
+            break;
+        }
+    }
+    return cnt;
+}
+
+void OPvPCapturePointNA::SpawnNPCsForTeam(uint32 team)
+{
+    const creature_type * creatures = NULL;
+    if(team == ALLIANCE)
+        creatures=AllianceControlNPCs;
+    else if(team == HORDE)
+        creatures=HordeControlNPCs;
+    else
+        return;
+    for (int i = 0; i < NA_CONTROL_NPC_NUM; ++i)
+        AddCreature(i,creatures[i].entry,creatures[i].teamval,creatures[i].map,creatures[i].x,creatures[i].y,creatures[i].z,creatures[i].o,1000000);
+}
+
+void OPvPCapturePointNA::DeSpawnNPCs()
+{
+    for (int i = 0; i < NA_CONTROL_NPC_NUM; ++i)
+        DelCreature(i);
+}
+
+void OPvPCapturePointNA::SpawnGOsForTeam(uint32 team)
+{
+    const go_type * gos = NULL;
+    if(team == ALLIANCE)
+        gos=AllianceControlGOs;
+    else if(team == HORDE)
+        gos=HordeControlGOs;
+    else
+        return;
+    for (int i = 0; i < NA_CONTROL_GO_NUM; ++i)
+    {
+        if( i == NA_ROOST_S ||
+            i == NA_ROOST_W ||
+            i == NA_ROOST_N ||
+            i == NA_ROOST_E ||
+            i == NA_BOMB_WAGON_S ||
+            i == NA_BOMB_WAGON_W ||
+            i == NA_BOMB_WAGON_N ||
+            i == NA_BOMB_WAGON_E )
+            continue;   // roosts and bomb wagons are spawned when someone uses the matching destroyed roost
+        AddObject(i,gos[i].entry,gos[i].map,gos[i].x,gos[i].y,gos[i].z,gos[i].o,gos[i].rot0,gos[i].rot1,gos[i].rot2,gos[i].rot3);
+    }
+}
+
+void OPvPCapturePointNA::DeSpawnGOs()
+{
+    for (int i = 0; i < NA_CONTROL_GO_NUM; ++i)
+    {
+        DelObject(i);
+    }
+}
+
+void OPvPCapturePointNA::FactionTakeOver(uint32 team)
+{
+    if(m_ControllingFaction)
+        sObjectMgr.RemoveGraveYardLink(NA_HALAA_GRAVEYARD,NA_HALAA_GRAVEYARD_ZONE,m_ControllingFaction,false);
+    if(m_ControllingFaction == ALLIANCE)
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_NA_LOOSE_A));
+    else if(m_ControllingFaction == HORDE)
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_NA_LOOSE_H));
+
+    m_ControllingFaction = team;
+    if(m_ControllingFaction)
+        sObjectMgr.AddGraveYardLink(NA_HALAA_GRAVEYARD,NA_HALAA_GRAVEYARD_ZONE,m_ControllingFaction,false);
+    DeSpawnGOs();
+    DeSpawnNPCs();
+    SpawnGOsForTeam(team);
+    SpawnNPCsForTeam(team);
+    m_GuardsAlive = NA_GUARDS_MAX;
+    m_capturable = false;
+    this->UpdateHalaaWorldState();
+    if(team == ALLIANCE)
+    {
+        m_WyvernStateSouth = WYVERN_NEU_HORDE;
+        m_WyvernStateNorth = WYVERN_NEU_HORDE;
+        m_WyvernStateEast = WYVERN_NEU_HORDE;
+        m_WyvernStateWest = WYVERN_NEU_HORDE;
+        m_PvP->TeamApplyBuff(TEAM_ALLIANCE, NA_CAPTURE_BUFF);
+        m_PvP->SendUpdateWorldState(NA_UI_HORDE_GUARDS_SHOW, 0);
+        m_PvP->SendUpdateWorldState(NA_UI_ALLIANCE_GUARDS_SHOW, 1);
+        m_PvP->SendUpdateWorldState(NA_UI_GUARDS_LEFT, m_GuardsAlive);
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_NA_CAPTURE_A));
+    }
+    else
+    {
+        m_WyvernStateSouth = WYVERN_NEU_ALLIANCE;
+        m_WyvernStateNorth = WYVERN_NEU_ALLIANCE;
+        m_WyvernStateEast = WYVERN_NEU_ALLIANCE;
+        m_WyvernStateWest = WYVERN_NEU_ALLIANCE;
+        m_PvP->TeamApplyBuff(TEAM_HORDE, NA_CAPTURE_BUFF);
+        m_PvP->SendUpdateWorldState(NA_UI_HORDE_GUARDS_SHOW, 1);
+        m_PvP->SendUpdateWorldState(NA_UI_ALLIANCE_GUARDS_SHOW, 0);
+        m_PvP->SendUpdateWorldState(NA_UI_GUARDS_LEFT, m_GuardsAlive);
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_NA_CAPTURE_H));
+    }
+    UpdateWyvernRoostWorldState(NA_ROOST_S);
+    UpdateWyvernRoostWorldState(NA_ROOST_N);
+    UpdateWyvernRoostWorldState(NA_ROOST_W);
+    UpdateWyvernRoostWorldState(NA_ROOST_E);
+}
+
+bool OPvPCapturePointNA::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointNA::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+OPvPCapturePointNA::OPvPCapturePointNA(OutdoorPvP *pvp) :
+OPvPCapturePoint(pvp), m_capturable(true), m_GuardsAlive(0), m_ControllingFaction(0),
+m_HalaaState(HALAA_N), m_WyvernStateSouth(0), m_WyvernStateNorth(0), m_WyvernStateWest(0),
+m_WyvernStateEast(0), m_RespawnTimer(NA_RESPAWN_TIME), m_GuardCheckTimer(NA_GUARD_CHECK_TIME)
+{
+    SetCapturePointData(182210,530,-1572.57f,7945.3f,-22.475f,2.05949f,0,0,0.857167f,0.515038f);
+}
+
+bool OutdoorPvPNA::SetupOutdoorPvP()
+{
+//    m_TypeId = OUTDOOR_PVP_NA; _MUST_ be set in ctor, because of spawns cleanup
+    // add the zones affected by the pvp buff
+    RegisterZone(NA_BUFF_ZONE);
+
+    // halaa
+    m_obj = new OPvPCapturePointNA(this);
+    if(!m_obj)
+        return false;
+    AddCapturePoint(m_obj);
+
+    return true;
+}
+
+void OutdoorPvPNA::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    // add buffs
+    if(plr->GetTeam() == m_obj->m_ControllingFaction)
+        plr->CastSpell(plr,NA_CAPTURE_BUFF,true);
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPNA::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr->RemoveAurasDueToSpell(NA_CAPTURE_BUFF);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+void OutdoorPvPNA::FillInitialWorldStates(WorldPacket &data)
+{
+    m_obj->FillInitialWorldStates(data);
+}
+
+void OPvPCapturePointNA::FillInitialWorldStates(WorldPacket &data)
+{
+    if(m_ControllingFaction == ALLIANCE)
+    {
+        data << NA_UI_HORDE_GUARDS_SHOW << uint32(0);
+        data << NA_UI_ALLIANCE_GUARDS_SHOW << uint32(1);
+    }
+    else if(m_ControllingFaction == HORDE)
+    {
+        data << NA_UI_HORDE_GUARDS_SHOW << uint32(1);
+        data << NA_UI_ALLIANCE_GUARDS_SHOW << uint32(0);
+    }
+    else
+    {
+        data << NA_UI_HORDE_GUARDS_SHOW << uint32(0);
+        data << NA_UI_ALLIANCE_GUARDS_SHOW << uint32(0);
+    }
+
+    data << NA_UI_GUARDS_MAX << NA_GUARDS_MAX;
+    data << NA_UI_GUARDS_LEFT << uint32(m_GuardsAlive);
+
+    data << NA_UI_TOWER_SLIDER_DISPLAY << uint32(0);
+    data << NA_UI_TOWER_SLIDER_POS << uint32(50);
+    data << NA_UI_TOWER_SLIDER_N << uint32(100);
+
+    data << NA_MAP_WYVERN_NORTH_NEU_H << uint32(bool(m_WyvernStateNorth & WYVERN_NEU_HORDE));
+    data << NA_MAP_WYVERN_NORTH_NEU_A << uint32(bool(m_WyvernStateNorth & WYVERN_NEU_ALLIANCE));
+    data << NA_MAP_WYVERN_NORTH_H << uint32(bool(m_WyvernStateNorth & WYVERN_HORDE));
+    data << NA_MAP_WYVERN_NORTH_A << uint32(bool(m_WyvernStateNorth & WYVERN_ALLIANCE));
+
+    data << NA_MAP_WYVERN_SOUTH_NEU_H << uint32(bool(m_WyvernStateSouth & WYVERN_NEU_HORDE));
+    data << NA_MAP_WYVERN_SOUTH_NEU_A << uint32(bool(m_WyvernStateSouth & WYVERN_NEU_ALLIANCE));
+    data << NA_MAP_WYVERN_SOUTH_H << uint32(bool(m_WyvernStateSouth & WYVERN_HORDE));
+    data << NA_MAP_WYVERN_SOUTH_A << uint32(bool(m_WyvernStateSouth & WYVERN_ALLIANCE));
+
+    data << NA_MAP_WYVERN_WEST_NEU_H << uint32(bool(m_WyvernStateWest & WYVERN_NEU_HORDE));
+    data << NA_MAP_WYVERN_WEST_NEU_A << uint32(bool(m_WyvernStateWest & WYVERN_NEU_ALLIANCE));
+    data << NA_MAP_WYVERN_WEST_H << uint32(bool(m_WyvernStateWest & WYVERN_HORDE));
+    data << NA_MAP_WYVERN_WEST_A << uint32(bool(m_WyvernStateWest & WYVERN_ALLIANCE));
+
+    data << NA_MAP_WYVERN_EAST_NEU_H << uint32(bool(m_WyvernStateEast & WYVERN_NEU_HORDE));
+    data << NA_MAP_WYVERN_EAST_NEU_A << uint32(bool(m_WyvernStateEast & WYVERN_NEU_ALLIANCE));
+    data << NA_MAP_WYVERN_EAST_H << uint32(bool(m_WyvernStateEast & WYVERN_HORDE));
+    data << NA_MAP_WYVERN_EAST_A << uint32(bool(m_WyvernStateEast & WYVERN_ALLIANCE));
+
+    data << NA_MAP_HALAA_NEUTRAL << uint32(bool(m_HalaaState & HALAA_N));
+    data << NA_MAP_HALAA_NEU_A << uint32(bool(m_HalaaState & HALAA_N_A));
+    data << NA_MAP_HALAA_NEU_H << uint32(bool(m_HalaaState & HALAA_N_H));
+    data << NA_MAP_HALAA_HORDE << uint32(bool(m_HalaaState & HALAA_H));
+    data << NA_MAP_HALAA_ALLIANCE << uint32(bool(m_HalaaState & HALAA_A));
+}
+
+void OutdoorPvPNA::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(NA_UI_HORDE_GUARDS_SHOW,0);
+    plr->SendUpdateWorldState(NA_UI_ALLIANCE_GUARDS_SHOW,0);
+    plr->SendUpdateWorldState(NA_UI_GUARDS_MAX,0);
+    plr->SendUpdateWorldState(NA_UI_GUARDS_LEFT,0);
+    plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY,0);
+    plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_POS,0);
+    plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_N,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_WEST_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_WEST_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_EAST_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_EAST_A,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_NEUTRAL,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_HORDE,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_ALLIANCE,0);
+}
+
+bool OutdoorPvPNA::Update(uint32 diff)
+{
+    return m_obj->Update(diff);
+}
+
+bool OPvPCapturePointNA::HandleCustomSpell(Player * plr, uint32 spellId, GameObject * go)
+{
+    std::vector<uint32> nodes;
+    nodes.resize(2);
+    bool retval = false;
+    switch(spellId)
+    {
+    case NA_SPELL_FLY_NORTH:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_N];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_N];
+        plr->ActivateTaxiPathTo(nodes);
+        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr->UpdatePvP(true,true);
+        retval = true;
+        break;
+    case NA_SPELL_FLY_SOUTH:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_S];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_S];
+        plr->ActivateTaxiPathTo(nodes);
+        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr->UpdatePvP(true,true);
+        retval = true;
+        break;
+    case NA_SPELL_FLY_WEST:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_W];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_W];
+        plr->ActivateTaxiPathTo(nodes);
+        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr->UpdatePvP(true,true);
+        retval = true;
+        break;
+    case NA_SPELL_FLY_EAST:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_E];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_E];
+        plr->ActivateTaxiPathTo(nodes);
+        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr->UpdatePvP(true,true);
+        retval = true;
+        break;
+    default:
+        break;
+    }
+
+    if(retval)
+    {
+        //Adding items
+        uint32 noSpaceForCount = 0;
+
+        // check space and find places
+        ItemPosCountVec dest;
+
+        int32 count = 10;
+        uint32 itemid = 24538;
+                                                                // bomb id count
+        uint8 msg = plr->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, itemid, count, &noSpaceForCount );
+        if( msg != EQUIP_ERR_OK )                               // convert to possible store amount
+            count -= noSpaceForCount;
+
+        if( count == 0 || dest.empty())                         // can't add any
+        {
+            return true;
+        }
+
+        Item* item = plr->StoreNewItem( dest, itemid, true);
+
+        if(count > 0 && item)
+        {
+            plr->SendNewItem(item,count,true,false);
+        }
+
+        return true;
+    }
+    return false;
+}
+
+int32 OPvPCapturePointNA::HandleOpenGo(Player *plr, uint64 guid)
+{
+    uint32 retval = OPvPCapturePoint::HandleOpenGo(plr, guid);
+    if(retval>=0)
+    {
+        const go_type * gos = NULL;
+        if(m_ControllingFaction == ALLIANCE)
+            gos=AllianceControlGOs;
+        else if(m_ControllingFaction == HORDE)
+            gos=HordeControlGOs;
+        else
+            return -1;
+
+        int32 del = -1;
+        int32 del2 = -1;
+        int32 add = -1;
+        int32 add2 = -1;
+
+        switch(retval)
+        {
+        case NA_DESTROYED_ROOST_S:
+            del = NA_DESTROYED_ROOST_S;
+            add = NA_ROOST_S;
+            add2 = NA_BOMB_WAGON_S;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateSouth = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateSouth = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_S);
+            break;
+        case NA_DESTROYED_ROOST_N:
+            del = NA_DESTROYED_ROOST_N;
+            add = NA_ROOST_N;
+            add2 = NA_BOMB_WAGON_N;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateNorth = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateNorth = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_N);
+            break;
+        case NA_DESTROYED_ROOST_W:
+            del = NA_DESTROYED_ROOST_W;
+            add = NA_ROOST_W;
+            add2 = NA_BOMB_WAGON_W;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateWest = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateWest = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_W);
+            break;
+        case NA_DESTROYED_ROOST_E:
+            del = NA_DESTROYED_ROOST_E;
+            add = NA_ROOST_E;
+            add2 = NA_BOMB_WAGON_E;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateEast = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateEast = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_E);
+            break;
+        case NA_BOMB_WAGON_S:
+            del = NA_BOMB_WAGON_S;
+            del2 = NA_ROOST_S;
+            add = NA_DESTROYED_ROOST_S;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateSouth = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateSouth = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_S);
+            break;
+        case NA_BOMB_WAGON_N:
+            del = NA_BOMB_WAGON_N;
+            del2 = NA_ROOST_N;
+            add = NA_DESTROYED_ROOST_N;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateNorth = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateNorth = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_N);
+            break;
+        case NA_BOMB_WAGON_W:
+            del = NA_BOMB_WAGON_W;
+            del2 = NA_ROOST_W;
+            add = NA_DESTROYED_ROOST_W;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateWest = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateWest = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_W);
+            break;
+        case NA_BOMB_WAGON_E:
+            del = NA_BOMB_WAGON_E;
+            del2 = NA_ROOST_E;
+            add = NA_DESTROYED_ROOST_E;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateEast = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateEast = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_E);
+            break;
+        default:
+            return -1;
+            break;
+        }
+
+        if(del>-1)
+            DelObject(del);
+
+        if(del2>-1)
+            DelObject(del2);
+
+        if(add>-1)
+            AddObject(add,gos[add].entry,gos[add].map,gos[add].x,gos[add].y,gos[add].z,gos[add].o,gos[add].rot0,gos[add].rot1,gos[add].rot2,gos[add].rot3);
+
+        if(add2>-1)
+            AddObject(add2,gos[add2].entry,gos[add2].map,gos[add2].x,gos[add2].y,gos[add2].z,gos[add2].o,gos[add2].rot0,gos[add2].rot1,gos[add2].rot2,gos[add2].rot3);
+
+        return retval;
+    }
+    return -1;
+}
+
+bool OPvPCapturePointNA::Update(uint32 diff)
+{
+    // let the controlling faction advance in phase
+    bool capturable = false;
+    if(m_ControllingFaction == ALLIANCE && m_activePlayers[0].size() > m_activePlayers[1].size())
+        capturable = true;
+    else if(m_ControllingFaction == HORDE && m_activePlayers[0].size() < m_activePlayers[1].size())
+        capturable = true;
+
+    if(m_GuardCheckTimer < diff)
+    {
+        m_GuardCheckTimer = NA_GUARD_CHECK_TIME;
+        uint32 cnt = GetAliveGuardsCount();
+        if(cnt != m_GuardsAlive)
+        {
+            m_GuardsAlive = cnt;
+            if(m_GuardsAlive == 0)
+                m_capturable = true;
+            // update the guard count for the players in zone
+            m_PvP->SendUpdateWorldState(NA_UI_GUARDS_LEFT,m_GuardsAlive);
+        }
+    } else m_GuardCheckTimer -= diff;
+
+    if(m_capturable || capturable)
+    {
+        if(m_RespawnTimer < diff)
+        {
+            // if the guards have been killed, then the challenger has one hour to take over halaa.
+            // in case they fail to do it, the guards are respawned, and they have to start again.
+            if(m_ControllingFaction)
+                FactionTakeOver(m_ControllingFaction);
+            m_RespawnTimer = NA_RESPAWN_TIME;
+        } else m_RespawnTimer -= diff;
+
+        return OPvPCapturePoint::Update(diff);
+    }
+    return false;
+}
+
+void OPvPCapturePointNA::ChangeState()
+{
+    uint32 artkit = 21;
+    switch(m_State)
+    {
+        case OBJECTIVESTATE_NEUTRAL:
+            m_HalaaState = HALAA_N;
+            break;
+        case OBJECTIVESTATE_ALLIANCE:
+            m_HalaaState = HALAA_A;
+            FactionTakeOver(ALLIANCE);
+            artkit = 2;
+            break;
+        case OBJECTIVESTATE_HORDE:
+            m_HalaaState = HALAA_H;
+            FactionTakeOver(HORDE);
+            artkit = 1;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            m_HalaaState = HALAA_N_A;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            m_HalaaState = HALAA_N_H;
+            break;
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            m_HalaaState = HALAA_N_A;
+            artkit = 2;
+            break;
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            m_HalaaState = HALAA_N_H;
+            artkit = 1;
+        break;
+    }
+
+    GameObject * flag = ObjectAccessor::GetGameObjectInWorld(m_capturePointGUID);
+    if(flag)
+    {
+        flag->SetGoArtKit(artkit);
+    }
+
+    UpdateHalaaWorldState();
+}
+
+void OPvPCapturePointNA::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(NA_UI_TOWER_SLIDER_POS, phase);
+    SendUpdateWorldState(NA_UI_TOWER_SLIDER_N, m_neutralValuePct);
+}
+
+void OPvPCapturePointNA::UpdateHalaaWorldState()
+{
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_NEUTRAL ,uint32(bool(m_HalaaState & HALAA_N)));
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_NEU_A ,uint32(bool(m_HalaaState & HALAA_N_A)));
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_NEU_H ,uint32(bool(m_HalaaState & HALAA_N_H)));
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_HORDE ,uint32(bool(m_HalaaState & HALAA_H)));
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_ALLIANCE ,uint32(bool(m_HalaaState & HALAA_A)));
+}
+
+void OPvPCapturePointNA::UpdateWyvernRoostWorldState(uint32 roost)
+{
+    switch(roost)
+    {
+    case NA_ROOST_S:
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_H,uint32(bool(m_WyvernStateSouth & WYVERN_NEU_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_A,uint32(bool(m_WyvernStateSouth & WYVERN_NEU_ALLIANCE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_H,uint32(bool(m_WyvernStateSouth & WYVERN_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_A,uint32(bool(m_WyvernStateSouth & WYVERN_ALLIANCE)));
+        break;
+    case NA_ROOST_N:
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_H,uint32(bool(m_WyvernStateNorth & WYVERN_NEU_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_A,uint32(bool(m_WyvernStateNorth & WYVERN_NEU_ALLIANCE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_H,uint32(bool(m_WyvernStateNorth & WYVERN_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_A,uint32(bool(m_WyvernStateNorth & WYVERN_ALLIANCE)));
+        break;
+    case NA_ROOST_W:
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_H,uint32(bool(m_WyvernStateWest & WYVERN_NEU_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_A,uint32(bool(m_WyvernStateWest & WYVERN_NEU_ALLIANCE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_WEST_H,uint32(bool(m_WyvernStateWest & WYVERN_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_WEST_A,uint32(bool(m_WyvernStateWest & WYVERN_ALLIANCE)));
+        break;
+    case NA_ROOST_E:
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_H,uint32(bool(m_WyvernStateEast & WYVERN_NEU_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_A,uint32(bool(m_WyvernStateEast & WYVERN_NEU_ALLIANCE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_EAST_H,uint32(bool(m_WyvernStateEast & WYVERN_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_EAST_A,uint32(bool(m_WyvernStateEast & WYVERN_ALLIANCE)));
+        break;
+    }
+}
diff --git a/Core/src/game/OutdoorPvPNA.h b/Core/src/game/OutdoorPvPNA.h
new file mode 100644
index 0000000..ab299a4
--- /dev/null
+++ b/Core/src/game/OutdoorPvPNA.h
@@ -0,0 +1,297 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_NA_
+#define OUTDOOR_PVP_NA_
+
+// TODO: "sometimes" set to neutral
+
+#include "OutdoorPvPImpl.h"
+enum OutdoorPvPNASpells
+{
+    NA_KILL_TOKEN_ALLIANCE = 33005,
+    NA_KILL_TOKEN_HORDE = 33004,
+    NA_CAPTURE_BUFF = 33795  // strength of the halaani
+};
+// kill credit for pks
+const uint32 NA_CREDIT_MARKER = 24867;
+const uint32 NA_GUARDS_MAX = 15;
+
+const uint32 NA_BUFF_ZONE = 3518;
+
+const uint32 NA_HALAA_GRAVEYARD = 993;
+
+const uint32 NA_HALAA_GRAVEYARD_ZONE = 3518; // need to add zone id, not area id
+
+const uint32 NA_RESPAWN_TIME = 3600000; // one hour to capture after defeating all guards
+
+const uint32 NA_GUARD_CHECK_TIME = 500; // every half second
+
+enum OutdoorPvPNAWorldStates{
+    NA_UI_HORDE_GUARDS_SHOW = 2503,
+    NA_UI_ALLIANCE_GUARDS_SHOW = 2502,
+    NA_UI_GUARDS_MAX = 2493,
+    NA_UI_GUARDS_LEFT = 2491,
+
+    NA_UI_TOWER_SLIDER_DISPLAY = 2495,
+    NA_UI_TOWER_SLIDER_POS = 2494,
+    NA_UI_TOWER_SLIDER_N = 2497,
+
+    NA_MAP_WYVERN_NORTH_NEU_H = 2762,
+    NA_MAP_WYVERN_NORTH_NEU_A = 2662,
+    NA_MAP_WYVERN_NORTH_H = 2663,
+    NA_MAP_WYVERN_NORTH_A = 2664,
+
+    NA_MAP_WYVERN_SOUTH_NEU_H = 2760,
+    NA_MAP_WYVERN_SOUTH_NEU_A = 2670,
+    NA_MAP_WYVERN_SOUTH_H = 2668,
+    NA_MAP_WYVERN_SOUTH_A = 2669,
+
+    NA_MAP_WYVERN_WEST_NEU_H = 2761,
+    NA_MAP_WYVERN_WEST_NEU_A = 2667,
+    NA_MAP_WYVERN_WEST_H = 2665,
+    NA_MAP_WYVERN_WEST_A = 2666,
+
+    NA_MAP_WYVERN_EAST_NEU_H = 2763,
+    NA_MAP_WYVERN_EAST_NEU_A = 2659,
+    NA_MAP_WYVERN_EAST_H = 2660,
+    NA_MAP_WYVERN_EAST_A = 2661,
+
+    NA_MAP_HALAA_NEUTRAL = 2671,
+    NA_MAP_HALAA_NEU_A = 2676,
+    NA_MAP_HALAA_NEU_H = 2677,
+    NA_MAP_HALAA_HORDE = 2672,
+    NA_MAP_HALAA_ALLIANCE = 2673
+};
+
+const uint32 FLIGHT_NODES_NUM = 4;
+
+// used to access the elements of Horde/AllyControlGOs
+enum ControlGOTypes{
+    NA_ROOST_S = 0,
+    NA_ROOST_W = 1,
+    NA_ROOST_N = 2,
+    NA_ROOST_E = 3,
+
+    NA_BOMB_WAGON_S = 4,
+    NA_BOMB_WAGON_W = 5,
+    NA_BOMB_WAGON_N = 6,
+    NA_BOMB_WAGON_E = 7,
+
+    NA_DESTROYED_ROOST_S = 8,
+    NA_DESTROYED_ROOST_W = 9,
+    NA_DESTROYED_ROOST_N = 10,
+    NA_DESTROYED_ROOST_E = 11,
+
+    NA_CONTROL_GO_NUM = 12
+};
+
+const uint32 FlightPathStartNodes[FLIGHT_NODES_NUM] = {103,105,107,109};
+const uint32 FlightPathEndNodes[FLIGHT_NODES_NUM] = {104,106,108,110};
+
+enum FlightSpellsNA{
+    NA_SPELL_FLY_SOUTH = 32059,
+    NA_SPELL_FLY_WEST = 32068,
+    NA_SPELL_FLY_NORTH = 32075,
+    NA_SPELL_FLY_EAST = 32081
+};
+
+// spawned when the alliance is attacking, horde is in control
+const go_type HordeControlGOs[NA_CONTROL_GO_NUM] = {
+    {182267,530,-1815.8f,8036.51f,-26.2354f,-2.89725f,0,0,0.992546f,-0.121869f}, //ALLY_ROOST_SOUTH
+    {182280,530,-1507.95f,8132.1f,-19.5585f,-1.3439f,0,0,0.622515f,-0.782608f}, //ALLY_ROOST_WEST
+    {182281,530,-1384.52f,7779.33f,-11.1663f,-0.575959f,0,0,0.284015f,-0.95882f}, //ALLY_ROOST_NORTH
+    {182282,530,-1650.11f,7732.56f,-15.4505f,-2.80998f,0,0,0.986286f,-0.165048f}, //ALLY_ROOST_EAST
+
+    {182222,530,-1825.4022f,8039.2602f,-26.08f,-2.89725f,0,0,0.992546f,-0.121869f}, //HORDE_BOMB_WAGON_SOUTH
+    {182272,530,-1515.37f,8136.91f,-20.42f,-1.3439f,0,0,0.622515f,-0.782608f}, //HORDE_BOMB_WAGON_WEST
+    {182273,530,-1377.95f,7773.44f,-10.31f,-0.575959f,0,0,0.284015f,-0.95882f}, //HORDE_BOMB_WAGON_NORTH
+    {182274,530,-1659.87f,7733.15f,-15.75f,-2.80998f,0,0,0.986286f,-0.165048f}, //HORDE_BOMB_WAGON_EAST
+
+    {182266,530,-1815.8f,8036.51f,-26.2354f,-2.89725f,0,0,0.992546f,-0.121869f}, //DESTROYED_ALLY_ROOST_SOUTH
+    {182275,530,-1507.95f,8132.1f,-19.5585f,-1.3439f,0,0,0.622515f,-0.782608f}, //DESTROYED_ALLY_ROOST_WEST
+    {182276,530,-1384.52f,7779.33f,-11.1663f,-0.575959f,0,0,0.284015f,-0.95882f}, //DESTROYED_ALLY_ROOST_NORTH
+    {182277,530,-1650.11f,7732.56f,-15.4505f,-2.80998f,0,0,0.986286f,-0.165048f}  //DESTROYED_ALLY_ROOST_EAST
+};
+
+// spawned when the horde is attacking, alliance is in control
+const go_type AllianceControlGOs[NA_CONTROL_GO_NUM] = {
+    {182301,530,-1815.8f,8036.51f,-26.2354f,-2.89725f,0,0,0.992546f,-0.121869f}, //HORDE_ROOST_SOUTH
+    {182302,530,-1507.95f,8132.1f,-19.5585f,-1.3439f,0,0,0.622515f,-0.782608f}, //HORDE_ROOST_WEST
+    {182303,530,-1384.52f,7779.33f,-11.1663f,-0.575959f,0,0,0.284015f,-0.95882f}, //HORDE_ROOST_NORTH
+    {182304,530,-1650.11f,7732.56f,-15.4505f,-2.80998f,0,0,0.986286f,-0.165048f}, //HORDE_ROOST_EAST
+
+    {182305,530,-1825.4022f,8039.2602f,-26.08f,-2.89725f,0,0,0.992546f,-0.121869f}, //ALLY_BOMB_WAGON_SOUTH
+    {182306,530,-1515.37f,8136.91f,-20.42f,-1.3439f,0,0,0.622515f,-0.782608f}, //ALLY_BOMB_WAGON_WEST
+    {182307,530,-1377.95f,7773.44f,-10.31f,-0.575959f,0,0,0.284015f,-0.95882f}, //ALLY_BOMB_WAGON_NORTH
+    {182308,530,-1659.87f,7733.15f,-15.75f,-2.80998f,0,0,0.986286f,-0.165048f}, //ALLY_BOMB_WAGON_EAST
+
+    {182297,530,-1815.8f,8036.51f,-26.2354f,-2.89725f,0,0,0.992546f,-0.121869f}, //DESTROYED_HORDE_ROOST_SOUTH
+    {182298,530,-1507.95f,8132.1f,-19.5585f,-1.3439f,0,0,0.622515f,-0.782608f}, //DESTROYED_HORDE_ROOST_WEST
+    {182299,530,-1384.52f,7779.33f,-11.1663f,-0.575959f,0,0,0.284015f,-0.95882f}, //DESTROYED_HORDE_ROOST_NORTH
+    {182300,530,-1650.11f,7732.56f,-15.4505f,-2.80998f,0,0,0.986286f,-0.165048f}  //DESTROYED_HORDE_ROOST_EAST
+};
+
+enum ControlNPCTypes{
+    NA_NPC_RESEARCHER = 0,
+    NA_NPC_QUARTERMASTER,
+    NA_NPC_BLADE_MERCHANT,
+    NA_NPC_FOOD_MERCHANT,
+    NA_NPC_AMMO,
+
+    NA_NPC_GUARD_01,
+    NA_NPC_GUARD_02,
+    NA_NPC_GUARD_03,
+    NA_NPC_GUARD_04,
+    NA_NPC_GUARD_05,
+    NA_NPC_GUARD_06,
+    NA_NPC_GUARD_07,
+    NA_NPC_GUARD_08,
+    NA_NPC_GUARD_09,
+    NA_NPC_GUARD_10,
+    NA_NPC_GUARD_11,
+    NA_NPC_GUARD_12,
+    NA_NPC_GUARD_13,
+    NA_NPC_GUARD_14,
+    NA_NPC_GUARD_15,
+
+    NA_CONTROL_NPC_NUM
+};
+
+const creature_type HordeControlNPCs[NA_CONTROL_NPC_NUM] = {
+    {18816,67,530,-1523.92f,7951.76f,-17.6942f,3.51172f},
+    {18821,67,530,-1527.75f,7952.46f,-17.6948f,3.99317f},
+    {21474,67,530,-1520.14f,7927.11f,-20.2527f,3.39389f},
+    {21484,67,530,-1524.84f,7930.34f,-20.182f,3.6405f},
+    {21483,67,530,-1570.01f,7993.8f,-22.4505f,5.02655f},
+    {18192,67,530,-1654.06f,8000.46f,-26.59f,3.37f},
+    {18192,67,530,-1487.18f,7899.1f,-19.53f,0.954f},
+    {18192,67,530,-1480.88f,7908.79f,-19.19f,4.485f},
+    {18192,67,530,-1540.56f,7995.44f,-20.45f,0.947f},
+    {18192,67,530,-1546.95f,8000.85f,-20.72f,6.035f},
+    {18192,67,530,-1595.31f,7860.53f,-21.51f,3.747f},
+    {18192,67,530,-1642.31f,7995.59f,-25.8f,3.317f},
+    {18192,67,530,-1545.46f,7995.35f,-20.63f,1.094f},
+    {18192,67,530,-1487.58f,7907.99f,-19.27f,5.567f},
+    {18192,67,530,-1651.54f,7988.56f,-26.5289f,2.98451f},
+    {18192,67,530,-1602.46f,7866.43f,-22.1177f,4.74729f},
+    {18192,67,530,-1591.22f,7875.29f,-22.3536f,4.34587f},
+    {18192,67,530,-1550.6f,7944.45f,-21.63f,3.559f},
+    {18192,67,530,-1545.57f,7935.83f,-21.13f,3.448f},
+    {18192,67,530,-1550.86f,7937.56f,-21.7f,3.801f}
+};
+
+const creature_type AllianceControlNPCs[NA_CONTROL_NPC_NUM] = {
+    {18817,469,530,-1591.18f,8020.39f,-22.2042f,4.59022f},
+    {18822,469,530,-1588.0f,8019.0f,-22.2042f,4.06662f},
+    {21485,469,530,-1521.93f,7927.37f,-20.2299f,3.24631f},
+    {21487,469,530,-1540.33f,7971.95f,-20.7186f,3.07178f},
+    {21488,469,530,-1570.01f,7993.8f,-22.4505f,5.02655f},
+    {18256,469,530,-1654.06f,8000.46f,-26.59f,3.37f},
+    {18256,469,530,-1487.18f,7899.1f,-19.53f,0.954f},
+    {18256,469,530,-1480.88f,7908.79f,-19.19f,4.485f},
+    {18256,469,530,-1540.56f,7995.44f,-20.45f,0.947f},
+    {18256,469,530,-1546.95f,8000.85f,-20.72f,6.035f},
+    {18256,469,530,-1595.31f,7860.53f,-21.51f,3.747f},
+    {18256,469,530,-1642.31f,7995.59f,-25.8f,3.317f},
+    {18256,469,530,-1545.46f,7995.35f,-20.63f,1.094f},
+    {18256,469,530,-1487.58f,7907.99f,-19.27f,5.567f},
+    {18256,469,530,-1651.54f,7988.56f,-26.5289f,2.98451f},
+    {18256,469,530,-1602.46f,7866.43f,-22.1177f,4.74729f},
+    {18256,469,530,-1591.22f,7875.29f,-22.3536f,4.34587f},
+    {18256,469,530,-1603.75f,8000.36f,-24.18f,4.516f},
+    {18256,469,530,-1585.73f,7994.68f,-23.29f,4.439f},
+    {18256,469,530,-1595.5f,7991.27f,-23.53f,4.738f}
+};
+
+enum WyvernStates{
+    WYVERN_NEU_HORDE = 1,
+    WYVERN_NEU_ALLIANCE = 2,
+    WYVERN_HORDE = 4,
+    WYVERN_ALLIANCE = 8
+};
+
+enum HalaaStates{
+    HALAA_N = 1,
+    HALAA_N_A = 2,
+    HALAA_A = 4,
+    HALAA_N_H = 8,
+    HALAA_H = 16
+};
+
+class Unit;
+class Creature;
+class OutdoorPvPNA;
+class OPvPCapturePointNA : public OPvPCapturePoint
+{
+friend class OutdoorPvPNA;
+public:
+    OPvPCapturePointNA(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    bool HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go);
+    int32 HandleOpenGo(Player *plr, uint64 guid);
+    uint32 GetAliveGuardsCount();
+protected:
+    // called when a faction takes control
+    void FactionTakeOver(uint32 team);
+
+    void DeSpawnNPCs();
+    void DeSpawnGOs();
+    void SpawnNPCsForTeam(uint32 team);
+    void SpawnGOsForTeam(uint32 team);
+
+    void UpdateWyvernRoostWorldState(uint32 roost);
+    void UpdateHalaaWorldState();
+
+private:
+    bool m_capturable;
+    uint32 m_GuardsAlive;
+    uint32 m_ControllingFaction;
+    uint32 m_WyvernStateNorth;
+    uint32 m_WyvernStateSouth;
+    uint32 m_WyvernStateEast;
+    uint32 m_WyvernStateWest;
+    uint32 m_HalaaState;
+    uint32 m_RespawnTimer;
+    uint32 m_GuardCheckTimer;
+};
+
+class OutdoorPvPNA : public OutdoorPvP
+{
+friend class OPvPCapturePointNA;
+public:
+    OutdoorPvPNA();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void HandleKillImpl(Player * plr, Unit * killed);
+private:
+    OPvPCapturePointNA * m_obj;
+};
+
+#endif
+
diff --git a/Core/src/game/OutdoorPvPSI.cpp b/Core/src/game/OutdoorPvPSI.cpp
new file mode 100644
index 0000000..f92cb27
--- /dev/null
+++ b/Core/src/game/OutdoorPvPSI.cpp
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPSI.h"
+#include "WorldPacket.h"
+#include "Player.h"
+#include "GameObject.h"
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPSI::OutdoorPvPSI()
+{
+    m_TypeId = OUTDOOR_PVP_SI;
+    m_Gathered_A = 0;
+    m_Gathered_H = 0;
+    m_LastController = 0;
+}
+
+void OutdoorPvPSI::FillInitialWorldStates(WorldPacket &data)
+{
+    data << SI_GATHERED_A << m_Gathered_A;
+    data << SI_GATHERED_H << m_Gathered_H;
+    data << SI_SILITHYST_MAX << SI_MAX_RESOURCES;
+}
+
+void OutdoorPvPSI::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(SI_GATHERED_A,0);
+    plr->SendUpdateWorldState(SI_GATHERED_H,0);
+    plr->SendUpdateWorldState(SI_SILITHYST_MAX,0);
+}
+
+void OutdoorPvPSI::UpdateWorldState()
+{
+    SendUpdateWorldState(SI_GATHERED_A,m_Gathered_A);
+    SendUpdateWorldState(SI_GATHERED_H,m_Gathered_H);
+    SendUpdateWorldState(SI_SILITHYST_MAX,SI_MAX_RESOURCES);
+}
+
+bool OutdoorPvPSI::SetupOutdoorPvP()
+{
+    for (int i = 0; i < OutdoorPvPSIBuffZonesNum; ++i)
+        RegisterZone(OutdoorPvPSIBuffZones[i]);
+    return true;
+}
+
+bool OutdoorPvPSI::Update(uint32 diff)
+{
+    return false;
+}
+
+void OutdoorPvPSI::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr->GetTeam() == m_LastController)
+        plr->CastSpell(plr,SI_CENARION_FAVOR,true);
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPSI::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr->RemoveAurasDueToSpell(SI_CENARION_FAVOR);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+bool OutdoorPvPSI::HandleAreaTrigger(Player *plr, uint32 trigger)
+{
+    switch(trigger)
+    {
+    case SI_AREATRIGGER_A:
+        if(plr->GetTeam() == ALLIANCE && plr->HasAura(SI_SILITHYST_FLAG))
+        {
+            // remove aura
+            plr->RemoveAurasDueToSpell(SI_SILITHYST_FLAG);
+            ++ m_Gathered_A;
+            if(m_Gathered_A >= SI_MAX_RESOURCES)
+            {
+                TeamApplyBuff(TEAM_ALLIANCE, SI_CENARION_FAVOR);
+                sWorld.SendZoneText(OutdoorPvPSIBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_SI_CAPTURE_A));
+                m_LastController = ALLIANCE;
+                m_Gathered_A = 0;
+                m_Gathered_H = 0;
+            }
+            UpdateWorldState();
+            // reward player
+            plr->CastSpell(plr,SI_TRACES_OF_SILITHYST,true);
+            // add 19 honor
+            plr->RewardHonor(NULL,1,19);
+            // add 20 cenarion circle repu
+            plr->GetReputationMgr().ModifyReputation(sFactionStore.LookupEntry(609),20);
+            // complete quest
+            plr->KilledMonsterCredit(SI_TURNIN_QUEST_CM_A,0);
+        }
+        return true;
+    case SI_AREATRIGGER_H:
+        if(plr->GetTeam() == HORDE && plr->HasAura(SI_SILITHYST_FLAG))
+        {
+            // remove aura
+            plr->RemoveAurasDueToSpell(SI_SILITHYST_FLAG);
+            ++ m_Gathered_H;
+            if(m_Gathered_H >= SI_MAX_RESOURCES)
+            {
+                TeamApplyBuff(TEAM_HORDE, SI_CENARION_FAVOR);
+                sWorld.SendZoneText(OutdoorPvPSIBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_SI_CAPTURE_H));
+                m_LastController = HORDE;
+                m_Gathered_A = 0;
+                m_Gathered_H = 0;
+            }
+            UpdateWorldState();
+            // reward player
+            plr->CastSpell(plr,SI_TRACES_OF_SILITHYST,true);
+            // add 19 honor
+            plr->RewardHonor(NULL,1,19);
+            // add 20 cenarion circle repu
+            plr->GetReputationMgr().ModifyReputation(sFactionStore.LookupEntry(609),20);
+            // complete quest
+            plr->KilledMonsterCredit(SI_TURNIN_QUEST_CM_H,0);
+        }
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPSI::HandleDropFlag(Player *plr, uint32 spellId)
+{
+    if(spellId == SI_SILITHYST_FLAG)
+    {
+        // if it was dropped away from the player's turn-in point, then create a silithyst mound, if it was dropped near the areatrigger, then it was dispelled by the outdoorpvp, so do nothing
+        switch(plr->GetTeam())
+        {
+        case ALLIANCE:
+            {
+                AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(SI_AREATRIGGER_A);
+                if(atEntry)
+                {
+                    // 5.0f is safe-distance
+                    if(plr->GetDistance(atEntry->x,atEntry->y,atEntry->z) > 5.0f + atEntry->radius)
+                    {
+                        // he dropped it further, summon mound
+                        GameObject * go = new GameObject;
+                        Map * map = plr->GetMap();
+                        if(!map)
+                        {
+                            delete go;
+                            return true;
+                        }
+
+                        if(!go->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT),SI_SILITHYST_MOUND, map, plr->GetPhaseMask(), plr->GetPositionX(),plr->GetPositionY(),plr->GetPositionZ(),plr->GetOrientation(),0,0,0,0,100,GO_STATE_READY))
+                        {
+                            delete go;
+                        }
+                        else
+                        {
+                            go->SetRespawnTime(0);
+                            map->Add(go);
+                        }
+                    }
+                }
+            }
+            break;
+        case HORDE:
+            {
+                AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(SI_AREATRIGGER_H);
+                if(atEntry)
+                {
+                    // 5.0f is safe-distance
+                    if(plr->GetDistance(atEntry->x,atEntry->y,atEntry->z) > 5.0f + atEntry->radius)
+                    {
+                        // he dropped it further, summon mound
+                        GameObject * go = new GameObject;
+                        Map * map = plr->GetMap();
+                        if(!map)
+                        {
+                          delete go;
+                          return true;
+                          }
+                        if(!go->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT),SI_SILITHYST_MOUND, map, plr->GetPhaseMask() ,plr->GetPositionX(),plr->GetPositionY(),plr->GetPositionZ(),plr->GetOrientation(),0,0,0,0,100,GO_STATE_READY))
+                        {
+                            delete go;
+                        }
+                        else
+                        {
+                            go->SetRespawnTime(0);
+                            map->Add(go);
+                        }
+                    }
+                }
+            }
+            break;
+        }
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPSI::HandleCustomSpell(Player *plr, uint32 spellId, GameObject *go)
+{
+    if(!go || spellId != SI_SILITHYST_FLAG_GO_SPELL)
+        return false;
+    plr->CastSpell(plr,SI_SILITHYST_FLAG,true);
+    if(go->GetGOInfo()->id == SI_SILITHYST_MOUND)
+    {
+        // despawn go
+        go->SetRespawnTime(0);
+        go->Delete();
+    }
+    return true;
+}
+
diff --git a/Core/src/game/OutdoorPvPSI.h b/Core/src/game/OutdoorPvPSI.h
new file mode 100644
index 0000000..29ed726
--- /dev/null
+++ b/Core/src/game/OutdoorPvPSI.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_SI_
+#define OUTDOOR_PVP_SI_
+
+#include "OutdoorPvPImpl.h"
+
+enum OutdoorPvPSISpells
+{
+    SI_SILITHYST_FLAG_GO_SPELL = 29518,
+    SI_SILITHYST_FLAG = 29519,
+    SI_TRACES_OF_SILITHYST = 29534,
+    SI_CENARION_FAVOR = 30754
+};
+
+const uint32 SI_MAX_RESOURCES = 200;
+
+const uint32 OutdoorPvPSIBuffZonesNum = 3;
+
+const uint32 OutdoorPvPSIBuffZones[OutdoorPvPSIBuffZonesNum] = { 1377, 3428, 3429 };
+
+const uint32 SI_AREATRIGGER_H = 4168;
+
+const uint32 SI_AREATRIGGER_A = 4162;
+
+const uint32 SI_TURNIN_QUEST_CM_A = 17090;
+
+const uint32 SI_TURNIN_QUEST_CM_H = 18199;
+
+const uint32 SI_SILITHYST_MOUND = 181597;
+
+enum SI_WorldStates{
+    SI_GATHERED_A = 2313,
+    SI_GATHERED_H = 2314,
+    SI_SILITHYST_MAX = 2317
+};
+
+class OutdoorPvPSI : public OutdoorPvP
+{
+public:
+    OutdoorPvPSI();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    bool HandleAreaTrigger(Player * plr, uint32 trigger);
+    bool HandleDropFlag(Player * plr, uint32 spellId);
+    bool HandleCustomSpell(Player * plr, uint32 spellId, GameObject *go);
+    void UpdateWorldState();
+private:
+    uint32 m_Gathered_A;
+    uint32 m_Gathered_H;
+    uint32 m_LastController;
+};
+
+#endif
+
diff --git a/Core/src/game/OutdoorPvPTF.cpp b/Core/src/game/OutdoorPvPTF.cpp
new file mode 100644
index 0000000..1bf4158
--- /dev/null
+++ b/Core/src/game/OutdoorPvPTF.cpp
@@ -0,0 +1,308 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPTF.h"
+#include "OutdoorPvPMgr.h"
+#include "WorldPacket.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPTF::OutdoorPvPTF()
+{
+    m_TypeId = OUTDOOR_PVP_TF;
+}
+
+OPvPCapturePointTF::OPvPCapturePointTF(OutdoorPvP *pvp, OutdoorPvPTF_TowerType type)
+: OPvPCapturePoint(pvp), m_TowerType(type), m_TowerState(TF_TOWERSTATE_N)
+{
+    SetCapturePointData(TFCapturePoints[type].entry,TFCapturePoints[type].map,TFCapturePoints[type].x,TFCapturePoints[type].y,TFCapturePoints[type].z,TFCapturePoints[type].o,TFCapturePoints[type].rot0,TFCapturePoints[type].rot1,TFCapturePoints[type].rot2,TFCapturePoints[type].rot3);
+}
+
+void OPvPCapturePointTF::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(TFTowerWorldStates[m_TowerType].n) << uint32(bool(m_TowerState & TF_TOWERSTATE_N));
+    data << uint32(TFTowerWorldStates[m_TowerType].h) << uint32(bool(m_TowerState & TF_TOWERSTATE_H));
+    data << uint32(TFTowerWorldStates[m_TowerType].a) << uint32(bool(m_TowerState & TF_TOWERSTATE_A));
+}
+
+void OutdoorPvPTF::FillInitialWorldStates(WorldPacket &data)
+{
+    data << TF_UI_TOWER_SLIDER_POS << uint32(50);
+    data << TF_UI_TOWER_SLIDER_N << uint32(100);
+    data << TF_UI_TOWER_SLIDER_DISPLAY << uint32(0);
+
+    data << TF_UI_TOWER_COUNT_H << m_HordeTowersControlled;
+    data << TF_UI_TOWER_COUNT_A << m_AllianceTowersControlled;
+    data << TF_UI_TOWERS_CONTROLLED_DISPLAY << uint32(!m_IsLocked);
+
+    data << TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT << first_digit;
+    data << TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT << second_digit;
+    data << TF_UI_LOCKED_TIME_HOURS << hours_left;
+
+    data << TF_UI_LOCKED_DISPLAY_NEUTRAL << uint32(m_IsLocked && !m_HordeTowersControlled && !m_AllianceTowersControlled);
+    data << TF_UI_LOCKED_DISPLAY_HORDE << uint32(m_IsLocked && (m_HordeTowersControlled > m_AllianceTowersControlled));
+    data << TF_UI_LOCKED_DISPLAY_ALLIANCE << uint32(m_IsLocked && (m_HordeTowersControlled < m_AllianceTowersControlled));
+
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+    {
+        itr->second->FillInitialWorldStates(data);
+    }
+}
+
+void OutdoorPvPTF::SendRemoveWorldStates(Player * plr)
+{
+    plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_POS,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_N,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY,uint32(0));
+
+    plr->SendUpdateWorldState(TF_UI_TOWER_COUNT_H,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_TOWER_COUNT_A,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY,uint32(0));
+
+    plr->SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_LOCKED_TIME_HOURS,uint32(0));
+
+    plr->SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(0));
+
+    for (int i = 0; i < TF_TOWER_NUM; ++i)
+    {
+        plr->SendUpdateWorldState(uint32(TFTowerWorldStates[i].n),uint32(0));
+        plr->SendUpdateWorldState(uint32(TFTowerWorldStates[i].h),uint32(0));
+        plr->SendUpdateWorldState(uint32(TFTowerWorldStates[i].a),uint32(0));
+    }
+}
+
+void OPvPCapturePointTF::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(uint32(TFTowerWorldStates[m_TowerType].n),uint32(bool(m_TowerState & TF_TOWERSTATE_N)));
+    m_PvP->SendUpdateWorldState(uint32(TFTowerWorldStates[m_TowerType].h),uint32(bool(m_TowerState & TF_TOWERSTATE_H)));
+    m_PvP->SendUpdateWorldState(uint32(TFTowerWorldStates[m_TowerType].a),uint32(bool(m_TowerState & TF_TOWERSTATE_A)));
+}
+
+bool OPvPCapturePointTF::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointTF::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPTF::Update(uint32 diff)
+{
+    bool changed = false;
+
+    if(changed = OutdoorPvP::Update(diff))
+    {
+        if(m_AllianceTowersControlled == TF_TOWER_NUM)
+        {
+            TeamApplyBuff(TEAM_ALLIANCE, TF_CAPTURE_BUFF);
+            m_IsLocked = true;
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(1));
+            SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY, uint32(0));
+        }
+        else if(m_HordeTowersControlled == TF_TOWER_NUM)
+        {
+            TeamApplyBuff(TEAM_HORDE, TF_CAPTURE_BUFF);
+            m_IsLocked = true;
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(1));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(0));
+            SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY, uint32(0));
+        }
+        else
+        {
+            TeamCastSpell(TEAM_ALLIANCE, -TF_CAPTURE_BUFF);
+            TeamCastSpell(TEAM_HORDE, -TF_CAPTURE_BUFF);
+        }
+        SendUpdateWorldState(TF_UI_TOWER_COUNT_A, m_AllianceTowersControlled);
+        SendUpdateWorldState(TF_UI_TOWER_COUNT_H, m_HordeTowersControlled);
+    }
+    if(m_IsLocked)
+    {
+        // lock timer is down, release lock
+        if(m_LockTimer < diff)
+        {
+            m_LockTimer = TF_LOCK_TIME;
+            m_LockTimerUpdate = 0;
+            m_IsLocked = false;
+            SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY, uint32(1));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(0));
+        }
+        else
+        {
+            // worldstateui update timer is down, update ui with new time data
+            if(m_LockTimerUpdate < diff)
+            {
+                m_LockTimerUpdate = TF_LOCK_TIME_UPDATE;
+                uint32 minutes_left = m_LockTimer / 60000;
+                hours_left = minutes_left / 60;
+                minutes_left -= hours_left * 60;
+                second_digit = minutes_left % 10;
+                first_digit = minutes_left / 10;
+
+                SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT,first_digit);
+                SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT,second_digit);
+                SendUpdateWorldState(TF_UI_LOCKED_TIME_HOURS,hours_left);
+            } else m_LockTimerUpdate -= diff;
+            m_LockTimer -= diff;
+        }
+    }
+    return changed;
+}
+
+void OutdoorPvPTF::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        if(m_AllianceTowersControlled >= TF_TOWER_NUM)
+            plr->CastSpell(plr,TF_CAPTURE_BUFF,true);
+    }
+    else
+    {
+        if(m_HordeTowersControlled >= TF_TOWER_NUM)
+            plr->CastSpell(plr,TF_CAPTURE_BUFF,true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPTF::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr->RemoveAurasDueToSpell(TF_CAPTURE_BUFF);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+bool OutdoorPvPTF::SetupOutdoorPvP()
+{
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+
+    m_IsLocked = false;
+    m_LockTimer = TF_LOCK_TIME;
+    m_LockTimerUpdate = 0;
+    hours_left = 6;
+    second_digit = 0;
+    first_digit = 0;
+
+    // add the zones affected by the pvp buff
+    for (int i = 0; i < OutdoorPvPTFBuffZonesNum; ++i)
+        RegisterZone(OutdoorPvPTFBuffZones[i]);
+
+    AddCapturePoint(new OPvPCapturePointTF(this,TF_TOWER_NW));
+    AddCapturePoint(new OPvPCapturePointTF(this,TF_TOWER_N));
+    AddCapturePoint(new OPvPCapturePointTF(this,TF_TOWER_NE));
+    AddCapturePoint(new OPvPCapturePointTF(this,TF_TOWER_SE));
+    AddCapturePoint(new OPvPCapturePointTF(this,TF_TOWER_S));
+
+    return true;
+}
+
+bool OPvPCapturePointTF::Update(uint32 diff)
+{
+    // can update even in locked state if gathers the controlling faction
+    bool canupdate = ((((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled > 0) && m_activePlayers[0].size() > m_activePlayers[1].size()) ||
+            ((((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled > 0) && m_activePlayers[0].size() < m_activePlayers[1].size());
+    // if gathers the other faction, then only update if the pvp is unlocked
+    canupdate = canupdate || !((OutdoorPvPTF*)m_PvP)->m_IsLocked;
+    return canupdate && OPvPCapturePoint::Update(diff);
+}
+
+void OPvPCapturePointTF::ChangeState()
+{
+    // if changing from controlling alliance to horde
+    if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+    {
+        if(((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled)
+            ((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled--;
+        sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_TF_LOOSE_A));
+    }
+    // if changing from controlling horde to alliance
+    else if ( m_OldState == OBJECTIVESTATE_HORDE )
+    {
+        if(((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled)
+            ((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled--;
+        sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_TF_LOOSE_H));
+    }
+
+    uint32 artkit = 21;
+
+    switch(m_State)
+    {
+    case OBJECTIVESTATE_ALLIANCE:
+        m_TowerState = TF_TOWERSTATE_A;
+        artkit = 2;
+        if(((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled<TF_TOWER_NUM)
+            ((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled++;
+        sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_TF_CAPTURE_A));
+        break;
+    case OBJECTIVESTATE_HORDE:
+        m_TowerState = TF_TOWERSTATE_H;
+        artkit = 1;
+        if(((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled<TF_TOWER_NUM)
+            ((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled++;
+        sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_TF_CAPTURE_H));
+        break;
+    case OBJECTIVESTATE_NEUTRAL:
+    case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+    case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+    case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+    case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+        m_TowerState = TF_TOWERSTATE_N;
+        break;
+    }
+
+    GameObject * flag = ObjectAccessor::GetGameObjectInWorld(m_capturePointGUID);
+    if(flag)
+    {
+        flag->SetGoArtKit(artkit);
+    }
+
+    UpdateTowerState();
+}
+
+void OPvPCapturePointTF::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(TF_UI_TOWER_SLIDER_POS, phase);
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(TF_UI_TOWER_SLIDER_N, m_neutralValuePct);
+}
+
diff --git a/Core/src/game/OutdoorPvPTF.h b/Core/src/game/OutdoorPvPTF.h
new file mode 100644
index 0000000..d84a56b
--- /dev/null
+++ b/Core/src/game/OutdoorPvPTF.h
@@ -0,0 +1,117 @@
+#ifndef OUTDOOR_PVP_TF_
+#define OUTDOOR_PVP_TF_
+
+#include "OutdoorPvPImpl.h"
+
+const uint32 OutdoorPvPTFBuffZonesNum = 5;
+
+const uint32 OutdoorPvPTFBuffZones[OutdoorPvPTFBuffZonesNum] = { 3519 /*Terokkar Forest*/, 3791 /*Sethekk Halls*/, 3789 /*Shadow Labyrinth*/, 3792 /*Mana-Tombs*/, 3790 /*Auchenai Crypts*/ };
+
+// locked for 6 hours after capture
+const uint32 TF_LOCK_TIME = 3600 * 6 * 1000;
+// update lock timer every 1/4 minute (overkill, but this way it's sure the timer won't "jump" 2 minutes at once.)
+const uint32 TF_LOCK_TIME_UPDATE = 15000;
+
+// blessing of auchindoun
+#define TF_CAPTURE_BUFF 33377
+
+const uint32 TF_ALLY_QUEST = 11505;
+const uint32 TF_HORDE_QUEST = 11506;
+
+enum OutdoorPvPTF_TowerType{
+    TF_TOWER_NW = 0,
+    TF_TOWER_N,
+    TF_TOWER_NE,
+    TF_TOWER_SE,
+    TF_TOWER_S,
+    TF_TOWER_NUM
+};
+
+const go_type TFCapturePoints[TF_TOWER_NUM] = {
+    {183104,530,-3081.65f,5335.03f,17.1853f,-2.14675f,0,0,0.878817f,-0.477159f},
+    {183411,530,-2939.9f,4788.73f,18.987f,2.77507f,0,0,0.983255f,0.182236f},
+    {183412,530,-3174.94f,4440.97f,16.2281f,1.86750f,0,0.803857f,0.594823f},
+    {183413,530,-3603.31f,4529.15f,20.9077f,0.994838f,0,0,0.477159f,0.878817f},
+    {183414,530,-3812.37f,4899.3f,17.7249f,0.087266f,0,0,0.043619f,0.999048f}
+};
+
+struct tf_tower_world_state{
+    uint32 n;
+    uint32 h;
+    uint32 a;
+};
+
+const tf_tower_world_state TFTowerWorldStates[TF_TOWER_NUM] = {
+    {0xa79,0xa7a,0xa7b},
+    {0xa7e,0xa7d,0xa7c},
+    {0xa82,0xa81,0xa80},
+    {0xa88,0xa87,0xa86},
+    {0xa85,0xa84,0xa83}
+};
+
+const uint32 TFTowerPlayerEnterEvents[TF_TOWER_NUM] = {12226, 12497, 12486, 12499, 12501};
+
+const uint32 TFTowerPlayerLeaveEvents[TF_TOWER_NUM] = {12225, 12496, 12487, 12498, 12500};
+
+enum TFWorldStates{
+    TF_UI_TOWER_SLIDER_POS = 0xa41,
+    TF_UI_TOWER_SLIDER_N = 0xa40,
+    TF_UI_TOWER_SLIDER_DISPLAY = 0xa3f,
+
+    TF_UI_TOWER_COUNT_H = 0xa3e,
+    TF_UI_TOWER_COUNT_A = 0xa3d,
+    TF_UI_TOWERS_CONTROLLED_DISPLAY = 0xa3c,
+
+    TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT = 0x9d0,
+    TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT = 0x9ce,
+    TF_UI_LOCKED_TIME_HOURS = 0x9cd,
+    TF_UI_LOCKED_DISPLAY_NEUTRAL = 0x9cc,
+    TF_UI_LOCKED_DISPLAY_HORDE = 0xad0,
+    TF_UI_LOCKED_DISPLAY_ALLIANCE = 0xacf
+};
+
+enum TFTowerStates {
+    TF_TOWERSTATE_N = 1,
+    TF_TOWERSTATE_H = 2,
+    TF_TOWERSTATE_A = 4
+};
+
+class OPvPCapturePointTF : public OPvPCapturePoint
+{
+public:
+    OPvPCapturePointTF(OutdoorPvP * pvp, OutdoorPvPTF_TowerType type);
+    bool Update(uint32 diff);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    void UpdateTowerState();
+protected:
+    OutdoorPvPTF_TowerType m_TowerType;
+    uint32 m_TowerState;
+};
+
+class OutdoorPvPTF : public OutdoorPvP
+{
+friend class OPvPCapturePointTF;
+public:
+    OutdoorPvPTF();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+private:
+    bool m_IsLocked;
+    uint32 m_LockTimer;
+    uint32 m_LockTimerUpdate;
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+    uint32 hours_left, second_digit, first_digit;
+};
+
+#endif
+
diff --git a/Core/src/game/OutdoorPvPZM.cpp b/Core/src/game/OutdoorPvPZM.cpp
new file mode 100644
index 0000000..33aaede
--- /dev/null
+++ b/Core/src/game/OutdoorPvPZM.cpp
@@ -0,0 +1,423 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPZM.h"
+#include "ObjectMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "Player.h"
+#include "Creature.h"
+#include "ObjectAccessor.h"
+#include "WorldPacket.h"
+#include "GossipDef.h"
+#include "World.h"
+
+OPvPCapturePointZM_Beacon::OPvPCapturePointZM_Beacon(OutdoorPvP *pvp, ZM_BeaconType type)
+: OPvPCapturePoint(pvp), m_TowerType(type), m_TowerState(ZM_TOWERSTATE_N)
+{
+    SetCapturePointData(ZMCapturePoints[type].entry,ZMCapturePoints[type].map,ZMCapturePoints[type].x,ZMCapturePoints[type].y,ZMCapturePoints[type].z,ZMCapturePoints[type].o,ZMCapturePoints[type].rot0,ZMCapturePoints[type].rot1,ZMCapturePoints[type].rot2,ZMCapturePoints[type].rot3);
+}
+
+void OPvPCapturePointZM_Beacon::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(ZMBeaconInfo[m_TowerType].ui_tower_n) << uint32(bool(m_TowerState & ZM_TOWERSTATE_N));
+    data << uint32(ZMBeaconInfo[m_TowerType].map_tower_n) << uint32(bool(m_TowerState & ZM_TOWERSTATE_N));
+    data << uint32(ZMBeaconInfo[m_TowerType].ui_tower_a) << uint32(bool(m_TowerState & ZM_TOWERSTATE_A));
+    data << uint32(ZMBeaconInfo[m_TowerType].map_tower_a) << uint32(bool(m_TowerState & ZM_TOWERSTATE_A));
+    data << uint32(ZMBeaconInfo[m_TowerType].ui_tower_h) << uint32(bool(m_TowerState & ZM_TOWERSTATE_H));
+    data << uint32(ZMBeaconInfo[m_TowerType].map_tower_h) << uint32(bool(m_TowerState & ZM_TOWERSTATE_H));
+}
+
+void OPvPCapturePointZM_Beacon::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].ui_tower_n),uint32(bool(m_TowerState & ZM_TOWERSTATE_N)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].map_tower_n),uint32(bool(m_TowerState & ZM_TOWERSTATE_N)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].ui_tower_a),uint32(bool(m_TowerState & ZM_TOWERSTATE_A)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].map_tower_a),uint32(bool(m_TowerState & ZM_TOWERSTATE_A)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].ui_tower_h),uint32(bool(m_TowerState & ZM_TOWERSTATE_H)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].map_tower_h),uint32(bool(m_TowerState & ZM_TOWERSTATE_H)));
+}
+
+bool OPvPCapturePointZM_Beacon::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_disp, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr->SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_pos, phase);
+        plr->SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_n, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointZM_Beacon::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_disp, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+void OPvPCapturePointZM_Beacon::ChangeState()
+{
+    // if changing from controlling alliance to horde
+    if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+    {
+        if(((OutdoorPvPZM*)m_PvP)->m_AllianceTowersControlled)
+            ((OutdoorPvPZM*)m_PvP)->m_AllianceTowersControlled--;
+        sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(ZMBeaconLooseA[m_TowerType]));
+    }
+    // if changing from controlling horde to alliance
+    else if ( m_OldState == OBJECTIVESTATE_HORDE )
+    {
+        if(((OutdoorPvPZM*)m_PvP)->m_HordeTowersControlled)
+            ((OutdoorPvPZM*)m_PvP)->m_HordeTowersControlled--;
+        sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(ZMBeaconLooseH[m_TowerType]));
+    }
+
+    switch(m_State)
+    {
+        case OBJECTIVESTATE_ALLIANCE:
+            m_TowerState = ZM_TOWERSTATE_A;
+            if(((OutdoorPvPZM*)m_PvP)->m_AllianceTowersControlled<ZM_NUM_BEACONS)
+                ((OutdoorPvPZM*)m_PvP)->m_AllianceTowersControlled++;
+            sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(ZMBeaconCaptureA[m_TowerType]));
+            break;
+        case OBJECTIVESTATE_HORDE:
+            m_TowerState = ZM_TOWERSTATE_H;
+            if(((OutdoorPvPZM*)m_PvP)->m_HordeTowersControlled<ZM_NUM_BEACONS)
+                ((OutdoorPvPZM*)m_PvP)->m_HordeTowersControlled++;
+            sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(ZMBeaconCaptureH[m_TowerType]));
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            m_TowerState = ZM_TOWERSTATE_N;
+            break;
+    }
+
+    UpdateTowerState();
+}
+
+void OPvPCapturePointZM_Beacon::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_disp, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_pos, phase);
+    SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_n, m_neutralValuePct);
+}
+
+bool OutdoorPvPZM::Update(uint32 diff)
+{
+    bool changed = false;
+    if(changed = OutdoorPvP::Update(diff))
+    {
+        if(m_AllianceTowersControlled == ZM_NUM_BEACONS)
+            m_GraveYard->SetBeaconState(ALLIANCE);
+        else if(m_HordeTowersControlled == ZM_NUM_BEACONS)
+            m_GraveYard->SetBeaconState(HORDE);
+        else
+            m_GraveYard->SetBeaconState(0);
+    }
+    return changed;
+}
+
+void OutdoorPvPZM::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        if(m_GraveYard->m_GraveYardState & ZM_GRAVEYARD_A)
+            plr->CastSpell(plr,ZM_CAPTURE_BUFF,true);
+    }
+    else
+    {
+        if(m_GraveYard->m_GraveYardState & ZM_GRAVEYARD_H)
+            plr->CastSpell(plr,ZM_CAPTURE_BUFF,true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPZM::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr->RemoveAurasDueToSpell(ZM_CAPTURE_BUFF);
+    // remove flag
+    plr->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_A);
+    plr->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_H);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+OutdoorPvPZM::OutdoorPvPZM()
+{
+    m_TypeId = OUTDOOR_PVP_ZM;
+    m_GraveYard = NULL;
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+
+}
+
+bool OutdoorPvPZM::SetupOutdoorPvP()
+{
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+
+    // add the zones affected by the pvp buff
+    for (int i = 0; i < OutdoorPvPZMBuffZonesNum; ++i)
+        RegisterZone(OutdoorPvPZMBuffZones[i]);
+
+    AddCapturePoint(new OPvPCapturePointZM_Beacon(this,ZM_BEACON_WEST));
+    AddCapturePoint(new OPvPCapturePointZM_Beacon(this,ZM_BEACON_EAST));
+    m_GraveYard = new OPvPCapturePointZM_GraveYard(this);
+    AddCapturePoint(m_GraveYard); // though the update function isn't used, the handleusego is!
+
+    return true;
+}
+
+void OutdoorPvPZM::HandleKillImpl(Player *plr, Unit * killed)
+{
+    if(killed->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if(plr->GetTeam() == ALLIANCE && ((Player*)killed)->GetTeam() != ALLIANCE)
+        plr->CastSpell(plr,ZM_AlliancePlayerKillReward,true);
+    else if(plr->GetTeam() == HORDE && ((Player*)killed)->GetTeam() != HORDE)
+        plr->CastSpell(plr,ZM_HordePlayerKillReward,true);
+}
+
+bool OPvPCapturePointZM_GraveYard::Update(uint32 diff)
+{
+    bool retval = m_State != m_OldState;
+    m_State = m_OldState;
+    return retval;
+}
+
+int32 OPvPCapturePointZM_GraveYard::HandleOpenGo(Player *plr, uint64 guid)
+{
+    uint32 retval = OPvPCapturePoint::HandleOpenGo(plr, guid);
+    if(retval>=0)
+    {
+        if(plr->HasAura(ZM_BATTLE_STANDARD_A) && m_GraveYardState != ZM_GRAVEYARD_A)
+        {
+            if(m_GraveYardState == ZM_GRAVEYARD_H)
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_ZM_LOOSE_GY_H));
+            m_GraveYardState = ZM_GRAVEYARD_A;
+            DelObject(0);   // only one gotype is used in the whole outdoor pvp, no need to call it a constant
+            AddObject(0,ZM_Banner_A.entry,ZM_Banner_A.map,ZM_Banner_A.x,ZM_Banner_A.y,ZM_Banner_A.z,ZM_Banner_A.o,ZM_Banner_A.rot0,ZM_Banner_A.rot1,ZM_Banner_A.rot2,ZM_Banner_A.rot3);
+            sObjectMgr.RemoveGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, HORDE);          // rem gy
+            sObjectMgr.AddGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, ALLIANCE, false);   // add gy
+            m_PvP->TeamApplyBuff(TEAM_ALLIANCE, ZM_CAPTURE_BUFF);
+            plr->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_A);
+            sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_ZM_CAPTURE_GY_A));
+        }
+        else if(plr->HasAura(ZM_BATTLE_STANDARD_H) && m_GraveYardState != ZM_GRAVEYARD_H)
+        {
+            if(m_GraveYardState == ZM_GRAVEYARD_A)
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_ZM_LOOSE_GY_A));
+            m_GraveYardState = ZM_GRAVEYARD_H;
+            DelObject(0);   // only one gotype is used in the whole outdoor pvp, no need to call it a constant
+            AddObject(0,ZM_Banner_H.entry,ZM_Banner_H.map,ZM_Banner_H.x,ZM_Banner_H.y,ZM_Banner_H.z,ZM_Banner_H.o,ZM_Banner_H.rot0,ZM_Banner_H.rot1,ZM_Banner_H.rot2,ZM_Banner_H.rot3);
+            sObjectMgr.RemoveGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, ALLIANCE);          // rem gy
+            sObjectMgr.AddGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, HORDE, false);   // add gy
+            m_PvP->TeamApplyBuff(TEAM_HORDE, ZM_CAPTURE_BUFF);
+            plr->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_H);
+            sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_ZM_CAPTURE_GY_H));
+        }
+        UpdateTowerState();
+    }
+    return retval;
+}
+
+OPvPCapturePointZM_GraveYard::OPvPCapturePointZM_GraveYard(OutdoorPvP *pvp)
+: OPvPCapturePoint(pvp)
+{
+    m_BothControllingFaction = 0;
+    m_GraveYardState = ZM_GRAVEYARD_N;
+    m_FlagCarrierGUID = 0;
+    // add field scouts here
+    AddCreature(ZM_ALLIANCE_FIELD_SCOUT,ZM_AllianceFieldScout.entry,ZM_AllianceFieldScout.teamval,ZM_AllianceFieldScout.map,ZM_AllianceFieldScout.x,ZM_AllianceFieldScout.y,ZM_AllianceFieldScout.z,ZM_AllianceFieldScout.o);
+    AddCreature(ZM_HORDE_FIELD_SCOUT,ZM_HordeFieldScout.entry,ZM_HordeFieldScout.teamval,ZM_HordeFieldScout.map,ZM_HordeFieldScout.x,ZM_HordeFieldScout.y,ZM_HordeFieldScout.z,ZM_HordeFieldScout.o);
+    // add neutral banner
+    AddObject(0,ZM_Banner_N.entry,ZM_Banner_N.map,ZM_Banner_N.x,ZM_Banner_N.y,ZM_Banner_N.z,ZM_Banner_N.o,ZM_Banner_N.rot0,ZM_Banner_N.rot1,ZM_Banner_N.rot2,ZM_Banner_N.rot3);
+}
+
+void OPvPCapturePointZM_GraveYard::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(ZM_MAP_GRAVEYARD_N,uint32(bool(m_GraveYardState & ZM_GRAVEYARD_N)));
+    m_PvP->SendUpdateWorldState(ZM_MAP_GRAVEYARD_H,uint32(bool(m_GraveYardState & ZM_GRAVEYARD_H)));
+    m_PvP->SendUpdateWorldState(ZM_MAP_GRAVEYARD_A,uint32(bool(m_GraveYardState & ZM_GRAVEYARD_A)));
+
+    m_PvP->SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_READY,uint32(m_BothControllingFaction == ALLIANCE));
+    m_PvP->SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_NOT_READY,uint32(m_BothControllingFaction != ALLIANCE));
+    m_PvP->SendUpdateWorldState(ZM_MAP_HORDE_FLAG_READY,uint32(m_BothControllingFaction == HORDE));
+    m_PvP->SendUpdateWorldState(ZM_MAP_HORDE_FLAG_NOT_READY,uint32(m_BothControllingFaction != HORDE));
+}
+
+void OPvPCapturePointZM_GraveYard::FillInitialWorldStates(WorldPacket &data)
+{
+    data << ZM_MAP_GRAVEYARD_N  << uint32(bool(m_GraveYardState & ZM_GRAVEYARD_N));
+    data << ZM_MAP_GRAVEYARD_H  << uint32(bool(m_GraveYardState & ZM_GRAVEYARD_H));
+    data << ZM_MAP_GRAVEYARD_A  << uint32(bool(m_GraveYardState & ZM_GRAVEYARD_A));
+
+    data << ZM_MAP_ALLIANCE_FLAG_READY  << uint32(m_BothControllingFaction == ALLIANCE);
+    data << ZM_MAP_ALLIANCE_FLAG_NOT_READY  << uint32(m_BothControllingFaction != ALLIANCE);
+    data << ZM_MAP_HORDE_FLAG_READY  << uint32(m_BothControllingFaction == HORDE);
+    data << ZM_MAP_HORDE_FLAG_NOT_READY  << uint32(m_BothControllingFaction != HORDE);
+}
+
+void OPvPCapturePointZM_GraveYard::SetBeaconState(uint32 controlling_faction)
+{
+    // nothing to do here
+    if(m_BothControllingFaction == controlling_faction)
+        return;
+    m_BothControllingFaction = controlling_faction;
+
+    switch(controlling_faction)
+    {
+    case ALLIANCE:
+        // if ally already controls the gy and taken back both beacons, return, nothing to do for us
+        if(m_GraveYardState & ZM_GRAVEYARD_A)
+            return;
+        // ally doesn't control the gy, but controls the side beacons -> add gossip option, add neutral banner
+        break;
+    case HORDE:
+        // if horde already controls the gy and taken back both beacons, return, nothing to do for us
+        if(m_GraveYardState & ZM_GRAVEYARD_H)
+            return;
+        // horde doesn't control the gy, but controls the side beacons -> add gossip option, add neutral banner
+        break;
+    default:
+        // if the graveyard is not neutral, then leave it that way
+        // if the graveyard is neutral, then we have to dispel the buff from the flag carrier
+        if(m_GraveYardState & ZM_GRAVEYARD_N)
+        {
+            // gy was neutral, thus neutral banner was spawned, it is possible that someone was taking the flag to the gy
+            if(m_FlagCarrierGUID)
+            {
+                // remove flag from carrier, reset flag carrier guid
+                Player * p = sObjectMgr.GetPlayer(m_FlagCarrierGUID);
+                if(p)
+                {
+                   p->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_A);
+                   p->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_H);
+                }
+                m_FlagCarrierGUID = 0;
+            }
+        }
+        break;
+    }
+    // send worldstateupdate
+    UpdateTowerState();
+}
+
+bool OPvPCapturePointZM_GraveYard::CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso)
+{
+    uint64 guid = c->GetGUID();
+    std::map<uint64,uint32>::iterator itr = m_CreatureTypes.find(guid);
+    if(itr != m_CreatureTypes.end())
+    {
+        if(itr->second == ZM_ALLIANCE_FIELD_SCOUT && plr->GetTeam() == ALLIANCE && m_BothControllingFaction == ALLIANCE && !m_FlagCarrierGUID && m_GraveYardState != ZM_GRAVEYARD_A)
+            return true;
+        else if(itr->second == ZM_HORDE_FIELD_SCOUT && plr->GetTeam() == HORDE && m_BothControllingFaction == HORDE && !m_FlagCarrierGUID && m_GraveYardState != ZM_GRAVEYARD_H)
+            return true;
+    }
+    return false;
+}
+
+bool OPvPCapturePointZM_GraveYard::HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid)
+{
+    std::map<uint64,uint32>::iterator itr = m_CreatureTypes.find(guid);
+    if(itr != m_CreatureTypes.end())
+    {
+        Creature * cr = ObjectAccessor::GetCreatureInWorld(guid);
+        if(!cr)
+            return true;
+        // if the flag is already taken, then return
+        if(m_FlagCarrierGUID)
+            return true;
+        if(itr->second == ZM_ALLIANCE_FIELD_SCOUT)
+        {
+            cr->CastSpell(plr,ZM_BATTLE_STANDARD_A,true);
+            m_FlagCarrierGUID = plr->GetGUID();
+        }
+        else if(itr->second == ZM_HORDE_FIELD_SCOUT)
+        {
+            cr->CastSpell(plr,ZM_BATTLE_STANDARD_H,true);
+            m_FlagCarrierGUID = plr->GetGUID();
+        }
+        UpdateTowerState();
+        plr->PlayerTalkClass->CloseGossip();
+        return true;
+    }
+    return false;
+}
+
+bool OPvPCapturePointZM_GraveYard::HandleDropFlag(Player * plr, uint32 spellId)
+{
+    switch(spellId)
+    {
+    case ZM_BATTLE_STANDARD_A:
+        m_FlagCarrierGUID = 0;
+        return true;
+    case ZM_BATTLE_STANDARD_H:
+        m_FlagCarrierGUID = 0;
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPZM::FillInitialWorldStates(WorldPacket &data)
+{
+    data << ZM_WORLDSTATE_UNK_1 << uint32(1);
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+    {
+        itr->second->FillInitialWorldStates(data);
+    }
+}
+
+void OutdoorPvPZM::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_N_W,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_POS_W,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_DISPLAY_W,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_N_E,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_POS_E,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_DISPLAY_E,0);
+    plr->SendUpdateWorldState(ZM_WORLDSTATE_UNK_1,1);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_EAST_N,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_EAST_H,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_EAST_A,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_WEST_N,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_WEST_H,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_WEST_A,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_EAST_N,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_EAST_H,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_EAST_A,0);
+    plr->SendUpdateWorldState(ZM_MAP_GRAVEYARD_H,0);
+    plr->SendUpdateWorldState(ZM_MAP_GRAVEYARD_A,0);
+    plr->SendUpdateWorldState(ZM_MAP_GRAVEYARD_N,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_WEST_N,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_WEST_H,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_WEST_A,0);
+    plr->SendUpdateWorldState(ZM_MAP_HORDE_FLAG_READY,0);
+    plr->SendUpdateWorldState(ZM_MAP_HORDE_FLAG_NOT_READY,0);
+    plr->SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_NOT_READY,0);
+    plr->SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_READY,0);
+}
+
diff --git a/Core/src/game/OutdoorPvPZM.h b/Core/src/game/OutdoorPvPZM.h
new file mode 100644
index 0000000..a726f07
--- /dev/null
+++ b/Core/src/game/OutdoorPvPZM.h
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_ZM_
+#define OUTDOOR_PVP_ZM_
+
+#include "OutdoorPvPImpl.h"
+#include "Language.h"
+
+const uint32 OutdoorPvPZMBuffZonesNum = 5;
+// the buff is cast in these zones
+const uint32 OutdoorPvPZMBuffZones[OutdoorPvPZMBuffZonesNum] = {3521,3607,3717,3715,3716};
+// linked when the central tower is controlled
+const uint32 ZM_GRAVEYARD_ZONE = 3521;
+// linked when the central tower is controlled
+const uint32 ZM_GRAVEYARD_ID = 969;
+
+enum OutdoorPvPZMSpells
+{
+    // cast on the players of the controlling faction
+    ZM_CAPTURE_BUFF = 33779,  // twin spire blessing
+    // spell that the field scout casts on the player to carry the flag
+    ZM_BATTLE_STANDARD_A = 32430,
+    // spell that the field scout casts on the player to carry the flag
+    ZM_BATTLE_STANDARD_H = 32431,
+    // token create spell
+    ZM_AlliancePlayerKillReward = 32155,
+    // token create spell
+    ZM_HordePlayerKillReward = 32158
+};
+
+// banners 182527, 182528, 182529, gotta check them ingame
+const go_type ZM_Banner_A = { 182527,530,253.54f,7083.81f,36.7728f,-0.017453f,0,0,0.008727f,-0.999962f };
+const go_type ZM_Banner_H = { 182528,530,253.54f,7083.81f,36.7728f,-0.017453f,0,0,0.008727f,-0.999962f };
+const go_type ZM_Banner_N = { 182529,530,253.54f,7083.81f,36.7728f,-0.017453f,0,0,0.008727f,-0.999962f };
+
+// horde field scout spawn data
+const creature_type ZM_HordeFieldScout = {18564,67,530,296.625f,7818.4f,42.6294f,5.18363f};
+// alliance field scout spawn data
+const creature_type ZM_AllianceFieldScout = {18581,469,530,374.395f,6230.08f,22.8351f,0.593412f};
+
+enum ZMCreatureTypes{
+    ZM_ALLIANCE_FIELD_SCOUT = 0,
+    ZM_HORDE_FIELD_SCOUT,
+    ZM_CREATURE_NUM
+};
+
+struct zm_beacon {
+    uint32 slider_disp;
+    uint32 slider_n;
+    uint32 slider_pos;
+    uint32 ui_tower_n;
+    uint32 ui_tower_h;
+    uint32 ui_tower_a;
+    uint32 map_tower_n;
+    uint32 map_tower_h;
+    uint32 map_tower_a;
+    uint32 event_enter;
+    uint32 event_leave;
+};
+
+enum ZM_BeaconType{
+    ZM_BEACON_EAST = 0,
+    ZM_BEACON_WEST,
+    ZM_NUM_BEACONS
+};
+
+const zm_beacon ZMBeaconInfo[ZM_NUM_BEACONS] = {
+    {2533,2535,2534,2560,2559,2558,2652,2651,2650,11807,11806},
+    {2527,2529,2528,2557,2556,2555,2646,2645,2644,11805,11804}
+};
+
+const uint32 ZMBeaconCaptureA[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_CAPTURE_EAST_A,
+    LANG_OPVP_ZM_CAPTURE_WEST_A
+};
+
+const uint32 ZMBeaconCaptureH[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_CAPTURE_EAST_H,
+    LANG_OPVP_ZM_CAPTURE_WEST_H
+};
+
+const uint32 ZMBeaconLooseA[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_LOOSE_EAST_A,
+    LANG_OPVP_ZM_LOOSE_WEST_A
+};
+
+const uint32 ZMBeaconLooseH[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_LOOSE_EAST_H,
+    LANG_OPVP_ZM_LOOSE_WEST_H
+};
+
+const go_type ZMCapturePoints[ZM_NUM_BEACONS] = {
+    {182523,530,303.243f,6841.36f,40.1245f,-1.58825f,0,0,0.71325f,-0.700909f},
+    {182522,530,336.466f,7340.26f,41.4984f,-1.58825f,0,0,0.71325f,-0.700909f}
+};
+
+enum OutdoorPvPZMWorldStates
+{
+    ZM_UI_TOWER_SLIDER_N_W = 2529,
+    ZM_UI_TOWER_SLIDER_POS_W = 2528,
+    ZM_UI_TOWER_SLIDER_DISPLAY_W = 2527,
+
+    ZM_UI_TOWER_SLIDER_N_E = 2535,
+    ZM_UI_TOWER_SLIDER_POS_E = 2534,
+    ZM_UI_TOWER_SLIDER_DISPLAY_E = 2533,
+
+    ZM_WORLDSTATE_UNK_1 = 2653,
+
+    ZM_UI_TOWER_EAST_N = 2560,
+    ZM_UI_TOWER_EAST_H = 2559,
+    ZM_UI_TOWER_EAST_A = 2558,
+    ZM_UI_TOWER_WEST_N = 2557,
+    ZM_UI_TOWER_WEST_H = 2556,
+    ZM_UI_TOWER_WEST_A = 2555,
+
+    ZM_MAP_TOWER_EAST_N = 2652,
+    ZM_MAP_TOWER_EAST_H = 2651,
+    ZM_MAP_TOWER_EAST_A = 2650,
+    ZM_MAP_GRAVEYARD_H = 2649,
+    ZM_MAP_GRAVEYARD_A = 2648,
+    ZM_MAP_GRAVEYARD_N = 2647,
+    ZM_MAP_TOWER_WEST_N = 2646,
+    ZM_MAP_TOWER_WEST_H = 2645,
+    ZM_MAP_TOWER_WEST_A = 2644,
+
+    ZM_MAP_HORDE_FLAG_READY = 2658,
+    ZM_MAP_HORDE_FLAG_NOT_READY = 2657,
+    ZM_MAP_ALLIANCE_FLAG_NOT_READY = 2656,
+    ZM_MAP_ALLIANCE_FLAG_READY = 2655
+};
+
+enum ZM_TowerStateMask{
+    ZM_TOWERSTATE_N = 1,
+    ZM_TOWERSTATE_A = 2,
+    ZM_TOWERSTATE_H = 4
+};
+
+class OutdoorPvPZM;
+class OPvPCapturePointZM_Beacon : public OPvPCapturePoint
+{
+friend class OutdoorPvPZM;
+public:
+    OPvPCapturePointZM_Beacon(OutdoorPvP * pvp, ZM_BeaconType type);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    void UpdateTowerState();
+protected:
+    ZM_BeaconType m_TowerType;
+    uint32 m_TowerState;
+};
+
+enum ZM_GraveYardState{
+    ZM_GRAVEYARD_N = 1,
+    ZM_GRAVEYARD_A = 2,
+    ZM_GRAVEYARD_H = 4
+};
+
+class OPvPCapturePointZM_GraveYard : public OPvPCapturePoint
+{
+friend class OutdoorPvPZM;
+public:
+    OPvPCapturePointZM_GraveYard(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void ChangeState() {}
+    void FillInitialWorldStates(WorldPacket & data);
+    void UpdateTowerState();
+    int32 HandleOpenGo(Player *plr, uint64 guid);
+    void SetBeaconState(uint32 controlling_team); // not good atm
+    bool HandleGossipOption(Player * plr, uint64 guid, uint32 gossipid);
+    bool HandleDropFlag(Player * plr, uint32 spellId);
+    bool CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso);
+private:
+    uint32 m_GraveYardState;
+protected:
+    uint32 m_BothControllingFaction;
+    uint64 m_FlagCarrierGUID;
+};
+
+class OutdoorPvPZM : public OutdoorPvP
+{
+friend class OPvPCapturePointZM_Beacon;
+public:
+    OutdoorPvPZM();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void HandleKillImpl(Player * plr, Unit * killed);
+private:
+    OPvPCapturePointZM_GraveYard * m_GraveYard;
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+};
+
+// todo: flag carrier death/leave/mount/activitychange should give back the gossip options
+#endif
+
diff --git a/mangos/src/game/Pet.cpp b/Core/src/game/Pet.cpp
index c077d0a..d3f92c3 100644
--- a/mangos/src/game/Pet.cpp
+++ b/Core/src/game/Pet.cpp
@@ -39,7 +39,7 @@ char const* petTypeSuffix[MAX_PET_TYPE] =
 
 Pet::Pet(PetType type) :
 Creature(CREATURE_SUBTYPE_PET), m_removed(false), m_petType(type), m_happinessTimer(7500), m_duration(0), m_resetTalentsCost(0),
-m_bonusdamage(0), m_resetTalentsTime(0), m_usedTalentCount(0), m_auraUpdateMask(0), m_loading(false),
+m_bonusdamage(0), m_resetTalentsTime(0), m_usedTalentCount(0), m_loading(false),
 m_declinedname(NULL), m_petModeFlags(PET_MODE_DEFAULT)
 {
     m_name = "Pet";
@@ -205,6 +205,10 @@ bool Pet::LoadPetFromDB( Player* owner, uint32 petentry, uint32 petnumber, bool
             SetUInt32Value(UNIT_FIELD_BYTES_0, 2048);
             SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
                                                             // this enables popup window (pet dismiss, cancel)
+
+            // DK ghouls have energy
+            if (cinfo->family == CREATURE_FAMILY_GHOUL)
+                setPowerType(POWER_ENERGY);
             break;
         case HUNTER_PET:
             SetUInt32Value(UNIT_FIELD_BYTES_0, 0x02020100);
@@ -335,6 +339,10 @@ bool Pet::LoadPetFromDB( Player* owner, uint32 petentry, uint32 petnumber, bool
         }
     }
 
+    //set last used pet number (for use in BG's)
+    if(owner->GetTypeId() == TYPEID_PLAYER && isControlled() && !isTemporarySummoned() && (getPetType() == SUMMON_PET || getPetType() == HUNTER_PET))
+        ((Player*)owner)->SetLastPetNumber(pet_number);
+
     m_loading = false;
 
     SynchronizeLevelWithOwner();
@@ -470,9 +478,22 @@ void Pet::setDeathState(DeathState s)                       // overwrite virtual
             MapEntry const* mapEntry = sMapStore.LookupEntry(GetMapId());
             if(!mapEntry || (mapEntry->map_type != MAP_ARENA && mapEntry->map_type != MAP_BATTLEGROUND))
                 ModifyPower(POWER_HAPPINESS, -HAPPINESS_LEVEL_SIZE);
+            if( HasSpell(55709) && GetOwner())
+                GetOwner()->CastSpell(GetOwner(), 54114, false);
 
             SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
         }
+        // send cooldown for summon spell if necessary
+        if (Player* p_owner = GetCharmerOrOwnerPlayerOrPlayerItself())
+        {
+            SpellEntry const *spellInfo = sSpellStore.LookupEntry(GetUInt32Value(UNIT_CREATED_BY_SPELL));
+            if (spellInfo && spellInfo->Attributes & SPELL_ATTR_DISABLED_WHILE_ACTIVE)
+                p_owner->SendCooldownEvent(spellInfo);
+            // Raise Dead hack
+            if (spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && spellInfo->SpellFamilyFlags & 0x1000)
+                if (spellInfo = sSpellStore.LookupEntry(46584))
+                    p_owner->SendCooldownEvent(spellInfo);
+        }
     }
     else if(getDeathState()==ALIVE)
     {
@@ -483,7 +504,7 @@ void Pet::setDeathState(DeathState s)                       // overwrite virtual
 
 void Pet::Update(uint32 diff)
 {
-    if(m_removed)                                           // pet already removed, just wait in remove queue, no updates
+    if(m_removed || m_loading)                                           // pet already removed, just wait in remove queue, no updates
         return;
 
     switch( m_deathState )
@@ -948,6 +969,7 @@ bool Pet::InitStatsForLevel(uint32 petlevel, Unit* owner)
 
                 // remove elite bonuses included in DB values
                 SetCreateHealth( uint32(((float(cinfo->maxhealth) / cinfo->maxlevel) / (1 + 2 * cinfo->rank)) * petlevel) );
+                setPowerType(POWER_FOCUS);
 
                 SetCreateStat(STAT_STRENGTH, 22);
                 SetCreateStat(STAT_AGILITY, 22);
@@ -1895,13 +1917,37 @@ void Pet::CastPetAura(PetAura const* aura)
     if(!auraId)
         return;
 
-    if(auraId == 35696)                                       // Demonic Knowledge
+    switch (auraId)
     {
-        int32 basePoints = int32(aura->GetDamage() * (GetStat(STAT_STAMINA) + GetStat(STAT_INTELLECT)) / 100);
-        CastCustomSpell(this, auraId, &basePoints, NULL, NULL, true);
+        case 35696: // Demonic Knowledge
+        {
+            int32 basePoints = int32(aura->GetDamage() * (GetStat(STAT_STAMINA) + GetStat(STAT_INTELLECT)) / 100);
+            CastCustomSpell(this, auraId, &basePoints, NULL, NULL, true);
+            break;
+        }
+        case 54566: // Ravenous Dead
+        {
+            Unit* owner = GetOwner();
+            if (owner)
+            {
+                // We must give x% bonus to base bonus from owner's stamina to ghoul stamina
+                int32 basePoints0 =
+                    int32(owner->GetStat(STAT_STAMINA)*0.3f*(aura->GetDamage()+100.0f)/100.0f
+                    - (GetStat(STAT_STAMINA)-GetCreateStat(STAT_STAMINA)));
+                // We must give x% bonus to base bonus from owner's strength to ghoul strength
+                int32 basePoints1 =
+                    int32(owner->GetStat(STAT_STRENGTH)*0.3f*(aura->GetDamage()+100.0f)/100.0f
+                    - (GetStat(STAT_STRENGTH)-GetCreateStat(STAT_STRENGTH)));
+                CastCustomSpell(this, auraId, &basePoints0, &basePoints1, NULL, true);
+            }
+            break;
+        }
+        default:
+        {
+            CastSpell(this, auraId, true);
+            break;
+        }
     }
-    else
-        CastSpell(this, auraId, true);
 }
 
 struct DoPetLearnSpell
diff --git a/mangos/src/game/Pet.h b/Core/src/game/Pet.h
index efc9ecd..5d7417a 100644
--- a/mangos/src/game/Pet.h
+++ b/Core/src/game/Pet.h
@@ -236,10 +236,6 @@ class Pet : public Creature
         time_t  m_resetTalentsTime;
         uint32  m_usedTalentCount;
 
-        const uint64& GetAuraUpdateMask() const { return m_auraUpdateMask; }
-        void SetAuraUpdateMask(uint8 slot) { m_auraUpdateMask |= (uint64(1) << slot); }
-        void ResetAuraUpdateMask() { m_auraUpdateMask = 0; }
-
         // overwrite Creature function for name localization back to WorldObject version without localization
         const char* GetNameForLocaleIdx(int32 locale_idx) const { return WorldObject::GetNameForLocaleIdx(locale_idx); }
 
@@ -251,7 +247,6 @@ class Pet : public Creature
         PetType m_petType;
         int32   m_duration;                                 // time until unsummon (used mostly for summoned guardians and not used for controlled pets)
         int32   m_bonusdamage;
-        uint64  m_auraUpdateMask;
         bool    m_loading;
 
         DeclinedName *m_declinedname;
diff --git a/mangos/src/game/PetAI.cpp b/Core/src/game/PetAI.cpp
index 3498083..cfdfd21 100644
--- a/mangos/src/game/PetAI.cpp
+++ b/Core/src/game/PetAI.cpp
@@ -62,7 +62,6 @@ void PetAI::MoveInLineOfSight(Unit *u)
             if(m_creature->IsWithinLOSInMap(u))
             {
                 AttackStart(u);
-                u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
             }
         }
     }
@@ -167,7 +166,7 @@ void PetAI::UpdateAI(const uint32 diff)
                     return;
             }
             // not required to be stopped case
-            else if (m_creature->isAttackReady() && m_creature->canReachWithAttack(m_creature->getVictim()))
+            else if (m_creature->isAttackReady() && m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
             {
                 m_creature->AttackerStateUpdate(m_creature->getVictim());
 
@@ -358,6 +357,6 @@ void PetAI::AttackedBy(Unit *attacker)
 {
     //when attacked, fight back in case 1)no victim already AND 2)not set to passive AND 3)not set to stay, unless can it can reach attacker with melee attack anyway
     if(!m_creature->getVictim() && m_creature->GetCharmInfo() && !m_creature->GetCharmInfo()->HasReactState(REACT_PASSIVE) &&
-        (!m_creature->GetCharmInfo()->HasCommandState(COMMAND_STAY) || m_creature->canReachWithAttack(attacker)))
+        (!m_creature->GetCharmInfo()->HasCommandState(COMMAND_STAY) || m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE)))
         AttackStart(attacker);
 }
diff --git a/mangos/src/game/PetHandler.cpp b/Core/src/game/PetHandler.cpp
index e306f80..ece7854 100644
--- a/mangos/src/game/PetHandler.cpp
+++ b/Core/src/game/PetHandler.cpp
@@ -286,7 +286,7 @@ void WorldSession::HandlePetNameQuery( WorldPacket & recv_data )
 
 void WorldSession::SendPetNameQuery( uint64 petguid, uint32 petnumber)
 {
-    Creature* pet = _player->GetMap()->GetCreatureOrPetOrVehicle(petguid);
+    Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*_player, petguid);
     if(!pet || !pet->GetCharmInfo() || pet->GetCharmInfo()->GetPetNumber() != petnumber)
         return;
 
@@ -318,7 +318,12 @@ void WorldSession::HandlePetSetAction( WorldPacket & recv_data )
 
     recv_data >> petguid;
 
-    Creature* pet = _player->GetMap()->GetCreatureOrPetOrVehicle(petguid);
+    // FIXME: charmed case
+    //Pet* pet = ObjectAccessor::Instance().GetPet(petguid);
+    if(ObjectAccessor::FindPlayer(petguid))
+        return;
+
+    Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*_player, petguid);
 
     if(!pet || (pet != _player->GetPet() && pet != _player->GetCharm()))
     {
@@ -472,7 +477,7 @@ void WorldSession::HandlePetRename( WorldPacket & recv_data )
 
         std::wstring wname;
         Utf8toWStr(name, wname);
-        if(!ObjectMgr::CheckDeclinedNames(GetMainPartOfName(wname,0),declinedname))
+        if(!ObjectMgr::CheckDeclinedNames(wname, declinedname))
         {
             SendPetNameInvalid(PET_NAME_DECLENSION_DOESNT_MATCH_BASE_NAME, name, &declinedname);
             return;
@@ -506,7 +511,8 @@ void WorldSession::HandlePetAbandon( WorldPacket & recv_data )
         return;
 
     // pet/charmed
-    if (Creature* pet = _player->GetMap()->GetCreatureOrPetOrVehicle(guid))
+    Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*_player, guid);
+    if(pet)
     {
         if(pet->isPet())
         {
@@ -560,29 +566,32 @@ void WorldSession::HandlePetSpellAutocastOpcode( WorldPacket& recvPacket )
     uint8  state;                                           //1 for on, 0 for off
     recvPacket >> guid >> spellid >> state;
 
-    if(!_player->GetPet() && !_player->GetCharm())
+    if (!_player->GetPet() && !_player->GetCharm())
         return;
 
-    Creature* pet = _player->GetMap()->GetCreatureOrPetOrVehicle(guid);
+    if(ObjectAccessor::FindPlayer(guid))
+        return;
 
-    if(!pet || (pet != _player->GetPet() && pet != _player->GetCharm()))
+    Creature* pet=ObjectAccessor::GetCreatureOrPetOrVehicle(*_player,guid);
+
+    if (!pet || (pet != _player->GetPet() && pet != _player->GetCharm()))
     {
         sLog.outError( "HandlePetSpellAutocastOpcode.Pet %u isn't pet of player %s .", uint32(GUID_LOPART(guid)),GetPlayer()->GetName() );
         return;
     }
 
     // do not add not learned spells/ passive spells
-    if(!pet->HasSpell(spellid) || IsPassiveSpell(spellid))
+    if (!pet->HasSpell(spellid) || IsPassiveSpell(spellid))
         return;
 
     CharmInfo *charmInfo = pet->GetCharmInfo();
-    if(!charmInfo)
+    if (!charmInfo)
     {
         sLog.outError("WorldSession::HandlePetSpellAutocastOpcod: object (GUID: %u TypeId: %u) is considered pet-like but doesn't have a charminfo!", pet->GetGUIDLow(), pet->GetTypeId());
         return;
     }
 
-    if(pet->isCharmed())
+    if (pet->isCharmed())
                                                             //state can be used as boolean
         pet->GetCharmInfo()->ToggleCreatureAutocast(spellid, state);
     else
@@ -594,6 +603,23 @@ void WorldSession::HandlePetSpellAutocastOpcode( WorldPacket& recvPacket )
 void WorldSession::HandlePetCastSpellOpcode( WorldPacket& recvPacket )
 {
     DETAIL_LOG("WORLD: CMSG_PET_CAST_SPELL");
+    recvPacket.hexlike();
+    recvPacket.print_storage();
+
+    //2 - 0 - 0 - 43 - 129 - 0 - 80 - 241 | - 42 - 211 - 253 - 0 | - 0 | - 2 |- 96 - 0 - 0 - 0 | - 0 - 26
+    //- 164 - 59 - 196 - 174 - 98 - 131 | - 194 - 182 - 171 - 218| - 67 - 0 - 48 - 93| - 0 - 196 - 32
+    //- 177| - 242 - 193 - 22 - 110 - 224 - 67 - 203 - 166 | - 68 - 61 - 133 - 1| - 240 - 66 - 1 - 183 |
+    //- 0 - 0 - 0 - 217| - 2 - 43 - 129 - 80 - 241 - 0 - 10 - 0 - 0 - 0 - 0 - 76 - 109 - 175 - 0
+    //- 238 - 115 - 58 - 196 - 20 - 110 - 121 - 194 - 187 - 107 - 217 - 67 - 32 - 44 - 27 - 62 - 217
+    //- 1 - 36 - 129 - 80 - 241 - 0 - 0 - 160 - 64 - 0 - 0 - 160 - 64 - 0 - 0 - 160 - 64 - 192 - 233
+    //- 172 - 62 - 4 - 0 - 0 - 0 - 7 - 230 - 0 - 0 - 0 -
+
+    //5 - 0 - 0 - 43 - 129 - 0 - 80 - 241 | - 85 - 211 - 253 - 0 | - 0 | - 2 | - 96 - 0 - 0 - 0 | - 0 - 69 - 60 - 61
+    //- 196 - 171 - 248 - 107| - 194 - 8 - 236 - 218 | - 67 - 0 - 177 - 11 | - 46 - 196 - 89 - 16 | - 14 - 195
+    //- 5 - 38 - 231 - 67 - 23 - 221 | - 110 - 62 - 15 - 3 | - 240 - 66 -| 1 - 183 | - 0 - 0 - 0 - 217 | - 5 - 43
+    //- 129 - 80 - 241 - 0 - 10 - 0 - 0 - 0 - 0 - 233 - 41 - 203 - 0 - 106 - 207 - 59 - 196 - 179 - 173 - 83
+    //- 194 - 8 - 108 - 217 - 67 - 127 - 153 - 170 - 64 - 217 - 4 - 36 - 129 - 80 - 241 - 0 - 0 - 160 - 64
+    //- 0 - 0 - 160 - 64 - 0 - 0 - 160 - 64 - 7 - 77 - 175 - 64 - 4 - 0 - 0 - 0 - 7 - 195 - 0 - 0 - 0 -
 
     uint64 guid;
     uint32 spellid;
@@ -607,7 +633,10 @@ void WorldSession::HandlePetCastSpellOpcode( WorldPacket& recvPacket )
     if (!_player->GetPet() && !_player->GetCharm())
         return;
 
-    Creature* pet = _player->GetMap()->GetCreatureOrPetOrVehicle(guid);
+    if (GUID_HIPART(guid) == HIGHGUID_PLAYER)
+        return;
+
+    Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*_player,guid);
 
     if (!pet || (pet != _player->GetPet() && pet!= _player->GetCharm()))
     {
@@ -631,9 +660,20 @@ void WorldSession::HandlePetCastSpellOpcode( WorldPacket& recvPacket )
 
     SpellCastTargets targets;
 
+    //float elevation, speed;
+    //uint8 pos1, pos2;
     recvPacket >> targets.ReadForCaster(pet);
+    //recvPacket >> elevation >> speed;
+    //recvPacket >> pos1 >> pos2;
 
     pet->clearUnitState(UNIT_STAT_MOVING);
+    
+    //mask: 96, elevation: 0.167906, speed: 120.002441, pos1: 1, pos: 183
+ 
+    //sLog.outDebug("mask: %u, elevation: %f, speed: %f, pos1: %u, pos: %u", targets.m_targetMask, elevation, speed, pos1, pos2);
+ 
+    sLog.outDebug("guid: %u, sX: %f, sY:%f, sZ: %f", targets.getUnitTargetGUID(),targets.m_srcX,targets.m_srcY,targets.m_srcZ);
+    sLog.outDebug("guid: %u, sX: %f, sY:%f, sZ: %f", targets.getUnitTargetGUID(),targets.m_destX,targets.m_destY,targets.m_destZ);
 
     Spell *spell = new Spell(pet, spellInfo, false);
     spell->m_cast_count = cast_count;                       // probably pending spell cast
diff --git a/mangos/src/game/Player.cpp b/Core/src/game/Player.cpp
index 53706be..9a97e15 100644
--- a/mangos/src/game/Player.cpp
+++ b/Core/src/game/Player.cpp
@@ -47,6 +47,7 @@
 #include "Formulas.h"
 #include "Group.h"
 #include "Guild.h"
+#include "GameEventMgr.h"
 #include "Pet.h"
 #include "Util.h"
 #include "Transports.h"
@@ -54,6 +55,8 @@
 #include "BattleGround.h"
 #include "BattleGroundAV.h"
 #include "BattleGroundMgr.h"
+#include "OutdoorPvP.h"
+#include "OutdoorPvPMgr.h"
 #include "ArenaTeam.h"
 #include "Chat.h"
 #include "Database/DatabaseImpl.h"
@@ -62,6 +65,12 @@
 #include "AchievementMgr.h"
 #include "Mail.h"
 
+// Playerbot mod:
+#include "PlayerbotAI.h"
+#include "PlayerbotMgr.h"
+
+#include "GameEventMgr.h"
+
 #include <cmath>
 
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
@@ -302,113 +311,35 @@ bool SpellModifier::isAffectedOnSpell( SpellEntry const *spell ) const
     return false;
 }
 
-//== TradeData =================================================
-
-TradeData* TradeData::GetTraderData() const
-{
-    return m_trader->GetTradeData();
-}
-
-Item* TradeData::GetItem( TradeSlots slot ) const
-{
-    return !m_items[slot].IsEmpty() ? m_player->GetItemByGuid(m_items[slot]) : NULL;
-}
-
-bool TradeData::HasItem( ObjectGuid item_guid ) const
-{
-    for(int i = 0; i < TRADE_SLOT_COUNT; ++i)
-        if (m_items[i] == item_guid)
-            return true;
-    return false;
-}
-
-
-Item* TradeData::GetSpellCastItem() const
-{
-    return !m_spellCastItem.IsEmpty() ?  m_player->GetItemByGuid(m_spellCastItem) : NULL;
-}
-
-void TradeData::SetItem( TradeSlots slot, Item* item )
-{
-    ObjectGuid itemGuid = item ? item->GetObjectGuid() : ObjectGuid();
-
-    if (m_items[slot] == itemGuid)
-        return;
-
-    m_items[slot] = itemGuid;
-
-    SetAccepted(false);
-    GetTraderData()->SetAccepted(false);
-
-    Update();
-
-    // need remove possible trader spell applied to changed item
-    if (slot == TRADE_SLOT_NONTRADED)
-        GetTraderData()->SetSpell(0);
-
-    // need remove possible player spell applied (possible move reagent)
-    SetSpell(0);
-}
-
-void TradeData::SetSpell( uint32 spell_id, Item* castItem /*= NULL*/ )
-{
-    ObjectGuid itemGuid = castItem ? castItem->GetObjectGuid() : ObjectGuid();
-
-    if (m_spell == spell_id && m_spellCastItem == itemGuid)
-        return;
-
-    m_spell = spell_id;
-    m_spellCastItem = itemGuid;
-
-    SetAccepted(false);
-    GetTraderData()->SetAccepted(false);
-
-    Update(true);                                           // send spell info to item owner
-    Update(false);                                          // send spell info to caster self
-}
-
-void TradeData::SetMoney( uint32 money )
-{
-    if (m_money == money)
-        return;
-
-    m_money = money;
-
-    SetAccepted(false);
-    GetTraderData()->SetAccepted(false);
-
-    Update();
-}
-
-void TradeData::Update( bool for_trader /*= true*/ )
-{
-    if (for_trader)
-        m_trader->GetSession()->SendUpdateTrade(true);      // player state for trader
-    else
-        m_player->GetSession()->SendUpdateTrade(false);     // player state for player
-}
-
-void TradeData::SetAccepted(bool state, bool crosssend /*= false*/)
-{
-    m_accepted = state;
-
-    if (!state)
-    {
-        if (crosssend)
-            m_trader->GetSession()->SendTradeStatus(TRADE_STATUS_BACK_TO_TRADE);
-        else
-            m_player->GetSession()->SendTradeStatus(TRADE_STATUS_BACK_TO_TRADE);
-    }
-}
-
 //== Player ====================================================
 
 UpdateMask Player::updateVisualBits;
 
 Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputationMgr(this)
 {
+    // Jail by WarHead
+    m_jail_guid     = 0;
+    m_jail_char     = "";
+    m_jail_amnestie = false;
+    m_jail_warning  = false;
+    m_jail_isjailed = false;
+    m_jail_amnestietime =0;
+    m_jail_release  = 0;
+    m_jail_times    = 0;
+    m_jail_reason   = "";
+    m_jail_gmacc    = 0;
+    m_jail_gmchar   = "";
+    m_jail_lasttime = "";
+    m_jail_duration = 0;
+    // Jail end
+
+    m_GMLevel = 0;
     m_transport = 0;
 
+    // Playerbot mod:
+    m_playerbotAI = 0;
+    m_playerbotMgr = 0;
+
     m_speakTime = 0;
     m_speakCount = 0;
 
@@ -463,7 +394,6 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
     // group is initialized in the reference constructor
     SetGroupInvite(NULL);
     m_groupUpdateMask = 0;
-    m_auraUpdateMask = 0;
 
     duel = NULL;
 
@@ -489,6 +419,7 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
 
     m_DailyQuestChanged = false;
     m_WeeklyQuestChanged = false;
+    m_FirstBattleground = false;
 
     for (int i=0; i<MAX_TIMERS; ++i)
         m_MirrorTimer[i] = DISABLED_MIRROR_TIMER;
@@ -527,6 +458,7 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
     //returning reagents for temporarily removed pets
     //when dying/logging out
     m_oldpetspell = 0;
+    m_lastpetnumber = 0;
 
     ////////////////////Rest System/////////////////////
     time_inn_enter=0;
@@ -535,6 +467,17 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
     rest_type=REST_TYPE_NO;
     ////////////////////Rest System/////////////////////
 
+    //movement anticheat
+    m_anti_lastmovetime = 0;   //last movement time
+    m_anti_NextLenCheck = 0;
+    m_anti_MovedLen = 0.0f;
+    m_anti_BeginFallZ = INVALID_HEIGHT;
+    m_anti_lastalarmtime = 0;    //last time when alarm generated
+    m_anti_alarmcount = 0;       //alarm counter
+    m_anti_TeleTime = 0;
+    m_CanFly=false;
+    /////////////////////////////////
+
     m_mailsUpdated = false;
     unReadMails = 0;
     m_nextMailDelivereTime = 0;
@@ -548,7 +491,7 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
 
     m_stableSlots = 0;
 
-    /////////////////// Instance System /////////////////////
+    /////////////////// Instance System ////////////////////
 
     m_HomebindTimer = 0;
     m_InstanceValid = true;
@@ -577,6 +520,8 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
     // Honor System
     m_lastHonorUpdateTime = time(NULL);
 
+    m_IsBGRandomWinner = false;
+
     // Player summoning
     m_summon_expire = 0;
     m_summon_mapid = 0;
@@ -585,6 +530,7 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
     m_summon_z = 0.0f;
 
     m_mover = this;
+    m_mover_in_queve = NULL;
 
     m_miniPet = 0;
     m_contestedPvPTimer = 0;
@@ -594,6 +540,9 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
 
     m_lastFallTime = 0;
     m_lastFallZ = 0;
+    m_globalCooldowns.clear();
+
+    m_flytimer = time(NULL);
 }
 
 Player::~Player ()
@@ -636,6 +585,16 @@ Player::~Player ()
 
     delete m_declinedname;
     delete m_runes;
+
+    // Playerbot mod
+    if (m_playerbotAI) {
+        delete m_playerbotAI;
+        m_playerbotAI = 0;
+    }
+    if (m_playerbotMgr) {
+        delete m_playerbotMgr;
+        m_playerbotMgr = 0;
+    }
 }
 
 void Player::CleanupsBeforeDelete()
@@ -659,7 +618,7 @@ bool Player::Create( uint32 guidlow, const std::string& name, uint8 race, uint8
     PlayerInfo const* info = sObjectMgr.GetPlayerInfo(race, class_);
     if(!info)
     {
-        sLog.outError("Player have incorrect race/class pair. Can't be loaded.");
+        DEBUG_LOG("Player have incorrect race/class pair. Can't be loaded.");
         return false;
     }
 
@@ -672,7 +631,7 @@ bool Player::Create( uint32 guidlow, const std::string& name, uint8 race, uint8
     ChrClassesEntry const* cEntry = sChrClassesStore.LookupEntry(class_);
     if(!cEntry)
     {
-        sLog.outError("Class %u not found in DBC (Wrong DBC files?)",class_);
+        DEBUG_LOG("Class %u not found in DBC (Wrong DBC files?)",class_);
         return false;
     }
 
@@ -895,7 +854,7 @@ bool Player::StoreNewItemInBestSlots(uint32 titem_id, uint32 titem_amount)
     }
 
     // item can't be added
-    sLog.outError("STORAGE: Can't equip or store initial item %u for race %u class %u , error msg = %u",titem_id,getRace(),getClass(),msg);
+    DEBUG_LOG("STORAGE: Can't equip or store initial item %u for race %u class %u , error msg = %u",titem_id,getRace(),getClass(),msg);
     return false;
 }
 
@@ -968,6 +927,9 @@ uint32 Player::EnvironmentalDamage(EnviromentalDamage type, uint32 damage)
 
     uint32 final_damage = DealDamage(this, damage, NULL, SELF_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
 
+	if(HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED) && type==DAMAGE_FALL)
+	    final_damage = 0;
+		
     if(!isAlive())
     {
         if(type==DAMAGE_FALL)                               // DealDamage not apply item durability loss at self damage
@@ -1198,11 +1160,95 @@ void Player::Update( uint32 p_time )
         m_nextMailDelivereTime = 0;
     }
 
+    for (std::map<uint32, uint32>::iterator itr = m_globalCooldowns.begin(); itr != m_globalCooldowns.end(); ++itr)
+    {
+        if (itr->second)
+        {
+            if (itr->second > p_time)
+                itr->second -= p_time;
+            else
+                itr->second = 0;
+        }
+    }
+
     //used to implement delayed far teleports
     SetCanDelayTeleport(true);
     Unit::Update( p_time );
     SetCanDelayTeleport(false);
 
+    if (m_jail_isjailed)
+    {
+        time_t localtime;
+        localtime = time(NULL);
+        
+        if (m_jail_release <= localtime)
+        {
+            m_jail_isjailed = false;
+            m_jail_release = 0;
+
+            _SaveJail();
+            
+            sWorld.SendWorldText(LANG_JAIL_CHAR_FREE, GetName());
+            
+            CastSpell(this,8690,false);
+
+            return;
+        }
+
+        if (m_team == ALLIANCE)
+        {
+            if (GetDistance(sObjectMgr.m_jailconf_ally_x, sObjectMgr.m_jailconf_ally_y, sObjectMgr.m_jailconf_ally_z) > sObjectMgr.m_jailconf_radius)
+            {
+                TeleportTo(sObjectMgr.m_jailconf_ally_m, sObjectMgr.m_jailconf_ally_x,
+                    sObjectMgr.m_jailconf_ally_y, sObjectMgr.m_jailconf_ally_z, sObjectMgr.m_jailconf_ally_o);
+                return;
+            }
+        }
+        else
+        {
+            if (GetDistance(sObjectMgr.m_jailconf_horde_x, sObjectMgr.m_jailconf_horde_y, sObjectMgr.m_jailconf_horde_z) > sObjectMgr.m_jailconf_radius)
+            {
+                TeleportTo(sObjectMgr.m_jailconf_horde_m, sObjectMgr.m_jailconf_horde_x,
+                   sObjectMgr.m_jailconf_horde_y, sObjectMgr.m_jailconf_horde_z, sObjectMgr.m_jailconf_horde_o);
+                return;
+            }
+            
+        }
+    }
+    
+    if(m_jail_warning == true)
+    {
+        m_jail_warning  = false;
+        
+        if(sObjectMgr.m_jailconf_warn_player == m_jail_times || sObjectMgr.m_jailconf_warn_player <= m_jail_times)
+        {
+            if ((sObjectMgr.m_jailconf_max_jails-1 == m_jail_times-1) && sObjectMgr.m_jailconf_ban-1)
+            {
+                ChatHandler(this).PSendSysMessage(LANG_JAIL_WARNING_BAN, m_jail_times , sObjectMgr.m_jailconf_max_jails-1);
+            }
+            else
+            {
+                ChatHandler(this).PSendSysMessage(LANG_JAIL_WARNING, m_jail_times , sObjectMgr.m_jailconf_max_jails);
+            }
+                
+        }
+                return;
+    }
+    
+    if(m_jail_amnestie == true && sObjectMgr.m_jailconf_amnestie > 0 )
+    {
+        m_jail_amnestie =false;
+        time_t localtime;
+        localtime    = time(NULL);
+        
+        if(localtime >  m_jail_amnestietime)
+        {   
+            CharacterDatabase.PExecute("DELETE FROM `jail` WHERE `guid` = '%u'",GetGUIDLow());
+            ChatHandler(this).PSendSysMessage(LANG_JAIL_AMNESTII);
+        }
+        return;
+    }
+
     // update player only attacks
     if(uint32 ranged_att = getAttackTimer(RANGED_ATTACK))
     {
@@ -1273,7 +1319,7 @@ void Player::Update( uint32 p_time )
                     }
                 }
                 //120 degrees of radiant range
-                else if( !HasInArc( 2*M_PI_F/3, pVictim ))
+                else if( !HasInArc( 2*M_PI_F/3, pVictim ) && !GetVehicleGUID()) // - on vehicles is wrong facing set?
                 {
                     setAttackTimer(BASE_ATTACK,100);
                     if(m_swingErrorMsg != 2)                // send single time (client auto repeat)
@@ -1402,10 +1448,22 @@ void Player::Update( uint32 p_time )
             RegenerateAll();
     }
 
+    if (!isAlive() && !HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+        SetHealth(0);
+
     if (m_deathState == JUST_DIED)
-        KillPlayer();
+    {
+        // Prevent death of jailed players
+        if (!m_jail_isjailed)
+            KillPlayer();
+        else
+        {
+            m_deathState = ALIVE;
+            RegenerateAll();
+        }
+    }
 
-    if(m_nextSave > 0)
+    if(m_nextSave > 0 && !m_jail_isjailed)
     {
         if(p_time >= m_nextSave)
         {
@@ -1478,6 +1536,12 @@ void Player::Update( uint32 p_time )
     //because we don't want player's ghost teleported from graveyard
     if(IsHasDelayedTeleport() && isAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+        // Playerbot mod
+    if (m_playerbotAI)
+        m_playerbotAI->UpdateAI(p_time);
+    else if (m_playerbotMgr)
+        m_playerbotMgr->UpdateAI(p_time);
 }
 
 void Player::setDeathState(DeathState s)
@@ -1549,7 +1613,7 @@ bool Player::BuildEnumData( QueryResult * result, WorldPacket * p_data )
     PlayerInfo const *info = sObjectMgr.GetPlayerInfo(pRace, pClass);
     if(!info)
     {
-        sLog.outError("Player %u has incorrect race/class pair. Don't build enum.", guid);
+        DEBUG_LOG("Player %u has incorrect race/class pair. Don't build enum.", guid);
         return false;
     }
 
@@ -1598,8 +1662,15 @@ bool Player::BuildEnumData( QueryResult * result, WorldPacket * p_data )
         char_flags |= CHARACTER_FLAG_DECLINED;
 
     *p_data << uint32(char_flags);                          // character flags
-    // character customize flags
-    *p_data << uint32(atLoginFlags & AT_LOGIN_CUSTOMIZE ? CHAR_CUSTOMIZE_FLAG_CUSTOMIZE : CHAR_CUSTOMIZE_FLAG_NONE);
+    // character customize/faction/race change flags
+    if(atLoginFlags & AT_LOGIN_CUSTOMIZE)
+        *p_data << uint32(CHAR_CUSTOMIZE_FLAG_CUSTOMIZE);
+    else if(atLoginFlags & AT_LOGIN_CHANGE_FACTION)
+        *p_data << uint32(CHAR_CUSTOMIZE_FLAG_FACTION);
+    else if(atLoginFlags & AT_LOGIN_CHANGE_RACE)
+        *p_data << uint32(CHAR_CUSTOMIZE_FLAG_RACE);
+    else
+        *p_data << uint32(CHAR_CUSTOMIZE_FLAG_NONE);
     // First login
     *p_data << uint8(atLoginFlags & AT_LOGIN_FIRST ? 1 : 0);
 
@@ -1718,13 +1789,18 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
 {
     if(!MapManager::IsValidMapCoord(mapid, x, y, z, orientation))
     {
-        sLog.outError("TeleportTo: invalid map %d or absent instance template.", mapid);
+        DEBUG_LOG("TeleportTo: invalid map %d or absent instance template.", mapid);
         return false;
     }
 
     // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
     Pet* pet = GetPet();
 
+    // Playerbot mod: if this user has bots, tell them to stop following master
+    // so they don't try to follow the master after the master teleports
+    if (GetPlayerbotMgr())
+        GetPlayerbotMgr()->Stay();
+
     MapEntry const* mEntry = sMapStore.LookupEntry(mapid);
 
     // don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
@@ -1756,6 +1832,7 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         m_transport = NULL;
         m_movementInfo.ClearTransportData();
     }
+    ExitVehicle();
 
     // The player was ported to another map and looses the duel immediately.
     // We have to perform this check before the teleport, otherwise the
@@ -1928,6 +2005,7 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
 
             m_teleport_dest = WorldLocation(mapid, final_x, final_y, final_z, final_o);
             SetFallInformation(0, final_z);
+
             // if the player is saved before worldport ack (at logout for example)
             // this will be used instead of the current location in SaveToDB
 
@@ -2030,6 +2108,7 @@ void Player::RemoveFromWorld()
         ///- Release charmed creatures, unsummon totems and remove pets/guardians
         UnsummonAllTotems();
         RemoveMiniPet();
+        sOutdoorPvPMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
     }
 
     for(int i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
@@ -2235,12 +2314,19 @@ Creature* Player::GetNPCIfCanInteractWith(ObjectGuid guid, uint32 npcflagmask)
     if (guid.IsEmpty() || !IsInWorld() || isInFlight())
         return NULL;
 
+    // needed by Aura 292
+    if (GetGUID() == guid.GetRawValue())
+        return ((Creature*)this);
     // not in interactive state
     if (hasUnitState(UNIT_STAT_CAN_NOT_REACT))
         return NULL;
 
+    // needed by Aura 292
+    if (GetGUID() == guid.GetRawValue())
+        return ((Creature*)this);
+
     // exist (we need look pets also for some interaction (quest/etc)
-    Creature *unit = GetMap()->GetCreatureOrPetOrVehicle(guid);
+    Creature *unit = ObjectAccessor::GetCreatureOrPetOrVehicle(*this,guid);
     if (!unit)
         return NULL;
 
@@ -2317,7 +2403,7 @@ GameObject* Player::GetGameObjectIfCanInteractWith(ObjectGuid guid, uint32 gameo
             if (go->IsWithinDistInMap(this, maxdist) && go->isSpawned())
                 return go;
 
-            sLog.outError("GetGameObjectIfCanInteractWith: GameObject '%s' [GUID: %u] is too far away from player %s [GUID: %u] to be used by him (distance=%f, maximal 10 is allowed)", go->GetGOInfo()->name,
+            DEBUG_LOG("GetGameObjectIfCanInteractWith: GameObject '%s' [GUID: %u] is too far away from player %s [GUID: %u] to be used by him (distance=%f, maximal 10 is allowed)", go->GetGOInfo()->name,
                 go->GetGUIDLow(), GetName(), GetGUIDLow(), go->GetDistance(this));
         }
     }
@@ -2982,11 +3068,11 @@ bool Player::addSpell(uint32 spell_id, bool active, bool learning, bool dependen
         // do character spell book cleanup (all characters)
         if(!IsInWorld() && !learning)                       // spell load case
         {
-            sLog.outError("Player::addSpell: Non-existed in SpellStore spell #%u request, deleting for all characters in `character_spell`.",spell_id);
+            DEBUG_LOG("Player::addSpell: Non-existed in SpellStore spell #%u request, deleting for all characters in `character_spell`.",spell_id);
             CharacterDatabase.PExecute("DELETE FROM character_spell WHERE spell = '%u'",spell_id);
         }
         else
-            sLog.outError("Player::addSpell: Non-existed in SpellStore spell #%u request.",spell_id);
+            DEBUG_LOG("Player::addSpell: Non-existed in SpellStore spell #%u request.",spell_id);
 
         return false;
     }
@@ -2996,11 +3082,11 @@ bool Player::addSpell(uint32 spell_id, bool active, bool learning, bool dependen
         // do character spell book cleanup (all characters)
         if(!IsInWorld() && !learning)                       // spell load case
         {
-            sLog.outError("Player::addSpell: Broken spell #%u learning not allowed, deleting for all characters in `character_spell`.",spell_id);
+            DEBUG_LOG("Player::addSpell: Broken spell #%u learning not allowed, deleting for all characters in `character_spell`.",spell_id);
             CharacterDatabase.PExecute("DELETE FROM character_spell WHERE spell = '%u'",spell_id);
         }
         else
-            sLog.outError("Player::addSpell: Broken spell #%u learning not allowed.",spell_id);
+            DEBUG_LOG("Player::addSpell: Broken spell #%u learning not allowed.",spell_id);
 
         return false;
     }
@@ -3448,7 +3534,7 @@ void Player::removeSpell(uint32 spell_id, bool disabled, bool learn_low_rank, bo
                 m_talents[m_activeSpec].erase(iter);
         }
         else
-            sLog.outError("removeSpell: Player (GUID: %u) has talent spell (id: %u) but doesn't have talent",GetGUIDLow(), spell_id );
+            DEBUG_LOG("removeSpell: Player (GUID: %u) has talent spell (id: %u) but doesn't have talent",GetGUIDLow(), spell_id );
 
         // free talent points
         uint32 talentCosts = GetTalentSpellCost(talentPos);
@@ -3678,7 +3764,7 @@ void Player::_LoadSpellCooldowns(QueryResult *result)
 
             if(!sSpellStore.LookupEntry(spell_id))
             {
-                sLog.outError("Player %u has unknown spell %u in `character_spell_cooldown`, skipping.",GetGUIDLow(),spell_id);
+                DEBUG_LOG("Player %u has unknown spell %u in `character_spell_cooldown`, skipping.",GetGUIDLow(),spell_id);
                 continue;
             }
 
@@ -4332,7 +4418,7 @@ void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmC
             CharacterDatabase.PExecute("UPDATE characters SET deleteInfos_Name=name, deleteInfos_Account=account, deleteDate='" UI64FMTD "', name='', account=0 WHERE guid=%u", uint64(time(NULL)), guid);
             break;
         default:
-            sLog.outError("Player::DeleteFromDB: Unsupported delete method: %u.", charDelete_method);
+            DEBUG_LOG("Player::DeleteFromDB: Unsupported delete method: %u.", charDelete_method);
     }
 
     if (updateRealmChars)
@@ -4387,7 +4473,7 @@ void Player::SetMovement(PlayerMovementType pType)
         case MOVE_WATER_WALK: data.Initialize(SMSG_MOVE_WATER_WALK,   GetPackGUID().size()+4); break;
         case MOVE_LAND_WALK:  data.Initialize(SMSG_MOVE_LAND_WALK,    GetPackGUID().size()+4); break;
         default:
-            sLog.outError("Player::SetMovement: Unsupported move type (%d), data not sent to client.",pType);
+            DEBUG_LOG("Player::SetMovement: Unsupported move type (%d), data not sent to client.",pType);
             return;
     }
     data << GetPackGUID();
@@ -4416,15 +4502,16 @@ void Player::BuildPlayerRepop()
     // the player cannot have a corpse already, only bones which are not returned by GetCorpse
     if(GetCorpse())
     {
-        sLog.outError("BuildPlayerRepop: player %s(%d) already has a corpse", GetName(), GetGUIDLow());
-        ASSERT(false);
+        DEBUG_LOG("BuildPlayerRepop: player %s(%d) already has a corpse", GetName(), GetGUIDLow());
+        DEBUG_LOG("Removing player %s(%d) corpse from DB", GetName(), GetGUIDLow());
+        CharacterDatabase.PExecute("DELETE FROM corpse WHERE player = '%d'",GetGUIDLow());
     }
 
     // create a corpse and place it at the player's location
     Corpse *corpse = CreateCorpse();
     if(!corpse)
     {
-        sLog.outError("Error creating corpse for Player %s [%u]", GetName(), GetGUIDLow());
+        DEBUG_LOG("Error creating corpse for Player %s [%u]", GetName(), GetGUIDLow());
         return;
     }
     GetMap()->Add(corpse);
@@ -4489,6 +4576,7 @@ void Player::ResurrectPlayer(float restore_percent, bool applySickness)
     uint32 newzone, newarea;
     GetZoneAndAreaId(newzone,newarea);
     UpdateZone(newzone,newarea);
+    sOutdoorPvPMgr.HandlePlayerResurrects(this, newzone);
 
     // update visibility
     UpdateVisibilityForPlayer();
@@ -4526,25 +4614,34 @@ void Player::ResurrectPlayer(float restore_percent, bool applySickness)
 
 void Player::KillPlayer()
 {
-    SetMovement(MOVE_ROOT);
+    if (sWorld.getConfig(CONFIG_BOOL_PLAYER_AUTO_RESS))
+    {
+        m_deathTimer = 0;
+        BuildPlayerRepop();
+        RepopAtGraveyard(); // resurrect the player on the nearest graveyard, automatically leaves corpse behind
+    }
+    else
+    {
+        SetMovement(MOVE_ROOT);
 
-    StopMirrorTimers();                                     //disable timers(bars)
+        StopMirrorTimers();                                     //disable timers(bars)
 
-    setDeathState(CORPSE);
-    //SetFlag( UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_IN_PVP );
+        setDeathState(CORPSE);
+        //SetFlag( UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_IN_PVP );
 
-    SetFlag(UNIT_DYNAMIC_FLAGS, 0x00);
-    ApplyModFlag(PLAYER_FIELD_BYTES, PLAYER_FIELD_BYTE_RELEASE_TIMER, !sMapStore.LookupEntry(GetMapId())->Instanceable());
+        SetFlag(UNIT_DYNAMIC_FLAGS, 0x00);
+        ApplyModFlag(PLAYER_FIELD_BYTES, PLAYER_FIELD_BYTE_RELEASE_TIMER, !sMapStore.LookupEntry(GetMapId())->Instanceable());
 
-    // 6 minutes until repop at graveyard
-    m_deathTimer = 6*MINUTE*IN_MILLISECONDS;
+        // 6 minutes until repop at graveyard
+        m_deathTimer = 6*MINUTE*IN_MILLISECONDS;
 
-    UpdateCorpseReclaimDelay();                             // dependent at use SetDeathPvP() call before kill
+        UpdateCorpseReclaimDelay();                             // dependent at use SetDeathPvP() call before kill
 
-    // don't create corpse at this moment, player might be falling
+        // don't create corpse at this moment, player might be falling
 
-    // update visibility
-    UpdateObjectVisibility();
+        // update visibility
+        UpdateObjectVisibility();
+    }
 }
 
 Corpse* Player::CreateCorpse()
@@ -4772,7 +4869,7 @@ uint32 Player::DurabilityRepair(uint16 pos, bool cost, float discountMod, bool g
             DurabilityCostsEntry const *dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
             if(!dcost)
             {
-                sLog.outError("RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
+                DEBUG_LOG("RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
                 return TotalCost;
             }
 
@@ -4780,7 +4877,7 @@ uint32 Player::DurabilityRepair(uint16 pos, bool cost, float discountMod, bool g
             DurabilityQualityEntry const *dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
             if(!dQualitymodEntry)
             {
-                sLog.outError("RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
+                DEBUG_LOG("RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
                 return TotalCost;
             }
 
@@ -4852,7 +4949,7 @@ void Player::RepopAtGraveyard()
     AreaTableEntry const *zone = GetAreaEntryByAreaID(GetAreaId());
 
     // Such zones are considered unreachable as a ghost and the player must be automatically revived
-    if ((!isAlive() && zone && zone->flags & AREA_FLAG_NEED_FLY) || GetTransport())
+    if ((!isAlive() && zone && zone->flags & AREA_FLAG_NEED_FLY) || GetTransport() || GetPositionZ() < -500.0f)
     {
         ResurrectPlayer(0.5f);
         SpawnCorpseBones();
@@ -6099,12 +6196,12 @@ void Player::SendMessageToSetInRange(WorldPacket *data, float dist, bool self)
         GetSession()->SendPacket(data);
 }
 
-void Player::SendMessageToSetInRange(WorldPacket *data, float dist, bool self, bool own_team_only)
+void Player::SendMessageToSetInRange(WorldPacket *data, float dist, bool self, bool own_team_only, bool enemy_team_only)
 {
     Map * _map = IsInWorld() ? GetMap() : sMapMgr.FindMap(GetMapId(), GetInstanceId());
     if(_map)
     {
-        _map->MessageDistBroadcast(this, data, dist, self, own_team_only);
+        _map->MessageDistBroadcast(this, data, dist, self, own_team_only, enemy_team_only);
         return;
     }
 
@@ -6279,11 +6376,37 @@ void Player::RewardReputation(Unit *pVictim, float rate)
     if(!Rep)
         return;
 
+    uint32 Repfaction1 = Rep->repfaction1;
+    uint32 Repfaction2 = Rep->repfaction2;
+    uint32 tabardFactionID = 0;
+     
+    // Championning tabard reputation system
+    // aura 57818 is a hidden aura common to northrend tabards allowing championning.
+    if(pVictim->GetMap()->IsDungeon() && HasAura(57818))
+    {
+        InstanceTemplate const* mInstance = sObjectMgr.GetInstanceTemplate(pVictim->GetMapId());
+        MapEntry const* StoredMap = sMapStore.LookupEntry(pVictim->GetMapId());
+
+        // only for expansion 2 map (wotlk), and : min level >= lv75 or dungeon only heroic mod
+        // entering a lv80 designed instance require a min level>=75. note : min level != suggested level
+        if ( StoredMap->Expansion() == 2 && ( mInstance->levelMin >= 75 || pVictim->GetMap()->GetDifficulty() == DUNGEON_DIFFICULTY_HEROIC ) )
+        {             
+            if( Item* pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_TABARD ) )
+            {                 
+                if ( tabardFactionID = pItem->GetProto()->RequiredReputationFaction ) 
+                {
+                     Repfaction1 = tabardFactionID;
+                     Repfaction2 = tabardFactionID;
+                }
+            }
+        }
+    }  
+
     if(Rep->repfaction1 && (!Rep->team_dependent || GetTeam()==ALLIANCE))
     {
-        int32 donerep1 = CalculateReputationGain(pVictim->getLevel(), Rep->repvalue1, Rep->repfaction1, false);
+        int32 donerep1 = CalculateReputationGain(pVictim->getLevel(), Rep->repvalue1, Repfaction1, false);
         donerep1 = int32(donerep1*rate);
-        FactionEntry const *factionEntry1 = sFactionStore.LookupEntry(Rep->repfaction1);
+        FactionEntry const *factionEntry1 = sFactionStore.LookupEntry(Repfaction1);
         uint32 current_reputation_rank1 = GetReputationMgr().GetRank(factionEntry1);
         if (factionEntry1 && current_reputation_rank1 <= Rep->reputation_max_cap1)
             GetReputationMgr().ModifyReputation(factionEntry1, donerep1);
@@ -6299,9 +6422,9 @@ void Player::RewardReputation(Unit *pVictim, float rate)
 
     if(Rep->repfaction2 && (!Rep->team_dependent || GetTeam()==HORDE))
     {
-        int32 donerep2 = CalculateReputationGain(pVictim->getLevel(), Rep->repvalue2, Rep->repfaction2, false);
+        int32 donerep2 = CalculateReputationGain(pVictim->getLevel(), Rep->repvalue2, Repfaction2, false);
         donerep2 = int32(donerep2*rate);
-        FactionEntry const *factionEntry2 = sFactionStore.LookupEntry(Rep->repfaction2);
+        FactionEntry const *factionEntry2 = sFactionStore.LookupEntry(Repfaction2);
         uint32 current_reputation_rank2 = GetReputationMgr().GetRank(factionEntry2);
         if (factionEntry2 && current_reputation_rank2 <= Rep->reputation_max_cap2)
             GetReputationMgr().ModifyReputation(factionEntry2, donerep2);
@@ -6392,6 +6515,76 @@ void Player::UpdateHonorFields()
     }
 
     m_lastHonorUpdateTime = now;
+
+    
+    uint32 HonorKills = GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORBALE_KILLS);
+    uint32 victim_rank = 0;
+
+    if (HonorKills == 0)
+        return;
+
+    if (HonorKills >= 100 && HonorKills < 200)
+        victim_rank = 1;
+    else if (HonorKills >= 200 && HonorKills < 500)
+        victim_rank = 2;
+    else if (HonorKills >= 500 && HonorKills < 1000)
+        victim_rank = 3;
+    else if (HonorKills >= 1000 && HonorKills < 1500)
+        victim_rank = 4;
+    else if (HonorKills >= 1500 && HonorKills < 2000)
+        victim_rank = 5;
+    else if (HonorKills >= 2000 && HonorKills < 2500)
+        victim_rank = 6;
+    else if (HonorKills >= 2500 && HonorKills < 3000)
+       victim_rank = 7;
+    else if (HonorKills >= 3000 && HonorKills < 3500)
+        victim_rank = 8;
+    else if (HonorKills >= 3500 && HonorKills < 4000)
+        victim_rank = 9;
+    else if (HonorKills >= 4000 && HonorKills < 4500)
+        victim_rank = 10;
+    else if (HonorKills >= 4500 && HonorKills < 5000)
+        victim_rank = 11;
+    else if (HonorKills >= 5000 && HonorKills < 5500)
+        victim_rank = 12;
+    else if (HonorKills >= 5500 && HonorKills < 8000)
+        victim_rank = 13;
+    else if (HonorKills >= 8000)
+        victim_rank = 14;
+
+    if (victim_rank == 0)
+        return;
+
+    if (GetTeam() == HORDE && victim_rank != 0)
+        victim_rank += 14;
+
+    CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(victim_rank);
+    if (!HasTitle(titleEntry))
+        SetTitle(titleEntry);
+    else
+        return;
+
+    SetUInt32Value(PLAYER_CHOSEN_TITLE,victim_rank);
+
+    uint32 startid = 1;
+    if (GetTeam() == HORDE)
+        startid = 15;
+
+    for(int i = startid; i < int32(victim_rank); ++i)
+    {
+        if (i == victim_rank)
+            break;
+        else
+        {
+            if (!HasTitle(titleEntry))
+                continue;
+            else
+            {
+                CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(i);
+                SetTitle(titleEntry,true);
+            }
+        }
+    }
 }
 
 ///Calculate the amount of honor gained based on the victim
@@ -6436,7 +6629,7 @@ bool Player::RewardHonor(Unit *uVictim, uint32 groupsize, float honor)
                 return false;
 
             float f = 1;                                    //need for total kills (?? need more info)
-            uint32 k_grey = 0;
+            uint32 k_grey_diff = 0;
             uint32 k_level = getLevel();
             uint32 v_level = pVictim->getLevel();
 
@@ -6463,18 +6656,29 @@ bool Player::RewardHonor(Unit *uVictim, uint32 groupsize, float honor)
                     victim_guid = 0;                        // Don't show HK: <rank> message, only log.
             }
 
-            k_grey = MaNGOS::XP::GetGrayLevel(k_level);
-
-            if(v_level<=k_grey)
+            k_grey_diff = k_level - MaNGOS::XP::GetGrayLevel(k_level);
+            if(v_level <= k_level - k_grey_diff || v_level >= k_level + k_grey_diff)
                 return false;
 
-            float diff_level = (k_level == k_grey) ? 1 : ((float(v_level) - float(k_grey)) / (float(k_level) - float(k_grey)));
+            honor = MaNGOS::Honor::hk_honor_at_level(v_level);
 
-            int32 v_rank =1;                                //need more info
-
-            honor = ((f * diff_level * (190 + v_rank*10))/6);
-            honor *= ((float)k_level) / 70.0f;              //factor of dependence on levels of the killer
+            if(InBattleGround())
+            {
+                // Call To Arms events
+                uint16 m_event = 0;
+                switch(GetMapId())
+                {
+                    case 30:  m_event = 18; break;
+                    case 489: m_event = 19; break;
+                    case 529: m_event = 20; break;
+                    case 566: m_event = 21; break;
+                }
+                if(sGameEventMgr.IsActiveEvent(m_event))
+                    honor *= 1.5;
+            }
 
+            int32 v_rank =1;                                //need more info
+            
             // count the number of playerkills in one day
             ApplyModUInt32Value(PLAYER_FIELD_KILLS, 1, true);
             // and those in a lifetime
@@ -6490,7 +6694,7 @@ bool Player::RewardHonor(Unit *uVictim, uint32 groupsize, float honor)
             if (!cVictim->isRacialLeader())
                 return false;
 
-            honor = 100;                                    // ??? need more info
+            honor = 2000;                                    // ??? need more info
             victim_rank = 19;                               // HK: Leader
         }
     }
@@ -6502,10 +6706,9 @@ bool Player::RewardHonor(Unit *uVictim, uint32 groupsize, float honor)
 
         if(groupsize > 1)
             honor /= groupsize;
-
-        honor *= (((float)urand(8,12))/10);                 // approx honor: 80% - 120% of real honor
     }
 
+
     // honor - for show honor points in log
     // victim_guid - for show victim name in log
     // victim_rank [1..4]  HK: <dishonored rank>
@@ -6521,10 +6724,43 @@ bool Player::RewardHonor(Unit *uVictim, uint32 groupsize, float honor)
     // add honor points
     ModifyHonorPoints(int32(honor));
 
+    // battleground update players honor in bg statistics
+    if(InBattleGround())
+        if(BattleGround *bg = GetBattleGround())
+            bg->UpdatePlayerScore(this, SCORE_BONUS_HONOR, honor);
+
     ApplyModUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION, uint32(honor), true);
     return true;
 }
 
+
+void Player::RewardHonorEndBattlegroud(bool win)
+{
+    uint32 hk = 0;
+    bool ap = false;
+    if(!win)
+        hk = 5;
+
+    else
+    {
+        if(FirstBGDone())
+            hk = 15;
+        else
+        {
+            hk = 30;
+            if(getLevel() >= sWorld.getConfig(CONFIG_UINT32_MAX_PLAYER_LEVEL))
+                ap = true;
+            SetFirstBGTime();
+        }
+    }
+
+    if(hk)
+        RewardHonor(NULL, 1, MaNGOS::Honor::hk_honor_at_level(getLevel(),hk));
+    if(ap)
+        ModifyArenaPoints(25);
+
+}
+
 void Player::ModifyHonorPoints( int32 value )
 {
     if(value < 0)
@@ -6631,6 +6867,19 @@ uint32 Player::GetLevelFromDB(uint64 guid)
     return level;
 }
 
+uint32 Player::GetGMLevelFromDB(uint64 guid)
+{
+    QueryResult *result = CharacterDatabase.PQuery( "SELECT gmlevel FROM characters WHERE guid='%u'", GUID_LOPART(guid) );
+    if (!result)
+        return 0;
+
+    Field* fields = result->Fetch();
+    uint32 level = fields[0].GetUInt32();
+    delete result;
+
+    return level;
+}
+
 void Player::UpdateArea(uint32 newArea)
 {
     // FFA_PVP flags are area and not zone id dependent
@@ -6663,6 +6912,8 @@ void Player::UpdateZone(uint32 newZone, uint32 newArea)
 
     if(m_zoneUpdateId != newZone)
     {
+        sOutdoorPvPMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
+        sOutdoorPvPMgr.HandlePlayerEnterZone(this, newZone);
         SendInitWorldStates(newZone, newArea);              // only if really enters to new zone, not just area change, works strange...
 
         if (sWorld.getConfig(CONFIG_BOOL_WEATHER))
@@ -6712,8 +6963,31 @@ void Player::UpdateZone(uint32 newZone, uint32 newArea)
         if(IsPvP() && !HasFlag(PLAYER_FLAGS,PLAYER_FLAGS_IN_PVP) && pvpInfo.endTimer == 0)
             pvpInfo.endTimer = time(0);                     // start toggle-off
     }
+    
+    if(sWorld.getConfig(CONFIG_BOOL_EXTRA_PVP))
+    {
+        if(GetZoneId() == (sWorld.getConfig(CONFIG_UINT32_PVP_ID_1)) || GetZoneId() == (sWorld.getConfig(CONFIG_UINT32_PVP_ID_2)) || GetZoneId() == (sWorld.getConfig(CONFIG_UINT32_PVP_ID_3)) || GetZoneId() == (sWorld.getConfig(CONFIG_UINT32_PVP_ID_4)))
+        {
+            if (zone->flags & AREA_FLAG_SANCTUARY)
+                RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY);
+            if(sWorld.IsFFAPvPRealm())
+                SetFFAPvP(true);
+            if (!IsPvP() || pvpInfo.endTimer == 0)
+            {
+                UpdatePvP(true, true);
+                SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+                pvpInfo.inHostileArea = true;
+            }
+        }
+    }
 
-    if(zone->flags & AREA_FLAG_SANCTUARY)                   // in sanctuary
+    if(zone->flags & AREA_FLAG_SANCTUARY || GetZoneId() == 4298)                   // in sanctuary
+    {
+        SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY);
+        if(sWorld.IsFFAPvPRealm())
+            SetFFAPvP(false);
+    }
+    else if(GetZoneId() == (sWorld.getConfig(CONFIG_UINT32_SANCTUARY_ID)) && (sWorld.getConfig(CONFIG_BOOL_EXTRA_SANCTUARY)) == 1)                   // in sanctuary
     {
         SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY);
         if(sWorld.IsFFAPvPRealm())
@@ -6723,7 +6997,7 @@ void Player::UpdateZone(uint32 newZone, uint32 newArea)
     {
         RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY);
     }
-
+    
     if(zone->flags & AREA_FLAG_CAPITAL)                     // in capital city
         SetRestType(REST_TYPE_IN_CITY);
     else                                                    // anywhere else
@@ -6796,6 +7070,16 @@ void Player::CheckDuelDistance(time_t currTime)
     }
 }
 
+OutdoorPvP * Player::GetOutdoorPvP() const
+{
+    return sOutdoorPvPMgr.GetOutdoorPvPToZoneId(GetZoneId());
+}
+
+bool Player::IsOutdoorPvPActive()
+{
+    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && (IsPvP() || sWorld.IsPvPRealm())  && !HasMovementFlag(MOVEFLAG_FLYING) && !isInFlight();
+}
+
 void Player::DuelComplete(DuelCompleteType type)
 {
     // duel not requested
@@ -7786,7 +8070,7 @@ void Player::SendLoot(ObjectGuid guid, LootType loot_type)
     if (uint64 lguid = GetLootGUID())
         m_session->DoLootRelease(lguid);
 
-    Loot    *loot = 0;
+    Loot *loot = 0;
     PermissionTypes permission = ALL_PERMISSION;
 
     DEBUG_LOG("Player::SendLoot");
@@ -7794,7 +8078,7 @@ void Player::SendLoot(ObjectGuid guid, LootType loot_type)
     {
         case HIGHGUID_GAMEOBJECT:
         {
-            DEBUG_LOG("       IS_GAMEOBJECT_GUID(guid)");
+            DEBUG_LOG(" IS_GAMEOBJECT_GUID(guid)");
             GameObject *go = GetMap()->GetGameObject(guid);
 
             // not check distance for GO in case owned GO (fishing bobber case, for example)
@@ -7809,10 +8093,10 @@ void Player::SendLoot(ObjectGuid guid, LootType loot_type)
 
             if (go->getLootState() == GO_READY)
             {
-                uint32 lootid =  go->GetGOInfo()->GetLootId();
+                uint32 lootid = go->GetGOInfo()->GetLootId();
                 if ((go->GetEntry() == BG_AV_OBJECTID_MINE_N || go->GetEntry() == BG_AV_OBJECTID_MINE_S))
                     if (BattleGround *bg = GetBattleGround())
-                        if (bg->GetTypeID() == BATTLEGROUND_AV)
+                        if (bg->GetTypeID(true) == BATTLEGROUND_AV)
                             if (!(((BattleGroundAV*)bg)->PlayerCanDoMineQuest(go->GetEntry(), GetTeam())))
                             {
                                 SendLootRelease(guid);
@@ -7821,7 +8105,7 @@ void Player::SendLoot(ObjectGuid guid, LootType loot_type)
 
                 if (lootid)
                 {
-                    DEBUG_LOG("       if(lootid)");
+                    DEBUG_LOG(" if(lootid)");
                     loot->clear();
                     loot->FillLoot(lootid, LootTemplates_Gameobject, this, false);
                     loot->generateMoneyLoot(go->GetGOInfo()->MinMoneyLoot, go->GetGOInfo()->MaxMoneyLoot);
@@ -7870,7 +8154,7 @@ void Player::SendLoot(ObjectGuid guid, LootType loot_type)
             }
             break;
         }
-        case HIGHGUID_CORPSE:                               // remove insignia
+        case HIGHGUID_CORPSE: // remove insignia
         {
             Corpse *bones = GetMap()->GetCorpse(guid);
 
@@ -7887,7 +8171,7 @@ void Player::SendLoot(ObjectGuid guid, LootType loot_type)
                 bones->lootForBody = true;
                 uint32 pLevel = bones->loot.gold;
                 bones->loot.clear();
-                if (GetBattleGround()->GetTypeID() == BATTLEGROUND_AV)
+                if (GetBattleGround() && GetBattleGround()->GetTypeID(true) == BATTLEGROUND_AV)
                     loot->FillLoot(0, LootTemplates_Creature, this, false);
                 // It may need a better formula
                 // Now it works like this: lvl10: ~6copper, lvl70: ~9silver
@@ -7915,7 +8199,7 @@ void Player::SendLoot(ObjectGuid guid, LootType loot_type)
                 return;
             }
 
-            loot   = &creature->loot;
+            loot = &creature->loot;
 
             if (loot_type == LOOT_PICKPOCKETING)
             {
@@ -8037,7 +8321,7 @@ void Player::SendLoot(ObjectGuid guid, LootType loot_type)
     // LOOT_INSIGNIA and LOOT_FISHINGHOLE unsupported by client
     switch(loot_type)
     {
-        case LOOT_INSIGNIA:    loot_type = LOOT_SKINNING; break;
+        case LOOT_INSIGNIA: loot_type = LOOT_SKINNING; break;
         case LOOT_FISHINGHOLE: loot_type = LOOT_FISHING; break;
         default: break;
     }
@@ -8045,7 +8329,7 @@ void Player::SendLoot(ObjectGuid guid, LootType loot_type)
     // need know merged fishing/corpse loot type for achievements
     loot->loot_type = loot_type;
 
-    WorldPacket data(SMSG_LOOT_RESPONSE, (9+50));           // we guess size
+    WorldPacket data(SMSG_LOOT_RESPONSE, (9+50)); // we guess size
 
     data << guid;
     data << uint8(loot_type);
@@ -8338,6 +8622,7 @@ void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
     // data depends on zoneid/mapid...
     BattleGround* bg = GetBattleGround();
     uint32 mapid = GetMapId();
+    OutdoorPvP * pvp = sOutdoorPvPMgr.GetOutdoorPvPToZoneId(zoneid);
 
     DEBUG_LOG("Sending SMSG_INIT_WORLD_STATES to Map:%u, Zone: %u", mapid, zoneid);
 
@@ -8380,26 +8665,86 @@ void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
         case 1537:
         case 2257:
             break;
+        case 139: // EPL
+            {
+                if(pvp && pvp->GetTypeId() == OUTDOOR_PVP_EP)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    data << uint32(0x97a) << uint32(0x0); // 10 2426
+                    data << uint32(0x917) << uint32(0x0); // 11 2327
+                    data << uint32(0x918) << uint32(0x0); // 12 2328
+                    data << uint32(0x97b) << uint32(0x32); // 13 2427
+                    data << uint32(0x97c) << uint32(0x32); // 14 2428
+                    data << uint32(0x933) << uint32(0x1); // 15 2355
+                    data << uint32(0x946) << uint32(0x0); // 16 2374
+                    data << uint32(0x947) << uint32(0x0); // 17 2375
+                    data << uint32(0x948) << uint32(0x0); // 18 2376
+                    data << uint32(0x949) << uint32(0x0); // 19 2377
+                    data << uint32(0x94a) << uint32(0x0); // 20 2378
+                    data << uint32(0x94b) << uint32(0x0); // 21 2379
+                    data << uint32(0x932) << uint32(0x0); // 22 2354
+                    data << uint32(0x934) << uint32(0x0); // 23 2356
+                    data << uint32(0x935) << uint32(0x0); // 24 2357
+                    data << uint32(0x936) << uint32(0x0); // 25 2358
+                    data << uint32(0x937) << uint32(0x0); // 26 2359
+                    data << uint32(0x938) << uint32(0x0); // 27 2360
+                    data << uint32(0x939) << uint32(0x1); // 28 2361
+                    data << uint32(0x930) << uint32(0x1); // 29 2352
+                    data << uint32(0x93a) << uint32(0x0); // 30 2362
+                    data << uint32(0x93b) << uint32(0x0); // 31 2363
+                    data << uint32(0x93c) << uint32(0x0); // 32 2364
+                    data << uint32(0x93d) << uint32(0x0); // 33 2365
+                    data << uint32(0x944) << uint32(0x0); // 34 2372
+                    data << uint32(0x945) << uint32(0x0); // 35 2373
+                    data << uint32(0x931) << uint32(0x1); // 36 2353
+                    data << uint32(0x93e) << uint32(0x0); // 37 2366
+                    data << uint32(0x931) << uint32(0x1); // 38 2367 ??  grey horde not in dbc! send for consistency's sake, and to match field count
+                    data << uint32(0x940) << uint32(0x0); // 39 2368
+                    data << uint32(0x941) << uint32(0x0); // 7 2369
+                    data << uint32(0x942) << uint32(0x0); // 8 2370
+                    data << uint32(0x943) << uint32(0x0); // 9 2371
+                }
+            }
+            break;
+        case 1377: // Silithus
+            {
+                if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_SI)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    // states are always shown
+                    data << uint32(2313) << uint32(0x0); // 7 ally silityst gathered
+                    data << uint32(2314) << uint32(0x0); // 8 horde silityst gathered
+                    data << uint32(2317) << uint32(0x0); // 9 max silithyst
+                }
+                // dunno about these... aq opening event maybe?
+                data << uint32(2322) << uint32(0x0); // 10 sandworm N
+                data << uint32(2323) << uint32(0x0); // 11 sandworm S
+                data << uint32(2324) << uint32(0x0); // 12 sandworm SW
+                data << uint32(2325) << uint32(0x0); // 13 sandworm E
+            }
+            break;
         case 2597:                                          // AV
-            if (bg && bg->GetTypeID() == BATTLEGROUND_AV)
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_AV)
                 bg->FillInitialWorldStates(data, count);
             else
                 FillInitialWorldState(data,count, AV_world_states);
             break;
         case 3277:                                          // WS
-            if (bg && bg->GetTypeID() == BATTLEGROUND_WS)
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_WS)
                 bg->FillInitialWorldStates(data, count);
             else
                 FillInitialWorldState(data,count, WS_world_states);
             break;
         case 3358:                                          // AB
-            if (bg && bg->GetTypeID() == BATTLEGROUND_AB)
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_AB)
                 bg->FillInitialWorldStates(data, count);
             else
                 FillInitialWorldState(data,count, AB_world_states);
             break;
         case 3820:                                          // EY
-            if (bg && bg->GetTypeID() == BATTLEGROUND_EY)
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_EY)
                 bg->FillInitialWorldStates(data, count);
             else
                 FillInitialWorldState(data,count, EY_world_states);
@@ -8414,7 +8759,7 @@ void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
             FillInitialWorldState(data,count, ZM_world_states);
             break;
         case 3698:                                          // Nagrand Arena
-            if (bg && bg->GetTypeID() == BATTLEGROUND_NA)
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_NA)
                 bg->FillInitialWorldStates(data, count);
             else
             {
@@ -8424,7 +8769,7 @@ void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
             }
             break;
         case 3702:                                          // Blade's Edge Arena
-            if (bg && bg->GetTypeID() == BATTLEGROUND_BE)
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_BE)
                 bg->FillInitialWorldStates(data, count);
             else
             {
@@ -8434,7 +8779,7 @@ void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
             }
             break;
         case 3968:                                          // Ruins of Lordaeron
-            if (bg && bg->GetTypeID() == BATTLEGROUND_RL)
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_RL)
                 bg->FillInitialWorldStates(data, count);
             else
             {
@@ -8443,8 +8788,63 @@ void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
                 FillInitialWorldState(data,count,0xbba,0x0);// 9 show
             }
             break;
+        case 4378:                                          // Dalaran Severs
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_DS)
+                bg->FillInitialWorldStates(data, count);
+            else
+            {
+                FillInitialWorldState(data,count,0xe11,0x0);// 7 gold
+                FillInitialWorldState(data,count,0xe10,0x0);// 8 green
+                FillInitialWorldState(data,count,0xe1a,0x0);// 9 show
+            }
+            break;
+        case 4406:                                          // Ring of Valor
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_RV)
+                bg->FillInitialWorldStates(data, count);
+            else
+            {
+                FillInitialWorldState(data,count,0xe11,0x0);// 7 gold
+                FillInitialWorldState(data,count,0xe10,0x0);// 8 green
+                FillInitialWorldState(data,count,0xe1a,0x0);// 9 show
+            }
+            break;
         case 3703:                                          // Shattrath City
             break;
+        case 4384:                                          // SA
+            /*if (bg && bg->GetTypeID() == BATTLEGROUND_SA)
+                bg->FillInitialWorldStates(data);
+            else
+            {*/
+                // 1-3 A defend, 4-6 H defend, 7-9 unk defend, 1 - ok, 2 - half destroyed, 3 - destroyed
+                data << uint32(0xf09) << uint32(0x4);       // 7  3849 Gate of Temple
+                data << uint32(0xe36) << uint32(0x4);       // 8  3638 Gate of Yellow Moon
+                data << uint32(0xe27) << uint32(0x4);       // 9  3623 Gate of Green Emerald
+                data << uint32(0xe24) << uint32(0x4);       // 10 3620 Gate of Blue Sapphire
+                data << uint32(0xe21) << uint32(0x4);       // 11 3617 Gate of Red Sun
+                data << uint32(0xe1e) << uint32(0x4);       // 12 3614 Gate of Purple Ametyst
+
+                data << uint32(0xdf3) << uint32(0x0);       // 13 3571 bonus timer (1 - on, 0 - off)
+                data << uint32(0xded) << uint32(0x0);       // 14 3565 Horde Attacker
+                data << uint32(0xdec) << uint32(0x1);       // 15 3564 Alliance Attacker
+                // End Round (timer), better explain this by example, eg. ends in 19:59 -> A:BC
+                data << uint32(0xde9) << uint32(0x9);       // 16 3561 C
+                data << uint32(0xde8) << uint32(0x5);       // 17 3560 B
+                data << uint32(0xde7) << uint32(0x19);      // 18 3559 A
+                data << uint32(0xe35) << uint32(0x1);       // 19 3637 East g - Horde control
+                data << uint32(0xe34) << uint32(0x1);       // 20 3636 West g - Horde control
+                data << uint32(0xe33) << uint32(0x1);       // 21 3635 South g - Horde control
+                data << uint32(0xe32) << uint32(0x0);       // 22 3634 East g - Alliance control
+                data << uint32(0xe31) << uint32(0x0);       // 23 3633 West g - Alliance control
+                data << uint32(0xe30) << uint32(0x0);       // 24 3632 South g - Alliance control
+                data << uint32(0xe2f) << uint32(0x1);       // 25 3631 Chamber of Ancients - Horde control
+                data << uint32(0xe2e) << uint32(0x0);       // 26 3630 Chamber of Ancients - Alliance control
+                data << uint32(0xe2d) << uint32(0x0);       // 27 3629 Beach1 - Horde control
+                data << uint32(0xe2c) << uint32(0x0);       // 28 3628 Beach2 - Horde control
+                data << uint32(0xe2b) << uint32(0x1);       // 29 3627 Beach1 - Alliance control
+                data << uint32(0xe2a) << uint32(0x1);       // 30 3626 Beach2 - Alliance control
+                // and many unks...
+            //}
+            break;
         default:
             FillInitialWorldState(data,count, 0x914, 0x0);  // 7
             FillInitialWorldState(data,count, 0x913, 0x0);  // 8
@@ -8458,7 +8858,6 @@ void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
     data.put<uint16>(count_pos,count);                     // set actual world state amount
 
     GetSession()->SendPacket(&data);
-
 }
 
 void Player::FillBGWeekendWorldStates(WorldPacket& data, uint32& count)
@@ -9153,34 +9552,34 @@ bool Player::HasItemCount( uint32 item, uint32 count, bool inBankAlso ) const
     for(int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
     {
         Item *pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, i );
-        if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
+        if( pItem && pItem->GetEntry() == item )
         {
             tempcount += pItem->GetCount();
-            if (tempcount >= count)
+            if( tempcount >= count )
                 return true;
         }
     }
     for(int i = KEYRING_SLOT_START; i < CURRENCYTOKEN_SLOT_END; ++i)
     {
         Item *pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, i );
-        if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
+        if( pItem && pItem->GetEntry() == item )
         {
             tempcount += pItem->GetCount();
-            if (tempcount >= count)
+            if( tempcount >= count )
                 return true;
         }
     }
     for(int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
     {
-        if (Bag* pBag = (Bag*)GetItemByPos( INVENTORY_SLOT_BAG_0, i ))
+        if(Bag* pBag = (Bag*)GetItemByPos( INVENTORY_SLOT_BAG_0, i ))
         {
             for(uint32 j = 0; j < pBag->GetBagSize(); ++j)
             {
                 Item* pItem = GetItemByPos( i, j );
-                if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
+                if( pItem && pItem->GetEntry() == item )
                 {
                     tempcount += pItem->GetCount();
-                    if (tempcount >= count)
+                    if( tempcount >= count )
                         return true;
                 }
             }
@@ -9192,24 +9591,24 @@ bool Player::HasItemCount( uint32 item, uint32 count, bool inBankAlso ) const
         for(int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; ++i)
         {
             Item *pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, i );
-            if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
+            if( pItem && pItem->GetEntry() == item )
             {
                 tempcount += pItem->GetCount();
-                if (tempcount >= count)
+                if( tempcount >= count )
                     return true;
             }
         }
         for(int i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
         {
-            if (Bag* pBag = (Bag*)GetItemByPos( INVENTORY_SLOT_BAG_0, i ))
+            if(Bag* pBag = (Bag*)GetItemByPos( INVENTORY_SLOT_BAG_0, i ))
             {
                 for(uint32 j = 0; j < pBag->GetBagSize(); ++j)
                 {
                     Item* pItem = GetItemByPos( i, j );
-                    if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
+                    if( pItem && pItem->GetEntry() == item )
                     {
                         tempcount += pItem->GetCount();
-                        if (tempcount >= count)
+                        if( tempcount >= count )
                             return true;
                     }
                 }
@@ -10624,6 +11023,64 @@ uint8 Player::CanUseItem( Item *pItem, bool not_loading ) const
 {
     if (pItem)
     {
+        if (sWorld.getConfig(CONFIG_BOOL_ALLOW_FLYING_MOUNTS_EVERYWHERE))
+        {
+            ItemPrototype const *iProto = pItem->GetProto();
+            if (iProto)
+            {
+                for(int i = 0; i < 5; i++)
+                {
+                    SpellEntry const *sEntry = sSpellStore.LookupEntry(iProto->Spells[i].SpellId);
+                    if (sEntry)
+                    {
+                        Player* player = ((Player*)this);
+                        if(isFlyingSpell(sEntry))
+                        {
+                            if(player->HasAuraTypeFlyingSpell())
+                                player->RemoveFlyingSpells();
+                            else if(player->HasAuraTypeFlyingFormSpell())
+                                player->RemoveFlyingFormSpells();
+                            else if(player->HasAuraTypeRunningFormSpell())
+                                player->RemoveRunningFormSpells();
+
+                            if(player->CanUseFlyingMounts(sEntry))
+                            {
+                                for(int j = 0; j < MAX_EFFECT_INDEX; ++j)
+                                {
+                                    Aura* aur = CreateAura(sEntry, SpellEffectIndex(j), NULL, player, player, NULL);
+                                    player->AddAura(aur);
+                                }
+                            }
+                            return EQUIP_ERR_OK;
+                        }
+                        else if(isFlyingFormSpell(sEntry))
+                        {
+                            if(player->HasAuraTypeFlyingSpell())
+                                player->RemoveFlyingSpells();
+                            else if(player->HasAuraTypeFlyingFormSpell())
+                                player->RemoveFlyingFormSpells();
+                            /*else if(player->HasAuraTypeRunningFormSpell())
+                                player->RemoveRunningFormSpells();*/
+
+                            if(player->CanUseFlyingMounts(sEntry))
+                            {
+                                for(int j = 0; j < MAX_EFFECT_INDEX; ++j)
+                                {
+                                    Aura* aur = CreateAura(sEntry, SpellEffectIndex(j), NULL, player, player, NULL);
+                                    player->AddAura(aur);
+                                }
+                            }
+                            return EQUIP_ERR_OK;
+                        }
+                        else if (isRunningSpell(sEntry) || isRunningFormSpell(sEntry))
+                        {
+                            player->RemoveAllFlyingSpells();
+                            return EQUIP_ERR_OK;
+                        }
+                    }
+                }
+            }
+        }
         DEBUG_LOG( "STORAGE: CanUseItem item = %u", pItem->GetEntry());
 
         if (!isAlive() && not_loading)
@@ -10982,6 +11439,10 @@ Item* Player::EquipItem( uint16 pos, Item *pItem, bool update )
             if(pProto && pProto->ItemSet)
                 AddItemsSetItem(this, pItem);
 
+            //There must be some check also for unequip...
+            // if(IsWeaponDisarmed(slot))
+              //   return NULL;
+
             _ApplyItemMods(pItem, slot, true);
 
             if(pProto && isInCombat()&& pProto->Class == ITEM_CLASS_WEAPON && m_weaponChangeTimer == 0)
@@ -11330,7 +11791,7 @@ void Player::DestroyItemCount( uint32 item, uint32 count, bool update, bool uneq
     {
         if (Item* pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, i ))
         {
-            if (pItem->GetEntry() == item && !pItem->IsInTrade())
+            if (pItem->GetEntry() == item)
             {
                 if (pItem->GetCount() + remcount <= count)
                 {
@@ -11358,7 +11819,7 @@ void Player::DestroyItemCount( uint32 item, uint32 count, bool update, bool uneq
     {
         if (Item* pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, i ))
         {
-            if (pItem->GetEntry() == item && !pItem->IsInTrade())
+            if (pItem->GetEntry() == item)
             {
                 if (pItem->GetCount() + remcount <= count)
                 {
@@ -11391,7 +11852,7 @@ void Player::DestroyItemCount( uint32 item, uint32 count, bool update, bool uneq
             {
                 if(Item* pItem = pBag->GetItemByPos(j))
                 {
-                    if (pItem->GetEntry() == item && !pItem->IsInTrade())
+                    if (pItem->GetEntry() == item)
                     {
                         // all items in bags can be unequipped
                         if (pItem->GetCount() + remcount <= count)
@@ -11422,7 +11883,7 @@ void Player::DestroyItemCount( uint32 item, uint32 count, bool update, bool uneq
     {
         if (Item* pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, i ))
         {
-            if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
+            if (pItem && pItem->GetEntry() == item)
             {
                 if (pItem->GetCount() + remcount <= count)
                 {
@@ -11511,6 +11972,27 @@ void Player::DestroyItemCount( Item* pItem, uint32 &count, bool update )
     if(!pItem)
         return;
 
+    if (sWorld.getConfig(CONFIG_BOOL_ALLOW_FLYING_MOUNTS_EVERYWHERE))
+    {
+        ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(pItem->GetEntry());
+        if(pProto)
+        {
+            for(int i = 0; i < 5; i++)
+            {
+                SpellEntry const *sEntry = sSpellStore.LookupEntry(pProto->Spells[i].SpellId);
+                if(!sEntry)
+                    continue;
+
+                if(isFlyingSpell(sEntry) || isFlyingFormSpell(sEntry))
+                {
+                    pItem->SetSpellCharges(0, 1);
+                    pItem->SetState(ITEM_CHANGED, this);
+                    return;
+                }
+            }
+        }
+    }
+
     DEBUG_LOG( "STORAGE: DestroyItemCount item (GUID: %u, Entry: %u) count = %u", pItem->GetGUIDLow(),pItem->GetEntry(), count);
 
     if( pItem->GetCount() <= count )
@@ -12091,7 +12573,7 @@ void Player::TradeCancel(bool sendback)
 {
     if (m_trade)
     {
-        Player* trader = m_trade->GetTrader();
+        Player* trader = m_trade->m_tradeWith;
 
         // send yellow "Trade canceled" message to both traders
         if (sendback)
@@ -12268,6 +12750,15 @@ void Player::ApplyEnchantment(Item *item, EnchantmentSlot slot, bool apply, bool
     if (!ignore_condition && pEnchant->EnchantmentCondition && !((Player*)this)->EnchantmentFitsRequirements(pEnchant->EnchantmentCondition, -1))
         return;
 
+    if ((pEnchant->requiredLevel) > ((Player*)this)->getLevel())
+        return;
+
+    if ((pEnchant->requiredSkill) > 0)
+    {
+       if ((pEnchant->requiredSkillValue) > (((Player*)this)->GetSkillValue(pEnchant->requiredSkill)))
+        return;
+    }
+
     if (!item->IsBroken())
     {
         for (int s = 0; s < 3; ++s)
@@ -12532,6 +13023,7 @@ void Player::ApplyEnchantment(Item *item, EnchantmentSlot slot, bool apply, bool
                         case ITEM_MOD_FERAL_ATTACK_POWER:
                         case ITEM_MOD_SPELL_HEALING_DONE:   // deprecated
                         case ITEM_MOD_SPELL_DAMAGE_DONE:    // deprecated
+                            break;
                         default:
                             break;
                     }
@@ -12707,6 +13199,10 @@ void Player::PrepareGossipMenu(WorldObject *pSource, uint32 menuId)
                     if (!pCreature->isCanTrainingOf(this, false))
                         hasMenuItem = false;
                     break;
+                case GOSSIP_OPTION_LEARNDUALSPEC:
+                    if(!(GetSpecsCount() == 1 && pCreature->isCanTrainingAndResetTalentsOf(this) && !(getLevel() < sWorld.getConfig(CONFIG_MIN_LEVEL_DUALSPEC))))
+                        hasMenuItem = false;
+                    break;
                 case GOSSIP_OPTION_UNLEARNTALENTS:
                     if (!pCreature->isCanTrainingAndResetTalentsOf(this))
                         hasMenuItem = false;
@@ -12734,6 +13230,10 @@ void Player::PrepareGossipMenu(WorldObject *pSource, uint32 menuId)
                 case GOSSIP_OPTION_TABARDDESIGNER:
                 case GOSSIP_OPTION_AUCTIONEER:
                     break;                                  // no checks
+                case GOSSIP_OPTION_OUTDOORPVP:
+                    if (!sOutdoorPvPMgr.CanTalkTo(this, pCreature, itr->second))
+                        hasMenuItem = false;
+                    break;
                 default:
                     sLog.outErrorDb("Creature entry %u have unknown gossip option %u for menu %u", pCreature->GetEntry(), itr->second.option_id, itr->second.menu_id);
                     hasMenuItem = false;
@@ -12905,6 +13405,9 @@ void Player::OnGossipSelect(WorldObject* pSource, uint32 gossipListId, uint32 me
 
             break;
         }
+        case GOSSIP_OPTION_OUTDOORPVP:
+            sOutdoorPvPMgr.HandleGossipOption(this, pSource->GetGUID(), gossipListId);
+            break;
         case GOSSIP_OPTION_SPIRITHEALER:
             if (isDead())
                 ((Creature*)pSource)->CastSpell(((Creature*)pSource),17251,true,NULL,NULL,GetGUID());
@@ -12923,6 +13426,18 @@ void Player::OnGossipSelect(WorldObject* pSource, uint32 gossipListId, uint32 me
         case GOSSIP_OPTION_TRAINER:
             GetSession()->SendTrainerList(guid);
             break;
+        case GOSSIP_OPTION_LEARNDUALSPEC:
+            if(GetSpecsCount() == 1 && !(getLevel() < sWorld.getConfig(CONFIG_MIN_LEVEL_DUALSPEC)))
+            {
+                // Cast spells that teach dual spec
+                // Both are also ImplicitTarget self and must be cast by player
+                CastSpell(this,63680,true,NULL,NULL,GetGUID());
+                CastSpell(this,63624,true,NULL,NULL,GetGUID());
+                
+                // Should show another Gossip text with "Congratulations..."
+                PlayerTalkClass->CloseGossip();
+            }			
+            break;
         case GOSSIP_OPTION_UNLEARNTALENTS:
             PlayerTalkClass->CloseGossip();
             SendTalentWipeConfirm(guid);
@@ -13022,7 +13537,8 @@ void Player::PrepareQuestMenu( uint64 guid )
     QuestRelations* pObjectQIR;
 
     // pets also can have quests
-    if (Creature *pCreature = GetMap()->GetCreatureOrPetOrVehicle(guid))
+    Creature *pCreature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
+    if( pCreature )
     {
         pObject = (Object*)pCreature;
         pObjectQR  = &sObjectMgr.mCreatureQuestRelations;
@@ -13116,7 +13632,8 @@ void Player::SendPreparedQuest(uint64 guid)
         std::string title = "";
 
         // need pet case for some quests
-        if (Creature *pCreature = GetMap()->GetCreatureOrPetOrVehicle(guid))
+        Creature *pCreature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this,guid);
+        if (pCreature)
         {
             uint32 textid = GetGossipTextId(pCreature);
 
@@ -13189,7 +13706,8 @@ Quest const * Player::GetNextQuest( uint64 guid, Quest const *pQuest )
     QuestRelations* pObjectQR;
     QuestRelations* pObjectQIR;
 
-    if (Creature *pCreature = GetMap()->GetCreatureOrPetOrVehicle(guid))
+    Creature *pCreature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this,guid);
+    if( pCreature )
     {
         pObject = (Object*)pCreature;
         pObjectQR  = &sObjectMgr.mCreatureQuestRelations;
@@ -13562,7 +14080,7 @@ void Player::RewardQuest( Quest const *pQuest, uint32 reward, Object* questGiver
     RemoveTimedQuest(quest_id);
 
     if (BattleGround* bg = GetBattleGround())
-        if (bg->GetTypeID() == BATTLEGROUND_AV)
+        if (bg->GetTypeID(true) == BATTLEGROUND_AV)
             ((BattleGroundAV*)bg)->HandleQuestComplete(pQuest->GetQuestId(), this);
 
     if (pQuest->GetRewChoiceItemsCount() > 0)
@@ -14961,8 +15479,8 @@ bool Player::LoadFromDB( uint32 guid, SqlQueryHolder *holder )
     //"resettalents_time, trans_x, trans_y, trans_z, trans_o, transguid, extra_flags, stable_slots, at_login, zone, online, death_expire_time, taxi_path, dungeon_difficulty,"
     // 39           40                41                42                    43          44          45              46           47               48              49
     //"arenaPoints, totalHonorPoints, todayHonorPoints, yesterdayHonorPoints, totalKills, todayKills, yesterdayKills, chosenTitle, knownCurrencies, watchedFaction, drunk,"
-    // 50      51      52      53      54      55      56      57      58         59          60             61              62      63           64
-    //"health, power1, power2, power3, power4, power5, power6, power7, specCount, activeSpec, exploredZones, equipmentCache, ammoId, knownTitles, actionBars  FROM characters WHERE guid = '%u'", GUID_LOPART(m_guid));
+    // 50      51      52      53      54      55      56      57      58         59          60             61              62      63           64          65
+    //"health, power1, power2, power3, power4, power5, power6, power7, specCount, activeSpec, exploredZones, equipmentCache, ammoId, knownTitles, actionBars, gmlevel  FROM characters WHERE guid = '%u'", GUID_LOPART(m_guid));
     QueryResult *result = holder->GetResult(PLAYER_LOGIN_QUERY_LOADFROM);
 
     if(!result)
@@ -14975,6 +15493,10 @@ bool Player::LoadFromDB( uint32 guid, SqlQueryHolder *holder )
 
     uint32 dbAccountId = fields[1].GetUInt32();
 
+    m_GMLevel = fields[65].GetInt32();
+    if (m_GMLevel > 0)
+        GetSession()->SetSecurity((AccountTypes)m_GMLevel);
+
     // check if the character's account in the db and the logged in account match.
     // player should be able to load/delete character only with correct account!
     if( dbAccountId != GetSession()->GetAccountId() )
@@ -15123,7 +15645,8 @@ bool Player::LoadFromDB( uint32 guid, SqlQueryHolder *holder )
 
         m_movementInfo.ClearTransportData();
     }
-
+    
+    _LoadBGStatus(holder->GetResult(PLAYER_LOGIN_QUERY_LOADBGSTATUS));
     _LoadBGData(holder->GetResult(PLAYER_LOGIN_QUERY_LOADBGDATA));
 
     if(m_bgData.bgInstanceID)                                                //saved in BattleGround
@@ -15386,6 +15909,7 @@ bool Player::LoadFromDB( uint32 guid, SqlQueryHolder *holder )
     _LoadQuestStatus(holder->GetResult(PLAYER_LOGIN_QUERY_LOADQUESTSTATUS));
     _LoadDailyQuestStatus(holder->GetResult(PLAYER_LOGIN_QUERY_LOADDAILYQUESTSTATUS));
     _LoadWeeklyQuestStatus(holder->GetResult(PLAYER_LOGIN_QUERY_LOADWEEKLYQUESTSTATUS));
+    _LoadRandomBGStatus(holder->GetResult(PLAYER_LOGIN_QUERY_LOADRANDOMBG));
 
     _LoadTalents(holder->GetResult(PLAYER_LOGIN_QUERY_LOADTALENTS));
 
@@ -15552,14 +16076,91 @@ bool Player::LoadFromDB( uint32 guid, SqlQueryHolder *holder )
 
     m_achievementMgr.LoadFromDB(holder->GetResult(PLAYER_LOGIN_QUERY_LOADACHIEVEMENTS), holder->GetResult(PLAYER_LOGIN_QUERY_LOADCRITERIAPROGRESS));
     m_achievementMgr.CheckAllAchievementCriteria();
-
+    
     _LoadEquipmentSets(holder->GetResult(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS));
-
-    return true;
-}
+   // Loads the jail datas and if jailed it corrects the position to the corresponding jail
+    _LoadJail();
+
+return true;
+}
+
+ // Loads the jail datas (added by WarHead).
+ void Player::_LoadJail(void)
+ {
+     CharacterDatabase.BeginTransaction();
+     QueryResult *result = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", GetGUIDLow());
+     CharacterDatabase.CommitTransaction();
+ 
+     if (!result)
+     {
+         m_jail_isjailed = false;
+         return;
+     }
+ 
+         Field *fields = result->Fetch();
+         m_jail_warning = true;
+         m_jail_isjailed = true;
+         m_jail_guid = fields[0].GetUInt32();
+         m_jail_char = fields[1].GetString();
+         m_jail_release = fields[2].GetUInt32();
+         m_jail_amnestietime = fields[3].GetUInt32();
+         m_jail_reason = fields[4].GetString();
+         m_jail_times = fields[5].GetUInt32();
+         m_jail_gmacc = fields[6].GetUInt32();
+         m_jail_gmchar = fields[7].GetString();
+         m_jail_lasttime = fields[8].GetString();
+         m_jail_duration = fields[9].GetUInt32();
+ 
+     if (m_jail_release == 0)
+     {
+         m_jail_isjailed = false;
+         delete result;
+         return;
+     }
+ 
+     time_t localtime;
+     localtime = time(NULL);
+ 
+     if (m_jail_release <= localtime)
+     {
+         m_jail_isjailed = false;
+         m_jail_release = 0;
+ 
+         _SaveJail();
+ 
+         sWorld.SendWorldText(LANG_JAIL_CHAR_FREE, GetName());
+ 
+         CastSpell(this,8690,false);
+ 
+         delete result;
+         return;
+     }
+ 
+     if (m_jail_isjailed)
+    {
+         if (m_team == ALLIANCE)
+         {
+             TeleportTo(sObjectMgr.m_jailconf_ally_m, sObjectMgr.m_jailconf_ally_x,
+                 sObjectMgr.m_jailconf_ally_y, sObjectMgr.m_jailconf_ally_z, sObjectMgr.m_jailconf_ally_o);
+         }
+         else
+         {
+             TeleportTo(sObjectMgr.m_jailconf_horde_m, sObjectMgr.m_jailconf_horde_x,
+                 sObjectMgr.m_jailconf_horde_y, sObjectMgr.m_jailconf_horde_z, sObjectMgr.m_jailconf_horde_o);
+        }
+          
+         sWorld.SendWorldText(LANG_JAIL_CHAR_TELE, GetName() );
+     }
+     
+     delete result;
+     
+  }
 
 bool Player::isAllowedToLoot(Creature* creature)
 {
+    if(creature && creature->isDead() && !creature->AreLootAndRewardAllowed())
+        return false;
+
     if(Player* recipient = creature->GetLootRecipient())
     {
         if (recipient == this)
@@ -16303,6 +16904,7 @@ void Player::_LoadTalents(QueryResult *result)
         delete result;
     }
 }
+
 void Player::_LoadGroup(QueryResult *result)
 {
     //QueryResult *result = CharacterDatabase.PQuery("SELECT groupId FROM group_member WHERE memberGuid='%u'", GetGUIDLow());
@@ -16613,12 +17215,44 @@ bool Player::_LoadHomeBind(QueryResult *result)
     return true;
 }
 
+void Player::_LoadBGStatus(QueryResult *result)
+{
+    if (result)
+    {
+        m_FirstBGTime = (*result)[0].GetUInt32();
+        delete result;
+    }
+    else
+        m_FirstBGTime = 0;
+}
+
 /*********************************************************/
 /***                   SAVE SYSTEM                     ***/
 /*********************************************************/
 
+// Saves the jail datas (added by WarHead).
+void Player::_SaveJail(void)
+{
+    CharacterDatabase.BeginTransaction();
+    QueryResult *result = CharacterDatabase.PQuery("SELECT `guid` FROM `jail` WHERE `guid`='%u' LIMIT 1", m_jail_guid);
+
+    if (!result)
+        CharacterDatabase.PExecute("INSERT INTO `jail` VALUES ('%u','%s','%u', '%u','%s','%u','%u','%s',CURRENT_TIMESTAMP,'%u')", m_jail_guid, m_jail_char.c_str(), m_jail_release, m_jail_amnestietime, m_jail_reason.c_str(), m_jail_times, m_jail_gmacc, m_jail_gmchar.c_str(), m_jail_duration);
+    else
+        CharacterDatabase.PExecute("UPDATE `jail` SET `release`='%u', `amnestietime`='%u',`reason`='%s',`times`='%u',`gmacc`='%u',`gmchar`='%s',`duration`='%u' WHERE `guid`='%u' LIMIT 1", m_jail_release, m_jail_amnestietime, m_jail_reason.c_str(), m_jail_times, m_jail_gmacc, m_jail_gmchar.c_str(), m_jail_duration, m_jail_guid);
+
+    CharacterDatabase.CommitTransaction();
+
+    if (result)
+        delete result;
+}
+
 void Player::SaveToDB()
 {
+    // Jail: Prevent saving of jailed players
+    if (m_jail_isjailed)
+        return;
+
     // we should assure this: ASSERT((m_nextSave != sWorld.getConfig(CONFIG_UINT32_INTERVAL_SAVE)));
     // delay auto save at any saves (manual, in code, or autosave)
     m_nextSave = sWorld.getConfig(CONFIG_UINT32_INTERVAL_SAVE);
@@ -16637,7 +17271,7 @@ void Player::SaveToDB()
     outDebugStatsValues();
 
     CharacterDatabase.BeginTransaction();
-
+    
     CharacterDatabase.PExecute("DELETE FROM characters WHERE guid = '%u'",GetGUIDLow());
 
     std::string sql_name = m_name;
@@ -16651,7 +17285,7 @@ void Player::SaveToDB()
         "trans_x, trans_y, trans_z, trans_o, transguid, extra_flags, stable_slots, at_login, zone, "
         "death_expire_time, taxi_path, arenaPoints, totalHonorPoints, todayHonorPoints, yesterdayHonorPoints, totalKills, "
         "todayKills, yesterdayKills, chosenTitle, knownCurrencies, watchedFaction, drunk, health, power1, power2, power3, "
-        "power4, power5, power6, power7, specCount, activeSpec, exploredZones, equipmentCache, ammoId, knownTitles, actionBars) VALUES ("
+        "power4, power5, power6, power7, specCount, activeSpec, exploredZones, equipmentCache, ammoId, knownTitles, actionBars, gmlevel) VALUES ("
         << GetGUIDLow() << ", "
         << GetSession()->GetAccountId() << ", '"
         << sql_name << "', "
@@ -16773,6 +17407,7 @@ void Player::SaveToDB()
     }
     ss << "',";
     ss << uint32(GetByteValue(PLAYER_FIELD_BYTES, 2));
+    ss << uint32(m_GMLevel);
     ss << ")";
 
     CharacterDatabase.Execute( ss.str().c_str() );
@@ -16781,6 +17416,7 @@ void Player::SaveToDB()
         _SaveMail();
 
     _SaveBGData();
+    _SaveBGStatus();
     _SaveInventory();
     _SaveQuestStatus();
     _SaveDailyQuestStatus();
@@ -17215,12 +17851,23 @@ void Player::_SaveStats()
     // check if stat saving is enabled and if char level is high enough
     if(!sWorld.getConfig(CONFIG_UINT32_MIN_LEVEL_STAT_SAVE) || getLevel() < sWorld.getConfig(CONFIG_UINT32_MIN_LEVEL_STAT_SAVE))
         return;
+		
+	std::ostringstream data_armory;
+	for(uint16 i = 0; i < m_valuesCount; i++)
+	{
+	    data_armory << GetUInt32Value(i) << " ";
+	}	
 
     CharacterDatabase.PExecute("DELETE FROM character_stats WHERE guid = '%u'", GetGUIDLow());
     std::ostringstream ss;
     ss << "INSERT INTO character_stats (guid, maxhealth, maxpower1, maxpower2, maxpower3, maxpower4, maxpower5, maxpower6, maxpower7, "
         "strength, agility, stamina, intellect, spirit, armor, resHoly, resFire, resNature, resFrost, resShadow, resArcane, "
-        "blockPct, dodgePct, parryPct, critPct, rangedCritPct, spellCritPct, attackPower, rangedAttackPower, spellPower) VALUES ("
+        "blockPct, dodgePct, parryPct, critPct, rangedCritPct, spellCritPct, attackPower, rangedAttackPower, spellPower, "
+        "a_apmelee, a_ranged, a_blockrating, a_defrating, a_dodgerating, a_parryrating, a_resilience, a_manaregen, "
+        "a_melee_hitrating, a_melee_critrating, a_melee_hasterating, a_melee_mainmindmg, a_melee_mainmaxdmg, "
+        "a_melee_offmindmg, a_melee_offmaxdmg, a_melee_maintime, a_melee_offtime, a_ranged_critrating, a_ranged_hasterating, "
+        "a_ranged_hitrating, a_ranged_mindmg, a_ranged_maxdmg, a_ranged_attacktime, "
+        "a_spell_hitrating, a_spell_critrating, a_spell_hasterating, a_spell_bonusdmg, a_spell_bonusheal, a_spell_critproc, data) VALUES ("
         << GetGUIDLow() << ", "
         << GetMaxHealth() << ", ";
     for(int i = 0; i < MAX_POWERS; ++i)
@@ -17238,7 +17885,37 @@ void Player::_SaveStats()
        << GetFloatValue(PLAYER_SPELL_CRIT_PERCENTAGE1) << ", "
        << GetUInt32Value(UNIT_FIELD_ATTACK_POWER) << ", "
        << GetUInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER) << ", "
-       << GetBaseSpellPowerBonus() << ")";
+       << GetBaseSpellPowerBonus() << ", "
+       << (GetUInt32Value(ANDEERIA_AP_MELEE_1)+GetUInt32Value(ANDEERIA_AP_MELEE_2)) << ", "
+       << (GetUInt32Value(ANDEERIA_AP_RANGED_1)+GetUInt32Value(ANDEERIA_AP_RANGED_2)) << ", "
+       << GetUInt32Value(ANDEERIA_BLOCKRATING) << ", "
+       << GetUInt32Value(ANDEERIA_DEFRATING) << ", "
+       << GetUInt32Value(ANDEERIA_DODGERATING) << ", "
+       << GetUInt32Value(ANDEERIA_PARRYRATING) << ", "
+       << GetUInt32Value(ANDEERIA_RESILIENCE) << ", "
+       << GetFloatValue(ANDEERIA_MANAREGEN) << ", "
+       << GetUInt32Value(ANDEERIA_MELEE_HITRATING) << ", "
+       << GetUInt32Value(ANDEERIA_MELEE_CRITRATING) << ", "
+       << GetUInt32Value(ANDEERIA_MELEE_HASTERATING) << ", "
+       << GetFloatValue(ANDEERIA_MELEE_MAINMINDMG) << ", "
+       << GetFloatValue(ANDEERIA_MELEE_MAINMAXDMG) << ", "
+       << GetFloatValue(ANDEERIA_MELEE_OFFMINDMG) << ", "
+       << GetFloatValue(ANDEERIA_MELEE_OFFMAXDMG) << ", "
+       << GetFloatValue(ANDEERIA_MELLE_MAINTIME) << ", "
+       << GetFloatValue(ANDEERIA_MELLE_OFFTIME) << ", "
+       << GetUInt32Value(ANDEERIA_RANGED_CRITRATING) << ", "
+       << GetUInt32Value(ANDEERIA_RANGED_HASTERATING) << ", "
+       << GetUInt32Value(ANDEERIA_RANGED_HITRATING) << ", "
+       << GetFloatValue(ANDEERIA_RANGED_MINDMG) << ", "
+       << GetFloatValue(ANDEERIA_RANGED_MAXDMG) << ", "
+       << GetFloatValue(ANDEERIA_RANGED_ATTACKTIME) << ", "
+       << GetUInt32Value(ANDEERIA_SPELL_HITRATING) << ", "
+       << GetUInt32Value(ANDEERIA_SPELL_CRITRATING) << ", "
+       << GetUInt32Value(ANDEERIA_SPELL_HASTERATING) << ", "
+       << GetUInt32Value(ANDEERIA_SPELL_BONUSDMG) << ", "
+       << GetUInt32Value(ANDEERIA_SPELL_BONUSHEAL) << ", "
+       << GetFloatValue(ANDEERIA_SPELL_CRITPROC) << ", '"
+	   << data_armory.str().c_str() << "')";
     CharacterDatabase.Execute( ss.str().c_str() );
 }
 
@@ -17540,28 +18217,40 @@ void Player::RemovePet(Pet* pet, PetSaveMode mode, bool returnreagent)
     if (pet && m_temporaryUnsummonedPetNumber && m_temporaryUnsummonedPetNumber != pet->GetCharmInfo()->GetPetNumber() && mode == PET_SAVE_AS_CURRENT)
         mode = PET_SAVE_NOT_IN_SLOT;
 
-    if (returnreagent && pet && mode != PET_SAVE_AS_CURRENT)
+    if(mode != PET_SAVE_AS_CURRENT && !InBattleGround())
     {
         //returning of reagents only for players, so best done here
-        uint32 spellId = pet ? pet->GetUInt32Value(UNIT_CREATED_BY_SPELL) : m_oldpetspell;
-        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+        uint32 spellId = pet ? pet->GetUInt32Value(UNIT_CREATED_BY_SPELL) : m_oldpetspell;      // this is nonsense, pet will always be != NULL here
 
-        if(spellInfo)
+        if(SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId))
         {
-            for(uint32 i = 0; i < MAX_SPELL_REAGENTS; ++i)
+            // returning of reagents
+            if (returnreagent)
             {
-                if(spellInfo->Reagent[i] > 0)
+                for(uint32 i = 0; i < MAX_SPELL_REAGENTS; ++i)
                 {
-                    ItemPosCountVec dest;                   //for succubus, voidwalker, felhunter and felguard credit soulshard when despawn reason other than death (out of range, logout)
-                    uint8 msg = CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, spellInfo->Reagent[i], spellInfo->ReagentCount[i] );
-                    if( msg == EQUIP_ERR_OK )
+                    if(spellInfo->Reagent[i] > 0)
                     {
-                        Item* item = StoreNewItem( dest, spellInfo->Reagent[i], true);
-                        if(IsInWorld())
-                            SendNewItem(item,spellInfo->ReagentCount[i],true,false);
+                        ItemPosCountVec dest;                   //for succubus, voidwalker, felhunter and felguard credit soulshard when despawn reason other than death (out of range, logout)
+                        uint8 msg = CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, spellInfo->Reagent[i], spellInfo->ReagentCount[i] );
+                        if( msg == EQUIP_ERR_OK )
+                        {
+                            Item* item = StoreNewItem( dest, spellInfo->Reagent[i], true);
+                            if(IsInWorld())
+                                SendNewItem(item,spellInfo->ReagentCount[i],true,false);
+                        }
                     }
                 }
             }
+            // cooldown, only if pet is not death already (corpse)
+            if (spellInfo->Attributes & SPELL_ATTR_DISABLED_WHILE_ACTIVE && pet->getDeathState() != CORPSE)
+            {
+                SendCooldownEvent(spellInfo);
+                // Raise Dead hack
+                if (spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && spellInfo->SpellFamilyFlags & 0x1000)
+                    if (spellInfo = sSpellStore.LookupEntry(46584))
+                        SendCooldownEvent(spellInfo);
+            }
         }
     }
 
@@ -18081,7 +18770,12 @@ void Player::HandleStealthedUnitsDetection()
                 // target aura duration for caster show only if target exist at caster client
                 // send data at target visibility change (adding to client)
                 if((*i)!=this && (*i)->isType(TYPEMASK_UNIT))
+                {
                     SendAurasForTarget(*i);
+                    WorldPacket data;
+                    (*i)->BuildHeartBeatMsg(&data);
+                    GetSession()->SendPacket(&data);
+                }
             }
         }
         else
@@ -18116,7 +18810,7 @@ bool Player::ActivateTaxiPathTo(std::vector<uint32> const& nodes, Creature* npc
     if(npc)
     {
         // not let cheating with start flight mounted
-        if(IsMounted())
+        if(IsMounted() || GetVehicleGUID())
         {
             WorldPacket data(SMSG_ACTIVATETAXIREPLY, 4);
             data << uint32(ERR_TAXIPLAYERALREADYMOUNTED);
@@ -18145,6 +18839,7 @@ bool Player::ActivateTaxiPathTo(std::vector<uint32> const& nodes, Creature* npc
     else
     {
         RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
+        ExitVehicle();
 
         if( m_ShapeShiftFormSpellId && m_form != FORM_BATTLESTANCE && m_form != FORM_BERSERKERSTANCE && m_form != FORM_DEFENSIVESTANCE && m_form != FORM_SHADOW )
             RemoveAurasDueToSpell(m_ShapeShiftFormSpellId);
@@ -18583,6 +19278,7 @@ bool Player::BuyItemFromVendorSlot(uint64 vendorguid, uint32 vendorslot, uint32
         }
 
         ModifyMoney( -(int32)price );
+        uint32 extCostId = 0;
         if (uint32 extendedCostId = crItem->GetExtendedCostId())
         {
             ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(extendedCostId);
@@ -18595,6 +19291,7 @@ bool Player::BuyItemFromVendorSlot(uint64 vendorguid, uint32 vendorslot, uint32
                 if (iece->reqitem[i])
                     DestroyItemCount(iece->reqitem[i], (iece->reqitemcount[i] * count), true);
             }
+            extCostId = iece->ID;
         }
 
         if (Item *it = StoreNewItem( dest, item, true ))
@@ -18609,6 +19306,14 @@ bool Player::BuyItemFromVendorSlot(uint64 vendorguid, uint32 vendorslot, uint32
             GetSession()->SendPacket(&data);
 
             SendNewItem(it, pProto->BuyCount*count, true, false, false);
+
+            // Item Refund system, only works for non stackable items with extendedcost
+            if(count == 1 && crItem->ExtendedCost )
+            {
+                it->SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, m_Played_time[0]);
+                it->SetPrice(price); // <- cuz of faction discount
+                it->SetExtCostId(extCostId); // <- because we cant get to it afterwards :/
+            }
         }
     }
     else if (IsEquipmentPos(bag, slot))
@@ -19272,7 +19977,12 @@ void Player::UpdateVisibilityOf(WorldObject const* viewPoint, WorldObject* targe
             // target aura duration for caster show only if target exist at caster client
             // send data at target visibility change (adding to client)
             if(target!=this && target->isType(TYPEMASK_UNIT))
+            {
                 SendAurasForTarget((Unit*)target);
+                WorldPacket data;
+                ((Unit*)target)->BuildHeartBeatMsg(&data);
+                GetSession()->SendPacket(&data);
+            }
 
             if(target->GetTypeId()==TYPEID_UNIT && ((Creature*)target)->isAlive())
                 ((Creature*)target)->SendMonsterMoveWithSpeedToCurrentDestination(this);
@@ -19337,13 +20047,22 @@ void Player::InitPrimaryProfessions()
 void Player::SendComboPoints()
 {
     Unit *combotarget = ObjectAccessor::GetUnit(*this, m_comboTarget);
-    if (combotarget)
-    {
-        WorldPacket data(SMSG_UPDATE_COMBO_POINTS, combotarget->GetPackGUID().size()+1);
-        data << combotarget->GetPackGUID();
-        data << uint8(m_comboPoints);
-        GetSession()->SendPacket(&data);
-    }
+    if (!combotarget)
+        return;
+
+    WorldPacket data;
+    if(!GetVehicleGUID())
+        data.Initialize(SMSG_UPDATE_COMBO_POINTS, combotarget->GetPackGUID().size()+1);
+    else{
+       if(Unit *vehicle = ObjectAccessor::GetUnit(*this, GetVehicleGUID()))
+       {
+           data.Initialize(SMSG_PET_UPDATE_COMBO_POINTS, vehicle->GetPackGUID().size()+combotarget->GetPackGUID().size()+1);
+           data << vehicle->GetPackGUID();
+       }else return;
+    }
+    data << combotarget->GetPackGUID();
+    data << uint8(m_comboPoints);
+    GetSession()->SendPacket(&data);
 }
 
 void Player::AddComboPoints(Unit* target, int8 count)
@@ -19462,10 +20181,18 @@ void Player::SendInitialPacketsBeforeAddToMap()
         m_movementInfo.AddMovementFlag(MOVEFLAG_FLYING);
 
     m_mover = this;
+    m_mover_in_queve = NULL;
 }
 
 void Player::SendInitialPacketsAfterAddToMap()
 {
+    if(getClass() == CLASS_DEATH_KNIGHT)
+        ResyncRunes(MAX_RUNES);
+
+    WorldPacket data0(SMSG_SET_PHASE_SHIFT, 4);
+    data0 << uint32(GetPhaseMask());
+    GetSession()->SendPacket(&data0);
+
     // update zone
     uint32 newzone, newarea;
     GetZoneAndAreaId(newzone,newarea);
@@ -19504,6 +20231,14 @@ void Player::SendInitialPacketsAfterAddToMap()
         SendMessageToSet(&data2,true);
     }
 
+    if(GetVehicleGUID())
+    {
+        WorldPacket data3(SMSG_FORCE_MOVE_ROOT, 10);
+        data3 << GetPackGUID();
+        data3 << (uint32)((m_movementInfo.GetVehicleSeatFlags() & SF_CAN_CAST) ? 2 : 0);
+        SendMessageToSet(&data3,true);
+    }
+
     SendAurasForTarget(this);
     SendEnchantmentDurations();                             // must be after add to map
     SendItemDurations();                                    // must be after add to map
@@ -19518,7 +20253,7 @@ void Player::SendUpdateToOutOfRangeGroupMembers()
 
     m_groupUpdateMask = GROUP_UPDATE_FLAG_NONE;
     m_auraUpdateMask = 0;
-    if(Pet *pet = GetPet())
+    if(Unit *pet = GetCharmOrPet())
         pet->ResetAuraUpdateMask();
 }
 
@@ -19613,7 +20348,15 @@ void Player::learnDefaultSpells()
         uint32 tspell = *itr;
         DEBUG_LOG("PLAYER (Class: %u Race: %u): Adding initial spell, id = %u",uint32(getClass()),uint32(getRace()), tspell);
         if(!IsInWorld())                                    // will send in INITIAL_SPELLS in list anyway at map add
+        {
             addSpell(tspell, true, true, true, false);
+            if (sWorld.getConfig(CONFIG_BOOL_DUALSPEC_AT_CREATE) && GetSpecsCount() == 1)
+            {
+                CastSpell(this,63680,true,NULL,NULL,GetGUID());
+                CastSpell(this,63624,true,NULL,NULL,GetGUID());
+            }
+
+        }
         else                                                // but send in normal spell in game learn case
             learnSpell(tspell, true);
     }
@@ -19950,7 +20693,7 @@ void Player::UpdateForQuestWorldObjects()
         }
         else if (itr->IsCreatureOrVehicle())
         {
-            Creature *obj = GetMap()->GetCreatureOrPetOrVehicle(*itr);
+            Creature *obj = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, *itr);
             if(!obj)
                 continue;
 
@@ -20235,6 +20978,8 @@ void Player::RewardSinglePlayerAtKill(Unit* pVictim)
         if(pVictim->GetTypeId()==TYPEID_UNIT)
             KilledMonster(((Creature*)pVictim)->GetCreatureInfo(), pVictim->GetObjectGuid());
     }
+    if(GetVehicleGUID() && !(m_movementInfo.GetVehicleFlags() & VF_GIVE_EXP))
+        xp = 0;
 }
 
 void Player::RewardPlayerAndGroupAtEvent(uint32 creature_id, WorldObject* pRewardSource)
@@ -20720,28 +21465,22 @@ void Player::ApplyGlyphs(bool apply)
         ApplyGlyph(i,apply);
 }
 
-void Player::EnterVehicle(Vehicle *vehicle)
+void Player::SendEnterVehicle(Vehicle *vehicle, VehicleSeatEntry const *veSeat)
 {
-    VehicleEntry const *ve = sVehicleStore.LookupEntry(vehicle->GetVehicleId());
-    if(!ve)
-        return;
-
-    VehicleSeatEntry const *veSeat = sVehicleSeatStore.LookupEntry(ve->m_seatID[0]);
-    if(!veSeat)
-        return;
-
-    vehicle->SetCharmerGUID(GetGUID());
-    vehicle->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK);
-    vehicle->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
-    vehicle->setFaction(getFaction());
-
-    SetCharm(vehicle);                                      // charm
-    SetFarSightGUID(vehicle->GetGUID());                    // set view
-
-    SetClientControl(vehicle, 1);                           // redirect controls to vehicle
-    SetMover(vehicle);
+    m_movementInfo.AddMovementFlag(MOVEFLAG_ONTRANSPORT);
+    m_movementInfo.AddMovementFlag(MOVEFLAG_ROOT);
 
-    WorldPacket data(SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA, 0);
+    if(m_transport)                                         // if we were on a transport, leave
+    {
+        m_transport->RemovePassenger(this);
+        m_transport = NULL;
+    }
+    // vehicle is our transport from now, if we get to zeppelin or boat
+    // with vehicle, ONLY my vehicle will be passenger on that transport
+    // player ----> vehicle ----> zeppelin
+    
+    WorldPacket data(SMSG_BREAK_TARGET, 8);
+    data << vehicle->GetPackGUID();
     GetSession()->SendPacket(&data);
 
     data.Initialize(MSG_MOVE_TELEPORT_ACK, 30);
@@ -20780,7 +21519,7 @@ void Player::EnterVehicle(Vehicle *vehicle)
     GetSession()->SendPacket(&data);
 }
 
-void Player::ExitVehicle(Vehicle *vehicle)
+/*void Player::ExitVehicle(Vehicle *vehicle)
 {
     vehicle->SetCharmerGUID(0);
     vehicle->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK);
@@ -20795,22 +21534,22 @@ void Player::ExitVehicle(Vehicle *vehicle)
 
     WorldPacket data(MSG_MOVE_TELEPORT_ACK, 30);
     data << GetPackGUID();
-    data << uint32(0);                                      // counter?
-    data << uint32(MOVEFLAG_ROOT);                          // fly unk
-    data << uint16(MOVEFLAG2_UNK4);                         // special flags
-    data << uint32(getMSTime());                            // time
-    data << vehicle->GetPositionX();                        // x
-    data << vehicle->GetPositionY();                        // y
-    data << vehicle->GetPositionZ();                        // z
-    data << vehicle->GetOrientation();                      // o
-    data << uint32(0);                                      // fall time
+    data << uint32(0); // counter?
+    data << uint32(MOVEFLAG_ROOT); // fly unk
+    data << uint16(MOVEFLAG2_UNK4); // special flags
+    data << uint32(getMSTime()); // time
+    data << vehicle->GetPositionX(); // x
+    data << vehicle->GetPositionY(); // y
+    data << vehicle->GetPositionZ(); // z
+    data << vehicle->GetOrientation(); // o
+    data << uint32(0); // fall time
     GetSession()->SendPacket(&data);
 
     RemovePetActionBar();
 
     // maybe called at dummy aura remove?
-    // CastSpell(this, 45472, true);                        // Parachute
-}
+    // CastSpell(this, 45472, true); // Parachute
+} */
 
 bool Player::isTotalImmune()
 {
@@ -20874,7 +21613,8 @@ void Player::ConvertRune(uint8 index, RuneType newType)
 
 void Player::ResyncRunes(uint8 count)
 {
-    WorldPacket data(SMSG_RESYNC_RUNES, count * 2);
+    WorldPacket data(SMSG_RESYNC_RUNES, 4 + count * 2);
+    data << uint32(count + 1);
     for(uint32 i = 0; i < count; ++i)
     {
         data << uint8(GetCurrentRune(i));                   // rune type
@@ -20960,21 +21700,28 @@ void Player::AutoStoreLoot(uint8 bag, uint8 slot, uint32 loot_id, LootStore cons
 uint32 Player::CalculateTalentsPoints() const
 {
     uint32 base_talent = getLevel() < 10 ? 0 : getLevel()-9;
+    if (!(sWorld.getConfig(CONFIG_BOOL_DK_NO_QUESTS_FOR_TP)))
+    {
+        if(getClass() != CLASS_DEATH_KNIGHT)
+            return uint32(base_talent * sWorld.getConfig(CONFIG_FLOAT_RATE_TALENT));
 
-    if(getClass() != CLASS_DEATH_KNIGHT)
-        return uint32(base_talent * sWorld.getConfig(CONFIG_FLOAT_RATE_TALENT));
-
-    uint32 talentPointsForLevel = getLevel() < 56 ? 0 : getLevel() - 55;
-    talentPointsForLevel += m_questRewardTalentCount;
+        uint32 talentPointsForLevel = getLevel() < 56 ? 0 : getLevel() - 55;
+        talentPointsForLevel += m_questRewardTalentCount;
 
-    if(talentPointsForLevel > base_talent)
-        talentPointsForLevel = base_talent;
+        if(talentPointsForLevel > base_talent)
+            talentPointsForLevel = base_talent;
 
-    return uint32(talentPointsForLevel * sWorld.getConfig(CONFIG_FLOAT_RATE_TALENT));
+        return uint32(talentPointsForLevel * sWorld.getConfig(CONFIG_FLOAT_RATE_TALENT));
+    }
+    else
+    {
+        return uint32(base_talent * sWorld.getConfig(CONFIG_FLOAT_RATE_TALENT));
+    }
 }
 
 bool Player::IsKnowHowFlyIn(uint32 mapid, uint32 zone, uint32 area) const
 {
+    if(sWorld.getConfig(CONFIG_BOOL_ALLOW_FLYING_MOUNTS_EVERYWHERE)) return true;
     // continent checked in SpellMgr::GetSpellAllowedInLocationError at cast and area update
     uint32 v_map = GetVirtualMapForMapAndZone(mapid, zone);
 
@@ -21180,7 +21927,9 @@ uint8 Player::CanEquipUniqueItem( ItemPrototype const* itemProto, uint8 except_s
 void Player::HandleFall(MovementInfo const& movementInfo)
 {
     // calculate total z distance of the fall
-    float z_diff = m_lastFallZ - movementInfo.GetPos()->z;
+    float z_diff = (m_lastFallZ >= m_anti_BeginFallZ ? m_lastFallZ : m_anti_BeginFallZ) - movementInfo.GetPos()->z;
+
+    m_anti_BeginFallZ=INVALID_HEIGHT;
     DEBUG_LOG("zDiff = %f", z_diff);
 
     //Players with low fall distance, Feather Fall or physical immunity (charges used) are ignored
@@ -21237,7 +21986,7 @@ void Player::LearnTalent(uint32 talentId, uint32 talentRank)
     if(CurTalentPoints == 0)
         return;
 
-    if (talentRank >= MAX_TALENT_RANK)
+    if(talentRank >= MAX_TALENT_RANK)
         return;
 
     TalentEntry const *talentInfo = sTalentStore.LookupEntry( talentId );
@@ -21468,12 +22217,48 @@ void Player::UpdateFallInformationIfNeed( MovementInfo const& minfo,uint16 opcod
         SetFallInformation(minfo.GetFallTime(), minfo.GetPos()->z);
 }
 
+///PVP Token
+void Player::ReceiveToken()
+{
+    if(!sWorld.getConfig(CONFIG_PVP_TOKEN_ENABLE))
+        return;
+
+    uint8 MapRestriction = sWorld.getConfig(CONFIG_PVP_TOKEN_RESTRICTION);
+
+    if( MapRestriction == 1 && !InBattleGround() && !HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP) ||
+        MapRestriction == 2 && !HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP) ||
+        MapRestriction == 3 && !InBattleGround())
+        return;
+
+    uint32 itemID = sWorld.getConfig(CONFIG_PVP_TOKEN_ITEMID);
+    uint32 itemCount = sWorld.getConfig(CONFIG_PVP_TOKEN_ITEMCOUNT);
+
+    ItemPosCountVec dest;
+    uint8 msg = CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, itemID, itemCount);
+    if( msg != EQUIP_ERR_OK )   // convert to possible store amount
+    {
+        SendEquipError( msg, NULL, NULL );
+        return;
+    }
+
+    Item* item = StoreNewItem( dest, itemID, true, Item::GenerateItemRandomPropertyId(itemID));
+    SendNewItem(item,itemCount,true,false);
+
+    ChatHandler(this).PSendSysMessage(LANG_YOU_RECEIVE_TOKEN);
+}
+
 void Player::UnsummonPetTemporaryIfAny()
 {
     Pet* pet = GetPet();
     if(!pet)
         return;
 
+    if (((Player*)this)->InArena())
+    {
+        RemovePet(pet, PET_SAVE_NOT_IN_SLOT); // remove pet while is player teleported to arena
+        return;
+    }
+ 
     if(!m_temporaryUnsummonedPetNumber && pet->isControlled() && !pet->isTemporarySummoned() )
     {
         m_temporaryUnsummonedPetNumber = pet->GetCharmInfo()->GetPetNumber();
@@ -21814,6 +22599,18 @@ void Player::_SaveBGData()
     }
 }
 
+void Player::_SaveBGStatus()
+{
+    if(!m_FirstBattleground)
+        return;
+
+    CharacterDatabase.PExecute("DELETE FROM character_battleground_status WHERE guid='%u'", GetGUIDLow());
+    CharacterDatabase.PExecute("INSERT INTO character_battleground_status VALUES ('%u', '%u')",
+        GetGUIDLow(), m_FirstBGTime);
+
+    m_FirstBattleground = false;
+}
+
 void Player::DeleteEquipmentSet(uint64 setGuid)
 {
     for(EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end(); ++itr)
@@ -21841,7 +22638,7 @@ void Player::ActivateSpec(uint8 specNum)
 
     ApplyGlyphs(false);
 
-    // copy of new talent spec (we will use it as model for converting current tlanet state to new)
+    // copy of new talent spec (we will use it as model for converting current talent state to new)
     PlayerTalentMap tempSpec = m_talents[specNum];
 
     // copy old spec talents to new one, must be before spec switch to have previous spec num(as m_activeSpec)
@@ -22080,6 +22877,40 @@ void Player::SendDuelCountdown(uint32 counter)
     GetSession()->SendPacket(&data);
 }
 
+void Player::AddGlobalCooldown(SpellEntry const *spellInfo, Spell *spell)
+{
+    if (!spellInfo || !spellInfo->StartRecoveryTime)
+        return;
+
+    float cdTime = float(spellInfo->StartRecoveryTime);
+
+    if (!(spellInfo->Attributes & (SPELL_ATTR_UNK4|SPELL_ATTR_PASSIVE)))
+        cdTime *= GetFloatValue(UNIT_MOD_CAST_SPEED);
+    else if ((spellInfo->Attributes & SPELL_ATTR_RANGED) && !spell->IsAutoRepeat())
+        cdTime *= m_modAttackSpeedPct[RANGED_ATTACK];
+
+    ApplySpellMod(spellInfo->Id, SPELLMOD_CASTING_TIME_OLD, cdTime, spell);
+    if (cdTime > 0)
+        m_globalCooldowns[spellInfo->StartRecoveryCategory] = uint32(cdTime);
+}
+
+bool Player::HasGlobalCooldown(SpellEntry const *spellInfo) const
+{
+    if (!spellInfo)
+        return false;
+
+    std::map<uint32, uint32>::const_iterator itr = m_globalCooldowns.find(spellInfo->StartRecoveryCategory);
+    return itr != m_globalCooldowns.end() && (itr->second > sWorld.GetDiffTime());
+}
+
+void Player::RemoveGlobalCooldown(SpellEntry const *spellInfo)
+{
+    if (!spellInfo)
+        return;
+
+    m_globalCooldowns[spellInfo->StartRecoveryCategory] = 0;
+}
+
 bool Player::IsImmunedToSpellEffect(SpellEntry const* spellInfo, SpellEffectIndex index) const
 {
     switch(spellInfo->Effect[index])
@@ -22155,6 +22986,12 @@ Object* Player::GetObjectByTypeMask(ObjectGuid guid, TypeMask typemask)
     return NULL;
 }
 
+
+void Player::CompletedAchievement(AchievementEntry const* entry)
+{
+  GetAchievementMgr().CompletedAchievement(entry);
+}
+
 void Player::SetRestType( RestType n_r_type, uint32 areaTriggerId /*= 0*/)
 {
     rest_type = n_r_type;
@@ -22178,3 +23015,169 @@ void Player::SetRestType( RestType n_r_type, uint32 areaTriggerId /*= 0*/)
             SetFFAPvP(false);
     }
 }
+
+void Player::FlyingMountsSpellsToItems()
+{
+    for (PlayerSpellMap::const_iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
+    {
+        SpellEntry const *sEntry = sSpellStore.LookupEntry(itr->first);
+        if(!sEntry)
+            continue;
+
+        if(! (isFlyingSpell(sEntry) || isFlyingFormSpell(sEntry)) )
+            continue;
+
+        uint32 itemId = 0;
+        for (uint32 id = 0; id < sItemStorage.MaxEntry; id++)
+        {
+            ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(id);
+            if(!pProto)
+                continue;
+
+            for(int i = 0; i < 5; i++)
+            {
+                if(pProto->Spells[i].SpellId == itr->first)
+                {
+                    itemId = id;
+                    break;
+                }
+            }
+        }
+        if(!HasItemCount(itemId, 1, false))
+        {
+            //Adding items
+            uint32 noSpaceForCount = 0;
+
+            // check space and find places
+            ItemPosCountVec dest;
+            uint8 msg = CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, itemId, 1, &noSpaceForCount );
+
+            if(!dest.empty())                         // can't add any
+            {
+                Item* item = StoreNewItem( dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+                SendNewItem(item, 1,false,false);
+            }
+        }
+
+    }
+
+    for(int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+    {
+        Item *pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, i );
+        if(!pItem)
+            continue;
+
+        ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(pItem->GetEntry());
+        if(!pProto)
+            continue;
+
+        for(int i = 0; i < 5; i++)
+        {
+            SpellEntry const *sEntry = sSpellStore.LookupEntry(pProto->Spells[i].SpellId);
+            if(!sEntry)
+                continue;
+
+            if(! (isFlyingSpell(sEntry) || isFlyingFormSpell(sEntry)) )
+                continue;
+
+            if(HasSpell(pProto->Spells[i].SpellId))
+            {
+                uint16 RidingSkill = GetSkillValue(SKILL_RIDING);
+                removeSpell(pProto->Spells[i].SpellId, false, false);
+                SetSkill(SKILL_RIDING, RidingSkill, 300);
+                break;
+            }
+
+        }        
+    }
+
+    for(int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        if(Bag* pBag = (Bag*)GetItemByPos( INVENTORY_SLOT_BAG_0, i ))
+        {
+            for(uint32 j = 0; j < pBag->GetBagSize(); ++j)
+            {
+                Item* pItem = GetItemByPos( i, j );
+                if(!pItem)
+                    continue;
+
+                ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(pItem->GetEntry());
+                if(!pProto)
+                    continue;
+
+                for(int i = 0; i < 5; i++)
+                {
+                    SpellEntry const *sEntry = sSpellStore.LookupEntry(pProto->Spells[i].SpellId);
+                    if(!sEntry)
+                        continue;
+
+                    if(! (isFlyingSpell(sEntry) || isFlyingFormSpell(sEntry)) )
+                        continue;
+
+                    if(HasSpell(pProto->Spells[i].SpellId))
+                    {
+                        uint16 RidingSkill = GetSkillValue(SKILL_RIDING);
+                        removeSpell(pProto->Spells[i].SpellId, false, false);
+                        SetSkill(SKILL_RIDING, RidingSkill, 300);
+                        break;
+                    }
+                }
+            }
+        }
+    }
+}
+
+bool Player::CanUseFlyingMounts(SpellEntry const* sEntry)
+{
+    if(!GetFlyingMountTimer())
+        return false;
+
+    if (sWorld.getConfig(CONFIG_BOOL_LIMIT_ALLOWED_MOUNTS))
+    {
+            if ((sEntry->Id == (sWorld.getConfig(CONFIG_UINT32_ALLOWED_MOUNT1))) || (sEntry->Id == (sWorld.getConfig(CONFIG_UINT32_ALLOWED_MOUNT2))) || (sEntry->Id == (sWorld.getConfig(CONFIG_UINT32_ALLOWED_MOUNT3))))
+                    return false;
+    }
+
+    uint32 v_map = GetVirtualMapForMapAndZone(GetMapId(), GetZoneId());
+    MapEntry const* mapEntry = sMapStore.LookupEntry(v_map);
+    if(!getAttackers().empty())
+    {
+        WorldPacket data(SMSG_CAST_FAILED, (4+1+1));
+        data << uint8(0);
+        data << uint32(sEntry->Id);
+        data << uint8(SPELL_FAILED_TARGET_IN_COMBAT); 
+        GetSession()->SendPacket(&data);
+        return false;
+    }
+    if(GetZoneId() == 4378 || GetZoneId() == 4406 || GetZoneId() == 3968 || GetZoneId() == 3702 || GetZoneId() == 3698)
+        return false;
+    if( (!mapEntry)/* || (mapEntry->Instanceable())*/ || (mapEntry->IsDungeon()) ||
+        (mapEntry->IsRaid()) || (mapEntry->IsBattleArena()) || (mapEntry->IsBattleGround()) )
+    {
+        WorldPacket data(SMSG_CAST_FAILED, (4+1+1));
+        data << uint8(0);
+        data << uint32(sEntry->Id);
+        data << uint8(SPELL_FAILED_NOT_HERE); 
+        GetSession()->SendPacket(&data);
+        return false;
+    }
+    return true;
+}
+
+void Player::SetRandomWinner(bool isWinner)
+{
+    m_IsBGRandomWinner = isWinner;
+    if(m_IsBGRandomWinner)
+        CharacterDatabase.PExecute("INSERT INTO character_battleground_random (guid) VALUES ('%u')", GetGUIDLow());
+}
+
+void Player::_LoadRandomBGStatus(QueryResult *result)
+{
+    //QueryResult *result = CharacterDatabase.PQuery("SELECT guid FROM character_battleground_random WHERE guid = '%u'", GetGUIDLow());
+
+    if (result)
+    {
+        m_IsBGRandomWinner = true;
+        delete result;
+    }
+}
diff --git a/mangos/src/game/Player.h b/Core/src/game/Player.h
index bdaa399..bc72d5d 100644
--- a/mangos/src/game/Player.h
+++ b/Core/src/game/Player.h
@@ -32,7 +32,7 @@
 #include "WorldSession.h"
 #include "Pet.h"
 #include "MapReference.h"
-#include "Util.h"                                           // for Tokens typedef
+#include "Util.h"                                          // for Tokens typedef
 #include "AchievementMgr.h"
 #include "ReputationMgr.h"
 #include "BattleGround.h"
@@ -55,6 +55,13 @@ class InstanceSave;
 class Spell;
 class Item;
 
+// Playerbot mod
+class PlayerbotAI;
+class PlayerbotMgr;
+
+// OutdoorPvP
+class OutdoorPvP;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -634,6 +641,8 @@ enum AtLoginFlags
     AT_LOGIN_CUSTOMIZE         = 0x08,
     AT_LOGIN_RESET_PET_TALENTS = 0x10,
     AT_LOGIN_FIRST             = 0x20,
+    AT_LOGIN_CHANGE_FACTION	   = 0x40,
+    AT_LOGIN_CHANGE_RACE	   = 0x80
 };
 
 typedef std::map<uint32, QuestStatusData> QuestStatusMap;
@@ -911,7 +920,8 @@ enum PlayerLoginQueryIndex
     PLAYER_LOGIN_QUERY_LOADMAILEDITEMS,
     PLAYER_LOGIN_QUERY_LOADTALENTS,
     PLAYER_LOGIN_QUERY_LOADWEEKLYQUESTSTATUS,
-
+    PLAYER_LOGIN_QUERY_LOADBGSTATUS,
+    PLAYER_LOGIN_QUERY_LOADRANDOMBG,
     MAX_PLAYER_LOGIN_QUERY
 };
 
@@ -1019,58 +1029,24 @@ struct BGData
     bool HasTaxiPath() const { return taxiPath[0] && taxiPath[1]; }
 };
 
-class TradeData
+struct TradeData
 {
-    public:                                                 // constructors
-        TradeData(Player* player, Player* trader) :
-            m_player(player),  m_trader(trader), m_accepted(false), m_acceptProccess(false),
-            m_money(0), m_spell(0) {}
-
-    public:                                                 // access functions
-
-        Player* GetTrader() const { return m_trader; }
-        TradeData* GetTraderData() const;
-
-        Item* GetItem(TradeSlots slot) const;
-        bool HasItem(ObjectGuid item_guid) const;
-
-        uint32 GetSpell() const { return m_spell; }
-        Item*  GetSpellCastItem() const;
-        bool HasSpellCastItem() const { return !m_spellCastItem.IsEmpty(); }
-
-        uint32 GetMoney() const { return m_money; }
-
-        bool IsAccepted() const { return m_accepted; }
-        bool IsInAcceptProcess() const { return m_acceptProccess; }
-    public:                                                 // access functions
-
-        void SetItem(TradeSlots slot, Item* item);
-        void SetSpell(uint32 spell_id, Item* castItem = NULL);
-        void SetMoney(uint32 money);
+    explicit TradeData(Player* tradeWith)
+        : m_tradeWith(tradeWith), m_acceptedTrade(false), m_tradeGold(0), m_tradeSpell(0) {}
 
-        void SetAccepted(bool state, bool crosssend = false);
+    Player*    m_tradeWith;
+    bool       m_acceptedTrade;
+    uint32     m_tradeGold;
+    uint32     m_tradeSpell;
+    ObjectGuid m_tradeItems[TRADE_SLOT_COUNT];
 
-        // must be called only from accept handler helper functions
-        void SetInAcceptProcess(bool state) { m_acceptProccess = state; }
-
-    private:                                                // internal functions
-
-        void Update(bool for_trader = true);
-
-    private:                                                // fields
-
-        Player*    m_player;                                // Player who own of this TradeData
-        Player*    m_trader;                                // Player who trade with m_player
-
-        bool       m_accepted;                              // m_player press accept for trade list
-        bool       m_acceptProccess;                        // one from player/trader press accept and this processed
-
-        uint32     m_money;                                 // m_player place money to trade
-
-        uint32     m_spell;                                 // m_player apply spell to non-traded slot item
-        ObjectGuid m_spellCastItem;                         // applied spell casted by item use
-
-        ObjectGuid m_items[TRADE_SLOT_COUNT];               // traded itmes from m_player side including non-traded slot
+    bool HasItem(ObjectGuid item_guid) const
+    {
+        for(int i = 0; i < TRADE_SLOT_COUNT; ++i)
+            if (m_tradeItems[i] == item_guid)
+                return true;
+        return false;
+    }
 };
 
 class MANGOS_DLL_SPEC Player : public Unit
@@ -1237,7 +1213,7 @@ class MANGOS_DLL_SPEC Player : public Unit
         bool IsValidPos( uint8 bag, uint8 slot, bool explicit_pos ) const;
         uint8 GetBankBagSlotCount() const { return GetByteValue(PLAYER_BYTES_2, 2); }
         void SetBankBagSlotCount(uint8 count) { SetByteValue(PLAYER_BYTES_2, 2, count); }
-        bool HasItemCount( uint32 item, uint32 count, bool inBankAlso = false) const;
+        bool HasItemCount( uint32 item, uint32 count, bool inBankAlso = false ) const;
         bool HasItemFitToSpellReqirements(SpellEntry const* spellInfo, Item const* ignoreItem = NULL);
         bool CanNoReagentCast(SpellEntry const* spellInfo) const;
         bool HasItemOrGemWithIdEquipped( uint32 item, uint32 count, uint8 except_slot = NULL_SLOT) const;
@@ -1280,6 +1256,97 @@ class MANGOS_DLL_SPEC Player : public Unit
         void AutoStoreLoot(uint8 bag, uint8 slot, uint32 loot_id, LootStore const& store, bool broadcast = false);
         void AutoStoreLoot(uint32 loot_id, LootStore const& store, bool broadcast = false) { AutoStoreLoot(NULL_BAG,NULL_SLOT,loot_id,store,broadcast); }
 
+        /// Flying mounts everywhere mode
+        void FlyingMountsSpellsToItems();
+        bool CanUseFlyingMounts(SpellEntry const* spellInfo);
+        //helpers
+        bool isFlyingSpell(SpellEntry const* spellInfo) const
+        {
+            return spellInfo->EffectApplyAuraName[0]==SPELL_AURA_MOUNTED && 
+            spellInfo->EffectApplyAuraName[1]==SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED && 
+            spellInfo->EffectApplyAuraName[2]==SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED;
+        }
+
+        bool isRunningSpell(SpellEntry const* spellInfo) const
+        {
+            return spellInfo->EffectApplyAuraName[0]==SPELL_AURA_MOUNTED &&
+            spellInfo->EffectApplyAuraName[1]==SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED; 
+        }
+
+        bool isFlyingFormSpell(SpellEntry const* spellInfo) const
+        { 
+            return spellInfo->EffectApplyAuraName[0]==SPELL_AURA_MOD_SHAPESHIFT && 
+            spellInfo->EffectApplyAuraName[1]==SPELL_AURA_MECHANIC_IMMUNITY &&
+            spellInfo->EffectApplyAuraName[2]==SPELL_AURA_FLY;
+        }
+
+        bool isRunningFormSpell(SpellEntry const* spellInfo) const
+        { 
+            return spellInfo->EffectApplyAuraName[0]==SPELL_AURA_MOD_SHAPESHIFT &&
+            spellInfo->EffectApplyAuraName[1]==SPELL_AURA_MECHANIC_IMMUNITY &&
+            spellInfo->EffectApplyAuraName[2]!=SPELL_AURA_FLY;
+        }
+
+        void RemoveFlyingSpells()
+        { 
+            Unmount(); 
+            RemoveSpellsCausingAura(SPELL_AURA_MOUNTED); 
+            RemoveSpellsCausingAura(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED);
+            RemoveSpellsCausingAura(SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED);
+        }
+
+        void RemoveFlyingFormSpells()
+        { 
+            RemoveSpellsCausingAura(SPELL_AURA_MOD_SHAPESHIFT);
+            RemoveSpellsCausingAura(SPELL_AURA_MECHANIC_IMMUNITY);
+            RemoveSpellsCausingAura(SPELL_AURA_FLY);
+        }
+
+        void RemoveRunningFormSpells()
+        { 
+            RemoveSpellsCausingAura(SPELL_AURA_MOD_SHAPESHIFT);
+            RemoveSpellsCausingAura(SPELL_AURA_MECHANIC_IMMUNITY);
+        }
+
+        void RemoveAllFlyingSpells()
+        {
+            RemoveFlyingSpells();
+            RemoveFlyingFormSpells();
+        }
+
+        bool HasAuraTypeFlyingSpell()
+        {
+            return HasAuraType(SPELL_AURA_MOUNTED) &&
+            HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED) &&
+            HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED);
+        }
+
+        bool HasAuraTypeFlyingFormSpell()
+        {
+            return HasAuraType(SPELL_AURA_MOD_SHAPESHIFT) &&
+            HasAuraType(SPELL_AURA_MECHANIC_IMMUNITY) &&
+            HasAuraType(SPELL_AURA_FLY);
+        }
+
+        bool HasAuraTypeRunningFormSpell()
+        {
+            return HasAuraType(SPELL_AURA_MOD_SHAPESHIFT) &&
+            HasAuraType(SPELL_AURA_MECHANIC_IMMUNITY) &&
+            !HasAuraType(SPELL_AURA_FLY);
+        }
+
+        bool GetFlyingMountTimer()
+        {
+            return m_flytimer < time(NULL);
+        }
+
+        void SetFlyingMountTimer()
+        {
+            m_flytimer = time(NULL) + 0.5;
+        }
+        //end of helpers.
+        ///end of Flying mounts everywhere mode
+
         uint8 _CanTakeMoreSimilarItems(uint32 entry, uint32 count, Item* pItem, uint32* no_space_count = NULL) const;
         uint8 _CanStoreItem( uint8 bag, uint8 slot, ItemPosCountVec& dest, uint32 entry, uint32 count, Item *pItem = NULL, bool swap = false, uint32* no_space_count = NULL ) const;
 
@@ -1334,10 +1401,9 @@ class MANGOS_DLL_SPEC Player : public Unit
         bool BuyItemFromVendorSlot(uint64 vendorguid, uint32 vendorslot, uint32 item, uint8 count, uint8 bag, uint8 slot);
 
         float GetReputationPriceDiscount( Creature const* pCreature ) const;
-
-        Player* GetTrader() const { return m_trade ? m_trade->GetTrader() : NULL; }
-        TradeData* GetTradeData() const { return m_trade; }
+        Player* GetTrader() const { return m_trade ? m_trade->m_tradeWith : NULL; }
         void TradeCancel(bool sendback);
+        Item* GetItemByTradeSlot(uint32 slot) const { return m_trade && !m_trade->m_tradeItems[slot].IsEmpty() ? GetItemByGuid(m_trade->m_tradeItems[slot]) : NULL; }
 
         void UpdateEnchantTime(uint32 time);
         void UpdateItemDuration(uint32 time, bool realtimeonly=false);
@@ -1494,8 +1560,11 @@ class MANGOS_DLL_SPEC Player : public Unit
 
         bool LoadFromDB(uint32 guid, SqlQueryHolder *holder);
 
+        void Initialize(uint32 guid);                      // AHBot
+
         static uint32 GetZoneIdFromDB(uint64 guid);
         static uint32 GetLevelFromDB(uint64 guid);
+        static uint32 GetGMLevelFromDB(uint64 guid);
         static bool   LoadPositionFromDB(uint32& mapid, float& x,float& y,float& z,float& o, bool& in_flight, uint64 guid);
 
         /*********************************************************/
@@ -1505,8 +1574,12 @@ class MANGOS_DLL_SPEC Player : public Unit
         void SaveToDB();
         void SaveInventoryAndGoldToDB();                    // fast save function for item/money cheating preventing
         void SaveGoldToDB();
+        void SaveDataFieldToDB();
+        static bool SaveValuesArrayInDB(Tokens const& data,uint64 guid);
         static void SetUInt32ValueInArray(Tokens& data,uint16 index, uint32 value);
         static void SetFloatValueInArray(Tokens& data,uint16 index, float value);
+        static void SetUInt32ValueInDB(uint16 index, uint32 value, uint64 guid);
+        static void SetFloatValueInDB(uint16 index, float value, uint64 guid);
         static void Customize(uint64 guid, uint8 gender, uint8 skin, uint8 face, uint8 hairStyle, uint8 hairColor, uint8 facialHair);
         static void SavePositionInDB(uint32 mapid, float x,float y,float z,float o,uint32 zone,uint64 guid);
 
@@ -1700,6 +1773,11 @@ class MANGOS_DLL_SPEC Player : public Unit
         uint32 GetLastPotionId() { return m_lastPotionId; }
         void UpdatePotionCooldown(Spell* spell = NULL);
 
+        // global cooldown
+        void AddGlobalCooldown(SpellEntry const *spellInfo, Spell *spell);
+        bool HasGlobalCooldown(SpellEntry const *spellInfo) const;
+        void RemoveGlobalCooldown(SpellEntry const *spellInfo);
+
         void setResurrectRequestData(uint64 guid, uint32 mapId, float X, float Y, float Z, uint32 health, uint32 mana)
         {
             m_resurrectGUID = guid;
@@ -1891,7 +1969,7 @@ class MANGOS_DLL_SPEC Player : public Unit
         void SendMessageToSet(WorldPacket *data, bool self);// overwrite Object::SendMessageToSet
         void SendMessageToSetInRange(WorldPacket *data, float fist, bool self);
                                                             // overwrite Object::SendMessageToSetInRange
-        void SendMessageToSetInRange(WorldPacket *data, float dist, bool self, bool own_team_only);
+        void SendMessageToSetInRange(WorldPacket *data, float dist, bool self, bool own_team_only, bool enemy_team_only = false);
 
         Corpse *GetCorpse() const;
         void SpawnCorpseBones();
@@ -1953,6 +2031,7 @@ class MANGOS_DLL_SPEC Player : public Unit
 
         static uint32 TeamForRace(uint8 race);
         uint32 GetTeam() const { return m_team; }
+        TeamId GetTeamId() const { return m_team == ALLIANCE ? TEAM_ALLIANCE : TEAM_HORDE; }
         static uint32 getFactionForRace(uint8 race);
         void setFactionForRace(uint8 race);
 
@@ -1985,6 +2064,7 @@ class MANGOS_DLL_SPEC Player : public Unit
         void ModifyHonorPoints( int32 value );
         void ModifyArenaPoints( int32 value );
         uint32 GetMaxPersonalArenaRatingRequirement(uint32 minarenaslot);
+        void RewardHonorEndBattlegroud( bool win);
 
         //End of PvP System
 
@@ -2022,6 +2102,9 @@ class MANGOS_DLL_SPEC Player : public Unit
         void _ApplyWeaponDependentAuraCritMod(Item *item, WeaponAttackType attackType, Aura* aura, bool apply);
         void _ApplyWeaponDependentAuraDamageMod(Item *item, WeaponAttackType attackType, Aura* aura, bool apply);
 
+        ///PVP Token
+        void ReceiveToken();
+        
         void _ApplyItemMods(Item *item,uint8 slot,bool apply);
         void _RemoveAllItemMods();
         void _ApplyAllItemMods();
@@ -2162,6 +2245,25 @@ class MANGOS_DLL_SPEC Player : public Unit
         bool CanUseBattleGroundObject();
         bool isTotalImmune();
         bool CanCaptureTowerPoint();
+        
+        bool FirstBGDone() { return m_FirstBGTime > 0; }
+        void SetFirstBGTime()
+        {
+            m_FirstBGTime = uint64(time(NULL));
+            m_FirstBattleground = true;
+        }
+        void ResetBGStatus() { m_FirstBGTime = 0; }
+
+        /*********************************************************/
+        /***               OUTDOOR PVP SYSTEM                  ***/
+        /*********************************************************/
+
+        OutdoorPvP * GetOutdoorPvP() const;
+        // returns true if the player is in active state for outdoor pvp objective capturing, false otherwise
+        bool IsOutdoorPvPActive();
+
+        bool GetRandomWinner() { return m_IsBGRandomWinner; }
+        void SetRandomWinner(bool isWinner);
 
         /*********************************************************/
         /***                    REST SYSTEM                    ***/
@@ -2177,6 +2279,26 @@ class MANGOS_DLL_SPEC Player : public Unit
         /*********************************************************/
 
         uint32 EnvironmentalDamage(EnviromentalDamage type, uint32 damage);
+        
+        // Jail by WarHead
+       // ---------------
+       // Char datas...
+        bool m_jail_warning;
+         bool m_jail_amnestie;
+         bool m_jail_isjailed;           // Is this player jailed?
+         std::string m_jail_char;        // Name of jailed char
+         uint32 m_jail_guid;             // guid of the jailed char
+         uint32 m_jail_release;          // When is the player a free man/woman?
+         std::string m_jail_reason;      // Why was the char jailed?
+         uint32 m_jail_times;			// How often was the player jailed?
+         uint32 m_jail_amnestietime;
+        uint32 m_jail_gmacc;            // Used GM acc
+         std::string m_jail_gmchar;      // Used GM char
+         std::string m_jail_lasttime;    // Last jail time
+         uint32 m_jail_duration;         // Duration of the jail
+        // Load / save functions...
+         void _LoadJail(void);           // Loads the jail datas
+         void _SaveJail(void);           // Saves the jail datas
 
         /*********************************************************/
         /***               FLOOD FILTER SYSTEM                 ***/
@@ -2192,6 +2314,10 @@ class MANGOS_DLL_SPEC Player : public Unit
         bool HasMovementFlag(MovementFlags f) const;        // for script access to m_movementInfo.HasMovementFlag
         void UpdateFallInformationIfNeed(MovementInfo const& minfo,uint16 opcode);
         Unit *m_mover;
+        Unit *m_mover_in_queve;
+
+        void SetMoverInQueve(Unit* pet) {m_mover_in_queve = pet ? pet : this; }
+
         void SetFallInformation(uint32 time, float z)
         {
             m_lastFallTime = time;
@@ -2204,15 +2330,19 @@ class MANGOS_DLL_SPEC Player : public Unit
         bool isMoving() const { return m_movementInfo.HasMovementFlag(movementFlagsMask); }
         bool isMovingOrTurning() const { return m_movementInfo.HasMovementFlag(movementOrTurningFlagsMask); }
 
-        bool CanFly() const { return m_movementInfo.HasMovementFlag(MOVEFLAG_CAN_FLY); }
+        uint32 Anti__GetLastTeleTime() const { return m_anti_TeleTime; }
+        void Anti__SetLastTeleTime(uint32 TeleTime) { m_anti_TeleTime=TeleTime; }
+        //bool CanFly() const { return m_movementInfo.HasMovementFlag(MOVEFLAG_CAN_FLY); }
+        bool CanFly() const { return m_CanFly;  }
+        void SetCanFly(bool CanFly) { m_CanFly=CanFly; }
         bool IsFlying() const { return m_movementInfo.HasMovementFlag(MOVEFLAG_FLYING); }
         bool IsKnowHowFlyIn(uint32 mapid, uint32 zone, uint32 area) const;
 
         void SetClientControl(Unit* target, uint8 allowMove);
         void SetMover(Unit* target) { m_mover = target ? target : this; }
 
-        void EnterVehicle(Vehicle *vehicle);
-        void ExitVehicle(Vehicle *vehicle);
+        // vehicle system
+        void SendEnterVehicle(Vehicle *vehicle, VehicleSeatEntry const *veSeat);
 
         uint64 GetFarSight() const { return GetUInt64Value(PLAYER_FARSIGHT); }
         void SetFarSightGUID(uint64 guid);
@@ -2301,6 +2431,10 @@ class MANGOS_DLL_SPEC Player : public Unit
         void SendSavedInstances();
         static void ConvertInstancesToGroup(Player *player, Group *group = NULL, uint64 player_guid = 0);
 
+        // last used pet number (for BG's)
+        uint32 GetLastPetNumber() const { return m_lastpetnumber; }
+        void SetLastPetNumber(uint32 petnumber) { m_lastpetnumber = petnumber; }
+
         /*********************************************************/
         /***                   GROUP SYSTEM                    ***/
         /*********************************************************/
@@ -2314,8 +2448,6 @@ class MANGOS_DLL_SPEC Player : public Unit
         uint8 GetSubGroup() const { return m_group.getSubGroup(); }
         uint32 GetGroupUpdateFlag() const { return m_groupUpdateMask; }
         void SetGroupUpdateFlag(uint32 flag) { m_groupUpdateMask |= flag; }
-        const uint64& GetAuraUpdateMask() const { return m_auraUpdateMask; }
-        void SetAuraUpdateMask(uint8 slot) { m_auraUpdateMask |= (uint64(1) << slot); }
         Player* GetNextRandomRaidMember(float radius);
         PartyResult CanUninviteFromGroup() const;
         // BattleGround Group System
@@ -2349,12 +2481,23 @@ class MANGOS_DLL_SPEC Player : public Unit
 
         AchievementMgr& GetAchievementMgr() { return m_achievementMgr; }
         void UpdateAchievementCriteria(AchievementCriteriaTypes type, uint32 miscvalue1=0, uint32 miscvalue2=0, Unit *unit=NULL, uint32 time=0);
+        void CompletedAchievement(AchievementEntry const* entry);
         bool HasTitle(uint32 bitIndex);
         bool HasTitle(CharTitlesEntry const* title) { return HasTitle(title->bit_index); }
         void SetTitle(CharTitlesEntry const* title, bool lost = false);
 
         bool isActiveObject() const { return true; }
         bool canSeeSpellClickOn(Creature const* creature) const;
+
+        // Playerbot mod:
+        // A Player can either have a playerbotMgr (to manage its bots), or have playerbotAI (if it is a bot), or
+        // neither. Code that enables bots must create the playerbotMgr and set it using SetPlayerbotMgr.
+        void SetPlayerbotAI(PlayerbotAI* ai) { assert(!m_playerbotAI && !m_playerbotMgr); m_playerbotAI=ai; }
+        PlayerbotAI* GetPlayerbotAI() { return m_playerbotAI; }
+        void SetPlayerbotMgr(PlayerbotMgr* mgr) { assert(!m_playerbotAI && !m_playerbotMgr); m_playerbotMgr=mgr; }
+        PlayerbotMgr* GetPlayerbotMgr() { return m_playerbotMgr; }
+        void SetBotDeathTimer() { m_deathTimer = 0; }
+
     protected:
 
         uint32 m_contestedPvPTimer;
@@ -2375,6 +2518,8 @@ class MANGOS_DLL_SPEC Player : public Unit
         BgBattleGroundQueueID_Rec m_bgBattleGroundQueueID[PLAYER_MAX_BATTLEGROUND_QUEUES];
         BGData                    m_bgData;
 
+        bool m_IsBGRandomWinner;
+
         /*********************************************************/
         /***                    QUEST SYSTEM                   ***/
         /*********************************************************/
@@ -2400,6 +2545,7 @@ class MANGOS_DLL_SPEC Player : public Unit
         void _LoadQuestStatus(QueryResult *result);
         void _LoadDailyQuestStatus(QueryResult *result);
         void _LoadWeeklyQuestStatus(QueryResult *result);
+        void _LoadRandomBGStatus(QueryResult *result);
         void _LoadGroup(QueryResult *result);
         void _LoadSkills(QueryResult *result);
         void _LoadSpells(QueryResult *result);
@@ -2410,6 +2556,7 @@ class MANGOS_DLL_SPEC Player : public Unit
         void _LoadArenaTeamInfo(QueryResult *result);
         void _LoadEquipmentSets(QueryResult *result);
         void _LoadBGData(QueryResult* result);
+        void _LoadBGStatus(QueryResult* result);
         void _LoadGlyphs(QueryResult *result);
         void _LoadIntoDataField(const char* data, uint32 startOffset, uint32 count);
 
@@ -2428,6 +2575,7 @@ class MANGOS_DLL_SPEC Player : public Unit
         void _SaveSpells();
         void _SaveEquipmentSets();
         void _SaveBGData();
+        void _SaveBGStatus();
         void _SaveGlyphs();
         void _SaveTalents();
         void _SaveStats();
@@ -2484,6 +2632,7 @@ class MANGOS_DLL_SPEC Player : public Unit
         PlayerSpellMap m_spells;
         PlayerTalentMap m_talents[MAX_TALENT_SPEC_COUNT];
         SpellCooldowns m_spellCooldowns;
+        std::map<uint32, uint32> m_globalCooldowns;         // whole start recovery category stored in one
         uint32 m_lastPotionId;                              // last used health/mana potion in combat, that block next potion use
 
         uint8 m_activeSpec;
@@ -2521,6 +2670,7 @@ class MANGOS_DLL_SPEC Player : public Unit
 
         bool   m_DailyQuestChanged;
         bool   m_WeeklyQuestChanged;
+        bool   m_FirstBattleground;
 
         uint32 m_drunkTimer;
         uint16 m_drunk;
@@ -2532,6 +2682,7 @@ class MANGOS_DLL_SPEC Player : public Unit
 
         uint32 m_deathTimer;
         time_t m_deathExpireTime;
+        time_t m_flytimer;
 
         uint32 m_restTime;
 
@@ -2551,6 +2702,16 @@ class MANGOS_DLL_SPEC Player : public Unit
         RestType rest_type;
         ////////////////////Rest System/////////////////////
 
+        //movement anticheat
+        uint32 m_anti_lastmovetime;     //last movement time
+        float  m_anti_MovedLen;         //Length of traveled way
+        uint32 m_anti_NextLenCheck;
+        float  m_anti_BeginFallZ;    //alternative falling begin
+        uint32 m_anti_lastalarmtime;    //last time when alarm generated
+        uint32 m_anti_alarmcount;       //alarm counter
+        uint32 m_anti_TeleTime;
+        bool m_CanFly;
+
         // Transports
         Transport * m_transport;
 
@@ -2567,10 +2728,12 @@ class MANGOS_DLL_SPEC Player : public Unit
         GroupReference m_originalGroup;
         Group *m_groupInvite;
         uint32 m_groupUpdateMask;
-        uint64 m_auraUpdateMask;
 
         uint64 m_miniPet;
 
+        // last used pet number (for BG's)
+        uint32 m_lastpetnumber;
+
         // Player summoning
         time_t m_summon_expire;
         uint32 m_summon_mapid;
@@ -2606,6 +2769,10 @@ class MANGOS_DLL_SPEC Player : public Unit
         GridReference<Player> m_gridRef;
         MapReference m_mapRef;
 
+         // Playerbot mod:
+        PlayerbotAI* m_playerbotAI;
+    PlayerbotMgr* m_playerbotMgr;
+
         // Homebind coordinates
         uint32 m_homebindMapId;
         uint16 m_homebindAreaId;
@@ -2639,11 +2806,20 @@ class MANGOS_DLL_SPEC Player : public Unit
 
         AchievementMgr m_achievementMgr;
         ReputationMgr  m_reputationMgr;
-
         uint32 m_timeSyncCounter;
         uint32 m_timeSyncTimer;
         uint32 m_timeSyncClient;
         uint32 m_timeSyncServer;
+        
+        // Battleground reward system
+        uint32 m_FirstBGTime;
+        
+        // per character gm levels
+    public:
+        int32 GetSecurity() { return m_GMLevel; }
+        void SetSecurity(int32 gmlevel) { m_GMLevel = gmlevel; m_session->SetSecurity(AccountTypes(m_GMLevel)); }
+    private:
+        int32 m_GMLevel;
 };
 
 void AddItemsSetItem(Player*player,Item *item);
diff --git a/Core/src/game/PlayerbotAI.cpp b/Core/src/game/PlayerbotAI.cpp
new file mode 100644
index 0000000..84efc33
--- /dev/null
+++ b/Core/src/game/PlayerbotAI.cpp
@@ -0,0 +1,3341 @@
+#include "Common.h"
+#include "Database/DatabaseEnv.h"
+#include "ItemPrototype.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotMgr.h"
+#include "PlayerbotDeathKnightAI.h"
+#include "PlayerbotDruidAI.h"
+#include "PlayerbotHunterAI.h"
+#include "PlayerbotMageAI.h"
+#include "PlayerbotPaladinAI.h"
+#include "PlayerbotPriestAI.h"
+#include "PlayerbotRogueAI.h"
+#include "PlayerbotShamanAI.h"
+#include "PlayerbotWarlockAI.h"
+#include "PlayerbotWarriorAI.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "Chat.h"
+#include "WorldPacket.h"
+#include "Spell.h"
+#include "Unit.h"
+#include "SpellAuras.h"
+#include "SharedDefines.h"
+#include "Log.h"
+#include "GossipDef.h"
+
+// returns a float in range of..
+float rand_float(float low, float high)
+{
+    return (rand() / (static_cast<float> (RAND_MAX) + 1.0)) * (high - low) + low;
+}
+
+/*
+ * Packets often compress the GUID (global unique identifier)
+ * This function extracts the guid from the packet and decompresses it.
+ * The first word (8 bits) in the packet represents how many words in the following packet(s) are part of
+ * the guid and what weight they hold. I call it the mask. For example) if mask is 01001001,
+ * there will be only 3 words. The first word is shifted to the left 0 times,
+ * the second is shifted 3 times, and the third is shifted 6.
+ *
+ * Possibly use ByteBuffer::readPackGUID?
+ */
+uint64 extractGuid(WorldPacket& packet)
+{
+    uint8 mask;
+    packet >> mask;
+    uint64 guid = 0;
+    uint8 bit = 0;
+    uint8 testMask = 1;
+    while (true)
+    {
+        if (mask & testMask)
+        {
+            uint8 word;
+            packet >> word;
+            guid += (word << bit);
+        }
+        if (bit == 7)
+            break;
+        ++bit;
+        testMask <<= 1;
+    }
+    return guid;
+}
+
+// ChatHandler already implements some useful commands the master can call on bots
+// These commands are protected inside the ChatHandler class so this class provides access to the commands
+// we'd like to call on our bots
+class PlayerbotChatHandler: protected ChatHandler
+{
+public:
+    explicit PlayerbotChatHandler(Player* pMasterPlayer) : ChatHandler(pMasterPlayer) {}
+    bool revive(const Player& botPlayer) { return HandleReviveCommand(botPlayer.GetName()); }
+    bool teleport(const Player& botPlayer) { return HandleNamegoCommand(botPlayer.GetName()); }
+    void sysmessage(const char *str) { SendSysMessage(str); }
+    bool dropQuest(const char *str) { return HandleQuestRemove(str); }
+};
+
+PlayerbotAI::PlayerbotAI(PlayerbotMgr* const mgr, Player* const bot) :
+    m_mgr(mgr), m_bot(bot), m_ignoreAIUpdatesUntilTime(0),
+    m_combatOrder(ORDERS_NONE), m_ScenarioType(SCENARIO_PVEEASY),
+    m_TimeDoneEating(0), m_TimeDoneDrinking(0),
+    m_CurrentlyCastingSpellId(0), m_spellIdCommand(0),
+	m_targetGuidCommand(0), m_classAI(0) {
+
+    // set bot state and needed item list
+    m_botState = BOTSTATE_NORMAL;
+    SetQuestNeedItems();
+
+	// reset some pointers
+    m_targetChanged = false;
+    m_targetType = TARGET_NORMAL;
+	m_targetCombat = 0;
+	m_targetAssist = 0;
+	m_targetProtect = 0;
+
+	// start following master (will also teleport bot to master)
+	SetMovementOrder( MOVEMENT_FOLLOW, GetMaster() );
+
+    // get class specific ai
+    switch (m_bot->getClass())
+    {
+        case CLASS_PRIEST:
+			m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI*) new PlayerbotPriestAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_MAGE:
+			m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI*) new PlayerbotMageAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_WARLOCK:
+			m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI*) new PlayerbotWarlockAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_WARRIOR:
+			m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI*) new PlayerbotWarriorAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_SHAMAN:
+			m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI*) new PlayerbotShamanAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_PALADIN:
+			m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI*) new PlayerbotPaladinAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_ROGUE:
+			m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI*) new PlayerbotRogueAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_DRUID:
+			m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI*) new PlayerbotDruidAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_HUNTER:
+			m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI*)new PlayerbotHunterAI(GetMaster(), m_bot, this);
+            break;
+        case CLASS_DEATH_KNIGHT:
+			m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI*)new PlayerbotDeathKnightAI(GetMaster(), m_bot, this);
+            break;
+    }
+}
+
+PlayerbotAI::~PlayerbotAI()
+{
+    if (m_classAI) delete m_classAI;
+}
+
+Player* PlayerbotAI::GetMaster() const
+{
+    return m_mgr->GetMaster();
+}
+
+// finds spell ID for matching substring args
+// in priority of full text match, spells not taking reagents, and highest rank
+uint32 PlayerbotAI::getSpellId(const char* args, bool master) const
+{
+    if (!*args)
+        return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart))
+        return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+    int loc = 0;
+	if (master)
+		loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+	else
+		loc = m_bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundExactMatch = false;
+    bool foundMatchUsesNoReagents = false;
+
+    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        if (itr->second.state == PLAYERSPELL_REMOVED || itr->second.disabled || IsPassiveSpell(spellId))
+            continue;
+
+        const SpellEntry* pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if (name.empty() || !Utf8FitTo(name, wnamepart))
+            continue;
+
+        bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0) ? true : false;
+
+        // if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0)
+        {
+            if (isExactMatch && !foundExactMatch) {}
+            else if (usesNoReagents && !foundMatchUsesNoReagents) {}
+            else if (spellId > foundSpellId) {}
+            else
+                useThisSpell = false;
+        }
+        if (useThisSpell)
+        {
+            foundSpellId = spellId;
+            foundExactMatch = isExactMatch;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+
+    return foundSpellId;
+}
+
+/*
+ * Send a list of equipment that is in bot's inventor that is currently unequipped.
+ * This is called when the master is inspecting the bot.
+ */
+
+void PlayerbotAI::SendNotEquipList(Player& player)
+{
+    // find all unequipped items and put them in
+    // a vector of dynamically created lists where the vector index is from 0-18
+    // and the list contains Item* that can be equipped to that slot
+    // Note: each dynamically created list in the vector must be deleted at end
+    // so NO EARLY RETURNS!
+    // see enum EquipmentSlots in Player.h to see what equipment slot each index in vector
+    // is assigned to. (The first is EQUIPMENT_SLOT_HEAD=0, and last is EQUIPMENT_SLOT_TABARD=18)
+    std::list<Item*>* equip[19];
+    for (uint8 i = 0; i < 19; ++i)
+        equip[i] = NULL;
+
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        uint16 dest;
+        uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+        if (msg != EQUIP_ERR_OK)
+            continue;
+
+        // the dest looks like it includes the old loc in the 8 higher bits
+        // so casting it to a uint8 strips them
+        uint8 equipSlot = uint8(dest);
+        if (!(equipSlot >= 0 && equipSlot < 19))
+            continue;
+
+        // create a list if one doesn't already exist
+        if (equip[equipSlot] == NULL)
+            equip[equipSlot] = new std::list<Item*>;
+
+        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+        itemListForEqSlot->push_back(pItem);
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (!pItem)
+                    continue;
+
+                uint16 equipSlot;
+                uint8 msg = m_bot->CanEquipItem(NULL_SLOT, equipSlot, pItem, !pItem->IsBag());
+                if (msg != EQUIP_ERR_OK)
+                    continue;
+                if (!(equipSlot >= 0 && equipSlot < 19))
+                    continue;
+
+                // create a list if one doesn't already exist
+                if (equip[equipSlot] == NULL)
+                    equip[equipSlot] = new std::list<Item*>;
+
+                std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+                itemListForEqSlot->push_back(pItem);
+            }
+        }
+    }
+
+    TellMaster("Here's all the items in my inventory that I can equip.");
+    ChatHandler ch(GetMaster());
+
+    const std::string descr[] = { "head", "neck", "shoulders", "body", "chest",
+            "waist", "legs", "feet", "wrists", "hands", "finger1", "finger2",
+            "trinket1", "trinket2", "back", "mainhand", "offhand", "ranged",
+            "tabard" };
+
+    // now send client all items that can be equipped by slot
+    for (uint8 equipSlot = 0; equipSlot < 19; ++equipSlot)
+    {
+        if (equip[equipSlot] == NULL)
+            continue;
+        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+        std::ostringstream out;
+        out << descr[equipSlot] << ": ";
+        for (std::list<Item*>::iterator it = itemListForEqSlot->begin(); it != itemListForEqSlot->end(); ++it) {
+            const ItemPrototype* const pItemProto = (*it)->GetProto();
+
+            std::string itemName = pItemProto->Name1;
+            ItemLocalization(itemName, pItemProto->ItemId);
+
+            out << " |cffffffff|Hitem:" << pItemProto->ItemId
+                << ":0:0:0:0:0:0:0" << "|h[" << itemName
+                << "]|h|r";
+        }
+        ch.SendSysMessage(out.str().c_str());
+
+        delete itemListForEqSlot; // delete list of Item*
+    }
+}
+
+void PlayerbotAI::SendQuestItemList( Player& player )
+{
+    std::ostringstream out;
+
+    for( BotNeedItem::iterator itr=m_needItemList.begin(); itr!=m_needItemList.end(); ++itr )
+    {
+        const ItemPrototype * pItemProto = sObjectMgr.GetItemPrototype( itr->first );
+
+        std::string itemName = pItemProto->Name1;
+        ItemLocalization(itemName, pItemProto->ItemId);
+
+        out << " " << itr->second << "x|cffffffff|Hitem:" << pItemProto->ItemId
+            << ":0:0:0:0:0:0:0" << "|h[" << itemName
+            << "]|h|r";
+    }
+
+    TellMaster( "Here's a list of all items I need for quests:" );
+    TellMaster( out.str().c_str() );
+}
+
+void PlayerbotAI::SendOrders( Player& player )
+{
+	std::ostringstream out;
+
+	if( !m_combatOrder )
+		out << "Got no combat orders!";
+	else if( m_combatOrder&ORDERS_TANK )
+		out << "I TANK";
+	else if( m_combatOrder&ORDERS_ASSIST )
+		out << "I ASSIST " << (m_targetAssist?m_targetAssist->GetName():"unknown");
+	else if( m_combatOrder&ORDERS_HEAL )
+		out << "I HEAL";
+	if( (m_combatOrder&ORDERS_PRIMARY) && (m_combatOrder&ORDERS_SECONDARY) )
+		out << " and ";
+	if( m_combatOrder&ORDERS_PROTECT )
+		out << "I PROTECT " << (m_targetProtect?m_targetProtect->GetName():"unknown");
+    out << ".";
+
+    if( m_mgr->m_confDebugWhisper )
+    {
+	    out << " " << (IsInCombat()?"I'm in COMBAT! ":"Not in combat. ");
+        out << "Current state is ";
+        if( m_botState == BOTSTATE_NORMAL )
+            out << "NORMAL";
+        else if( m_botState == BOTSTATE_COMBAT )
+            out << "COMBAT";
+        else if( m_botState == BOTSTATE_DEAD )
+            out << "DEAD";
+        else if( m_botState == BOTSTATE_DEADRELEASED )
+            out << "RELEASED";
+        else if( m_botState == BOTSTATE_LOOTING )
+            out << "LOOTING";
+        out << ". Movement order is ";
+        if( m_movementOrder == MOVEMENT_NONE )
+            out << "NONE";
+        else if( m_movementOrder == MOVEMENT_FOLLOW )
+            out << "FOLLOW " << (m_followTarget?m_followTarget->GetName():"unknown");
+        else if( m_movementOrder == MOVEMENT_STAY )
+            out << "STAY";
+        out << ". Got " << m_attackerInfo.size() << " attacker(s) in list.";
+        out << " Next action in " << (m_ignoreAIUpdatesUntilTime-time(0)) << "sec.";
+    }
+
+	TellMaster( out.str().c_str() );
+}
+
+// handle outgoing packets the server would send to the client
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket& packet)
+{
+    switch (packet.GetOpcode())
+    {
+        case SMSG_DUEL_WINNER:
+        {
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_APPLAUD);
+            return;
+        }
+        case SMSG_DUEL_COMPLETE:
+        {
+            m_ignoreAIUpdatesUntilTime = time(0) + 4;
+            m_ScenarioType = SCENARIO_PVEEASY;
+            m_bot->GetMotionMaster()->Clear(true);
+            return;
+        }
+        case SMSG_DUEL_OUTOFBOUNDS:
+        {
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_CHICKEN);
+            return;
+        }
+        case SMSG_DUEL_REQUESTED:
+        {
+            m_ignoreAIUpdatesUntilTime = 0;
+            WorldPacket p(packet);
+            uint64 flagGuid;
+            p >> flagGuid;
+            uint64 playerGuid;
+            p >> playerGuid;
+            Player* const pPlayer = ObjectAccessor::FindPlayer(playerGuid);
+            if (canObeyCommandFrom(*pPlayer))
+            {
+                m_bot->GetMotionMaster()->Clear(true);
+                WorldPacket* const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+                *packet << flagGuid;
+                m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+
+                // follow target in casting range
+                float angle = rand_float(0, M_PI_F);
+                float dist = rand_float(4, 10);
+
+                m_bot->GetMotionMaster()->Clear(true);
+                m_bot->GetMotionMaster()->MoveFollow(pPlayer, dist, angle);
+
+                m_bot->SetSelection(playerGuid);
+                m_ignoreAIUpdatesUntilTime = time(0) + 4;
+                m_ScenarioType = SCENARIO_DUEL;
+            }
+            return;
+        }
+
+        case SMSG_INVENTORY_CHANGE_FAILURE:
+        {
+            TellMaster("I can't use that.");
+            return;
+        }
+        case SMSG_SPELL_FAILURE:
+        {
+            WorldPacket p(packet);
+            uint64 casterGuid = extractGuid(p);
+            if (casterGuid != m_bot->GetGUID())
+                return;
+            uint32 spellId;
+            p >> spellId;
+            if (m_CurrentlyCastingSpellId == spellId)
+            {
+                m_ignoreAIUpdatesUntilTime = time(0) + 1;
+                m_CurrentlyCastingSpellId = 0;
+            }
+            return;
+        }
+
+        // if a change in speed was detected for the master
+        // make sure we have the same mount status
+        case SMSG_FORCE_RUN_SPEED_CHANGE:
+        {
+            WorldPacket p(packet);
+            uint64 guid = extractGuid(p);
+            if (guid != GetMaster()->GetGUID())
+                return;
+            if (GetMaster()->IsMounted() && !m_bot->IsMounted())
+            {
+                //Player Part
+                if (!GetMaster()->GetAurasByType(SPELL_AURA_MOUNTED).empty())
+                {
+                    int32 master_speed1 = 0;
+                    int32 master_speed2 = 0;
+                    master_speed1 = GetMaster()->GetAurasByType(SPELL_AURA_MOUNTED).front()->GetSpellProto()->EffectBasePoints[1];
+                    master_speed2 = GetMaster()->GetAurasByType(SPELL_AURA_MOUNTED).front()->GetSpellProto()->EffectBasePoints[2];
+
+                    //Bot Part
+                    uint32 spellMount = 0;
+                    for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+                    {
+                        uint32 spellId = itr->first;
+                        if(itr->second.state == PLAYERSPELL_REMOVED || itr->second.disabled || IsPassiveSpell(spellId))
+                            continue;
+                        const SpellEntry* pSpellInfo = sSpellStore.LookupEntry(spellId);
+                        if (!pSpellInfo)
+                            continue;
+
+                        if(pSpellInfo->EffectApplyAuraName[0] == SPELL_AURA_MOUNTED)
+                        {
+                            if(pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                            {
+                                if(pSpellInfo->EffectBasePoints[1] == master_speed1)
+                                {
+                                    spellMount = spellId;
+                                    break;
+                                }
+                            }
+                            else if((pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                                && (pSpellInfo->EffectApplyAuraName[2] == SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED))
+                            {
+                                if((pSpellInfo->EffectBasePoints[1] == master_speed1)
+                                    && (pSpellInfo->EffectBasePoints[2] == master_speed2))
+                                {
+                                    spellMount = spellId;
+                                    break;
+                                }
+                            }
+                            else if((pSpellInfo->EffectApplyAuraName[2] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                                && (pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED))
+                            {
+                                if((pSpellInfo->EffectBasePoints[2] == master_speed2)
+                                    && (pSpellInfo->EffectBasePoints[1] == master_speed1))
+                                {
+                                    spellMount = spellId;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    if(spellMount > 0) m_bot->CastSpell(m_bot, spellMount, false);
+                }
+            }
+            else if (!GetMaster()->IsMounted() && m_bot->IsMounted())
+            {
+                WorldPacket emptyPacket;
+                m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);  //updated code
+            }
+            return;
+        }
+
+        // handle flying acknowledgement
+        case SMSG_MOVE_SET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid = extractGuid(p);
+            if (guid != m_bot->GetGUID())
+                return;
+			m_bot->m_movementInfo.AddMovementFlag(MOVEFLAG_FLYING);
+            //m_bot->SetSpeed(MOVE_RUN, GetMaster()->GetSpeed(MOVE_FLIGHT) +0.1f, true);
+            return;
+        }
+
+        // handle dismount flying acknowledgement
+        case SMSG_MOVE_UNSET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid = extractGuid(p);
+            if (guid != m_bot->GetGUID())
+                return;
+			m_bot->m_movementInfo.RemoveMovementFlag(MOVEFLAG_FLYING);
+            //m_bot->SetSpeed(MOVE_RUN,GetMaster()->GetSpeedRate(MOVE_RUN),true);
+            return;
+        }
+
+        // If the leader role was given to the bot automatically give it to the master
+        // if the master is in the group, otherwise leave group
+        case SMSG_GROUP_SET_LEADER:
+        {
+            WorldPacket p(packet);
+            std::string name;
+            p >> name;
+            if (m_bot->GetGroup() && name == m_bot->GetName())
+            {
+                if (m_bot->GetGroup()->IsMember(GetMaster()->GetGUID()))
+                {
+                    p.resize(8);
+                    p << GetMaster()->GetGUID();
+                    m_bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+                }
+                else
+                {
+                    p.clear(); // not really needed
+                    m_bot->GetSession()->HandleGroupDisbandOpcode(p); // packet not used updated code
+                }
+            }
+            return;
+        }
+
+        // If the master leaves the group, then the bot leaves too
+        case SMSG_PARTY_COMMAND_RESULT:
+        {
+            WorldPacket p(packet);
+            uint32 operation;
+            p >> operation;
+            std::string member;
+            p >> member;
+            uint32 result;
+            p >> result;
+            p.clear();
+            if (operation == PARTY_OP_LEAVE)
+            {
+                if (member == GetMaster()->GetName())
+                    m_bot->GetSession()->HandleGroupDisbandOpcode(p); // packet not used updated code
+            }
+            return;
+        }
+
+        // Handle Group invites (auto accept if master is in group, otherwise decline & send message
+        case SMSG_GROUP_INVITE:
+        {
+            if (m_bot->GetGroupInvite())
+            {
+                const Group* const grp = m_bot->GetGroupInvite();
+                if (!grp)
+                    return;
+
+                Player* const inviter = sObjectMgr.GetPlayer(grp->GetLeaderGUID());
+                if (!inviter)
+                    return;
+
+                WorldPacket p;
+                if (!canObeyCommandFrom(*inviter))
+                {
+                    std::string buf = "I can't accept your invite unless you first invite my master ";
+                    buf += GetMaster()->GetName();
+                    buf += ".";
+                    SendWhisper(buf, *inviter);
+                    m_bot->GetSession()->HandleGroupDeclineOpcode(p); // packet not used
+                }
+                else
+                    m_bot->GetSession()->HandleGroupAcceptOpcode(p); // packet not used
+            }
+            return;
+        }
+
+        // Handle when another player opens the trade window with the bot
+        // also sends list of tradable items bot can trade if bot is allowed to obey commands from
+        case SMSG_TRADE_STATUS:
+        {
+            if (m_bot->GetTrader() == NULL)
+                break;
+
+            WorldPacket p(packet);
+            uint32 status;
+            p >> status;
+            p.clear();
+
+            //4 == TRADE_STATUS_TRADE_ACCEPT
+            if (status == 4)
+                m_bot->GetSession()->HandleAcceptTradeOpcode(p); // packet not used
+
+            //1 == TRADE_STATUS_BEGIN_TRADE
+            else if (status == 1)
+            {
+                m_bot->GetSession()->HandleBeginTradeOpcode(p); // packet not used
+
+                if (!canObeyCommandFrom(*(m_bot->GetTrader())))
+                {
+                    SendWhisper("I'm not allowed to trade you any of my items, but you are free to give me money or items.", *(m_bot->GetTrader()));
+                    return;
+                }
+
+                // list out items available for trade
+                std::ostringstream out;
+
+                // list out items in main backpack
+                for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+                {
+                    const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                    if (pItem && pItem->CanBeTraded())
+                    {
+                        const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                        std::string itemName = pItemProto->Name1;
+                        ItemLocalization(itemName, pItemProto->ItemId);
+
+                        out << " |cffffffff|Hitem:" << pItemProto->ItemId
+                            << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        if (pItem->GetCount() > 1)
+                            out << "x" << pItem->GetCount() << ' ';
+                    }
+                }
+                // list out items in other removable backpacks
+                for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+                {
+                    const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                    if (pBag)
+                    {
+                        for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                        {
+                            const Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                            if (pItem && pItem->CanBeTraded())
+                            {
+                                const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                                std::string itemName = pItemProto->Name1;
+                                ItemLocalization(itemName, pItemProto->ItemId);
+
+                                // item link format: http://www.wowwiki.com/ItemString
+                                // itemId, enchantId, jewelId1, jewelId2, jewelId3, jewelId4, suffixId, uniqueId
+                                out << " |cffffffff|Hitem:" << pItemProto->ItemId
+                                    << ":0:0:0:0:0:0:0" << "|h[" << itemName
+                                    << "]|h|r";
+                                if (pItem->GetCount() > 1)
+                                    out << "x" << pItem->GetCount() << ' ';
+                            }
+                        }
+                    }
+                }
+
+                // calculate how much money bot has
+                uint32 copper = m_bot->GetMoney();
+                uint32 gold = uint32(copper / 10000);
+                copper -= (gold * 10000);
+                uint32 silver = uint32(copper / 100);
+                copper -= (silver * 100);
+
+                // send bot the message
+                std::ostringstream whisper;
+                whisper << "I have |cff00ff00" << gold
+                        << "|r|cfffffc00g|r|cff00ff00" << silver
+                        << "|r|cffcdcdcds|r|cff00ff00" << copper
+                        << "|r|cffffd333c|r" << " and the following items:";
+                SendWhisper(whisper.str().c_str(), *(m_bot->GetTrader()));
+                ChatHandler ch(m_bot->GetTrader());
+                ch.SendSysMessage(out.str().c_str());
+            }
+            return;
+        }
+
+        case SMSG_SPELL_GO:
+        {
+            WorldPacket p(packet);
+            uint64 castItemGuid = extractGuid(p);
+            uint64 casterGuid = extractGuid(p);
+            if (casterGuid != m_bot->GetGUID())
+                return;
+
+            uint32 spellId;
+            p >> spellId;
+            uint16 castFlags;
+            p >> castFlags;
+            uint32 msTime;
+            p >> msTime;
+            uint8 numHit;
+            p >> numHit;
+
+            if (m_CurrentlyCastingSpellId == spellId)
+            {
+                Spell* const pSpell = m_bot->FindCurrentSpellBySpellId(spellId);
+                if (!pSpell)
+                    return;
+
+                if (pSpell->IsChannelActive() || pSpell->IsAutoRepeat())
+                    m_ignoreAIUpdatesUntilTime = time(0) + (GetSpellDuration(pSpell->m_spellInfo) / 1000) + 1;
+                else if (pSpell->IsAutoRepeat())
+                    m_ignoreAIUpdatesUntilTime = time(0) + 6;
+                else
+                {
+                    m_ignoreAIUpdatesUntilTime = time(0) + 1;
+                    m_CurrentlyCastingSpellId = 0;
+                }
+            }
+            return;
+        }
+
+        /* uncomment this and your bots will tell you all their outgoing packet opcode names
+        case SMSG_MONSTER_MOVE:
+        case SMSG_UPDATE_WORLD_STATE:
+        case SMSG_COMPRESSED_UPDATE_OBJECT:
+        case MSG_MOVE_SET_FACING:
+        case MSG_MOVE_STOP:
+        case MSG_MOVE_HEARTBEAT:
+        case MSG_MOVE_STOP_STRAFE:
+        case MSG_MOVE_START_STRAFE_LEFT:
+        case SMSG_UPDATE_OBJECT:
+        case MSG_MOVE_START_FORWARD:
+        case MSG_MOVE_START_STRAFE_RIGHT:
+        case SMSG_DESTROY_OBJECT:
+        case MSG_MOVE_START_BACKWARD:
+        case SMSG_AURA_UPDATE_ALL:
+        case MSG_MOVE_FALL_LAND:
+        case MSG_MOVE_JUMP:
+            return;
+
+        default:
+        {
+            const char* oc = LookupOpcodeName(packet.GetOpcode());
+
+            std::ostringstream out;
+            out << "botout: " << oc;
+            sLog.outError(out.str().c_str());
+
+            //TellMaster(oc);
+        }
+        */
+    }
+}
+
+uint8 PlayerbotAI::GetHealthPercent(const Unit& target) const
+{
+    return (static_cast<float> (target.GetHealth()) / target.GetMaxHealth()) * 100;
+}
+
+uint8 PlayerbotAI::GetHealthPercent() const
+{
+    return GetHealthPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetManaPercent(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_MANA)) / target.GetMaxPower(POWER_MANA)) * 100;
+}
+
+uint8 PlayerbotAI::GetManaPercent() const
+{
+    return GetManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent(const Unit& target) const
+{
+    if (target.GetPower(POWER_MANA) >= target.GetCreateMana())
+        return (100);
+    else
+        return (static_cast<float> (target.GetPower(POWER_MANA)) / target.GetMaxPower(POWER_MANA)) * 100;
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent() const
+{
+    return GetBaseManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRageAmount(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_RAGE)));
+}
+
+uint8 PlayerbotAI::GetRageAmount() const
+{
+    return GetRageAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetEnergyAmount(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_ENERGY)));
+}
+
+uint8 PlayerbotAI::GetEnergyAmount() const
+{
+    return GetEnergyAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRunicPower(const Unit& target) const
+{
+    return (static_cast<float>(target.GetPower(POWER_RUNIC_POWER)));
+}
+
+uint8 PlayerbotAI::GetRunicPower() const
+{
+    return GetRunicPower(*m_bot);
+}
+
+//typedef std::pair<uint32, uint8> spellEffectPair;
+//typedef std::multimap<spellEffectPair, Aura*> AuraMap;
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit& player) const
+{
+    if(spellId <= 0)
+        return false;
+
+    for (Unit::AuraMap::const_iterator iter = player.GetAuras().begin(); iter != player.GetAuras().end(); ++iter)
+    {
+        if (iter->second->GetId() == spellId)
+            return true;
+    }
+    return false;
+}
+
+bool PlayerbotAI::HasAura(const char* spellName) const
+{
+    return HasAura(spellName, *m_bot);
+}
+
+bool PlayerbotAI::HasAura(const char* spellName, const Unit& player) const
+{
+    uint32 spellId = getSpellId(spellName);
+    return (spellId) ? HasAura(spellId, player) : false;
+}
+
+// looks through all items / spells that bot could have to get a mount
+Item* PlayerbotAI::FindMount(uint32 matchingRidingSkill) const
+{
+    // list out items in main backpack
+
+    Item* partialMatch = NULL;
+
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (!pItemProto || !m_bot->CanUseItem(pItemProto) || pItemProto->RequiredSkill != SKILL_RIDING)
+                continue;
+
+            if (pItemProto->RequiredSkillRank == matchingRidingSkill)
+                return pItem;
+
+            else if (!partialMatch || (partialMatch && partialMatch->GetProto()->RequiredSkillRank < pItemProto->RequiredSkillRank))
+                partialMatch = pItem;
+        }
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (!pItemProto || !m_bot->CanUseItem(pItemProto) || pItemProto->RequiredSkill != SKILL_RIDING)
+                        continue;
+
+                    if (pItemProto->RequiredSkillRank == matchingRidingSkill)
+                        return pItem;
+
+                    else if (!partialMatch || (partialMatch && partialMatch->GetProto()->RequiredSkillRank < pItemProto->RequiredSkillRank))
+                        partialMatch = pItem;
+                }
+            }
+        }
+    }
+    return partialMatch;
+}
+
+Item* PlayerbotAI::FindFood() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (!pItemProto || !m_bot->CanUseItem(pItemProto))
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
+            {
+                // if is FOOD
+                // this enum is no longer defined in mangos. Is it no longer valid?
+                // according to google it was 11
+                if (pItemProto->Spells[0].SpellCategory == 11)
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                    if (!pItemProto || !m_bot->CanUseItem(pItemProto))
+                        continue;
+
+                    // this enum is no longer defined in mangos. Is it no longer valid?
+                    // according to google it was 11
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
+                    {
+                        // if is FOOD
+                        // this enum is no longer defined in mangos. Is it no longer valid?
+                        // according to google it was 11
+                        // if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+                        if (pItemProto->Spells[0].SpellCategory == 11)
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindDrink() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+
+            if (!pItemProto || !m_bot->CanUseItem(pItemProto))
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
+            {
+                // if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK)
+
+                // this enum is no longer defined in mangos. Is it no longer valid?
+                // according to google it was 59
+                // if (pItemProto->Spells[0].SpellCategory == 59)
+                if (pItemProto->Spells[0].SpellCategory == 59)
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                    if (!pItemProto || !m_bot->CanUseItem(pItemProto))
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
+                    {
+                        // if is WATER
+                        // SPELL_CATEGORY_DRINK is no longer defined in an enum in mangos
+                        // google says the valus is 59. Is this still valid?
+                        // if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK)
+                        if (pItemProto->Spells[0].SpellCategory == 59)
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindBandage() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+
+            if (!pItemProto || !m_bot->CanUseItem(pItemProto))
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                    if (!pItemProto || !m_bot->CanUseItem(pItemProto))
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE)
+                        return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+//Find Poison ...Natsukawa
+Item* PlayerbotAI::FindPoison() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+
+            if (!pItemProto || !m_bot->CanUseItem(pItemProto))
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == 6)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                    if (!pItemProto || !m_bot->CanUseItem(pItemProto))
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == 6)
+                        return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+void PlayerbotAI::InterruptCurrentCastingSpell()
+{
+    //TellMaster("I'm interrupting my current spell!");
+    WorldPacket* const packet = new WorldPacket(CMSG_CANCEL_CAST, 5);  //changed from thetourist suggestion
+    *packet << m_CurrentlyCastingSpellId;
+    *packet << m_targetGuidCommand;   //changed from thetourist suggestion
+    m_CurrentlyCastingSpellId = 0;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+void PlayerbotAI::Feast()
+{
+    // stand up if we are done feasting
+    if (!(m_bot->GetHealth() < m_bot->GetMaxHealth() || (m_bot->getPowerType() == POWER_MANA && m_bot->GetPower(POWER_MANA) < m_bot->GetMaxPower(POWER_MANA))))
+    {
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        return;
+    }
+
+    // wait 3 seconds before checking if we need to drink more or eat more
+    time_t currentTime = time(0);
+    m_ignoreAIUpdatesUntilTime = currentTime + 3;
+
+    // should we drink another
+    if (m_bot->getPowerType() == POWER_MANA && currentTime > m_TimeDoneDrinking
+            && ((static_cast<float> (m_bot->GetPower(POWER_MANA)) / m_bot->GetMaxPower(POWER_MANA)) < 0.8))
+    {
+        Item* pItem = FindDrink();
+        if (pItem != NULL)
+        {
+            UseItem(*pItem);
+            m_TimeDoneDrinking = currentTime + 30;
+            return;
+        }
+        TellMaster("I need water.");
+    }
+
+    // should we eat another
+    if (currentTime > m_TimeDoneEating && ((static_cast<float> (m_bot->GetHealth()) / m_bot->GetMaxHealth()) < 0.8))
+    {
+        Item* pItem = FindFood();
+        if (pItem != NULL)
+        {
+            //TellMaster("eating now...");
+            UseItem(*pItem);
+            m_TimeDoneEating = currentTime + 30;
+            return;
+        }
+        TellMaster("I need food.");
+    }
+
+    // if we are no longer eating or drinking
+    // because we are out of items or we are above 80% in both stats
+    if (currentTime > m_TimeDoneEating && currentTime > m_TimeDoneDrinking)
+    {
+        TellMaster("done feasting!");
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+    }
+}
+
+// intelligently sets a reasonable combat order for this bot
+// based on its class / level / etc
+void PlayerbotAI::GetCombatTarget( Unit* forcedTarget )
+{
+    // set combat state, and clear looting, etc...
+    if( m_botState != BOTSTATE_COMBAT )
+    {
+        SetState( BOTSTATE_COMBAT );
+        SetQuestNeedItems();
+        m_lootCreature.clear();
+        m_lootCurrent = 0;
+		m_targetCombat = 0;
+    }
+
+    // update attacker info now
+    UpdateAttackerInfo();
+
+	// check for attackers on protected unit, and make it a forcedTarget if any
+	if( !forcedTarget && (m_combatOrder&ORDERS_PROTECT) && m_targetProtect!=0 )
+    {
+		Unit *newTarget = FindAttacker( (ATTACKERINFOTYPE)(AIT_VICTIMNOTSELF|AIT_HIGHESTTHREAT), m_targetProtect );
+        if( newTarget && newTarget!=m_targetCombat )
+        {
+            forcedTarget = newTarget;
+            m_targetType = TARGET_THREATEN;
+            if( m_mgr->m_confDebugWhisper )
+                TellMaster( "Changing target to %s to protect %s", forcedTarget->GetName(), m_targetProtect->GetName() );
+        }
+    } else if( forcedTarget )
+    {
+		if( m_mgr->m_confDebugWhisper )
+            TellMaster( "Changing target to %s by force!", forcedTarget->GetName() );
+        m_targetType = (m_combatOrder==ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+    }
+
+	// we already have a target and we are not forced to change it
+	if( m_targetCombat && !forcedTarget )
+		return;
+
+	// are we forced on a target?
+	if( forcedTarget )
+    {
+        m_targetCombat = forcedTarget;
+        m_targetChanged = true;
+    }
+	// do we have to assist someone?
+	if( !m_targetCombat && (m_combatOrder&ORDERS_ASSIST) && m_targetAssist!=0 )
+    {
+		m_targetCombat = FindAttacker( (ATTACKERINFOTYPE)(AIT_VICTIMNOTSELF|AIT_LOWESTTHREAT), m_targetAssist );
+        if( m_mgr->m_confDebugWhisper && m_targetCombat )
+            TellMaster( "Attacking %s to assist %s", m_targetCombat->GetName(), m_targetAssist->GetName() );
+        m_targetType = (m_combatOrder==ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+        m_targetChanged = true;
+    }
+	// are there any other attackers?
+	if( !m_targetCombat )
+    {
+		m_targetCombat = FindAttacker();
+        m_targetType = (m_combatOrder==ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+        m_targetChanged = true;
+    }
+	// no attacker found anyway
+    if (!m_targetCombat)
+    {
+        m_targetType = TARGET_NORMAL;
+        m_targetChanged = false;
+        return;
+    }
+
+    // if thing to attack is in a duel, then ignore and don't call updateAI for 6 seconds
+    // this method never gets called when the bot is in a duel and this code
+    // prevents bot from helping
+    if (m_targetCombat->GetTypeId() == TYPEID_PLAYER && dynamic_cast<Player*> (m_targetCombat)->duel)
+    {
+        m_ignoreAIUpdatesUntilTime = time(0) + 6;
+        return;
+    }
+
+    m_bot->SetSelection(m_targetCombat->GetGUID());
+    m_ignoreAIUpdatesUntilTime = time(0) + 1;
+
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    m_bot->Attack(m_targetCombat, true);
+
+    // add thingToAttack to loot list
+    m_lootCreature.push_back( m_targetCombat->GetGUID() );
+
+	// set movement generators for combat movement
+	MovementClear();
+    return;
+}
+
+void PlayerbotAI::DoNextCombatManeuver()
+{
+    // check for new targets
+	GetCombatTarget();
+	// check if we have a target - fixes crash reported by rrtn (kill hunter's pet bug)
+	// if current target for attacks doesn't make sense anymore
+    // clear our orders so we can get orders in next update
+    if( !m_targetCombat || m_targetCombat->isDead() || !m_targetCombat->IsInWorld() || !m_bot->IsHostileTo(m_targetCombat) )
+    {
+        m_bot->AttackStop();
+        m_bot->SetSelection(0);
+        MovementReset();
+        m_bot->InterruptNonMeleeSpells(true);
+		m_targetCombat = 0;
+        m_targetChanged = false;
+        m_targetType = TARGET_NORMAL;
+        return;
+    }
+
+    // do opening moves, if we changed target
+    if( m_targetChanged )
+    {
+        if( GetClassAI() )
+            m_targetChanged = GetClassAI()->DoFirstCombatManeuver( m_targetCombat );
+        else
+            m_targetChanged = false;
+    }
+
+    // do normal combat movement
+	DoCombatMovement();
+
+    if (GetClassAI() && !m_targetChanged )
+        (GetClassAI())->DoNextCombatManeuver( m_targetCombat );
+}
+
+void PlayerbotAI::DoCombatMovement() {
+	if( !m_targetCombat ) return;
+
+	float targetDist = m_bot->GetDistance( m_targetCombat );
+
+	if( m_combatStyle==COMBAT_MELEE && !m_bot->hasUnitState( UNIT_STAT_CHASE ) && ( (m_movementOrder==MOVEMENT_STAY && targetDist<=ATTACK_DISTANCE) || (m_movementOrder!=MOVEMENT_STAY) ) )
+	{
+		// melee combat - chase target if in range or if we are not forced to stay
+		m_bot->GetMotionMaster()->MoveChase( m_targetCombat );
+	}
+	else if( m_combatStyle==COMBAT_RANGED && m_movementOrder!=MOVEMENT_STAY )
+	{
+		// ranged combat - just move within spell range
+		// TODO: just follow in spell range! how to determine bots spell range?
+		if( targetDist>25.0f ) {
+			m_bot->GetMotionMaster()->MoveChase( m_targetCombat );
+		} else {
+			MovementClear();
+		}
+	}
+}
+
+void PlayerbotAI::SetQuestNeedItems()
+{
+    // reset values first
+    m_needItemList.clear();
+    m_lootCreature.clear();
+    m_lootCurrent = 0;
+
+    // run through accepted quests, get quest infoand data
+    for( QuestStatusMap::iterator iter=m_bot->getQuestStatusMap().begin(); iter!=m_bot->getQuestStatusMap().end(); ++iter )
+    {
+        const Quest *qInfo = sObjectMgr.GetQuestTemplate( iter->first );
+        if( !qInfo )
+            continue;
+
+        QuestStatusData *qData = &iter->second;
+        // only check quest if it is incomplete
+        if( qData->m_status != QUEST_STATUS_INCOMPLETE )
+            continue;
+
+        // check for items we not have enough of
+        for( int i=0; i<QUEST_OBJECTIVES_COUNT; i++ )
+        {
+            if( !qInfo->ReqItemCount[i] || (qInfo->ReqItemCount[i]-qData->m_itemcount[i])<=0 )
+                continue;
+            m_needItemList[qInfo->ReqItemId[i]] = (qInfo->ReqItemCount[i]-qData->m_itemcount[i]);
+        }
+    }
+}
+
+void PlayerbotAI::SetState( BotState state )
+{
+    //sLog.outDebug( "[PlayerbotAI]: %s switch state %d to %d", m_bot->GetName(), m_botState, state );
+    m_botState = state;
+}
+
+void PlayerbotAI::DoLoot()
+{
+    if( !m_lootCurrent && m_lootCreature.empty() )
+    {
+        //sLog.outDebug( "[PlayerbotAI]: %s reset loot list / go back to idle", m_bot->GetName() );
+        m_botState = BOTSTATE_NORMAL;
+        SetQuestNeedItems();
+        return;
+    }
+
+    if( !m_lootCurrent )
+    {
+        m_lootCurrent = m_lootCreature.front();
+        m_lootCreature.pop_front();
+        Creature *c = m_bot->GetMap()->GetCreature( m_lootCurrent );
+        // check if we got a creature and if it is still a corpse, otherwise bot runs to spawn point
+        if( !c || c->getDeathState()!=CORPSE || GetMaster()->GetDistance( c )>BOTLOOT_DISTANCE )
+        {
+            m_lootCurrent = 0;
+            return;
+        }
+        m_bot->GetMotionMaster()->MovePoint( c->GetMapId(), c->GetPositionX(), c->GetPositionY(), c->GetPositionZ() );
+        //sLog.outDebug( "[PlayerbotAI]: %s is going to loot '%s' deathState=%d", m_bot->GetName(), c->GetName(), c->getDeathState() );
+    }
+    else
+    {
+        Creature *c = m_bot->GetMap()->GetCreature( m_lootCurrent );
+        if( !c || c->getDeathState()!=CORPSE || GetMaster()->GetDistance( c )>BOTLOOT_DISTANCE )
+        {
+            m_lootCurrent = 0;
+            return;
+        }
+        if( m_bot->IsWithinDistInMap( c, INTERACTION_DISTANCE ) )
+        {
+            // check for needed items
+            m_bot->SendLoot( m_lootCurrent, LOOT_CORPSE );
+            Loot *loot = &c->loot;
+            uint32 lootNum = loot->GetMaxSlotInLootFor( m_bot );
+            //sLog.outDebug( "[PlayerbotAI]: %s looting: '%s' got %d items", m_bot->GetName(), c->GetName(), loot->GetMaxSlotInLootFor( m_bot ) );
+            for( uint32 l=0; l<lootNum; l++ )
+            {
+                QuestItem *qitem=0, *ffaitem=0, *conditem=0;
+                LootItem *item = loot->LootItemInSlot( l, m_bot, &qitem, &ffaitem, &conditem );
+                if( !item )
+                    continue;
+
+                if( !qitem && item->is_blocked )
+                {
+                    m_bot->SendLootRelease( m_bot->GetLootGUID() );
+                    continue;
+                }
+
+                if( m_needItemList[item->itemid]>0 )
+                {
+                    //sLog.outDebug( "[PlayerbotAI]: %s looting: needed item '%s'", m_bot->GetName(), sObjectMgr.GetItemLocale(item->itemid)->Name );
+                    ItemPosCountVec dest;
+                    if( m_bot->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, item->itemid, item->count ) == EQUIP_ERR_OK )
+                    {
+                        Item * newitem = m_bot->StoreNewItem( dest, item->itemid, true, item->randomPropertyId);
+
+                        if( qitem )
+                        {
+                            qitem->is_looted = true;
+                            if( item->freeforall || loot->GetPlayerQuestItems().size() == 1 )
+                                m_bot->SendNotifyLootItemRemoved( l );
+                            else
+                                loot->NotifyQuestItemRemoved( qitem->index );
+                        }
+                        else
+                        {
+                            if( ffaitem )
+                            {
+                                ffaitem->is_looted=true;
+                                m_bot->SendNotifyLootItemRemoved( l );
+                            }
+                            else
+                            {
+                                if( conditem )
+                                    conditem->is_looted=true;
+                                loot->NotifyItemRemoved( l );
+                            }
+                        }
+                        if (!item->freeforall)
+                            item->is_looted = true;
+                        --loot->unlootedCount;
+                        m_bot->SendNewItem( newitem, uint32(item->count), false, false, true );
+                        m_bot->GetAchievementMgr().UpdateAchievementCriteria( ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count );
+                    }
+                }
+            }
+            // release loot
+            // if( uint64 lguid = m_bot->GetLootGUID() && m_bot->GetSession() )
+                m_bot->GetSession()->DoLootRelease( m_lootCurrent );
+            //else if( !m_bot->GetSession() )
+            //    sLog.outDebug( "[PlayerbotAI]: %s has no session. Cannot release loot!", m_bot->GetName() );
+
+            // clear movement target, take next target on next update
+            m_bot->GetMotionMaster()->Clear();
+            m_bot->GetMotionMaster()->MoveIdle();
+            SetQuestNeedItems();
+            //sLog.outDebug( "[PlayerbotAI]: %s looted target 0x%08X", m_bot->GetName(), m_lootCurrent );
+        }
+    }
+}
+
+void PlayerbotAI::AcceptQuest( Quest const *qInfo, Player *pGiver )
+{
+    if( !qInfo || !pGiver )
+        return;
+
+    uint32 quest = qInfo->GetQuestId();
+
+    if( !pGiver->CanShareQuest( qInfo->GetQuestId() ) )
+    {
+        // giver can't share quest
+        m_bot->SetDivider( 0 );
+        return;
+    }
+
+    if( !m_bot->CanTakeQuest( qInfo, false ) )
+    {
+        // can't take quest
+        m_bot->SetDivider( 0 );
+        return;
+    }
+
+    if( m_bot->GetDivider() != 0 )
+    {
+        // send msg to quest giving player
+        pGiver->SendPushToPartyResponse( m_bot, QUEST_PARTY_MSG_ACCEPT_QUEST );
+        m_bot->SetDivider( 0 );
+    }
+
+    if( m_bot->CanAddQuest( qInfo, false ) )
+    {
+        m_bot->AddQuest( qInfo, pGiver );
+
+        if( m_bot->CanCompleteQuest( quest ) )
+            m_bot->CompleteQuest( quest );
+
+        // Runsttren: did not add typeid switch from WorldSession::HandleQuestgiverAcceptQuestOpcode!
+        // I think it's not needed, cause typeid should be TYPEID_PLAYER - and this one is not handled
+        // there and there is no default case also.
+
+        if( qInfo->GetSrcSpell() > 0 )
+            m_bot->CastSpell( m_bot, qInfo->GetSrcSpell(), true );
+    }
+}
+
+void PlayerbotAI::TurnInQuests( WorldObject *questgiver )
+{
+    uint64 giverGUID = questgiver->GetGUID();
+
+    if( !m_bot->IsInMap( questgiver ) )
+        TellMaster("hey you are turning in quests without me!");
+    else
+    {
+        m_bot->SetSelection( giverGUID );
+
+        // auto complete every completed quest this NPC has
+        m_bot->PrepareQuestMenu( giverGUID );
+        QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+        for (uint32 iI = 0; iI < questMenu.MenuItemCount(); ++iI)
+        {
+               QuestMenuItem const& qItem = questMenu.GetItem(iI);
+               uint32 questID = qItem.m_qId;
+               Quest const* pQuest = sObjectMgr.GetQuestTemplate(questID);
+
+               std::ostringstream out;
+               std::string questTitle  = pQuest->GetTitle();
+               QuestLocalization(questTitle, questID);
+
+            QuestStatus status = m_bot->GetQuestStatus(questID);
+
+               // if quest is complete, turn it in
+               if (status == QUEST_STATUS_COMPLETE)
+               {
+                // if bot hasn't already turned quest in
+                if (! m_bot->GetQuestRewardStatus(questID))
+                {
+                    // auto reward quest if no choice in reward
+                    if (pQuest->GetRewChoiceItemsCount() == 0)
+                    {
+                        if (m_bot->CanRewardQuest(pQuest, false))
+                        {
+                            m_bot->RewardQuest(pQuest, 0, questgiver, false);
+                            out << "Quest complete: |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                        else
+                        {
+                            out << "|cffff0000Unable to turn quest in:|r |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                    }
+
+                    // auto reward quest if one item as reward
+                    else if (pQuest->GetRewChoiceItemsCount() == 1)
+                    {
+                        int rewardIdx = 0;
+                        ItemPrototype const *pRewardItem = sObjectMgr.GetItemPrototype(pQuest->RewChoiceItemId[rewardIdx]);
+                        std::string itemName = pRewardItem->Name1;
+                        ItemLocalization(itemName, pRewardItem->ItemId);
+                        if (m_bot->CanRewardQuest(pQuest, rewardIdx, false))
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, questgiver, true);
+
+                            std::string itemName = pRewardItem->Name1;
+                            ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            out << "Quest complete: "
+                                << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                                << "|h[" << questTitle << "]|h|r reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                        else
+                        {
+                            out << "|cffff0000Unable to turn quest in:|r "
+                                << "|cff808080|Hquest:" << questID << ':'
+                                << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r"
+                                << " reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                    }
+
+                    // else multiple rewards - let master pick
+                    else {
+                        out << "What reward should I take for |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                            << "|h[" << questTitle << "]|h|r? ";
+                        for (uint8 i=0; i < pQuest->GetRewChoiceItemsCount(); ++i)
+                        {
+                            ItemPrototype const * const pRewardItem = sObjectMgr.GetItemPrototype(pQuest->RewChoiceItemId[i]);
+                            std::string itemName = pRewardItem->Name1;
+                            ItemLocalization(itemName, pRewardItem->ItemId);
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                    }
+                }
+            }
+
+            else if (status == QUEST_STATUS_INCOMPLETE) {
+                out << "|cffff0000Quest incomplete:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+            }
+
+            else if (status == QUEST_STATUS_AVAILABLE){
+                out << "|cff00ff00Quest available:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+            }
+
+            if (! out.str().empty())
+                TellMaster(out.str());
+        }
+    }
+}
+
+bool PlayerbotAI::IsInCombat()
+{
+    bool inCombat = false;
+    inCombat |= m_bot->isInCombat();
+    inCombat |= GetMaster()->isInCombat();
+    if( m_bot->GetGroup() )
+    {
+        GroupReference *ref = m_bot->GetGroup()->GetFirstMember();
+        while( ref )
+        {
+            inCombat |= ref->getSource()->isInCombat();
+            ref = ref->next();
+        }
+    }
+    return inCombat;
+}
+
+void PlayerbotAI::UpdateAttackerInfo()
+{
+    // clear old list
+    m_attackerInfo.clear();
+
+    // check own attackers
+    HostileReference *ref = m_bot->getHostileRefManager().getFirst();
+    while( ref )
+    {
+        ThreatManager *target = ref->getSource();
+        uint64 guid = target->getOwner()->GetGUID();
+        m_attackerInfo[guid].attacker = target->getOwner();
+        m_attackerInfo[guid].victim = target->getOwner()->getVictim();
+        m_attackerInfo[guid].threat = target->getThreat( m_bot );
+        m_attackerInfo[guid].count = 1;
+        m_attackerInfo[guid].source = 1;
+        ref = ref->next();
+    }
+
+    // check master's attackers
+    ref = GetMaster()->getHostileRefManager().getFirst();
+    while( ref )
+    {
+        ThreatManager *target = ref->getSource();
+        uint64 guid = target->getOwner()->GetGUID();
+        if( m_attackerInfo.find( guid ) == m_attackerInfo.end() )
+        {
+            m_attackerInfo[guid].attacker = target->getOwner();
+            m_attackerInfo[guid].victim = target->getOwner()->getVictim();
+            m_attackerInfo[guid].count = 0;
+            m_attackerInfo[guid].source = 2;
+        }
+        m_attackerInfo[guid].threat = target->getThreat( m_bot );
+        m_attackerInfo[guid].count++;
+        ref = ref->next();
+    }
+
+    // check all group members now
+    if( m_bot->GetGroup() )
+    {
+        GroupReference *gref = m_bot->GetGroup()->GetFirstMember();
+        while( gref )
+        {
+            if( gref->getSource() == m_bot || gref->getSource() == GetMaster() )
+            {
+                gref = gref->next();
+                continue;
+            }
+            ref = gref->getSource()->getHostileRefManager().getFirst();
+            while( ref )
+            {
+                ThreatManager *target = ref->getSource();
+                uint64 guid = target->getOwner()->GetGUID();
+                if( m_attackerInfo.find( guid ) == m_attackerInfo.end() )
+                {
+                    m_attackerInfo[guid].attacker = target->getOwner();
+                    m_attackerInfo[guid].victim = target->getOwner()->getVictim();
+                    m_attackerInfo[guid].count = 0;
+                    m_attackerInfo[guid].source = 3;
+                }
+                m_attackerInfo[guid].threat = target->getThreat( m_bot );
+                m_attackerInfo[guid].count++;
+                ref = ref->next();
+            }
+            gref = gref->next();
+        }
+    }
+
+    // get highest threat not caused by bot for every entry in AttackerInfoList...
+    for( AttackerInfoList::iterator itr=m_attackerInfo.begin(); itr!=m_attackerInfo.end(); ++itr )
+    {
+        if( !itr->second.attacker )
+            continue;
+        Unit *a = itr->second.attacker;
+        float t = 0.00;
+        std::list<HostileReference*>::const_iterator i=a->getThreatManager().getThreatList().begin();
+        for( ; i!=a->getThreatManager().getThreatList().end(); ++i )
+        {
+            if( (*i)->getThreat() > t && (*i)->getTarget() != m_bot )
+                t = (*i)->getThreat();
+        }
+        m_attackerInfo[itr->first].threat2 = t;
+    }
+
+    // DEBUG: output attacker info
+    //sLog.outBasic( "[PlayerbotAI]: %s m_attackerInfo = {", m_bot->GetName() );
+    //for( AttackerInfoList::iterator i=m_attackerInfo.begin(); i!=m_attackerInfo.end(); ++i )
+    //    sLog.outBasic( "[PlayerbotAI]:     [%016I64X] { %08X, %08X, %.2f, %.2f, %d, %d }",
+    //        i->first,
+    //        (i->second.attacker?i->second.attacker->GetGUIDLow():0),
+    //        (i->second.victim?i->second.victim->GetGUIDLow():0),
+    //        i->second.threat,
+    //        i->second.threat2,
+    //        i->second.count,
+    //        i->second.source );
+    //sLog.outBasic( "[PlayerbotAI]: };" );
+}
+
+uint32 PlayerbotAI::EstRepairAll()
+{
+    uint32 TotalCost = 0;
+    // equipped, backpack, bags itself
+    for(int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        TotalCost += EstRepair(( (INVENTORY_SLOT_BAG_0 << 8) | i ));
+
+    // bank, buyback and keys not repaired
+
+    // items in inventory bags
+    for(int j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; ++j)
+        for(int i = 0; i < MAX_BAG_SIZE; ++i)
+            TotalCost += EstRepair(( (j << 8) | i ));
+    return TotalCost;
+}
+
+uint32 PlayerbotAI::EstRepair(uint16 pos)
+{
+    Item* item = m_bot->GetItemByPos(pos);
+
+    uint32 TotalCost = 0;
+    if(!item)
+        return TotalCost;
+
+    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
+    if(!maxDurability)
+        return TotalCost;
+
+    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
+
+    uint32 LostDurability = maxDurability - curDurability;
+    if(LostDurability>0)
+    {
+        ItemPrototype const *ditemProto = item->GetProto();
+
+        DurabilityCostsEntry const *dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
+        if(!dcost)
+        {
+            sLog.outError("RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
+            return TotalCost;
+        }
+
+        uint32 dQualitymodEntryId = (ditemProto->Quality+1)*2;
+        DurabilityQualityEntry const *dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
+        if(!dQualitymodEntry)
+        {
+            sLog.outError("RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
+            return TotalCost;
+        }
+
+        uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(ditemProto->Class,ditemProto->SubClass)];
+        uint32 costs = uint32(LostDurability*dmultiplier*double(dQualitymodEntry->quality_mod));
+
+        if (costs==0)                                   //fix for ITEM_QUALITY_ARTIFACT
+            costs = 1;
+
+        TotalCost = costs;
+    }
+    return TotalCost;
+}
+
+Unit *PlayerbotAI::FindAttacker( ATTACKERINFOTYPE ait, Unit *victim )
+{
+    // list empty? why are we here?
+    if( m_attackerInfo.empty() )
+        return 0;
+
+    // not searching something specific - return first in list
+    if( !ait )
+        return (m_attackerInfo.begin())->second.attacker;
+
+    float t = ( (ait & AIT_HIGHESTTHREAT) ? 0.00 : 9999.00 );
+    Unit *a = 0;
+    AttackerInfoList::iterator itr = m_attackerInfo.begin();
+    for( ; itr != m_attackerInfo.end(); ++itr )
+    {
+        if( (ait & AIT_VICTIMSELF) && !(ait & AIT_VICTIMNOTSELF) && itr->second.victim != m_bot )
+            continue;
+
+        if( !(ait & AIT_VICTIMSELF) && (ait & AIT_VICTIMNOTSELF) && itr->second.victim == m_bot )
+            continue;
+
+		if( (ait & AIT_VICTIMNOTSELF) && victim && itr->second.victim != victim )
+            continue;
+
+        if( !(ait & (AIT_LOWESTTHREAT|AIT_HIGHESTTHREAT)) )
+        {
+            a = itr->second.attacker;
+            itr = m_attackerInfo.end();
+        }
+        else
+        {
+            if( (ait & AIT_HIGHESTTHREAT) && /*(itr->second.victim==m_bot) &&*/ itr->second.threat>=t )
+            {
+                t = itr->second.threat;
+                a = itr->second.attacker;
+            }
+            else if( (ait & AIT_LOWESTTHREAT) && /*(itr->second.victim==m_bot) &&*/ itr->second.threat<=t )
+            {
+                t = itr->second.threat;
+                a = itr->second.attacker;
+            }
+        }
+    }
+    return a;
+}
+
+void PlayerbotAI::SetCombatOrderByStr( std::string str, Unit *target ) {
+	CombatOrderType co;
+	if( str == "tank" ) co = ORDERS_TANK;
+	else if( str == "assist" ) co = ORDERS_ASSIST;
+	else if( str == "heal" ) co = ORDERS_HEAL;
+	else if( str == "protect" ) co = ORDERS_PROTECT;
+	else co = ORDERS_RESET;
+	SetCombatOrder( co, target );
+}
+
+void PlayerbotAI::SetCombatOrder( CombatOrderType co, Unit *target ) {
+	if( (co == ORDERS_ASSIST || co == ORDERS_PROTECT) && !target )
+		return;
+	if( co == ORDERS_RESET ) {
+		m_combatOrder = ORDERS_NONE;
+		m_targetAssist = 0;
+		m_targetProtect = 0;
+		return;
+	}
+	if( co == ORDERS_PROTECT )
+		m_targetProtect = target;
+	else if( co == ORDERS_ASSIST )
+		m_targetAssist = target;
+	if( (co&ORDERS_PRIMARY) )
+		m_combatOrder = (CombatOrderType)(((uint32)m_combatOrder&(uint32)ORDERS_SECONDARY)|(uint32)co);
+	else
+		m_combatOrder = (CombatOrderType)(((uint32)m_combatOrder&(uint32)ORDERS_PRIMARY)|(uint32)co);
+}
+
+void PlayerbotAI::SetMovementOrder( MovementOrderType mo, Unit *followTarget ) {
+	m_movementOrder = mo;
+	m_followTarget = followTarget;
+	MovementReset();
+}
+
+void PlayerbotAI::MovementReset() {
+	// stop moving...
+	MovementClear();
+
+	if( m_movementOrder == MOVEMENT_FOLLOW )
+    {
+		if( !m_followTarget ) return;
+
+		// target player is teleporting...
+		if( m_followTarget->GetTypeId()==TYPEID_PLAYER && ((Player*)m_followTarget)->IsBeingTeleported() )
+			return;
+
+		// check if bot needs to teleport to reach target...
+        if( !m_bot->isInCombat() )
+        {
+		    if( m_followTarget->GetTypeId()==TYPEID_PLAYER && ((Player*)m_followTarget)->GetCorpse() )
+            {
+			    if( !FollowCheckTeleport( *((Player*)m_followTarget)->GetCorpse() ) ) return;
+            }
+		    else
+            {
+			    if( !FollowCheckTeleport( *m_followTarget ) ) return;
+            }
+        }
+
+        if( m_bot->isAlive() )
+        {
+			float angle = rand_float(0, M_PI_F);
+		    float dist = rand_float( m_mgr->m_confFollowDistance[0], m_mgr->m_confFollowDistance[1] );
+			m_bot->GetMotionMaster()->MoveFollow( m_followTarget, dist, angle );
+        }
+	}
+}
+
+void PlayerbotAI::MovementUpdate()
+{
+	// send heartbeats to world
+	WorldPacket data;
+	m_bot->BuildHeartBeatMsg( &data );
+	m_bot->SendMessageToSet( &data, false );
+
+    // call set position (updates states, exploration, etc.)
+    m_bot->SetPosition( m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), m_bot->GetOrientation(), false );
+}
+
+void PlayerbotAI::MovementClear()
+{
+    // stop...
+    m_bot->GetMotionMaster()->Clear( true );
+    m_bot->clearUnitState( UNIT_STAT_CHASE );
+    m_bot->clearUnitState( UNIT_STAT_FOLLOW );
+
+	// stand up...
+    if (!m_bot->IsStandState())
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+}
+
+bool PlayerbotAI::IsMoving()
+{
+	return (m_bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == IDLE_MOTION_TYPE ? false : true);
+}
+
+void PlayerbotAI::SetInFront( const Unit* obj )
+{
+	// removed SendUpdateToPlayer (is not updating movement/orientation)
+    if( !m_bot->HasInArc( M_PI_F, obj ) )
+        m_bot->SetInFront( obj );
+}
+
+// some possible things to use in AI
+//GetRandomContactPoint
+//GetPower, GetMaxPower
+// HasSpellCooldown
+// IsAffectedBySpellmod
+// isMoving
+// hasUnitState(FLAG) FLAG like: UNIT_STAT_ROOT, UNIT_STAT_CONFUSED, UNIT_STAT_STUNNED
+// hasAuraType
+
+void PlayerbotAI::UpdateAI(const uint32 p_time)
+{
+    if (m_bot->IsBeingTeleported() || m_bot->GetTrader())
+        return;
+
+    time_t currentTime = time(0);
+    if (currentTime < m_ignoreAIUpdatesUntilTime)
+        return;
+
+    // default updates occur every two seconds
+    m_ignoreAIUpdatesUntilTime = time(0) + 2;
+
+	// send heartbeat
+	MovementUpdate();
+
+    if( !m_bot->isAlive() )
+    {
+        if( m_botState != BOTSTATE_DEAD && m_botState != BOTSTATE_DEADRELEASED )
+        {
+            //sLog.outDebug( "[PlayerbotAI]: %s died and is not in correct state...", m_bot->GetName() );
+            // clear loot list on death
+            m_lootCreature.clear();
+            m_lootCurrent = 0;
+            // clear combat orders
+            m_bot->SetSelection(0);
+            m_bot->GetMotionMaster()->Clear(true);
+            // set state to dead
+            SetState( BOTSTATE_DEAD );
+            // wait 30sec
+            m_ignoreAIUpdatesUntilTime = time(0) + 30;
+        }
+        else if( m_botState == BOTSTATE_DEAD )
+        {
+            // become ghost
+            if( m_bot->GetCorpse() ){
+                //sLog.outDebug( "[PlayerbotAI]: %s already has a corpse...", m_bot->GetName() );
+                SetState( BOTSTATE_DEADRELEASED );
+                return;
+            }
+            m_bot->SetBotDeathTimer();
+            m_bot->BuildPlayerRepop();
+            // relocate ghost
+            WorldLocation loc;
+            Corpse *corpse = m_bot->GetCorpse();
+            corpse->GetPosition( loc );
+            m_bot->TeleportTo( loc.mapid, loc.coord_x, loc.coord_y, loc.coord_z, m_bot->GetOrientation() );
+            // set state to released
+            SetState( BOTSTATE_DEADRELEASED );
+        }
+        else if( m_botState == BOTSTATE_DEADRELEASED )
+        {
+            // get bot's corpse
+            Corpse *corpse = m_bot->GetCorpse();
+            if( !corpse )
+            {
+                //sLog.outDebug( "[PlayerbotAI]: %s has no corpse!", m_bot->GetName() );
+                return;
+            }
+            // teleport ghost from graveyard to corpse
+            //sLog.outDebug( "[PlayerbotAI]: Teleport %s to corpse...", m_bot->GetName() );
+            FollowCheckTeleport( *corpse );
+            // check if we are allowed to resurrect now
+            if( corpse->GetGhostTime() + m_bot->GetCorpseReclaimDelay( corpse->GetType()==CORPSE_RESURRECTABLE_PVP ) > time(0) )
+            {
+                m_ignoreAIUpdatesUntilTime = corpse->GetGhostTime() + m_bot->GetCorpseReclaimDelay( corpse->GetType()==CORPSE_RESURRECTABLE_PVP );
+                //sLog.outDebug( "[PlayerbotAI]: %s has to wait for %d seconds to revive...", m_bot->GetName(), m_ignoreAIUpdatesUntilTime-time(0) );
+                return;
+            }
+            // resurrect now
+            //sLog.outDebug( "[PlayerbotAI]: Reviving %s to corpse...", m_bot->GetName() );
+            m_ignoreAIUpdatesUntilTime = time(0) + 6;
+            PlayerbotChatHandler ch(GetMaster());
+            if (! ch.revive(*m_bot))
+            {
+                ch.sysmessage(".. could not be revived ..");
+                return;
+            }
+            // set back to normal
+            SetState( BOTSTATE_NORMAL );
+        }
+    }
+    else
+    {
+        // if we are casting a spell then interrupt it
+        // make sure any actions that cast a spell set a proper m_ignoreAIUpdatesUntilTime!
+        Spell* const pSpell = GetCurrentSpell();
+        if (pSpell && !(pSpell->IsChannelActive() || pSpell->IsAutoRepeat()))
+            InterruptCurrentCastingSpell();
+
+        // direct cast command from master
+        else if (m_spellIdCommand != 0)
+        {
+            Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
+            if (pTarget != NULL)
+                CastSpell(m_spellIdCommand, *pTarget);
+            m_spellIdCommand = 0;
+            m_targetGuidCommand = 0;
+        }
+
+        // handle combat (either self/master/group in combat, or combat state and valid target)
+        else if ( IsInCombat() || (m_botState == BOTSTATE_COMBAT && m_targetCombat) )
+            DoNextCombatManeuver();
+
+        // bot was in combat recently - loot now
+        else if (m_botState == BOTSTATE_COMBAT)
+        {
+            SetState( BOTSTATE_LOOTING );
+            m_attackerInfo.clear();
+        }
+        else if (m_botState == BOTSTATE_LOOTING)
+            DoLoot();
+/*
+        // are we sitting, if so feast if possible
+        else if (m_bot->getStandState() == UNIT_STAND_STATE_SIT)
+        Feast();
+*/
+        // if commanded to follow master and not already following master then follow master
+        else if (!m_bot->isInCombat() && !IsMoving() )
+            MovementReset();
+
+        // do class specific non combat actions
+        else if (GetClassAI())
+            (GetClassAI())->DoNonCombatActions();
+    }
+}
+
+Spell* PlayerbotAI::GetCurrentSpell() const
+{
+    if (m_CurrentlyCastingSpellId == 0)
+        return NULL;
+
+    Spell* const pSpell = m_bot->FindCurrentSpellBySpellId(m_CurrentlyCastingSpellId);
+    return pSpell;
+}
+
+void PlayerbotAI::TellMaster(const std::string& text) const
+{
+    SendWhisper(text, *GetMaster());
+}
+
+void PlayerbotAI::TellMaster( const char *fmt, ... ) const
+{
+    char temp_buf[1024];
+    va_list ap;
+    va_start( ap, fmt );
+    size_t temp_len = vsnprintf( temp_buf, 1024, fmt, ap );
+    va_end( ap );
+    std::string str = temp_buf;
+    TellMaster( str );
+}
+
+void PlayerbotAI::SendWhisper(const std::string& text, Player& player) const
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    m_bot->BuildPlayerChat(&data, CHAT_MSG_WHISPER, text, LANG_UNIVERSAL);
+    player.GetSession()->SendPacket(&data);
+}
+
+bool PlayerbotAI::canObeyCommandFrom(const Player& player) const
+{
+    return player.GetSession()->GetAccountId() == GetMaster()->GetSession()->GetAccountId();
+}
+
+bool PlayerbotAI::CastSpell(const char* args)
+{
+    uint32 spellId = getSpellId(args);
+    return (spellId) ? CastSpell(spellId) : false;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit& target)
+{
+    uint64 oldSel = m_bot->GetSelection();
+    m_bot->SetSelection(target.GetGUID());
+    bool rv = CastSpell(spellId);
+    m_bot->SetSelection(oldSel);
+    return rv;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId)
+{
+    // some AIs don't check if the bot doesn't have spell before using it
+    // so just return false when this happens
+    if (spellId == 0)
+        return false;
+
+    // check spell cooldown
+    if( m_bot->HasSpellCooldown( spellId ) )
+        return false;
+
+    // see Creature.cpp 1738 for reference
+    // don't allow bot to cast damage spells on friends
+    const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+    {
+        TellMaster("missing spell entry in CastSpell.");
+        return false;
+    }
+
+    // set target
+    uint64 targetGUID = m_bot->GetSelection();
+    Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+    if (IsPositiveSpell(spellId))
+    {
+        if (pTarget && !m_bot->IsFriendlyTo(pTarget))
+            pTarget = m_bot;
+    }
+    else
+    {
+        if (pTarget && m_bot->IsFriendlyTo(pTarget))
+            return false;
+
+        // search for Creature::reachWithSpellAttack to also see some examples of spell distance usage
+        if (!m_bot->isInFrontInMap(pTarget, 10))
+        {
+            m_bot->SetInFront(pTarget);
+            MovementUpdate();
+        }
+    }
+
+    if (HasAura(spellId, *pTarget))
+        return false;
+
+    // stop movement to prevent cancel spell casting
+    MovementClear();
+
+    // actually cast spell
+    m_bot->CastSpell(pTarget, pSpellInfo, false);
+
+    Spell* const pSpell = m_bot->FindCurrentSpellBySpellId(spellId);
+    if (!pSpell)
+        return false;
+
+    m_CurrentlyCastingSpellId = spellId;
+    m_ignoreAIUpdatesUntilTime = time(0) + (int32)((float)pSpell->GetCastTime()/1000.0f) + 1;
+
+    // if this caused the caster to move (blink) update the position
+    // I think this is normally done on the client
+    // this should be done on spell success
+    /*
+     if (name == "Blink") {
+     float x,y,z;
+     m_bot->GetPosition(x,y,z);
+     m_bot->GetNearPoint(m_bot, x, y, z, 1, 5, 0);
+     m_bot->Relocate(x,y,z);
+     WorldPacket data;
+     m_bot->BuildHeartBeatMsg(&data);
+     m_bot->SendMessageToSet(&data,true);
+     }
+     */
+
+    return true;
+}
+
+Item* PlayerbotAI::FindItem(uint32 ItemId)
+{
+     // list out items in main backpack
+     //INVENTORY_SLOT_ITEM_START = 23
+     //INVENTORY_SLOT_ITEM_END = 39
+
+     for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+     {
+         // sLog.outDebug("[%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
+         Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot); // 255, 23 to 38
+         if (pItem)
+         {
+              const ItemPrototype* const pItemProto = pItem->GetProto();
+              if (!pItemProto )
+                   continue;
+
+              if( pItemProto->ItemId == ItemId) // have required item
+                   return pItem;
+         }
+     }
+     // list out items in other removable backpacks
+     //INVENTORY_SLOT_BAG_START = 19
+     //INVENTORY_SLOT_BAG_END = 23
+
+     for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) // 20 to 23 = 4
+     {
+          const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag); // 255, 20 to 23
+          if (pBag)
+          {
+               for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+               {
+                    sLog.outDebug("[%s's]bag[%u] slot = %u",m_bot->GetName(),bag,slot); // 1 to bagsize = ?
+		    Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
+                    if (pItem)
+                    {
+                          const ItemPrototype* const pItemProto = pItem->GetProto();
+                          if (!pItemProto )
+                                continue;
+
+                          if( pItemProto->ItemId == ItemId ) // have required item
+                                return pItem;
+                    }
+               }
+          }
+     }
+     return NULL;
+}
+
+bool PlayerbotAI::HasPick()
+{
+    QueryResult *result;
+
+    // list out equiped items
+    for( uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+        if (pItem )
+	{
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (!pItemProto )
+                continue;
+
+            result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemProto->ItemId);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                uint32 tc = fields[0].GetUInt32();
+                // sLog.outDebug("HasPick %u",tc);
+                if(tc ==  165 || tc == 167) // pick = 165, hammer = 162 or hammer pick = 167
+                    return true;
+            }
+        }
+    }
+
+    // list out items in backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        // sLog.outDebug("[%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot); // 255, 23 to 38
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (!pItemProto )
+                continue;
+
+            result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemProto->ItemId);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                uint32 tc = fields[0].GetUInt32();
+                // sLog.outDebug("HasPick %u",tc);
+                if(tc ==  165 || tc == 167) // pick = 165, hammer = 162 or hammer pick = 167
+                    return true;
+            }
+        }
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) // 20 to 23 = 4
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag); // 255, 20 to 23
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                // sLog.outDebug("[%s's]bag[%u] slot = %u",m_bot->GetName(),bag,slot); // 1 to bagsize = ?
+                Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (!pItemProto )
+                        continue;
+
+                    result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemProto->ItemId);
+                    if (result)
+                    {
+                        Field *fields = result->Fetch();
+                        uint32 tc = fields[0].GetUInt32();
+                        // sLog.outDebug("HasPick %u",tc);
+                        if(tc ==  165 || tc == 167)
+                            return true;
+                    }
+                }
+            }
+        }
+    }
+    std::ostringstream out;
+    out << "|cffffffffI do not have a pick!";
+    TellMaster( out.str().c_str() );
+    return false;
+}
+
+// extracts all item ids in format below
+// I decided to roll my own extractor rather then use the one in ChatHandler
+// because this one works on a const string, and it handles multiple links
+// |color|linkType:key:something1:...:somethingN|h[name]|h|r
+void PlayerbotAI::extractItemIds(const std::string& text, std::list<uint32>& itemIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hitem:", pos);
+        if (i == -1)
+            break;
+        pos = i + 6;
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            itemIds.push_back(id);
+    }
+}
+
+bool PlayerbotAI::extractGOinfo(const std::string& text, uint32 &guid, uint32 &entry, int &mapid, float &x, float &y, float &z) const
+{
+
+     //    Link format
+     //    |cFFFFFF00|Hfound:" << guid << ':'  << entry << ':' << x << ':' << y << ':' << z  << ':' << mapid << ':' <<  "|h[" << gInfo->name << "]|h|r";
+     //    |cFFFFFF00|Hfound:5093:1731:-9295:-270:81.874:0:|h[Copper Vein]|h|r
+
+    uint8 pos = 0;
+
+        // extract GO guid
+        int i = text.find("Hfound:", pos); // base H = 11
+        if (i == -1) // break if error
+            return false;
+
+        pos = i + 7; //start of window in text 11 + 7 = 18
+        int endPos = text.find(':', pos); // end of window in text 22
+        if (endPos == -1) //break if error
+            return false;
+        std::string guidC = text.substr(pos, endPos - pos); // get string within window i.e guid 22 - 18 =  4
+        guid = atol(guidC.c_str()); // convert ascii to long int
+
+        // extract GO entry
+        pos = endPos + 1;
+        endPos = text.find(':', pos); // end of window in text
+        if (endPos == -1) //break if error
+            return false;
+
+        std::string entryC = text.substr(pos, endPos - pos); // get string within window i.e entry
+        entry = atol(entryC.c_str()); // convert ascii to float
+
+        // extract GO x
+        pos = endPos + 1;
+        endPos = text.find(':', pos); // end of window in text
+        if (endPos == -1) //break if error
+            return false;
+
+        std::string xC = text.substr(pos, endPos - pos); // get string within window i.e x
+        x = atof(xC.c_str()); // convert ascii to float
+
+        // extract GO y
+        pos = endPos + 1;
+        endPos = text.find(':', pos); // end of window in text
+        if (endPos == -1) //break if error
+            return false;
+
+        std::string yC = text.substr(pos, endPos - pos); // get string within window i.e y
+        y = atof(yC.c_str()); // convert ascii to float
+
+        // extract GO z
+        pos = endPos + 1;
+        endPos = text.find(':', pos); // end of window in text
+        if (endPos == -1) //break if error
+            return false;
+
+        std::string zC = text.substr(pos, endPos - pos); // get string within window i.e z
+        z = atof(zC.c_str()); // convert ascii to float
+
+        //extract GO mapid
+        pos = endPos + 1;
+        endPos = text.find(':', pos); // end of window in text
+        if (endPos == -1) //break if error
+            return false;
+
+        std::string mapidC = text.substr(pos, endPos - pos); // get string within window i.e mapid
+        mapid = atoi(mapidC.c_str()); // convert ascii to int
+        pos = endPos; // end
+        return true;
+}
+
+// extracts currency in #g#s#c format
+uint32 PlayerbotAI::extractMoney(const std::string& text) const
+{
+    // if user specified money in ##g##s##c format
+    std::string acum = "";
+    uint32 copper = 0;
+    for (uint8 i = 0; i < text.length(); i++)
+    {
+        if (text[i] == 'g')
+        {
+            copper += (atol(acum.c_str()) * 100 * 100);
+            acum = "";
+        }
+        else if (text[i] == 'c')
+        {
+            copper += atol(acum.c_str());
+            acum = "";
+        }
+        else if (text[i] == 's')
+        {
+            copper += (atol(acum.c_str()) * 100);
+            acum = "";
+        }
+        else if (text[i] == ' ')
+            break;
+        else if (text[i] >= 48 && text[i] <= 57)
+            acum += text[i];
+        else
+        {
+            copper = 0;
+            break;
+        }
+    }
+    return copper;
+}
+
+// finds items in equipment and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+    for( uint8 slot=EQUIPMENT_SLOT_START; itemIdSearchList.size()>0 && slot<EQUIPMENT_SLOT_END; slot++ ) {
+        Item* const pItem = m_bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+        if( !pItem )
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetProto()->ItemId != *it)
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+}
+
+// finds items in inventory and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+
+    // look for items in main bag
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; itemIdSearchList.size() > 0 && slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetProto()->ItemId != *it)
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+
+    // for all for items in other bags
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; itemIdSearchList.size() > 0 && bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (!pBag)
+            continue;
+
+        for (uint8 slot = 0; itemIdSearchList.size() > 0 && slot < pBag->GetBagSize(); ++slot)
+        {
+            Item* const pItem = m_bot->GetItemByPos(bag, slot);
+            if (!pItem)
+                continue;
+
+            for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+            {
+                if (pItem->GetProto()->ItemId != *it)
+                    continue;
+
+                foundItemList.push_back(pItem);
+                itemIdSearchList.erase(it);
+                break;
+            }
+        }
+    }
+}
+
+// submits packet to use an item
+void PlayerbotAI::UseItem(Item& item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint8 cast_count = 1;
+    uint32 spellid = 0; // only used in combat
+    uint64 item_guid = item.GetGUID();
+    uint32 glyphIndex = 0; // ??
+    uint8 unk_flags = 0; // not 0x02
+
+    // create target data
+    // note other targets are possible but not supported at the moment
+    // see SpellCastTargets::read in Spell.cpp to see other options
+    // for setting target
+
+    uint32 target = TARGET_FLAG_SELF;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_USE_ITEM, 1 + 1 + 1 + 4 + 8 + 4 + 1);
+    *packet << bagIndex << slot << cast_count << spellid << item_guid
+            << glyphIndex << unk_flags << target;
+    m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+
+    // certain items cause player to sit (food,drink)
+    // tell bot to stop following if this is the case
+    // (doesn't work since we queued the packet!)
+    // maybe its not needed???
+    //if (! m_bot->IsStandState())
+    //    m_bot->GetMotionMaster()->Clear();
+}
+
+// submits packet to use an item
+void PlayerbotAI::EquipItem(Item& item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+
+    WorldPacket* const packet = new WorldPacket(CMSG_AUTOEQUIP_ITEM, 2);
+    *packet << bagIndex << slot;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+// submits packet to trade an item (trade window must already be open)
+// default slot is -1 which means trade slots 0 to 5. if slot is set
+// to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
+// 'Will not be traded' slot.
+bool PlayerbotAI::TradeItem(const Item& item, int8 slot)
+{
+    sLog.outDebug( "[PlayerbotAI::TradeItem]: slot=%d, hasTrader=%d, itemInTrade=%d, itemTradeable=%d",
+        slot,
+        (m_bot->GetTrader()?1:0),
+        (item.IsInTrade()?1:0),
+        (item.CanBeTraded()?1:0)
+        );
+
+    if (!m_bot->GetTrader() || item.IsInTrade() || (!item.CanBeTraded() && slot!=TRADE_SLOT_NONTRADED) )
+        return false;
+
+    int8 tradeSlot = -1;
+
+    if( (slot>=0 && slot<TRADE_SLOT_COUNT) && m_bot->GetItemByTradeSlot(slot) == NULL )
+        tradeSlot = slot;
+    else
+    {
+        for( uint8 i=0; i<TRADE_SLOT_TRADED_COUNT && tradeSlot==-1; i++ )
+        {
+            if( m_bot->GetItemByTradeSlot(i) == NULL )
+                tradeSlot = i;
+        }
+    }
+
+    if( tradeSlot == -1 ) return false;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 3);
+    *packet << (uint8) tradeSlot << (uint8) item.GetBagSlot()
+            << (uint8) item.GetSlot();
+    m_bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
+// submits packet to trade copper (trade window must be open)
+bool PlayerbotAI::TradeCopper(uint32 copper)
+{
+    if (copper > 0)
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+        *packet << copper;
+        m_bot->GetSession()->QueuePacket(packet);
+        return true;
+    }
+    return false;
+}
+
+/*void PlayerbotAI::Stay()
+{
+    m_IsFollowingMaster = false;
+    m_bot->GetMotionMaster()->Clear(true);
+    m_bot->HandleEmoteCommand(EMOTE_ONESHOT_SALUTE);
+}*/
+
+/*bool PlayerbotAI::Follow(Player& player)
+{
+    if (GetMaster()->IsBeingTeleported())
+        return false;
+
+    m_IsFollowingMaster = true;
+
+    if (!m_bot->IsStandState())
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    if (!m_bot->isInCombat())
+    {
+        // follow player or his corpse if dead (stops bot from running to graveyard if player repops...)
+        if( player.GetCorpse() )
+        {
+            if( !FollowCheckTeleport( *player.GetCorpse() ) )
+                return false;
+        }
+        else
+        {
+            if( !FollowCheckTeleport( player ) )
+                return false;
+        }
+    }
+
+    if (m_bot->isAlive())
+    {
+        float angle = rand_float(0, M_PI);
+        float dist = rand_float(0.5f, 1.0f);
+        m_bot->GetMotionMaster()->Clear(true);
+        m_bot->GetMotionMaster()->MoveFollow(&player, dist, angle);
+        return true;
+    }
+    return false;
+}*/
+
+bool PlayerbotAI::FollowCheckTeleport( WorldObject &obj )
+{
+    // if bot has strayed too far from the master, teleport bot
+
+    if (!m_bot->IsWithinDistInMap( &obj, 50, true ) && GetMaster()->isAlive())
+    {
+        m_ignoreAIUpdatesUntilTime = time(0) + 6;
+        PlayerbotChatHandler ch(GetMaster());
+        if (! ch.teleport(*m_bot))
+        {
+            ch.sysmessage(".. could not be teleported ..");
+            //sLog.outDebug( "[PlayerbotAI]: %s failed to teleport", m_bot->GetName() );
+            return false;
+        }
+    }
+    return true;
+}
+
+void PlayerbotAI::HandleTeleportAck()
+{
+    m_ignoreAIUpdatesUntilTime = time(0) + 6;
+    m_bot->GetMotionMaster()->Clear(true);
+    if (m_bot->IsBeingTeleportedNear())
+    {
+        WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8 + 4 + 4);
+        p.appendPackGUID(m_bot->GetGUID());
+        p << (uint32) 0; // supposed to be flags? not used currently
+        p << (uint32) time(0); // time - not currently used
+        m_bot->GetSession()->HandleMoveTeleportAck(p);
+    }
+    else if (m_bot->IsBeingTeleportedFar())
+        m_bot->GetSession()->HandleMoveWorldportAckOpcode();
+}
+
+// Localization support
+void PlayerbotAI::ItemLocalization(std::string& itemName, const uint32 itemID) const
+{
+    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const *pItemInfo = sObjectMgr.GetItemLocale(itemID);
+    if (pItemInfo)
+    {
+        if (pItemInfo->Name.size() > loc && !pItemInfo->Name[loc].empty())
+        {
+            const std::string name = pItemInfo->Name[loc];
+            if (Utf8FitTo(name, wnamepart))
+                itemName = name.c_str();
+        }
+    }
+}
+
+void PlayerbotAI::QuestLocalization(std::string& questTitle, const uint32 questID) const
+{
+    uint32 loc = GetMaster()->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    QuestLocale const *pQuestInfo = sObjectMgr.GetQuestLocale(questID);
+    if (pQuestInfo)
+    {
+        if (pQuestInfo->Title.size() > loc && !pQuestInfo->Title[loc].empty())
+        {
+            const std::string title = pQuestInfo->Title[loc];
+            if (Utf8FitTo(title, wnamepart))
+                questTitle = title.c_str();
+        }
+    }
+}
+
+// handle commands sent through chat channels
+void PlayerbotAI::HandleCommand(const std::string& text, Player& fromPlayer)
+{
+    // ignore any messages from Addons
+	if (text.empty() ||
+		text.find("X-Perl") != std::wstring::npos ||
+		text.find("HealBot") != std::wstring::npos ||
+		text.find("LOOT_OPENED") != std::wstring::npos ||
+		text.find("CTRA") != std::wstring::npos)
+		return;
+
+    // if message is not from a player in the masters account auto reply and ignore
+    if (!canObeyCommandFrom(fromPlayer))
+    {
+        std::string msg = "I can't talk to you. Please speak to my master ";
+        msg += GetMaster()->GetName();
+        SendWhisper(msg, fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_NO);
+    }
+
+    // if in the middle of a trade, and player asks for an item/money
+    else if (m_bot->GetTrader() && m_bot->GetTrader()->GetGUID() == fromPlayer.GetGUID())
+    {
+        uint32 copper = extractMoney(text);
+        if (copper > 0)
+            TradeCopper(copper);
+
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (itemIds.size() == 0)
+            SendWhisper("Show me what item you want by shift clicking the item in the chat window.", fromPlayer);
+        else if( !strncmp( text.c_str(), "nt ", 3 ) )
+        {
+            if( itemIds.size() > 1 )
+                SendWhisper( "There is only one 'Will not be traded' slot. Shift-click just one item, please!", fromPlayer );
+            else
+            {
+                std::list<Item*> itemList;
+                findItemsInEquip( itemIds, itemList );
+                findItemsInInv( itemIds, itemList );
+                if( itemList.size()>0 )
+                    TradeItem( (**itemList.begin()), TRADE_SLOT_NONTRADED );
+                else
+                    SendWhisper( "I do not have this item equipped or in my bags!", fromPlayer );
+            }
+        }
+        else
+        {
+            std::list<Item*> itemList;
+            findItemsInInv(itemIds, itemList);
+            for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+                TradeItem(**it);
+        }
+    }
+
+    // if we are turning in a quest
+
+    else if (text == "reset")
+    {
+        SetState( BOTSTATE_NORMAL );
+		MovementReset();
+        SetQuestNeedItems();
+		UpdateAttackerInfo();
+        m_lootCreature.clear();
+        m_lootCurrent = 0;
+		m_targetCombat = 0;
+		// do we want to reset all states on this command?
+//		m_combatOrder = ORDERS_NONE;
+//		m_targetCombat = 0;
+//		m_targetAssisst = 0;
+//		m_targetProtect = 0;
+    }
+    else if (text == "report")
+        SendQuestItemList( *GetMaster() );
+    else if (text == "orders")
+        SendOrders( *GetMaster() );
+    else if (text == "follow" || text == "come")
+        SetMovementOrder( MOVEMENT_FOLLOW, GetMaster() );
+    else if (text == "stay" || text == "stop")
+        SetMovementOrder( MOVEMENT_STAY );
+    else if (text == "attack")
+    {
+        uint64 attackOnGuid = fromPlayer.GetSelection();
+        if (attackOnGuid)
+        {
+            Unit* thingToAttack = ObjectAccessor::GetUnit(*m_bot, attackOnGuid);
+            if (!m_bot->IsFriendlyTo(thingToAttack) && m_bot->IsWithinLOSInMap(thingToAttack))
+                GetCombatTarget( thingToAttack );
+        }
+        else
+        {
+            TellMaster("No target is selected.");
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+        }
+    }
+
+    // handle cast command
+    else if (text.size() > 2 && text.substr(0, 2) == "c " || text.size() > 5 && text.substr(0, 5) == "cast ")
+    {
+        std::string spellStr = text.substr(text.find(" ") + 1);
+        uint32 spellId = (uint32) atol(spellStr.c_str());
+
+        // try and get spell ID by name
+        if (spellId == 0)
+            spellId = getSpellId(spellStr.c_str(), true);
+
+        uint64 castOnGuid = fromPlayer.GetSelection();
+        if (spellId != 0 && castOnGuid != 0 && m_bot->HasSpell(spellId))
+        {
+            m_spellIdCommand = spellId;
+            m_targetGuidCommand = castOnGuid;
+        }
+    }
+
+    // use items
+    else if (text.size() > 2 && text.substr(0, 2) == "u " || text.size() > 4 && text.substr(0, 4) == "use ")
+    {
+        std::list<uint32> itemIds;
+        std::list<Item*> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+        for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+            UseItem(**it);
+    }
+
+    // equip items
+    else if (text.size() > 2 && text.substr(0, 2) == "e " || text.size() > 6 && text.substr(0, 6) == "equip ")
+    {
+        std::list<uint32> itemIds;
+        std::list<Item*> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+        for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+            EquipItem(**it);
+    }
+
+    // find item in world
+     else if (text.size() > 2 && text.substr(0, 2) == "f " || text.size() > 5 && text.substr(0, 5) == "find ")
+    {
+        uint32 guid;
+        float x,y,z;
+        uint32 entry;
+        int mapid;
+        if(extractGOinfo(text, guid, entry, mapid, x, y, z))
+        {    // sLog.outDebug("find: guid : %u entry : %u x : (%f) y : (%f) z : (%f) mapid : %d",guid, entry, x, y, z, mapid);
+             m_bot->UpdateGroundPositionZ(x,y,z);
+             SetMovementOrder( MOVEMENT_STAY );
+             m_bot->GetMotionMaster()->MovePoint( mapid, x, y, z );
+        }
+        else
+             SendWhisper("I have no info on that object", fromPlayer);
+    }
+
+    // get project: 18:50 03/05/10 rev.3 allows bots to retrieve all lootable & quest items from gameobjects
+    else if (text.size() > 2 && text.substr(0, 2) == "g " || text.size() > 4 && text.substr(0, 4) == "get ")
+    {
+        uint32 guid;
+        float x,y,z;
+        uint32 entry;
+        int mapid;
+        bool looted = false;
+        if (extractGOinfo(text, guid, entry, mapid, x, y, z))
+        {
+
+            //sLog.outDebug("find: guid : %u entry : %u x : (%f) y : (%f) z : (%f) mapid : %d",guid, entry, x, y, z, mapid);
+            m_lootCurrent = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+            GameObject *go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+            if (!go)
+            {
+                m_lootCurrent = 0;
+                return;
+            }
+
+            if ( !go->isSpawned() )
+                return;
+
+            m_bot->UpdateGroundPositionZ(x,y,z);
+            m_bot->GetMotionMaster()->MovePoint( mapid, x, y, z );
+            m_bot->SetPosition(x, y, z, m_bot->GetOrientation());
+            m_bot->SendLoot( m_lootCurrent, LOOT_CORPSE );
+            Loot *loot = &go->loot;
+            uint32 lootNum = loot->GetMaxSlotInLootFor( m_bot );
+            // sLog.outDebug( "[PlayerbotAI]: GetGOType %u - %s looting: '%s' got %d items", go->GetGoType(), m_bot->GetName(), go->GetGOInfo()->name, loot->GetMaxSlotInLootFor( m_bot ));
+            if(lootNum == 0) // Handle opening gameobjects that contain no items
+            {
+                uint32 lockId = go->GetGOInfo()->GetLockId();
+                LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+                if(lockInfo)
+                {
+                    for(int i = 0; i < 8; ++i)
+                    {
+                        uint32 skillId = SkillByLockType(LockType(lockInfo->Index[i]));
+                        if(skillId > 0)
+                        {
+                            if (m_bot->HasSkill(skillId)) // Has skill
+                            {
+                                uint32 reqSkillValue = lockInfo->Skill[i];
+                                uint32 SkillValue = m_bot->GetPureSkillValue(skillId);
+                                if (SkillValue >= reqSkillValue)
+                                {
+                                    // sLog.outDebug("[PlayerbotAI]i: skillId : %u SkillValue : %u reqSkillValue : %u",skillId,SkillValue,reqSkillValue);
+                                    m_bot->UpdateGatherSkill(skillId, SkillValue, reqSkillValue);
+                                    looted = true;
+                                }
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+            for ( uint32 l=0; l<lootNum; l++ )
+            {
+                // sLog.outDebug("[PlayerbotAI]: lootNum : %u",lootNum);
+                QuestItem *qitem=0, *ffaitem=0, *conditem=0;
+                LootItem *item = loot->LootItemInSlot( l, m_bot, &qitem, &ffaitem, &conditem );
+                if ( !item )
+                    continue;
+
+                if ( !qitem && item->is_blocked )
+                {
+                    m_bot->SendLootRelease( m_lootCurrent );
+                    continue;
+                }
+
+                if ( m_needItemList[item->itemid]>0 )
+                {
+                    ItemPosCountVec dest;
+                    if ( m_bot->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, item->itemid, item->count ) == EQUIP_ERR_OK )
+                    {
+                        Item * newitem = m_bot->StoreNewItem( dest, item->itemid, true, item->randomPropertyId);
+
+                        if ( qitem )
+                        {
+                            qitem->is_looted = true;
+                            if ( item->freeforall || loot->GetPlayerQuestItems().size() == 1 )
+                                m_bot->SendNotifyLootItemRemoved( l );
+                            else
+                                loot->NotifyQuestItemRemoved( qitem->index );
+                        }
+                        else
+                        {
+                            if ( ffaitem )
+                            {
+                                ffaitem->is_looted=true;
+                                m_bot->SendNotifyLootItemRemoved( l );
+                            }
+                            else
+                            {
+                                if ( conditem )
+                                    conditem->is_looted=true;
+                                loot->NotifyItemRemoved( l );
+                            }
+                        }
+                        if (!item->freeforall)
+                            item->is_looted = true;
+                        --loot->unlootedCount;
+                        m_bot->SendNewItem( newitem, uint32(item->count), false, false, true );
+                        m_bot->GetAchievementMgr().UpdateAchievementCriteria( ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count );
+                        looted = true;
+                    }
+                    continue;
+                }
+
+                uint32 lockId = go->GetGOInfo()->GetLockId();
+                LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+                if(lockInfo)
+                {
+                    uint32 skillId = 0;
+                    uint32 reqSkillValue = 0;
+                    for(int i = 0; i < 8; ++i)
+                    {
+                        skillId = SkillByLockType(LockType(lockInfo->Index[i]));
+                        if(skillId > 0)
+                        {
+                            reqSkillValue = lockInfo->Skill[i];
+                            break;
+                        }
+                    }
+
+                    if (m_bot->HasSkill(skillId) || skillId == SKILL_NONE) // Has skill or skill not required
+                    {
+                        if((skillId == SKILL_MINING) && !HasPick())
+                            continue;
+
+                        ItemPosCountVec dest;
+                        if ( m_bot->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK )
+                        {
+                            Item* pItem = m_bot->StoreNewItem (dest,item->itemid,true,item->randomPropertyId);
+                            uint32 SkillValue = m_bot->GetPureSkillValue(skillId);
+                            if (SkillValue >= reqSkillValue)
+                            {
+                                m_bot->SendNewItem(pItem, uint32(item->count), false, false, true);
+                                m_bot->UpdateGatherSkill(skillId, SkillValue, reqSkillValue);
+                                --loot->unlootedCount;
+                                looted = true;
+                            }
+                        }
+                    }
+                }
+            }
+            // release loot
+            if(looted)
+                m_bot->GetSession()->DoLootRelease( m_lootCurrent );
+            else
+                m_bot->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_LOOTING);
+            // sLog.outDebug( "[PlayerbotAI]: %s looted target 0x%08X", m_bot->GetName(), m_lootCurrent );
+            SetQuestNeedItems();
+        }
+        else
+            SendWhisper("I have no info on that object", fromPlayer);
+    }
+
+        else if (text == "quests")
+        {
+               bool hasIncompleteQuests = false;
+               std::ostringstream incomout;
+               incomout << "my incomplete quests are:";
+               bool hasCompleteQuests = false;
+               std::ostringstream comout;
+               comout << "my complete quests are:";
+               for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+               {
+                    if(uint32 questId = m_bot->GetQuestSlotQuestId(slot))
+                    {
+                          Quest const* pQuest = sObjectMgr.GetQuestTemplate(questId);
+
+                          std::string questTitle  = pQuest->GetTitle();
+                          m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questId);
+
+                         if (m_bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE) {
+                               hasCompleteQuests = true;
+                               comout << " |cFFFFFF00|Hquest:" << questId << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                          }
+                          else {
+                               hasIncompleteQuests = true;
+                               incomout << " |cFFFFFF00|Hquest:" << questId << ':' << pQuest->GetQuestLevel() << "|h[" <<  questTitle << "]|h|r";
+                          }
+                    }
+               }
+               if (hasCompleteQuests)
+                    SendWhisper(comout.str(), fromPlayer);
+               if (hasIncompleteQuests)
+                    SendWhisper(incomout.str(), fromPlayer);
+               if (! hasCompleteQuests && ! hasIncompleteQuests)
+                    SendWhisper("I have no quests!", fromPlayer);
+       }
+
+    // drop a quest
+       else if (text.size() > 5 && text.substr(0, 5) == "drop ")
+       {
+            uint64 oldSelectionGUID = 0;
+            if (fromPlayer.GetSelection() != m_bot->GetGUID()) {
+                  oldSelectionGUID = m_bot->GetGUID();
+                  fromPlayer.SetSelection(m_bot->GetGUID());
+            }
+            PlayerbotChatHandler ch(GetMaster());
+            if (! ch.dropQuest(text.substr(5).c_str()))
+                  ch.sysmessage("ERROR: could not drop quest");
+            if (oldSelectionGUID)
+                  fromPlayer.SetSelection(oldSelectionGUID);
+       }
+
+
+
+    else if (text == "spells")
+    {
+
+        int loc = GetMaster()->GetSession()->GetSessionDbcLocale();
+
+        std::ostringstream posOut;
+        std::ostringstream negOut;
+
+        const std::string ignoreList = ",Opening,Closing,Stuck,Remove Insignia,Opening - No Text,Grovel,Duel,Honorless Target,";
+        std::string alreadySeenList = ",";
+
+        for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr) {
+            const uint32 spellId = itr->first;
+
+            if (itr->second.state == PLAYERSPELL_REMOVED || itr->second.disabled || IsPassiveSpell(spellId))
+                continue;
+
+            const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+            if (!pSpellInfo)
+                continue;
+
+            //|| name.find("Teleport") != -1
+
+            std::string comp = ",";
+            comp.append(pSpellInfo->SpellName[loc]);
+            comp.append(",");
+
+            if (!(ignoreList.find(comp) == std::string::npos && alreadySeenList.find(comp) == std::string::npos))
+                continue;
+
+            alreadySeenList += pSpellInfo->SpellName[loc];
+            alreadySeenList += ",";
+
+            if (IsPositiveSpell(spellId))
+                posOut << " |cffffffff|Hspell:" << spellId << "|h["
+                       << pSpellInfo->SpellName[loc] << "]|h|r";
+            else
+                negOut << " |cffffffff|Hspell:" << spellId << "|h["
+                       << pSpellInfo->SpellName[loc] << "]|h|r";
+        }
+
+        ChatHandler ch(&fromPlayer);
+        SendWhisper("here's my non-attack spells:", fromPlayer);
+        ch.SendSysMessage(posOut.str().c_str());
+        SendWhisper("and here's my attack spells:", fromPlayer);
+        ch.SendSysMessage(negOut.str().c_str());
+    }
+
+    // survey project: 18:30 29/04/10 rev.3 filter out event triggered objects & now updates list
+    else if (text == "survey")
+    {
+        uint32 count = 0;
+        std::ostringstream detectout;
+        QueryResult *result;
+        GameEventMgr::ActiveEvents const& activeEventsList = sGameEventMgr.GetActiveEventList();
+        std::ostringstream eventFilter;
+        eventFilter << " AND (event IS NULL ";
+        bool initString = true;
+
+        for (GameEventMgr::ActiveEvents::const_iterator itr = activeEventsList.begin(); itr != activeEventsList.end(); ++itr)
+        {
+            if (initString)
+            {
+                eventFilter  <<  "OR event IN (" <<*itr;
+                initString =false;
+            }
+            else
+                eventFilter << "," << *itr;
+        }
+
+        if (!initString)
+            eventFilter << "))";
+        else
+            eventFilter << ")";
+
+        result = WorldDatabase.PQuery("SELECT gameobject.guid, id, position_x, position_y, position_z, map, "
+            "(POW(position_x - %f, 2) + POW(position_y - %f, 2) + POW(position_z - %f, 2)) AS order_ FROM gameobject "
+            "LEFT OUTER JOIN game_event_gameobject on gameobject.guid=game_event_gameobject.guid WHERE map = '%i' %s ORDER BY order_ ASC LIMIT 10",
+            m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), m_bot->GetMapId(),eventFilter.str().c_str());
+
+      if (result)
+      {
+         do
+         {
+             Field *fields = result->Fetch();
+             uint32 guid = fields[0].GetUInt32();
+             uint32 entry = fields[1].GetUInt32();
+             float x = fields[2].GetFloat();
+             float y = fields[3].GetFloat();
+             float z = fields[4].GetFloat();
+             int mapid = fields[5].GetUInt16();
+
+             GameObject *go = m_bot->GetMap()->GetGameObject(MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT));
+             if (!go)
+                 continue;
+
+             if ( !go->isSpawned() )
+                 continue;
+
+             detectout << "|cFFFFFF00|Hfound:" << guid << ":" << entry << ":" << x << ":" << y << ":" << z  << ":" << mapid  << ":" <<  "|h[" << go->GetGOInfo()->name << "]|h|r";
+             ++count;
+         } while (result->NextRow());
+
+         delete result;
+      }
+      SendWhisper(detectout.str().c_str(), fromPlayer);
+    }
+
+    // stats project: 10:00 19/04/10 rev.1 display bot statistics
+    else if (text == "stats")
+    {
+         std::ostringstream out;
+
+         uint32 totalused = 0;
+         // list out items in main backpack
+         for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+         {
+              const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+              if (pItem)
+                  totalused++;
+         }
+         uint32 totalfree = 16 - totalused;
+         // list out items in other removable backpacks
+         for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+         {
+              const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+              if (pBag)
+              {
+                     ItemPrototype const* pBagProto = pBag->GetProto();
+                     if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+                     totalfree =  totalfree + pBag->GetFreeSlots();
+              }
+
+         }
+
+         // calculate how much money bot has
+         uint32 copper = m_bot->GetMoney();
+         uint32 gold = uint32(copper / 10000);
+         copper -= (gold * 10000);
+         uint32 silver = uint32(copper / 100);
+         copper -= (silver * 100);
+
+         out << "|cffffffff[|h|cff00ffff" << m_bot->GetName() << "|h|cffffffff]" << " has |r|cff00ff00" << gold
+                 << "|r|cfffffc00g|r|cff00ff00" << silver
+                 << "|r|cffcdcdcds|r|cff00ff00" << copper
+                 << "|r|cffffd333c" << "|h|cffffffff bag slots |h|cff00ff00" << totalfree;
+
+         // estimate how much item damage the bot has
+         copper = EstRepairAll();
+         gold = uint32(copper / 10000);
+         copper -= (gold * 10000);
+         silver = uint32(copper / 100);
+         copper -= (silver * 100);
+
+         out << "|h|cffffffff & item damage cost " << "|r|cff00ff00" << gold
+                 << "|r|cfffffc00g|r|cff00ff00" << silver
+                 << "|r|cffcdcdcds|r|cff00ff00" << copper
+                 << "|r|cffffd333c";
+         ChatHandler ch(&fromPlayer);
+         ch.SendSysMessage(out.str().c_str());
+    }
+    else
+    {
+        // if this looks like an item link, reward item it completed quest and talking to NPC
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (!itemIds.empty()) {
+               uint32 itemId = itemIds.front();
+               bool wasRewarded = false;
+               uint64 questRewarderGUID = m_bot->GetSelection();
+               Object* const pNpc = (WorldObject*) m_bot->GetObjectByTypeMask(questRewarderGUID, TYPEMASK_CREATURE_OR_GAMEOBJECT);
+               if (!pNpc)
+                    return;
+
+               QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+               for (uint32 iI = 0; !wasRewarded && iI < questMenu.MenuItemCount(); ++iI)
+               {
+                     QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+                     uint32 questID = qItem.m_qId;
+                     Quest const* pQuest = sObjectMgr.GetQuestTemplate(questID);
+                     QuestStatus status = m_bot->GetQuestStatus(questID);
+
+                     // if quest is complete, turn it in
+                     if (status == QUEST_STATUS_COMPLETE &&
+                     ! m_bot->GetQuestRewardStatus(questID) &&
+                       pQuest->GetRewChoiceItemsCount() > 1 &&
+                          m_bot->CanRewardQuest(pQuest, false))
+                     {
+                           for (uint8 rewardIdx=0; !wasRewarded && rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+                           {
+                                ItemPrototype const * const pRewardItem = sObjectMgr.GetItemPrototype(pQuest->RewChoiceItemId[rewardIdx]);
+                                if (itemId == pRewardItem->ItemId)
+                                {
+                                      m_bot->RewardQuest(pQuest, rewardIdx, pNpc, false);
+
+                                      std::string questTitle  = pQuest->GetTitle();
+                                      m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questID);
+                                      std::string itemName = pRewardItem->Name1;
+                                      m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+
+                                      std::ostringstream out;
+                                      out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r rewarded";
+                                      SendWhisper(out.str(), fromPlayer);
+                                      wasRewarded = true;
+                                }
+                           }
+                     }
+               }
+
+        }
+        else {
+            std::string msg = "What? follow, stay, (c)ast <spellname>, spells, (e)quip <itemlink>, (u)se <itemlink>, drop <questlink>, report, quests, stats";
+            SendWhisper(msg, fromPlayer);
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+        }
+    }
+}
diff --git a/Core/src/game/PlayerbotAI.h b/Core/src/game/PlayerbotAI.h
new file mode 100644
index 0000000..ef4383f
--- /dev/null
+++ b/Core/src/game/PlayerbotAI.h
@@ -0,0 +1,287 @@
+#ifndef _PLAYERBOTAI_H
+#define _PLAYERBOTAI_H
+
+#include "Common.h"
+#include "QuestDef.h"
+#include "GameEventMgr.h"
+
+class WorldPacket;
+class WorldObject;
+class Player;
+class Unit;
+class Object;
+class Item;
+class PlayerbotClassAI;
+class PlayerbotMgr;
+
+#define BOTLOOT_DISTANCE 25.0f
+
+class MANGOS_DLL_SPEC PlayerbotAI
+{
+    public:
+        enum ScenarioType
+        {
+            SCENARIO_PVEEASY,
+            SCENARIO_PVEHARD,
+            SCENARIO_DUEL,
+            SCENARIO_PVPEASY,
+            SCENARIO_PVPHARD
+        };
+
+        enum CombatStyle {
+            COMBAT_MELEE                = 0x01,         // class melee attacker
+            COMBAT_RANGED               = 0x02          // class is ranged attacker
+        };
+
+        // masters orders that should be obeyed by the AI during the updteAI routine
+        // the master will auto set the target of the bot
+        enum CombatOrderType
+        {
+            ORDERS_NONE                 = 0x00,         // no special orders given
+            ORDERS_TANK                 = 0x01,         // bind attackers by gaining threat
+            ORDERS_ASSIST               = 0x02,         // assist someone (dps type)
+            ORDERS_HEAL                 = 0x04,         // concentrate on healing (no attacks, only self defense)
+            ORDERS_PROTECT              = 0x10,         // combinable state: check if protectee is attacked
+            ORDERS_PRIMARY              = 0x0F,
+            ORDERS_SECONDARY            = 0xF0,
+            ORDERS_RESET                = 0xFF
+        };
+
+        enum CombatTargetType
+        {
+            TARGET_NORMAL       = 0x00,
+            TARGET_THREATEN     = 0x01
+        };
+
+        enum BotState
+        {
+            BOTSTATE_NORMAL,        // normal AI routines are processed
+            BOTSTATE_COMBAT,        // bot is in combat
+            BOTSTATE_DEAD,          // we are dead and wait for becoming ghost
+            BOTSTATE_DEADRELEASED,  // we released as ghost and wait to revive
+            BOTSTATE_LOOTING        // looting mode, used just after combat
+        };
+
+        enum MovementOrderType
+        {
+            MOVEMENT_NONE		= 0x00,
+            MOVEMENT_FOLLOW		= 0x01,
+            MOVEMENT_STAY		= 0x02
+        };
+
+        typedef std::map<uint32, uint32> BotNeedItem;
+        typedef std::list<uint64> BotLootCreature;
+
+        // attacker query used in PlayerbotAI::FindAttacker()
+        enum ATTACKERINFOTYPE
+        {
+            AIT_NONE            = 0x00,
+            AIT_LOWESTTHREAT    = 0x01,
+            AIT_HIGHESTTHREAT   = 0x02,
+            AIT_VICTIMSELF      = 0x04,
+            AIT_VICTIMNOTSELF   = 0x08	// !!! must use victim param in FindAttackers
+        };
+        struct AttackerInfo
+        {
+            Unit*    attacker;        // reference to the attacker
+            Unit*    victim;          // combatant's current victim
+            float    threat;          // own threat on this combatant
+            float    threat2;         // highest threat not caused by bot
+            uint32  count;            // number of units attacking
+            uint32  source;           // 1=bot, 2=master, 3=group
+        };
+        typedef std::map<uint64,AttackerInfo> AttackerInfoList;
+
+    public:
+        PlayerbotAI(PlayerbotMgr* const mgr, Player* const bot);
+        virtual ~PlayerbotAI();
+
+        // This is called from Unit.cpp and is called every second (I think)
+        void UpdateAI(const uint32 p_time);
+
+        // This is called from ChatHandler.cpp when there is an incoming message to the bot
+        // from a whisper or from the party channel
+        void HandleCommand(const std::string& text, Player& fromPlayer);
+
+        // This is called by WorldSession.cpp
+        // It provides a view of packets normally sent to the client.
+        // Since there is no client at the other end, the packets are dropped of course.
+        // For a list of opcodes that can be caught see Opcodes.cpp (SMSG_* opcodes only)
+        void HandleBotOutgoingPacket(const WorldPacket& packet);
+
+        // This is called by WorldSession.cpp
+        // when it detects that a bot is being teleported. It acknowledges to the server to complete the
+        // teleportation
+        void HandleTeleportAck();
+
+        // Returns what kind of situation we are in so the ai can react accordingly
+        ScenarioType GetScenarioType() {return m_ScenarioType;}
+
+        PlayerbotClassAI* GetClassAI() {return m_classAI;}
+        PlayerbotMgr* const GetManager() {return m_mgr;}
+
+        // finds spell ID for matching substring args
+        // in priority of full text match, spells not taking reagents, and highest rank
+        uint32 getSpellId(const char* args, bool master = false) const;
+
+        // extracts item ids from links
+        void extractItemIds(const std::string& text, std::list<uint32>& itemIds) const;
+
+        // extracts currency from a string as #g#s#c and returns the total in copper
+        uint32 extractMoney(const std::string& text) const;
+
+        // extracts gameobject info from link
+        bool extractGOinfo(const std::string& text, uint32 &guid,  uint32 &entry, int &mapid, float &x, float &y, float &z) const;
+
+        // finds items in bots equipment and adds them to foundItemList, removes found items from itemIdSearchList
+        void findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+        // finds items in bots inventory and adds them to foundItemList, removes found items from itemIdSearchList
+        void findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+
+        // currently bots only obey commands from the master
+        bool canObeyCommandFrom(const Player& player) const;
+
+        // get current casting spell (will return NULL if no spell!)
+        Spell* GetCurrentSpell() const;
+
+        bool HasAura(uint32 spellId, const Unit& player) const;
+        bool HasAura(const char* spellName, const Unit& player) const;
+        bool HasAura(const char* spellName) const;
+
+        bool HasPick();
+
+        uint8 GetHealthPercent(const Unit& target) const;
+        uint8 GetHealthPercent() const;
+        uint8 GetBaseManaPercent(const Unit& target) const;
+        uint8 GetBaseManaPercent() const;
+        uint8 GetManaPercent(const Unit& target) const;
+        uint8 GetManaPercent() const;
+        uint8 GetRageAmount(const Unit& target) const;
+        uint8 GetRageAmount() const;
+        uint8 GetEnergyAmount(const Unit& target) const;
+        uint8 GetEnergyAmount() const;
+        uint8 GetRunicPower(const Unit& target) const;
+        uint8 GetRunicPower() const;
+
+        Item* FindFood() const;
+        Item* FindDrink() const;
+        Item* FindBandage() const;
+        Item* FindPoison() const;
+        Item* FindMount(uint32 matchingRidingSkill) const;
+        Item* FindItem(uint32 ItemId);
+
+        // ******* Actions ****************************************
+        // Your handlers can call these actions to make the bot do things.
+        void TellMaster(const std::string& text) const;
+        void TellMaster( const char *fmt, ... ) const;
+        void SendWhisper(const std::string& text, Player& player) const;
+        bool CastSpell(const char* args);
+        bool CastSpell(uint32 spellId);
+        bool CastSpell(uint32 spellId, Unit& target);
+        void UseItem(Item& item);
+        void EquipItem(Item& item);
+        //void Stay();
+        //bool Follow(Player& player);
+        void SendNotEquipList(Player& player);
+        void Feast();
+        void InterruptCurrentCastingSpell();
+        void GetCombatTarget( Unit* forcedTarged = 0 );
+        Unit *GetCurrentTarget() { return m_targetCombat; };
+        void DoNextCombatManeuver();
+        void DoCombatMovement();
+        void SetIgnoreUpdateTime(uint8 t) {m_ignoreAIUpdatesUntilTime=time(0) + t; };
+
+        Player *GetPlayerBot() const {return m_bot;}
+        Player *GetPlayer() const {return m_bot;}
+        Player *GetMaster() const;
+
+        BotState GetState() { return m_botState; };
+        void SetState( BotState state );
+        void SetQuestNeedItems();
+        void SendQuestItemList( Player& player );
+        void SendOrders( Player& player );
+        bool FollowCheckTeleport( WorldObject &obj );
+        void DoLoot();
+
+        uint32 EstRepairAll();
+        uint32 EstRepair(uint16 pos);
+
+        void AcceptQuest( Quest const *qInfo, Player *pGiver );
+        void TurnInQuests( WorldObject *questgiver );
+
+        bool IsInCombat();
+        void UpdateAttackerInfo();
+        Unit* FindAttacker( ATTACKERINFOTYPE ait=AIT_NONE, Unit *victim=0 );
+        uint32 GetAttackerCount() { return m_attackerInfo.size(); };
+        void SetCombatOrderByStr( std::string str, Unit *target=0 );
+        void SetCombatOrder( CombatOrderType co, Unit *target=0 );
+        CombatOrderType GetCombatOrder() { return this->m_combatOrder; }
+        void SetMovementOrder( MovementOrderType mo, Unit *followTarget=0 );
+        MovementOrderType GetMovementOrder() { return this->m_movementOrder; }
+        void MovementReset();
+        void MovementUpdate();
+        void MovementClear();
+        bool IsMoving();
+
+        void SetInFront( const Unit* obj );
+
+        void ItemLocalization(std::string& itemName, const uint32 itemID) const;
+        void QuestLocalization(std::string& questTitle, const uint32 questID) const;
+
+    private:
+        // ****** Closed Actions ********************************
+        // These actions may only be called at special times.
+        // Trade methods are only applicable when the trade window is open
+        // and are only called from within HandleCommand.
+        bool TradeItem(const Item& item, int8 slot=-1);
+        bool TradeCopper(uint32 copper);
+
+        // it is safe to keep these back reference pointers because m_bot
+        // owns the "this" object and m_master owns m_bot. The owner always cleans up.
+        PlayerbotMgr* const m_mgr;
+        Player* const m_bot;
+        PlayerbotClassAI* m_classAI;
+
+        // ignores AI updates until time specified
+        // no need to waste CPU cycles during casting etc
+        time_t m_ignoreAIUpdatesUntilTime;
+
+        CombatStyle m_combatStyle;
+        CombatOrderType m_combatOrder;
+        MovementOrderType m_movementOrder;
+
+        ScenarioType m_ScenarioType;
+
+        // defines the state of behaviour of the bot
+        BotState m_botState;
+
+        // list of items needed to fullfill quests
+        BotNeedItem m_needItemList;
+
+        // list of creatures we recently attacked and want to loot
+        BotLootCreature m_lootCreature;  // list of creatures
+        uint64 m_lootCurrent;            // current remains of interest
+
+        time_t m_TimeDoneEating;
+        time_t m_TimeDoneDrinking;
+        uint32 m_CurrentlyCastingSpellId;
+        //bool m_IsFollowingMaster;
+
+        // if master commands bot to do something, store here until updateAI
+        // can do it
+        uint32 m_spellIdCommand;
+        uint64 m_targetGuidCommand;
+
+        AttackerInfoList m_attackerInfo;
+
+        bool m_targetChanged;
+        CombatTargetType m_targetType;
+
+        Unit *m_targetCombat;	// current combat target
+        Unit *m_targetAssist;	// get new target by checking attacker list of assisted player
+        Unit *m_targetProtect;	// check
+
+        Unit *m_followTarget;	// whom to follow in non combat situation?
+};
+
+#endif
diff --git a/Core/src/game/PlayerbotClassAI.cpp b/Core/src/game/PlayerbotClassAI.cpp
new file mode 100644
index 0000000..b7e853c
--- /dev/null
+++ b/Core/src/game/PlayerbotClassAI.cpp
@@ -0,0 +1,17 @@
+#include "PlayerbotClassAI.h"
+#include "Common.h"
+
+PlayerbotClassAI::PlayerbotClassAI(Player* const master, Player* const bot, PlayerbotAI* const ai): m_master(master), m_bot(bot), m_ai(ai) {}
+PlayerbotClassAI::~PlayerbotClassAI() {}
+
+bool PlayerbotClassAI::DoFirstCombatManeuver(Unit *)
+{
+    // return false, if done with opening moves/spells
+    return false;
+}
+void PlayerbotClassAI::DoNextCombatManeuver(Unit *) {}
+
+void PlayerbotClassAI::DoNonCombatActions(){}
+
+void PlayerbotClassAI::BuffPlayer(Player* target) {}
+
diff --git a/Core/src/game/PlayerbotClassAI.h b/Core/src/game/PlayerbotClassAI.h
new file mode 100644
index 0000000..795ea15
--- /dev/null
+++ b/Core/src/game/PlayerbotClassAI.h
@@ -0,0 +1,45 @@
+#ifndef _PLAYERBOTCLASSAI_H
+#define _PLAYERBOTCLASSAI_H
+
+#include "Common.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "Unit.h"
+#include "SharedDefines.h"
+#include "PlayerbotAI.h"
+
+class Player;
+class PlayerbotAI;
+
+class MANGOS_DLL_SPEC PlayerbotClassAI
+{
+    public:
+        PlayerbotClassAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
+        virtual ~PlayerbotClassAI();
+
+        // all combat actions go here
+        virtual bool DoFirstCombatManeuver(Unit*);
+        virtual void DoNextCombatManeuver(Unit*);
+
+        // all non combat actions go here, ex buffs, heals, rezzes
+        virtual void DoNonCombatActions();
+
+        // buff a specific player, usually a real PC who is not in group
+        virtual void BuffPlayer(Player* target);
+
+        // Utilities
+        Player* GetMaster () {return m_master;}
+        Player* GetPlayerBot() {return m_bot;}
+        PlayerbotAI* GetAI (){return m_ai;};
+
+
+    private:
+        Player* m_master;
+        Player* m_bot;
+        PlayerbotAI* m_ai;
+};
+
+#endif
diff --git a/Core/src/game/PlayerbotDeathKnightAI.cpp b/Core/src/game/PlayerbotDeathKnightAI.cpp
new file mode 100644
index 0000000..e1bb31d
--- /dev/null
+++ b/Core/src/game/PlayerbotDeathKnightAI.cpp
@@ -0,0 +1,504 @@
+// a simple DK class by rrtn :)
+
+#include "PlayerbotDeathKnightAI.h"
+#include "PlayerbotMgr.h"
+
+class PlayerbotAI;
+PlayerbotDeathKnightAI::PlayerbotDeathKnightAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+
+    PLAGUE_STRIKE     = ai->getSpellId("plague strike"); // Unholy
+    DEATH_GRIP        = ai->getSpellId("death grip");
+    DEATH_COIL        = ai->getSpellId("death coil");
+    DEATH_STRIKE      = ai->getSpellId("death strike");
+    UNHOLY_BLIGHT     = ai->getSpellId("unholy blight");
+    SCOURGE_STRIKE    = ai->getSpellId("scourge strike");
+    DEATH_AND_DECAY   = ai->getSpellId("death and decay");
+    CORPSE_EXPLOSION  = ai->getSpellId("corpse explosion");
+    BONE_SHIELD		  = ai->getSpellId("shield"); // buffs
+    ANTI_MAGIC_SHELL  = ai->getSpellId("anti-magic shell");
+    ANTI_MAGIC_ZONE   = ai->getSpellId("anti-magic");
+    GHOUL_FRENZY      = ai->getSpellId("ghoul frenzy");
+    RAISE_DEAD        = ai->getSpellId("raise dead"); // pets
+    SUMMON_GARGOYLE   = ai->getSpellId("summon gargoyle");
+    ARMY_OF_THE_DEAD  = ai->getSpellId("army of the dead");
+    ICY_TOUCH         = ai->getSpellId("icy touch"); // Frost
+    OBLITERATE        = ai->getSpellId("obliterate");
+    HOWLING_BLAST     = ai->getSpellId("howling blast");
+    FROST_STRIKE      = ai->getSpellId("frost strike");
+    CHAINS_OF_ICE     = ai->getSpellId("chains of ice");
+    RUNE_STRIKE       = ai->getSpellId("rune strike");
+    ICY_CLUTCH        = ai->getSpellId("icy clutch");
+    MIND_FREEZE       = ai->getSpellId("mind freeze");
+    HUNGERING_COLD    = ai->getSpellId("hungering cold");
+    KILLING_MACHINE   = ai->getSpellId("killing machine"); // buffs
+    DEATHCHILL        = ai->getSpellId("deathchill");
+    HORN_OF_WINTER    = ai->getSpellId("horn of winter");
+    ICEBOUND_FORTITUDE= ai->getSpellId("icebound fortitude");
+    EMPOWER_WEAPON    = ai->getSpellId("empower rune weapon");
+    UNBREAKABLE_ARMOR = ai->getSpellId("unbreakable armor");
+    BLOOD_STRIKE      = ai->getSpellId("blood strike"); // Blood
+    PESTILENCE        = ai->getSpellId("pestilence");
+    STRANGULATE       = ai->getSpellId("strangulate");
+    BLOOD_BOIL        = ai->getSpellId("blood boil");
+    HEART_STRIKE      = ai->getSpellId("heart strike");
+    DANCING_WEAPON    = ai->getSpellId("dancing rune weapon");
+    DARK_COMMAND      = ai->getSpellId("dark command");
+    MARK_OF_BLOOD     = ai->getSpellId("mark of blood"); // buffs
+    RUNE_TAP		  = ai->getSpellId("rune tap");
+    VAMPIRIC_BLOOD    = ai->getSpellId("vampiric blood");
+    DEATH_PACT        = ai->getSpellId("death pact");
+    DEATH_RUNE_MASTERY= ai->getSpellId("death rune mastery");
+    HYSTERIA          = ai->getSpellId("hysteria");
+    UNHOLY_PRESENCE   = ai->getSpellId("unholy presence"); // presence (TODO: better spell == presence)
+    FROST_PRESENCE    = ai->getSpellId("frost presence");
+    BLOOD_PRESENCE    = ai->getSpellId("blood presence");
+
+    RECENTLY_BANDAGED = 11196; // first aid check
+
+	// racial
+    ARCANE_TORRENT          = ai->getSpellId("arcane torrent"); // blood elf
+    GIFT_OF_THE_NAARU       = ai->getSpellId("gift of the naaru"); // draenei
+    STONEFORM               = ai->getSpellId("stoneform"); // dwarf
+    ESCAPE_ARTIST           = ai->getSpellId("escape artist"); // gnome
+    EVERY_MAN_FOR_HIMSELF   = ai->getSpellId("every man for himself"); // human
+    SHADOWMELD              = ai->getSpellId("shadowmeld"); // night elf
+    BLOOD_FURY              = ai->getSpellId("blood fury"); // orc
+    WAR_STOMP               = ai->getSpellId("war stomp"); // tauren
+    BERSERKING              = ai->getSpellId("berserking"); // troll
+    WILL_OF_THE_FORSAKEN    = ai->getSpellId("will of the forsaken"); // undead
+}
+
+PlayerbotDeathKnightAI::~PlayerbotDeathKnightAI() {}
+
+void PlayerbotDeathKnightAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(PLAGUE_STRIKE);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    //ai->SetMovementOrder( PlayerbotAI::MOVEMENT_FOLLOW, GetMaster() ); // dont want to melee mob
+
+    // DK Attacks: Unholy, Frost & Blood
+
+    // damage spells
+    ai->SetInFront( pTarget );//<---
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    Pet *pet = m_bot->GetPet();
+    float dist = m_bot->GetDistance( pTarget );
+	std::ostringstream out;
+
+    switch (SpellSequence)
+    {
+        case SPELL_DK_UNHOLY:
+               if (UNHOLY_PRESENCE > 0)
+                     (!m_bot->HasAura(UNHOLY_PRESENCE, EFFECT_INDEX_0) && !m_bot->HasAura(BLOOD_PRESENCE, EFFECT_INDEX_0) && !m_bot->HasAura(FROST_PRESENCE, EFFECT_INDEX_0) && ai->CastSpell (UNHOLY_PRESENCE, *m_bot));
+
+               // check for BONE_SHIELD in combat
+               if (BONE_SHIELD > 0)
+                     (!m_bot->HasAura(BONE_SHIELD, EFFECT_INDEX_0) && !m_bot->HasAura(ARMY_OF_THE_DEAD, EFFECT_INDEX_0) && ai->CastSpell (BONE_SHIELD, *m_bot));
+
+               if (ARMY_OF_THE_DEAD > 0 && ai->GetAttackerCount()>=5 && LastSpellUnholyDK < 1)
+               {
+                      ai->CastSpell(ARMY_OF_THE_DEAD);
+                      out << " summoning Army of the Dead!";
+                      if (ARMY_OF_THE_DEAD > 0 && m_bot->HasAura(ARMY_OF_THE_DEAD, EFFECT_INDEX_0))
+                      ai->SetIgnoreUpdateTime(7);
+                      SpellSequence = SPELL_DK_FROST;
+                      LastSpellUnholyDK = LastSpellUnholyDK +1;
+                      break;
+               }
+               else if (PLAGUE_STRIKE > 0 && !pTarget->HasAura(PLAGUE_STRIKE, EFFECT_INDEX_0) && LastSpellUnholyDK < 2)
+               {
+                      ai->CastSpell(PLAGUE_STRIKE, *pTarget);
+                      out << " Plague Strike";
+                      SpellSequence = SPELL_DK_FROST;
+                      LastSpellUnholyDK = LastSpellUnholyDK +1;
+                      break;
+               }
+               else if (DEATH_GRIP > 0 && !pTarget->HasAura(DEATH_GRIP, EFFECT_INDEX_0) && LastSpellUnholyDK < 3)
+               {
+                      ai->CastSpell(DEATH_GRIP, *pTarget);
+                      out << " Death Grip";
+                      SpellSequence = SPELL_DK_FROST;
+                      LastSpellUnholyDK = LastSpellUnholyDK +1;
+                      break;
+               }
+               else if (DEATH_COIL > 0 && LastSpellUnholyDK < 4 && ai->GetRunicPower() >= 40)
+               {
+                      ai->CastSpell(DEATH_COIL, *pTarget);
+                      out << " Death Coil";
+                      SpellSequence = SPELL_DK_FROST;
+                      LastSpellUnholyDK = LastSpellUnholyDK +1;
+                      break;
+               }
+               else if (DEATH_STRIKE > 0 && !pTarget->HasAura(DEATH_STRIKE, EFFECT_INDEX_0) && LastSpellUnholyDK < 5)
+               {
+                      ai->CastSpell(DEATH_STRIKE, *pTarget);
+                      out << " Death Strike";
+                      SpellSequence = SPELL_DK_FROST;
+                      LastSpellUnholyDK = LastSpellUnholyDK +1;
+                      break;
+               }
+               else if (UNHOLY_BLIGHT > 0 && !pTarget->HasAura(UNHOLY_BLIGHT, EFFECT_INDEX_0) && LastSpellUnholyDK < 6)
+               {
+                      ai->CastSpell(UNHOLY_BLIGHT);
+                      out << " Unholy Blight";
+                      SpellSequence = SPELL_DK_FROST;
+                      LastSpellUnholyDK = LastSpellUnholyDK +1;
+                      break;
+               }
+               else if (SCOURGE_STRIKE > 0 && LastSpellUnholyDK < 7)
+               {
+                      ai->CastSpell(SCOURGE_STRIKE, *pTarget);
+                      out << " Scourge Strike";
+                      SpellSequence = SPELL_DK_FROST;
+                      LastSpellUnholyDK = LastSpellUnholyDK +1;
+                      break;
+               }
+               else if (DEATH_AND_DECAY > 0 && ai->GetAttackerCount()>=3 && dist <= ATTACK_DISTANCE && !pTarget->HasAura(DEATH_AND_DECAY, EFFECT_INDEX_0) && LastSpellUnholyDK < 8)
+               {
+                      ai->CastSpell(DEATH_AND_DECAY);
+                      out << " Death and Decay";
+                      ai->SetIgnoreUpdateTime(1);
+                      SpellSequence = SPELL_DK_FROST;
+                      LastSpellUnholyDK = LastSpellUnholyDK +1;
+                      break;
+               }
+               else if (SUMMON_GARGOYLE > 0 && !m_bot->HasAura(ARMY_OF_THE_DEAD, EFFECT_INDEX_0) && !pTarget->HasAura(SUMMON_GARGOYLE, EFFECT_INDEX_0) && LastSpellUnholyDK < 9 && ai->GetRunicPower() >= 60)
+               {
+                     ai->CastSpell(SUMMON_GARGOYLE, *pTarget);
+                     out << " summoning Gargoyle";
+                     ai->SetIgnoreUpdateTime(2);
+                     SpellSequence = SPELL_DK_FROST;
+                     LastSpellUnholyDK = LastSpellUnholyDK +1;
+                     break;
+               }
+               else if (CORPSE_EXPLOSION > 0 && dist <= ATTACK_DISTANCE && LastSpellUnholyDK < 10)
+               {
+                     ai->CastSpell(CORPSE_EXPLOSION, *pTarget);
+                     out << " Corpse Explosion";
+                     SpellSequence = SPELL_DK_FROST;
+                     LastSpellUnholyDK = LastSpellUnholyDK +1;
+                     break;
+               }
+               else if (ANTI_MAGIC_SHELL > 0 && pTarget->IsNonMeleeSpellCasted(true) && !m_bot->HasAura(ANTI_MAGIC_SHELL, EFFECT_INDEX_0) && LastSpellUnholyDK < 11 && ai->GetRunicPower() >= 20)
+               {
+                     ai->CastSpell(ANTI_MAGIC_SHELL, *m_bot);
+                     out << " Anti-Magic Shell";
+                     SpellSequence = SPELL_DK_FROST;
+                     LastSpellUnholyDK = LastSpellUnholyDK +1;
+                     break;
+               }
+               else if (ANTI_MAGIC_ZONE > 0 && pTarget->IsNonMeleeSpellCasted(true) && !m_bot->HasAura(ANTI_MAGIC_SHELL, EFFECT_INDEX_0) && LastSpellUnholyDK < 12)
+               {
+                     ai->CastSpell(ANTI_MAGIC_ZONE, *m_bot);
+                     out << " Anti-Magic Zone";
+                     SpellSequence = SPELL_DK_FROST;
+                     LastSpellUnholyDK = LastSpellUnholyDK +1;
+                     break;
+               }
+               else if(( !pet )
+                     && (RAISE_DEAD > 0 && !m_bot->HasAura(ARMY_OF_THE_DEAD, EFFECT_INDEX_0) && LastSpellUnholyDK < 13))
+               {
+                     ai->CastSpell(RAISE_DEAD);
+                     out << " summoning Ghoul";
+                     SpellSequence = SPELL_DK_FROST;
+                     LastSpellUnholyDK = LastSpellUnholyDK +1;
+                     break;
+               }
+               else if(( pet )
+                     && (GHOUL_FRENZY > 0 && pVictim == pet && !pet->HasAura(GHOUL_FRENZY, EFFECT_INDEX_0) && LastSpellUnholyDK < 14))
+               {
+                     ai->CastSpell(GHOUL_FRENZY, *pet);
+                     out << " casting Ghoul Frenzy on pet";
+                     SpellSequence = SPELL_DK_FROST;
+                     LastSpellUnholyDK = LastSpellUnholyDK +1;
+                     break;
+               }
+               else if (LastSpellUnholyDK > 15)
+               {
+                     LastSpellUnholyDK = 0;
+                     SpellSequence = SPELL_DK_FROST;
+                     break;
+               }
+
+               LastSpellUnholyDK = 0;
+
+        case SPELL_DK_FROST:
+               if (FROST_PRESENCE > 0)
+                     (!m_bot->HasAura(FROST_PRESENCE, EFFECT_INDEX_0) && !m_bot->HasAura(BLOOD_PRESENCE, EFFECT_INDEX_0) && !m_bot->HasAura(UNHOLY_PRESENCE, EFFECT_INDEX_0) && ai->CastSpell (FROST_PRESENCE, *m_bot));
+
+               if (DEATHCHILL > 0)
+                     (!m_bot->HasAura(DEATHCHILL, EFFECT_INDEX_0) && !m_bot->HasAura(KILLING_MACHINE, EFFECT_INDEX_0) && ai->CastSpell (DEATHCHILL, *m_bot));
+               else if (KILLING_MACHINE > 0)
+                     (!m_bot->HasAura(KILLING_MACHINE, EFFECT_INDEX_0) && !m_bot->HasAura(DEATHCHILL, EFFECT_INDEX_0) && ai->CastSpell (KILLING_MACHINE, *m_bot));
+
+               if (ICY_TOUCH > 0 && !pTarget->HasAura(ICY_TOUCH, EFFECT_INDEX_0) && LastSpellFrostDK < 1)
+               {
+                     ai->CastSpell(ICY_TOUCH, *pTarget);
+                     out << " Icy Touch";
+                     SpellSequence = SPELL_DK_BLOOD;
+                     LastSpellFrostDK = LastSpellFrostDK +1;
+                     break;
+               }
+               else if (OBLITERATE > 0 && LastSpellFrostDK < 2)
+               {
+                     ai->CastSpell(OBLITERATE, *pTarget);
+                     out << " Obliterate";
+                     SpellSequence = SPELL_DK_BLOOD;
+                     LastSpellFrostDK = LastSpellFrostDK +1;
+                     break;
+               }
+               else if (FROST_STRIKE > 0 && LastSpellFrostDK < 3 && ai->GetRunicPower() >= 40)
+               {
+                     ai->CastSpell(FROST_STRIKE, *pTarget);
+                     out << " Frost Strike";
+                     SpellSequence = SPELL_DK_BLOOD;
+                     LastSpellFrostDK = LastSpellFrostDK +1;
+                     break;
+               }
+               else if (HOWLING_BLAST > 0 && ai->GetAttackerCount()>=3 && LastSpellFrostDK < 4)
+               {
+                     ai->CastSpell(HOWLING_BLAST, *pTarget);
+                     out << " Howling Blast";
+                     SpellSequence = SPELL_DK_BLOOD;
+                     LastSpellFrostDK = LastSpellFrostDK +1;
+                     break;
+               }
+               else if (CHAINS_OF_ICE > 0 && !pTarget->HasAura(CHAINS_OF_ICE, EFFECT_INDEX_0) && LastSpellFrostDK < 5)
+               {
+                     ai->CastSpell(CHAINS_OF_ICE, *pTarget);
+                     out << " Chains of Ice";
+                     SpellSequence = SPELL_DK_BLOOD;
+                     LastSpellFrostDK = LastSpellFrostDK +1;
+                     break;
+               }
+               else if (RUNE_STRIKE > 0 && LastSpellFrostDK < 6 && ai->GetRunicPower() >= 20)
+               {
+                     ai->CastSpell(RUNE_STRIKE, *pTarget);
+                     out << " Rune Strike";
+                     SpellSequence = SPELL_DK_BLOOD;
+                     LastSpellFrostDK = LastSpellFrostDK +1;
+                     break;
+               }
+               else if (ICY_CLUTCH > 0 && !pTarget->HasAura(ICY_CLUTCH, EFFECT_INDEX_0) && LastSpellFrostDK < 7)
+               {
+                     ai->CastSpell(ICY_CLUTCH, *pTarget);
+                     out << " Icy Clutch";
+                     SpellSequence = SPELL_DK_BLOOD;
+                     LastSpellFrostDK = LastSpellFrostDK +1;
+                     break;
+               }
+               else if (ICEBOUND_FORTITUDE > 0 && ai->GetHealthPercent() < 50 && pVictim == m_bot && !m_bot->HasAura(ICEBOUND_FORTITUDE, EFFECT_INDEX_0) && LastSpellFrostDK < 8 && ai->GetRunicPower() >= 20)
+               {
+                     ai->CastSpell(ICEBOUND_FORTITUDE, *m_bot);
+                     out << " Icebound Fortitude";
+                     SpellSequence = SPELL_DK_BLOOD;
+                     LastSpellFrostDK = LastSpellFrostDK +1;
+                     break;
+               }
+               else if (MIND_FREEZE > 0 && pTarget->IsNonMeleeSpellCasted(true) && dist <= ATTACK_DISTANCE && LastSpellFrostDK < 9 && ai->GetRunicPower() >= 20)
+               {
+                     ai->CastSpell(MIND_FREEZE, *pTarget);
+                     out << " Mind Freeze";
+                     SpellSequence = SPELL_DK_BLOOD;
+                     LastSpellFrostDK = LastSpellFrostDK +1;
+                     break;
+               }
+               else if (HUNGERING_COLD > 0 && ai->GetAttackerCount()>=3 && dist <= ATTACK_DISTANCE && LastSpellFrostDK < 10 && ai->GetRunicPower() >= 40)
+               {
+                     ai->CastSpell(HUNGERING_COLD, *pTarget);
+                     out << " Hungering Cold";
+                     SpellSequence = SPELL_DK_BLOOD;
+                     LastSpellFrostDK = LastSpellFrostDK +1;
+                     break;
+               }
+               else if (EMPOWER_WEAPON > 0 && ai->GetRunicPower() < 20 && LastSpellFrostDK < 11)
+               {
+                     ai->CastSpell(EMPOWER_WEAPON, *m_bot);
+                     out << " Empower Rune Weapon";
+                     SpellSequence = SPELL_DK_BLOOD;
+                     LastSpellFrostDK = LastSpellFrostDK +1;
+                     break;
+               }
+               else if (UNBREAKABLE_ARMOR > 0 && !m_bot->HasAura(UNBREAKABLE_ARMOR, EFFECT_INDEX_0) && ai->GetHealthPercent() < 70 && pVictim == m_bot && LastSpellFrostDK < 12)
+               {
+                     ai->CastSpell(UNBREAKABLE_ARMOR, *m_bot);
+                     out << " Unbreakable Armor";
+                     SpellSequence = SPELL_DK_BLOOD;
+                     LastSpellFrostDK = LastSpellFrostDK +1;
+                     break;
+               }
+               else if (LastSpellFrostDK > 13)
+               {
+                     LastSpellFrostDK = 0;
+                     SpellSequence = SPELL_DK_BLOOD;
+                     break;
+               }
+
+               LastSpellFrostDK = 0;
+
+        case SPELL_DK_BLOOD:
+               if (BLOOD_PRESENCE > 0)
+                     (!m_bot->HasAura(BLOOD_PRESENCE, EFFECT_INDEX_0) && !m_bot->HasAura(UNHOLY_PRESENCE, EFFECT_INDEX_0) && !m_bot->HasAura(FROST_PRESENCE, EFFECT_INDEX_0) && ai->CastSpell (BLOOD_PRESENCE, *m_bot));
+
+               if (MARK_OF_BLOOD > 0 && !pTarget->HasAura(MARK_OF_BLOOD, EFFECT_INDEX_0) && LastSpellBloodDK < 1)
+               {
+                     ai->CastSpell(MARK_OF_BLOOD, *pTarget);
+                     out << " Mark of Blood";
+                     SpellSequence = SPELL_DK_UNHOLY;
+                     LastSpellBloodDK = LastSpellBloodDK +1;
+                     break;
+               }
+               else if (BLOOD_STRIKE > 0 && LastSpellBloodDK < 2)
+               {
+                     ai->CastSpell(BLOOD_STRIKE, *pTarget);
+                     out << " Blood Strike";
+                     SpellSequence = SPELL_DK_UNHOLY;
+                     LastSpellBloodDK =  LastSpellBloodDK +1;
+                     break;
+               }
+               else if (PESTILENCE > 0 && dist <= ATTACK_DISTANCE && ai->GetAttackerCount()>=3 && LastSpellBloodDK < 3)
+               {
+                     ai->CastSpell(PESTILENCE, *pTarget);
+                     out << " Pestilence";
+                     SpellSequence = SPELL_DK_UNHOLY;
+                     LastSpellBloodDK = LastSpellBloodDK +1;
+                     break;
+               }
+               else if (STRANGULATE > 0 && !pTarget->HasAura(STRANGULATE, EFFECT_INDEX_0) && LastSpellBloodDK < 4)
+               {
+                     ai->CastSpell(STRANGULATE, *pTarget);
+                     out << " Strangulate";
+                     SpellSequence = SPELL_DK_UNHOLY;
+                     LastSpellBloodDK = LastSpellBloodDK +1;
+                     break;
+               }
+               else if (BLOOD_BOIL > 0 && ai->GetAttackerCount()>=5 && dist <= ATTACK_DISTANCE && LastSpellBloodDK < 5)
+               {
+                     ai->CastSpell(BLOOD_BOIL, *pTarget);
+                     out << " Blood Boil";
+                     SpellSequence = SPELL_DK_UNHOLY;
+                     LastSpellBloodDK = LastSpellBloodDK +1;
+                     break;
+               }
+               else if (HEART_STRIKE > 0 && LastSpellBloodDK < 6)
+               {
+                     ai->CastSpell(HEART_STRIKE, *pTarget);
+                     out << " Heart Strike";
+                     SpellSequence = SPELL_DK_UNHOLY;
+                     LastSpellBloodDK = LastSpellBloodDK +1;
+                     break;
+               }
+               else if (VAMPIRIC_BLOOD > 0 && ai->GetHealthPercent() < 70 && !m_bot->HasAura(VAMPIRIC_BLOOD, EFFECT_INDEX_0) && LastSpellBloodDK < 7)
+               {
+                     ai->CastSpell(VAMPIRIC_BLOOD, *m_bot);
+                     out << " Vampiric Blood";
+                     SpellSequence = SPELL_DK_UNHOLY;
+                     LastSpellBloodDK = LastSpellBloodDK +1;
+                     break;
+               }
+               else if (RUNE_TAP > 0 && ai->GetHealthPercent() < 70 && !m_bot->HasAura(VAMPIRIC_BLOOD, EFFECT_INDEX_0) && LastSpellBloodDK < 8)
+               {
+                     ai->CastSpell(RUNE_TAP, *m_bot);
+                     out << " Rune Tap";
+                     SpellSequence = SPELL_DK_UNHOLY;
+                     LastSpellBloodDK = LastSpellBloodDK +1;
+                     break;
+               }
+               else if (HYSTERIA > 0 && ai->GetHealthPercent() > 25 && !m_bot->HasAura(HYSTERIA, EFFECT_INDEX_0) && LastSpellBloodDK < 9)
+               {
+                     ai->CastSpell(HYSTERIA, *m_bot);
+                     out << " Hysteria";
+                     SpellSequence = SPELL_DK_UNHOLY;
+                     LastSpellBloodDK = LastSpellBloodDK +1;
+                     break;
+               }
+               else if (DANCING_WEAPON > 0 && !m_bot->HasAura(DANCING_WEAPON, EFFECT_INDEX_0) && ai->GetRunicPower() >= 60 && LastSpellBloodDK < 10)
+               {
+                     ai->CastSpell(DANCING_WEAPON, *pTarget);
+                     out << " summoning Dancing Rune Weapon";
+                     SpellSequence = SPELL_DK_UNHOLY;
+                     LastSpellBloodDK = LastSpellBloodDK +1;
+                     break;
+               }
+               else if (DARK_COMMAND > 0 && ai->GetHealthPercent() > 50 && pVictim != m_bot && !pTarget->HasAura(DARK_COMMAND, EFFECT_INDEX_0) && dist <= ATTACK_DISTANCE && LastSpellBloodDK < 11)
+               {
+                     ai->CastSpell(DARK_COMMAND, *pTarget);
+                     out << " Dark Command";
+                     SpellSequence = SPELL_DK_UNHOLY;
+                     LastSpellBloodDK = LastSpellBloodDK +1;
+                     break;
+               }
+               else if(( pet )
+                     && (DEATH_PACT > 0 && ai->GetHealthPercent() < 50 && LastSpellBloodDK < 12 && ai->GetRunicPower() >= 40))
+               {
+                     ai->CastSpell(DEATH_PACT, *pet);
+                     out << " Death Pact (sacrifice pet)";
+                     SpellSequence = SPELL_DK_UNHOLY;
+                     LastSpellBloodDK = LastSpellBloodDK +1;
+                     break;
+               }
+               else if (LastSpellBloodDK > 13)
+               {
+                     LastSpellBloodDK = 0;
+                     SpellSequence = SPELL_DK_UNHOLY;
+                     break;
+               }
+               else
+               {
+                     LastSpellBloodDK = 0;
+                     SpellSequence = SPELL_DK_UNHOLY;
+               }
+    }
+    if( ai->GetManager()->m_confDebugWhisper )
+        ai->TellMaster( out.str().c_str() );
+
+} // end DoNextCombatManeuver
+
+void PlayerbotDeathKnightAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    SpellSequence = SPELL_DK_UNHOLY;
+
+    // buff master with HORN_OF_WINTER
+    if (HORN_OF_WINTER> 0)
+        (!GetMaster()->HasAura(HORN_OF_WINTER, EFFECT_INDEX_0) && ai->CastSpell (HORN_OF_WINTER, *GetMaster()));
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindFood();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, EFFECT_INDEX_0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(*fItem);
+        ai->SetIgnoreUpdateTime(8);
+        return;
+    }
+} // end DoNonCombatActions
diff --git a/Core/src/game/PlayerbotDeathKnightAI.h b/Core/src/game/PlayerbotDeathKnightAI.h
new file mode 100644
index 0000000..14a9d95
--- /dev/null
+++ b/Core/src/game/PlayerbotDeathKnightAI.h
@@ -0,0 +1,51 @@
+#ifndef _PLAYERDEATHKNIGHTAI_H
+#define _PLAYERDEATHKNIGHTAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_DK_UNHOLY,
+    SPELL_DK_FROST,
+    SPELL_DK_BLOOD
+};
+
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotDeathKnightAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotDeathKnightAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
+        virtual ~PlayerbotDeathKnightAI();
+
+        // all combat actions go here
+        void DoNextCombatManeuver(Unit*);
+
+        // all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        // buff a specific player, usually a real PC who is not in group
+        //void BuffPlayer(Player *target);
+
+    private:
+
+        // Unholy
+        uint32 BONE_SHIELD, PLAGUE_STRIKE, DEATH_GRIP, DEATH_COIL, DEATH_STRIKE, UNHOLY_BLIGHT, SCOURGE_STRIKE, DEATH_AND_DECAY, UNHOLY_PRESENCE, RAISE_DEAD, ARMY_OF_THE_DEAD, SUMMON_GARGOYLE, ANTI_MAGIC_SHELL, ANTI_MAGIC_ZONE, GHOUL_FRENZY, CORPSE_EXPLOSION;
+
+        // Frost
+        uint32 ICY_TOUCH, OBLITERATE, HOWLING_BLAST, FROST_STRIKE, CHAINS_OF_ICE, RUNE_STRIKE, ICY_CLUTCH, HORN_OF_WINTER, KILLING_MACHINE, FROST_PRESENCE, DEATHCHILL, ICEBOUND_FORTITUDE, MIND_FREEZE, EMPOWER_WEAPON, HUNGERING_COLD, UNBREAKABLE_ARMOR;
+
+        // Blood
+        uint32 BLOOD_STRIKE, PESTILENCE, STRANGULATE, BLOOD_BOIL, HEART_STRIKE, MARK_OF_BLOOD, BLOOD_PRESENCE, RUNE_TAP, VAMPIRIC_BLOOD, DEATH_PACT, DEATH_RUNE_MASTERY, HYSTERIA, DANCING_WEAPON, DARK_COMMAND;
+
+        // first aid
+        uint32 RECENTLY_BANDAGED;
+
+        // racial
+        uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+        uint32 SpellSequence, LastSpellUnholyDK, LastSpellFrostDK, LastSpellBloodDK;
+};
+
+#endif
+
diff --git a/Core/src/game/PlayerbotDruidAI.cpp b/Core/src/game/PlayerbotDruidAI.cpp
new file mode 100644
index 0000000..3cf5f6d
--- /dev/null
+++ b/Core/src/game/PlayerbotDruidAI.cpp
@@ -0,0 +1,681 @@
+/*
+    Name    : PlayerbotDruidAI.cpp
+    Complete: maybe around 33%
+    Authors : rrtn, Natsukawa
+    Version : 0.42
+*/
+#include "PlayerbotDruidAI.h"
+
+class PlayerbotAI;
+
+PlayerbotDruidAI::PlayerbotDruidAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+
+    MOONFIRE            = ai->getSpellId("moonfire"); // attacks
+    STARFIRE            = ai->getSpellId("starfire");
+    STARFALL            = ai->getSpellId("starfall");
+    WRATH               = ai->getSpellId("wrath");
+    ROOTS               = ai->getSpellId("roots");
+    INSECT_SWARM        = ai->getSpellId("insect swarm");
+    FORCE_OF_NATURE     = ai->getSpellId("force of nature");
+    HURRICANE           = ai->getSpellId("hurricane");
+    MARK_OF_THE_WILD    = ai->getSpellId("mark of the wild"); // buffs
+    THORNS              = ai->getSpellId("thorns");
+    BARKSKIN            = ai->getSpellId("barkskin");
+    INNERVATE           = ai->getSpellId("innervate");
+    MANA_REJUVENATION   = ai->getSpellId("mana rejuvenation");
+    FAERIE_FIRE         = ai->getSpellId("faerie fire"); // debuffs
+    REJUVENATION        = ai->getSpellId("rejuvenation"); // heals
+    REGROWTH            = ai->getSpellId("regrowth");
+    WILD_GROWTH         = ai->getSpellId("wild growth");
+    LIFEBLOOM           = ai->getSpellId("lifebloom");
+    NOURISH             = ai->getSpellId("nourish");
+    HEALING_TOUCH       = ai->getSpellId("healing touch");
+    SWIFTMEND           = ai->getSpellId("swiftmend");
+    TRANQUILITY         = ai->getSpellId("tranquility");
+    //Druid Forms
+    MOONKIN_FORM        = ai->getSpellId("moonkin form");
+    DIRE_BEAR_FORM      = ai->getSpellId("dire bear form");
+    BEAR_FORM           = ai->getSpellId("bear form");
+    CAT_FORM            = ai->getSpellId("cat form");
+	TREE_OF_LIFE        = 33891;
+    //Cat Attack type's
+    RAKE                = ai->getSpellId("rake");            //40 energy
+    CLAW                = ai->getSpellId("claw");            //45
+    COWER               = ai->getSpellId("cower");           //20
+    MANGLE              = ai->getSpellId("mangle");          //45
+    TIGERS_FURY         = ai->getSpellId("tigers's fury");
+    //Cat Finishing Move's
+    RIP                 = ai->getSpellId("rip");             //30
+    FEROCIOUS_BITE      = ai->getSpellId("ferocious bite");  //35
+    MAIM                = ai->getSpellId("maim");            //35
+	//Bear/Dire Bear Attacks & Buffs
+    BASH                = ai->getSpellId("bash");            //10 rage
+    MAUL                = ai->getSpellId("maul");            //15
+    SWIPE               = ai->getSpellId("swipe");           //20
+    DEMORALIZING_ROAR   = ai->getSpellId("roar");            //10
+    CHALLENGING_ROAR    = ai->getSpellId("challenging roar");//15
+    ENRAGE              = ai->getSpellId("enrage");
+    GROWL               = ai->getSpellId("growl");
+
+    RECENTLY_BANDAGED   = 11196; // first aid check
+
+	// racial
+    SHADOWMELD              = ai->getSpellId("shadowmeld"); // night elf
+    WAR_STOMP               = ai->getSpellId("war stomp"); // tauren
+}
+
+PlayerbotDruidAI::~PlayerbotDruidAI() {}
+
+void PlayerbotDruidAI::HealTarget(Unit &target, uint8 hp)
+{
+    PlayerbotAI* ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+
+    if (hp < 70 && REJUVENATION > 0 && !target.HasAura(REJUVENATION, EFFECT_INDEX_0) && !target.HasAura(REGROWTH, EFFECT_INDEX_0) && ai->GetManaPercent() >=21)
+        ai->CastSpell(REJUVENATION, target);
+
+	if (hp < 60 && LIFEBLOOM > 0 && !target.HasAura(LIFEBLOOM, EFFECT_INDEX_0) && ai->GetManaPercent() >= 28)
+        ai->CastSpell(LIFEBLOOM, target);
+
+    if (hp < 55 && REGROWTH > 0 && !target.HasAura(REGROWTH, EFFECT_INDEX_0) && !target.HasAura(REJUVENATION, EFFECT_INDEX_0) && ai->GetManaPercent() >= 33)
+        ai->CastSpell(REGROWTH, target);
+
+	if (hp < 50 && SWIFTMEND > 0 && target.HasAura(REJUVENATION, EFFECT_INDEX_0) || target.HasAura(REGROWTH, EFFECT_INDEX_0) && ai->GetManaPercent() >= 16)
+        ai->CastSpell(SWIFTMEND, target);
+
+    if (hp < 45 && WILD_GROWTH > 0 && !target.HasAura(WILD_GROWTH, EFFECT_INDEX_0) && ai->GetManaPercent() >= 26)
+        ai->CastSpell(WILD_GROWTH, target);
+
+	if (hp < 30 && NOURISH > 0 && ai->GetManaPercent() >= 18)
+        ai->CastSpell(NOURISH, target);
+
+	if (hp < 25 && HEALING_TOUCH > 0 && ai->GetManaPercent() >= 38)
+        ai->CastSpell(HEALING_TOUCH, target);
+} // end HealTarget
+
+void PlayerbotDruidAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(MOONFIRE);
+            return;
+    }
+
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+
+    ai->SetInFront( pTarget );
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+
+    if (pVictim && ai->GetHealthPercent() >= 40 && GetMaster()->GetHealth() >= GetMaster()->GetMaxHealth()*0.4)
+    {
+        if (pVictim == m_bot)
+            SpellSequence = DruidTank;
+    }
+    else if (pTarget->GetHealth() > pTarget->GetMaxHealth()*0.8 && pVictim)
+    {
+        if (pVictim != m_bot)
+            SpellSequence = DruidSpell;
+    }
+    else if (ai->GetHealthPercent() <= 40 || GetMaster()->GetHealth() <= GetMaster()->GetMaxHealth()*0.4)
+        SpellSequence = DruidHeal;
+    else
+        SpellSequence = DruidCombat;
+
+    switch (SpellSequence)
+    {
+        case DruidTank: // Its now a tank druid!
+            //ai->TellMaster("DruidTank");
+
+            if( !m_bot->HasInArc(M_PI_F, pTarget))
+            {
+                m_bot->SetInFront(pTarget);
+                if (pVictim)
+                    pVictim->Attack(pTarget, true);
+            }
+            if(m_bot->HasAura(CAT_FORM, EFFECT_INDEX_0))
+            {
+                m_bot->RemoveAurasDueToSpell(768);
+                //ai->TellMaster("FormClearCat");
+            }
+			if (MOONKIN_FORM > 0 && !m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0))
+            {
+                ai->CastSpell (MOONKIN_FORM);
+            }
+            else if (DIRE_BEAR_FORM > 0 && !m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && !m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0))
+            {
+                ai->CastSpell (DIRE_BEAR_FORM);
+            }
+			else if (BEAR_FORM > 0 && !m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && !m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0) && !m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0))
+            {
+                ai->CastSpell (BEAR_FORM);
+            }
+                        else if (DEMORALIZING_ROAR > 0 && (m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0) || m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0)) && !m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && !pTarget->HasAura(DEMORALIZING_ROAR, EFFECT_INDEX_0) && ai->GetRageAmount() >= 10)
+            {
+                ai->CastSpell(DEMORALIZING_ROAR, *pTarget);
+            }
+			if (FAERIE_FIRE > 0 && DruidSpellCombat < 1 && !pTarget->HasAura(FAERIE_FIRE, EFFECT_INDEX_0))
+            {
+                ai->CastSpell(FAERIE_FIRE, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (MOONFIRE > 0 && m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && DruidSpellCombat < 2 && !pTarget->HasAura(MOONFIRE, EFFECT_INDEX_0) && ai->GetManaPercent() >= 24)
+            {
+                ai->CastSpell(MOONFIRE, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (ROOTS > 0 && m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && DruidSpellCombat < 3 && !pTarget->HasAura(ROOTS, EFFECT_INDEX_0) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(ROOTS, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (HURRICANE > 0 && m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && ai->GetAttackerCount()>=5 && DruidSpellCombat < 4 && ai->GetManaPercent() >= 91)
+            {
+				//ai->TellMaster("casting hurricane!");
+                ai->CastSpell(HURRICANE, *pTarget);
+				ai->SetIgnoreUpdateTime(10);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (WRATH > 0 && m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && DruidSpellCombat < 5 && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(WRATH, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (INSECT_SWARM > 0 && m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && DruidSpellCombat < 6 && !pTarget->HasAura(INSECT_SWARM, EFFECT_INDEX_0) && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(INSECT_SWARM , *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (STARFIRE > 0 && m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && DruidSpellCombat < 7 && ai->GetManaPercent() >= 18)
+            {
+                ai->CastSpell(STARFIRE, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (FORCE_OF_NATURE > 0 && m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && DruidSpellCombat < 8 && ai->GetManaPercent() >= 12)
+            {
+				//ai->TellMaster("summoning treants.");
+                ai->CastSpell(FORCE_OF_NATURE);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (STARFALL > 0 && m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && !m_bot->HasAura(STARFALL, EFFECT_INDEX_0) && ai->GetAttackerCount()>=3 && DruidSpellCombat < 9 && ai->GetManaPercent() >= 39)
+            {
+                ai->CastSpell(STARFALL, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (BARKSKIN > 0 && pVictim == m_bot && m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && ai->GetHealthPercent() < 75 && DruidSpellCombat < 10 && !m_bot->HasAura(BARKSKIN, EFFECT_INDEX_0))
+            {
+                ai->CastSpell(BARKSKIN, *m_bot);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (INNERVATE > 0 && m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && ai->GetManaPercent() < 50 && DruidSpellCombat < 11 && !m_bot->HasAura(INNERVATE, EFFECT_INDEX_0))
+            {
+                ai->CastSpell(INNERVATE, *m_bot);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (MANA_REJUVENATION > 0 && m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0) && ai->GetManaPercent() < 50 && !m_bot->HasAura(INNERVATE, EFFECT_INDEX_0) && DruidSpellCombat < 12 && !m_bot->HasAura(MANA_REJUVENATION, EFFECT_INDEX_0))
+            {
+                ai->CastSpell(MANA_REJUVENATION, *m_bot);
+                DruidSpellCombat++;
+                break;
+            }
+                        else if (ENRAGE > 0 && (m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0) || m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0)) && DruidSpellCombat < 2 && !m_bot->HasAura(ENRAGE, EFFECT_INDEX_0))
+            {
+                ai->CastSpell(ENRAGE, *m_bot);
+                DruidSpellCombat = DruidSpellCombat +2;
+                break;
+            }
+                        else if (SWIPE > 0 && (m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0) || m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0)) && DruidSpellCombat < 4 && ai->GetRageAmount()>=20)
+            {
+                ai->CastSpell(SWIPE, *pTarget);
+                DruidSpellCombat = DruidSpellCombat +2;
+                break;
+            }
+                        else if (MAUL > 0 && (m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0) || m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0)) && DruidSpellCombat < 6 && ai->GetRageAmount()>=15)
+            {
+                ai->CastSpell(MAUL, *pTarget);
+                DruidSpellCombat = DruidSpellCombat +2;
+                break;
+            }
+                        else if (BASH > 0 && (m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0) || m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0)) && !pTarget->HasAura(BASH, EFFECT_INDEX_0) && DruidSpellCombat < 8 && ai->GetRageAmount()>=10)
+            {
+                ai->CastSpell(BASH, *pTarget);
+                DruidSpellCombat = DruidSpellCombat +2;
+                break;
+            }
+                        else if (CHALLENGING_ROAR > 0 && (m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0) || m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0)) && pVictim != m_bot && DruidSpellCombat < 10 && !pTarget->HasAura(CHALLENGING_ROAR, EFFECT_INDEX_0) && !pTarget->HasAura(GROWL, EFFECT_INDEX_0) && ai->GetRageAmount()>=15)
+            {
+                ai->CastSpell(CHALLENGING_ROAR, *pTarget);
+                DruidSpellCombat = DruidSpellCombat +2;
+                break;
+            }
+                        else if (GROWL > 0 && (m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0) || m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0)) && pVictim != m_bot && DruidSpellCombat < 12 && !pTarget->HasAura(CHALLENGING_ROAR, EFFECT_INDEX_0) && !pTarget->HasAura(GROWL, EFFECT_INDEX_0))
+            {
+                ai->CastSpell(GROWL, *pTarget);
+                DruidSpellCombat = DruidSpellCombat +2;
+                break;
+            }
+			else if (DruidSpellCombat > 13)
+            {
+                DruidSpellCombat = 0;
+                break;
+            }
+            else
+            {
+                DruidSpellCombat = 0;
+                break;
+            }
+            break;
+
+        case DruidSpell:
+            //ai->TellMaster("DruidSpell");
+            if(m_bot->HasAura(CAT_FORM, EFFECT_INDEX_0))
+            {
+                m_bot->RemoveAurasDueToSpell(768);
+                //ai->TellMaster("FormClearCat");
+                break;
+            }
+            if(m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0))
+            {
+                m_bot->RemoveAurasDueToSpell(5487);
+                //ai->TellMaster("FormClearBear");
+                break;
+            }
+			if(m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0))
+            {
+                m_bot->RemoveAurasDueToSpell(9634);
+                //ai->TellMaster("FormClearDireBear");
+                break;
+            }
+			if(m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0))
+            {
+                m_bot->RemoveAurasDueToSpell(24858);
+                //ai->TellMaster("FormClearMoonkin");
+                break;
+            }
+            if (FAERIE_FIRE > 0 && DruidSpellCombat < 1 && !pTarget->HasAura(FAERIE_FIRE, EFFECT_INDEX_0) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(FAERIE_FIRE, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (MOONFIRE > 0 && DruidSpellCombat < 2 && !pTarget->HasAura(MOONFIRE, EFFECT_INDEX_0) && ai->GetManaPercent() >= 24)
+            {
+                ai->CastSpell(MOONFIRE, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (ROOTS > 0 && DruidSpellCombat < 3 && !pTarget->HasAura(ROOTS, EFFECT_INDEX_0) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(ROOTS, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (HURRICANE > 0 && ai->GetAttackerCount()>=5 && DruidSpellCombat < 4 && ai->GetManaPercent() >= 91)
+            {
+				//ai->TellMaster("casting hurricane!");
+                ai->CastSpell(HURRICANE, *pTarget);
+				ai->SetIgnoreUpdateTime(10);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (WRATH > 0 && DruidSpellCombat < 5 && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(WRATH, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (INSECT_SWARM > 0 && DruidSpellCombat < 6 && !pTarget->HasAura(INSECT_SWARM, EFFECT_INDEX_0) && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(INSECT_SWARM , *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+            else if (STARFIRE > 0 && DruidSpellCombat < 7 && ai->GetManaPercent() >= 18)
+            {
+                ai->CastSpell(STARFIRE, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (FORCE_OF_NATURE > 0 && DruidSpellCombat < 8 && ai->GetManaPercent() >= 12)
+            {
+				//ai->TellMaster("summoning treants.");
+                ai->CastSpell(FORCE_OF_NATURE);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (STARFALL > 0 && !m_bot->HasAura(STARFALL, EFFECT_INDEX_0) && ai->GetAttackerCount()>=3 && DruidSpellCombat < 9 && ai->GetManaPercent() >= 39)
+            {
+                ai->CastSpell(STARFALL, *pTarget);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (BARKSKIN > 0 && pVictim == m_bot && ai->GetHealthPercent() < 75 && DruidSpellCombat < 10 && !m_bot->HasAura(BARKSKIN, EFFECT_INDEX_0))
+            {
+                ai->CastSpell(BARKSKIN, *m_bot);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (INNERVATE > 0 && ai->GetManaPercent() < 50 && DruidSpellCombat < 11 && !m_bot->HasAura(INNERVATE, EFFECT_INDEX_0))
+            {
+                ai->CastSpell(INNERVATE, *m_bot);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (MANA_REJUVENATION > 0 && ai->GetManaPercent() < 50 && DruidSpellCombat < 12 && !m_bot->HasAura(INNERVATE, EFFECT_INDEX_0) && !m_bot->HasAura(MANA_REJUVENATION, EFFECT_INDEX_0))
+            {
+                ai->CastSpell(MANA_REJUVENATION, *m_bot);
+                DruidSpellCombat++;
+                break;
+            }
+			else if (DruidSpellCombat > 13)
+            {
+                DruidSpellCombat = 0;
+                break;
+            }
+            else
+            {
+                DruidSpellCombat = 0;
+                break;
+            }
+            break;
+
+        case DruidHeal:
+            //ai->TellMaster("DruidHeal");
+            if(m_bot->HasAura(CAT_FORM, EFFECT_INDEX_0))
+            {
+                m_bot->RemoveAurasDueToSpell(768);
+                //ai->TellMaster("FormClearCat");
+                break;
+            }
+            if(m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0))
+            {
+                m_bot->RemoveAurasDueToSpell(5487);
+                //ai->TellMaster("FormClearBear");
+                break;
+            }
+            if(m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0))
+            {
+                m_bot->RemoveAurasDueToSpell(9634);
+                //ai->TellMaster("FormClearDireBear");
+                break;
+            }
+			if(m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0))
+            {
+                m_bot->RemoveAurasDueToSpell(24858);
+                //ai->TellMaster("FormClearMoonkin");
+                break;
+            }
+            if (ai->GetHealthPercent() <= 40)
+            {
+                HealTarget (*m_bot, ai->GetHealthPercent());
+                break;
+            }
+            if (masterHP <= 40)
+            {
+                HealTarget (*GetMaster(), masterHP);
+                break;
+            }
+            else
+            {
+                DruidSpellCombat = 0;
+                break;
+            }
+            break;
+
+        case DruidCombat:
+            //ai->TellMaster("DruidCombat");
+            if( !m_bot->HasInArc(M_PI_F, pTarget))
+            {
+                m_bot->SetInFront(pTarget);
+                if (pVictim)
+                    pVictim->Attack(pTarget, true);
+            }
+            if(m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0))
+            {
+                m_bot->RemoveAurasDueToSpell(5487);
+                //ai->TellMaster("FormClearBear");
+                break;
+            }
+			if(m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0))
+            {
+                m_bot->RemoveAurasDueToSpell(9634);
+                //ai->TellMaster("FormClearDireBear");
+                break;
+            }
+			if(m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0))
+            {
+                m_bot->RemoveAurasDueToSpell(24858);
+                //ai->TellMaster("FormClearMoonkin");
+                break;
+            }
+            if (CAT_FORM > 0 && !m_bot->HasAura(CAT_FORM, EFFECT_INDEX_0))
+                ai->CastSpell (CAT_FORM);
+/*
+            if (COWER > 0 && m_bot->GetComboPoints() == 1 && ai->GetEnergyAmount() >= 20)
+            {
+                ai->CastSpell(COWER);
+                //ai->TellMaster("Cower");
+            }*/
+            if (MAIM > 0 && m_bot->GetComboPoints() >= 1 && pTarget->IsNonMeleeSpellCasted(true))
+            {
+                ai->CastSpell(MAIM, *pTarget);
+                //ai->TellMaster("SpellPreventing Maim");
+                break;
+            }
+
+            if (RAKE > 0 && m_bot->GetComboPoints() <= 1 && ai->GetEnergyAmount() >= 40)
+            {
+                ai->CastSpell (RAKE, *pTarget);
+                //ai->TellMaster("Rake");
+                break;
+            }
+            else if (CLAW > 0 && m_bot->GetComboPoints() <= 2 && ai->GetEnergyAmount() >= 45)
+            {
+                ai->CastSpell (CLAW, *pTarget);
+                //ai->TellMaster("Claw");
+                break;
+            }
+            else if (MANGLE > 0 && m_bot->GetComboPoints() <= 3 && ai->GetEnergyAmount() >= 45)
+            {
+                ai->CastSpell (MANGLE, *pTarget);
+                //ai->TellMaster("Mangle");
+                break;
+            }
+            else if (CLAW > 0 && m_bot->GetComboPoints() <= 4 && ai->GetEnergyAmount() >= 45)
+            {
+                ai->CastSpell (CLAW, *pTarget);
+                //ai->TellMaster("Claw2");
+                break;
+            }
+
+            if (m_bot->GetComboPoints() == 5)
+            {
+                if (RIP > 0 && pTarget->getClass() == CLASS_ROGUE && ai->GetEnergyAmount() >= 30)
+                {
+                    ai->CastSpell(RIP, *pTarget);
+                    //ai->TellMaster("Rogue Rip");
+                }
+                else if (MAIM > 0 && pTarget->getClass() == CLASS_DRUID && ai->GetEnergyAmount() >= 35)
+                {
+                    ai->CastSpell(MAIM, *pTarget);
+                    //ai->TellMaster("Druid Maim");
+                }
+                else if (MAIM > 0 && pTarget->getClass() == CLASS_SHAMAN && ai->GetEnergyAmount() >= 35)
+                {
+                    ai->CastSpell(MAIM, *pTarget);
+                    //ai->TellMaster("Shaman Maim");
+                }
+                else if (MAIM > 0 && pTarget->getClass() == CLASS_WARLOCK && ai->GetEnergyAmount() >= 35)
+                {
+                    ai->CastSpell(MAIM, *pTarget);
+                    //ai->TellMaster("Warlock Maim");
+                }
+                else if (FEROCIOUS_BITE > 0 && pTarget->getClass() == CLASS_HUNTER && ai->GetEnergyAmount() >= 35)
+                {
+                    ai->CastSpell(FEROCIOUS_BITE, *pTarget);
+                    //ai->TellMaster("Hunter Ferocious Bite");
+                }
+                else if (FEROCIOUS_BITE > 0 && pTarget->getClass() == CLASS_WARRIOR && ai->GetEnergyAmount() >= 35)
+                {
+                    ai->CastSpell(FEROCIOUS_BITE, *pTarget);
+                    //ai->TellMaster("Warrior Ferocious Bite");
+                }
+                else if (FEROCIOUS_BITE > 0 && pTarget->getClass() == CLASS_PALADIN && ai->GetEnergyAmount() >= 35)
+                {
+                    ai->CastSpell(FEROCIOUS_BITE, *pTarget);
+                    //ai->TellMaster("Paladin Ferocious Bite");
+                }
+                else if (FEROCIOUS_BITE > 0 && pTarget->getClass() == CLASS_DEATH_KNIGHT && ai->GetEnergyAmount() >= 25)
+                {
+                    ai->CastSpell(FEROCIOUS_BITE, *pTarget);
+                    //ai->TellMaster("DK Ferocious Bite");
+                }
+                else if (MAIM > 0 && pTarget->getClass() == CLASS_MAGE && ai->GetEnergyAmount() >= 35)
+                {
+                    ai->CastSpell(MAIM, *pTarget);
+                    //ai->TellMaster("Mage Maim");
+                }
+                else if (MAIM > 0 && pTarget->getClass() == CLASS_PRIEST && ai->GetEnergyAmount() >= 35)
+                {
+                    ai->CastSpell(MAIM, *pTarget);
+                    //ai->TellMaster("Priest Maim");
+                }
+                else if (MAIM > 0 && ai->GetEnergyAmount() >= 35)
+                {
+                    ai->CastSpell(MAIM, *pTarget);
+                    //ai->TellMaster("Else Maim");
+                }
+                break;
+			}
+            else
+            {
+				DruidSpellCombat = 0;
+				break;
+            }
+            break;
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotDruidAI::DoNonCombatActions()
+{
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+	PlayerbotAI* ai = GetAI();
+
+    if(m_bot->HasAura(CAT_FORM, EFFECT_INDEX_0))
+    {
+        m_bot->RemoveAurasDueToSpell(768);
+        //ai->TellMaster("FormClearCat");
+    }
+    if(m_bot->HasAura(BEAR_FORM, EFFECT_INDEX_0))
+    {
+        m_bot->RemoveAurasDueToSpell(5487);
+        //ai->TellMaster("FormClearBear");
+    }
+	if(m_bot->HasAura(DIRE_BEAR_FORM, EFFECT_INDEX_0))
+    {
+        m_bot->RemoveAurasDueToSpell(9634);
+        //ai->TellMaster("FormClearDireBear");
+    }
+	if(m_bot->HasAura(MOONKIN_FORM, EFFECT_INDEX_0))
+    {
+        m_bot->RemoveAurasDueToSpell(24858);
+        //ai->TellMaster("FormClearMoonkin");
+    }
+    // buff myself with MARK_OF_THE_WILD
+    if (MARK_OF_THE_WILD > 0 && !m_bot->HasAura(MARK_OF_THE_WILD, EFFECT_INDEX_0))
+        ai->CastSpell (MARK_OF_THE_WILD, *m_bot);
+
+    // Thorns generates aggro for moonkin
+    if (THORNS > 0 && !m_bot->HasAura(THORNS, EFFECT_INDEX_0))
+        ai->CastSpell (THORNS, *m_bot);
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+	Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+	else if(pItem == NULL && INNERVATE>0 && !m_bot->HasAura(INNERVATE, EFFECT_INDEX_0) && ai->GetManaPercent() <= 70)
+    {
+		ai->CastSpell(INNERVATE, *m_bot);
+		//ai->TellMaster("casting innervate.");
+        return;
+    }
+	else if(pItem == NULL && MANA_REJUVENATION>0 && !m_bot->HasAura(INNERVATE, EFFECT_INDEX_0) && !m_bot->HasAura(MANA_REJUVENATION, EFFECT_INDEX_0) && ai->GetManaPercent() <= 70)
+    {
+		ai->CastSpell(MANA_REJUVENATION, *m_bot);
+		//ai->TellMaster("casting mana rejuvenation.");
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, EFFECT_INDEX_0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(*fItem);
+        ai->SetIgnoreUpdateTime(8);
+        return;
+    }
+
+    // buff and heal master's group
+    if (GetMaster()->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = sObjectMgr.GetPlayer(uint64 (itr->guid));
+            if( !tPlayer || !tPlayer->isAlive() )
+                continue;
+
+             // buff and heal
+             (!tPlayer->HasAura(MARK_OF_THE_WILD, EFFECT_INDEX_0) && ai->CastSpell (MARK_OF_THE_WILD, *tPlayer));
+			 //(!tPlayer->HasAura(THORNS, EFFECT_INDEX_0) && ai->CastSpell (THORNS, *tPlayer));
+             (HealTarget(*tPlayer, tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth()));
+        }
+    }
+} // end DoNonCombatActions
+
+void PlayerbotDruidAI::BuffPlayer(Player* target)
+{
+    GetAI()->CastSpell(MARK_OF_THE_WILD, *target);
+}
diff --git a/Core/src/game/PlayerbotDruidAI.h b/Core/src/game/PlayerbotDruidAI.h
new file mode 100644
index 0000000..927b74f
--- /dev/null
+++ b/Core/src/game/PlayerbotDruidAI.h
@@ -0,0 +1,62 @@
+#ifndef _PLAYERBOTDRUIDAI_H
+#define _PLAYERBOTDRUIDAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    DruidCombat,
+    DruidTank,
+    DruidHeal,
+    DruidSpell
+};
+
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotDruidAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotDruidAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
+        virtual ~PlayerbotDruidAI();
+
+        // all combat actions go here
+        void DoNextCombatManeuver(Unit*);
+
+        // all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        // buff a specific player, usually a real PC who is not in group
+        void BuffPlayer(Player *target);
+
+    private:
+        // Heals the target based off its hps
+        void HealTarget (Unit& target, uint8 hp);
+
+        // druid cat/bear/dire bear/moonkin/tree of life forms
+        uint32 CAT_FORM, BEAR_FORM, DIRE_BEAR_FORM, MOONKIN_FORM, TREE_OF_LIFE;
+
+        // druid cat attacks
+        uint32 CLAW, COWER, TIGERS_FURY, RAKE, RIP, FEROCIOUS_BITE, MAIM, MANGLE;
+
+        // druid bear/dire bear attacks & buffs
+        uint32 BASH, MAUL, SWIPE, DEMORALIZING_ROAR, CHALLENGING_ROAR, GROWL, ENRAGE;
+
+        // druid attacks & debuffs
+        uint32 MOONFIRE, ROOTS, WRATH, STARFALL, STARFIRE, INSECT_SWARM, FAERIE_FIRE, FORCE_OF_NATURE, HURRICANE;
+
+        // druid buffs
+        uint32 MARK_OF_THE_WILD, THORNS, MANA_REJUVENATION, INNERVATE, BARKSKIN;
+
+        // druid heals
+        uint32 LIFEBLOOM, REJUVENATION, REGROWTH, NOURISH, HEALING_TOUCH, WILD_GROWTH, SWIFTMEND, TRANQUILITY;
+
+        // first aid
+        uint32 RECENTLY_BANDAGED;
+
+        // racial
+        uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+        uint32 SpellSequence, DruidSpellCombat;
+};
+
+#endif
diff --git a/Core/src/game/PlayerbotHunterAI.cpp b/Core/src/game/PlayerbotHunterAI.cpp
new file mode 100644
index 0000000..b2ba9a1
--- /dev/null
+++ b/Core/src/game/PlayerbotHunterAI.cpp
@@ -0,0 +1,420 @@
+// an improved Hunter by rrtn & Runsttren :)
+
+#include "PlayerbotHunterAI.h"
+#include "PlayerbotMgr.h"
+
+class PlayerbotAI;
+
+PlayerbotHunterAI::PlayerbotHunterAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    // PET CTRL
+    PET_SUMMON           = ai->getSpellId("call pet");
+    PET_DISMISS          = ai->getSpellId("dismiss pet");
+    PET_REVIVE           = ai->getSpellId("revive pet");
+    PET_MEND             = ai->getSpellId("mend pet");
+    PET_FEED             = 1539;
+
+    // PET SKILLS
+    INTIMIDATION         = ai->getSpellId("intimidation"); // (generic)
+    SONIC_BLAST          = ai->getSpellId("sonic blast"); // bat
+    DEMORALIZING_SCREECH = ai->getSpellId("demoralizing screech"); // carrion bird
+    BAD_ATTITUDE         = ai->getSpellId("bad attitude"); // crocolisk
+    NETHER_SHOCK         = ai->getSpellId("nether shock"); // nether ray
+
+    // RANGED COMBAT
+    AUTO_SHOT            = ai->getSpellId("auto shot"); // basic ranged hunter fighting
+    HUNTERS_MARK         = ai->getSpellId("hunter's mark"); // mark target to get higher ranged combat power
+    ARCANE_SHOT          = ai->getSpellId("arcane shot");
+    CONCUSSIVE_SHOT      = ai->getSpellId("concussive shot");
+    DISTRACTING_SHOT     = ai->getSpellId("distracting shot");
+    MULTI_SHOT           = ai->getSpellId("multi-shot");
+    EXPLOSIVE_SHOT       = ai->getSpellId("explosive shot");
+    SERPENT_STING        = ai->getSpellId("serpent sting");
+    SCORPID_STING        = ai->getSpellId("scorpid sting");
+    WYVERN_STING         = ai->getSpellId("wyvern sting");
+    VIPER_STING          = ai->getSpellId("viper sting");
+    AIMED_SHOT           = ai->getSpellId("aimed shot");
+    STEADY_SHOT          = ai->getSpellId("steady shot");
+    CHIMERA_SHOT         = ai->getSpellId("chimera shot");
+    VOLLEY               = ai->getSpellId("volley");
+    BLACK_ARROW          = ai->getSpellId("black arrow");
+    KILL_SHOT            = ai->getSpellId("kill shot");
+
+    // MELEE
+    RAPTOR_STRIKE        = ai->getSpellId("raptor strike");
+    WING_CLIP            = ai->getSpellId("wing clip");
+    MONGOOSE_BITE        = ai->getSpellId("mongoose bite");
+    DISENGAGE            = ai->getSpellId("disengage");
+    MISDIRECTION         = ai->getSpellId("misdirection");
+    DETERRENCE           = ai->getSpellId("deterrence");
+
+    // TRAPS
+    BEAR_TRAP            = ai->getSpellId("bear trap");
+    FREEZING_TRAP        = ai->getSpellId("freezing trap");
+    IMMOLATION_TRAP      = ai->getSpellId("immolation trap");
+    FROST_TRAP           = ai->getSpellId("frost trap");
+    EXPLOSIVE_TRAP       = ai->getSpellId("explosive trap");
+    ARCANE_TRAP          = ai->getSpellId("arcane trap");
+    SNAKE_TRAP           = ai->getSpellId("snake trap");
+
+    // BUFFS
+    ASPECT_OF_THE_HAWK   = ai->getSpellId("aspect of the hawk");
+    ASPECT_OF_THE_MONKEY = ai->getSpellId("aspect of the monkey");
+    RAPID_FIRE           = ai->getSpellId("rapid fire");
+    TRUESHOT_AURA        = 19506;
+
+    RECENTLY_BANDAGED    = 11196; // first aid check
+
+	// racial
+    ARCANE_TORRENT       = ai->getSpellId("arcane torrent"); // blood elf
+    GIFT_OF_THE_NAARU    = ai->getSpellId("gift of the naaru"); // draenei
+    STONEFORM            = ai->getSpellId("stoneform"); // dwarf
+    SHADOWMELD           = ai->getSpellId("shadowmeld"); // night elf
+    BLOOD_FURY           = ai->getSpellId("blood fury"); // orc
+    WAR_STOMP            = ai->getSpellId("war stomp"); // tauren
+    BERSERKING           = ai->getSpellId("berserking"); // troll
+
+    m_petSummonFailed = false;
+    m_rangedCombat = true;
+}
+
+PlayerbotHunterAI::~PlayerbotHunterAI() {}
+
+bool PlayerbotHunterAI::HasPet(Player* bot)
+{
+	QueryResult* result = CharacterDatabase.PQuery("SELECT * FROM character_pet WHERE owner = '%u' AND (slot = '%u' OR slot = '%u')",bot->GetGUIDLow(),PET_SAVE_AS_CURRENT,PET_SAVE_NOT_IN_SLOT);
+
+	if(result)
+		return true; //hunter has current pet
+	else
+		return false; //hunter either has no pet or stabled
+}// end HasPet
+
+void PlayerbotHunterAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(RAPTOR_STRIKE);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    // Hunter
+    ai->SetInFront( pTarget );
+    Player *m_bot = GetPlayerBot();
+	Unit* pVictim = pTarget->getVictim();
+
+    // check for pet and heal if neccessary
+    Pet *pet = m_bot->GetPet();
+    if(( pet )
+		&& ( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+		&& ( PET_MEND>0 && !pet->getDeathState() != ALIVE && pVictim != m_bot && !pet->HasAura(PET_MEND, EFFECT_INDEX_0) && ai->GetManaPercent()>=13 && ai->CastSpell(PET_MEND,*m_bot) ))
+		{
+			ai->TellMaster( "healing pet." );
+			return;
+		}
+	else if(( pet )
+		&& ( INTIMIDATION>0 && pVictim == pet && !pet->HasAura(INTIMIDATION, EFFECT_INDEX_0) && ai->CastSpell(INTIMIDATION,*m_bot) ))
+		{
+			//ai->TellMaster( "casting intimidation." ); // if pet has aggro :)
+			return;
+		}
+
+	// racial traits
+	if( m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY, EFFECT_INDEX_0))
+	{
+		ai->CastSpell( BLOOD_FURY,*m_bot );
+		//ai->TellMaster( "Blood Fury." );
+	}
+	else if( m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING, EFFECT_INDEX_0))
+	{
+		ai->CastSpell( BERSERKING,*m_bot );
+		//ai->TellMaster( "Berserking." );
+	}
+
+    // check if ranged combat is possible (set m_rangedCombat and switch auras
+    float dist = m_bot->GetDistance( pTarget );
+    if( (dist<=ATTACK_DISTANCE || !m_bot->GetUInt32Value(PLAYER_AMMO_ID)) && m_rangedCombat )
+    {
+        // switch to melee combat (target in melee range, out of ammo)
+        m_rangedCombat = false;
+        if( !m_bot->GetUInt32Value(PLAYER_AMMO_ID) )
+            ai->TellMaster( "Out of ammo!" );
+        // become monkey (increases dodge chance)...
+        ( ASPECT_OF_THE_MONKEY>0 && !m_bot->HasAura(ASPECT_OF_THE_MONKEY, EFFECT_INDEX_0) && ai->CastSpell(ASPECT_OF_THE_MONKEY,*m_bot) );
+    }
+    else if( dist>ATTACK_DISTANCE && !m_rangedCombat )
+    {
+        // switch to ranged combat
+        m_rangedCombat = true;
+        // increase ranged attack power...
+        ( ASPECT_OF_THE_HAWK>0 && !m_bot->HasAura(ASPECT_OF_THE_HAWK, EFFECT_INDEX_0) && ai->CastSpell(ASPECT_OF_THE_HAWK,*m_bot) );
+    }
+    else if( m_rangedCombat && !m_bot->HasAura(ASPECT_OF_THE_HAWK, EFFECT_INDEX_0))
+    {
+        // check if we have hawk aspect in ranged combat
+        ( ASPECT_OF_THE_HAWK>0 && ai->CastSpell(ASPECT_OF_THE_HAWK,*m_bot) );
+    }
+    else if( !m_rangedCombat && !m_bot->HasAura(ASPECT_OF_THE_MONKEY, EFFECT_INDEX_0))
+    {
+        // check if we have monkey aspect in melee combat
+        ( ASPECT_OF_THE_MONKEY>0 && ai->CastSpell(ASPECT_OF_THE_MONKEY,*m_bot));
+    }
+
+    // activate auto shot
+    if( AUTO_SHOT>0 && m_rangedCombat && !m_bot->FindCurrentSpellBySpellId(AUTO_SHOT) )
+    {
+        ai->CastSpell(AUTO_SHOT,*pTarget);
+        //ai->TellMaster( "started auto shot." );
+    }
+    else if( AUTO_SHOT>0 && m_bot->FindCurrentSpellBySpellId(AUTO_SHOT) )
+    {
+        m_bot->InterruptNonMeleeSpells( true, AUTO_SHOT );
+        //ai->TellMaster( "stopped auto shot." );
+    }
+
+    // damage spells
+    std::ostringstream out;
+    if( m_rangedCombat )
+    {
+        out << "Case Ranged";
+        if( HUNTERS_MARK>0 && ai->GetManaPercent()>=3 && !pTarget->HasAura(HUNTERS_MARK, EFFECT_INDEX_0) && ai->CastSpell(HUNTERS_MARK,*pTarget) )
+            out << " > Hunter's Mark";
+        else if( RAPID_FIRE>0 && ai->GetManaPercent()>=3 && !m_bot->HasAura(RAPID_FIRE, EFFECT_INDEX_0) && ai->CastSpell(RAPID_FIRE,*m_bot) )
+            out << " > Rapid Fire";
+        else if( MULTI_SHOT>0 && ai->GetManaPercent()>=13 && ai->GetAttackerCount()>=3 && ai->CastSpell(MULTI_SHOT,*pTarget) )
+            out << " > Multi-Shot";
+        else if( ARCANE_SHOT>0 && ai->GetManaPercent()>=7 && ai->CastSpell(ARCANE_SHOT,*pTarget) )
+            out << " > Arcane Shot";
+        else if( CONCUSSIVE_SHOT>0 && ai->GetManaPercent()>=6 && !pTarget->HasAura(CONCUSSIVE_SHOT, EFFECT_INDEX_0) && ai->CastSpell(CONCUSSIVE_SHOT,*pTarget) )
+            out << " > Concussive Shot";
+		else if( EXPLOSIVE_SHOT>0 && ai->GetManaPercent()>=10 && !pTarget->HasAura(EXPLOSIVE_SHOT, EFFECT_INDEX_0) && ai->CastSpell(EXPLOSIVE_SHOT,*pTarget) )
+            out << " > Explosive Shot";
+		else if( VIPER_STING>0 && ai->GetManaPercent()>=8 && pTarget->GetPower(POWER_MANA) > 0 && ai->GetManaPercent()<70 && !pTarget->HasAura(VIPER_STING, EFFECT_INDEX_0) && ai->CastSpell(VIPER_STING,*pTarget) )
+            out << " > Viper Sting";
+        else if( SERPENT_STING>0 && ai->GetManaPercent()>=13 && !pTarget->HasAura(SERPENT_STING, EFFECT_INDEX_0) && !pTarget->HasAura(SCORPID_STING, EFFECT_INDEX_0) &&  !pTarget->HasAura(VIPER_STING, EFFECT_INDEX_0) && ai->CastSpell(SERPENT_STING,*pTarget) )
+            out << " > Serpent Sting";
+        else if( SCORPID_STING>0 && ai->GetManaPercent()>=11 && !pTarget->HasAura(WYVERN_STING, EFFECT_INDEX_0) && !pTarget->HasAura(SCORPID_STING, EFFECT_INDEX_0) && !pTarget->HasAura(SERPENT_STING, EFFECT_INDEX_0) && !pTarget->HasAura(VIPER_STING, EFFECT_INDEX_0) && ai->CastSpell(SCORPID_STING,*pTarget) )
+            out << " > Scorpid Sting";
+		else if( CHIMERA_SHOT>0 && ai->GetManaPercent()>=12 && ai->CastSpell(CHIMERA_SHOT,*pTarget) )
+            out << " > Chimera Shot";
+		else if( VOLLEY>0 && ai->GetManaPercent()>=24 && ai->GetAttackerCount()>=3 && ai->CastSpell(VOLLEY,*pTarget) )
+            out << " > Volley";
+		else if( BLACK_ARROW>0 && ai->GetManaPercent()>=6 && !pTarget->HasAura(BLACK_ARROW, EFFECT_INDEX_0) && ai->CastSpell(BLACK_ARROW,*pTarget) )
+            out << " > Black Arrow";
+		else if( AIMED_SHOT>0 && ai->GetManaPercent()>=12 && ai->CastSpell(AIMED_SHOT,*pTarget) )
+            out << " > Aimed Shot";
+		else if( STEADY_SHOT>0 && ai->GetManaPercent()>=5 && ai->CastSpell(STEADY_SHOT,*pTarget) )
+            out << " > Steady Shot";
+		else if( KILL_SHOT>0 && ai->GetManaPercent()>=7 && pTarget->GetHealth() < pTarget->GetMaxHealth()*0.2 && ai->CastSpell(KILL_SHOT,*pTarget) )
+            out << " > Kill Shot!";
+		else
+            out << " NONE!";
+    }
+    else
+    {
+        out << "Case Melee";
+        if( RAPTOR_STRIKE>0 && ai->GetManaPercent()>=6 && ai->CastSpell(RAPTOR_STRIKE,*pTarget) )
+            out << " > Raptor Strike";
+		else if( EXPLOSIVE_TRAP>0 && ai->GetManaPercent()>=27 && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(ARCANE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(BEAR_TRAP, EFFECT_INDEX_0) && ai->CastSpell(EXPLOSIVE_TRAP,*pTarget) )
+            out << " > Explosive Trap";
+        else if( WING_CLIP>0 && ai->GetManaPercent()>=6 && !pTarget->HasAura(WING_CLIP, EFFECT_INDEX_0) && ai->CastSpell(WING_CLIP,*pTarget) )
+            out << " > Wing Clip";
+		else if( IMMOLATION_TRAP>0 && ai->GetManaPercent()>=13 && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(ARCANE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(BEAR_TRAP, EFFECT_INDEX_0) && ai->CastSpell(IMMOLATION_TRAP,*pTarget) )
+            out << " > Immolation Trap";
+        else if( MONGOOSE_BITE>0 && ai->GetManaPercent()>=4 && ai->CastSpell(MONGOOSE_BITE,*pTarget) )
+            out << " > Mongoose Bite";
+		else if( FROST_TRAP>0 && ai->GetManaPercent()>=2 && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(ARCANE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(BEAR_TRAP, EFFECT_INDEX_0) && ai->CastSpell(FROST_TRAP,*pTarget))
+            out << " > Frost Trap";
+		else if( ARCANE_TRAP>0 && !pTarget->HasAura(ARCANE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(BEAR_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && ai->CastSpell(ARCANE_TRAP,*pTarget) )
+            out << " > Arcane Trap";
+		else if( DETERRENCE>0 && pVictim == m_bot && m_bot->GetHealth() < m_bot->GetMaxHealth()*0.5 && !m_bot->HasAura(DETERRENCE, EFFECT_INDEX_0) && ai->CastSpell(DETERRENCE,*m_bot) )
+            out << " > Deterrence";
+		else if( m_bot->getRace() == RACE_TAUREN && !pTarget->HasAura( WAR_STOMP, EFFECT_INDEX_0) && ai->CastSpell(WAR_STOMP,*pTarget) )
+            out << " > War Stomp";
+		else if( m_bot->getRace() == RACE_BLOODELF && !pTarget->HasAura( ARCANE_TORRENT, EFFECT_INDEX_0) && ai->CastSpell( ARCANE_TORRENT,*pTarget ) )
+            out << " > Arcane Torrent";
+		else if( m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState( AURA_STATE_DEADLY_POISON ) && ai->CastSpell( STONEFORM,*m_bot ) )
+            out << " > Stoneform";
+		else if( m_bot->getRace() == RACE_NIGHTELF && pVictim == m_bot && ai->GetHealthPercent() < 25 && !m_bot->HasAura( SHADOWMELD, EFFECT_INDEX_0) && ai->CastSpell( SHADOWMELD,*m_bot ) )
+            out << " > Shadowmeld";
+		else if( m_bot->getRace() == RACE_DRAENEI && ai->GetHealthPercent() < 25 && !m_bot->HasAura(GIFT_OF_THE_NAARU, EFFECT_INDEX_0) && ai->CastSpell(GIFT_OF_THE_NAARU,*m_bot) )
+            out << " > Gift of the Naaru";
+		else if(( pet && !pet->getDeathState() != ALIVE)
+		&& ( MISDIRECTION>0 && pVictim == m_bot && !m_bot->HasAura(MISDIRECTION, EFFECT_INDEX_0) && ai->GetManaPercent()>=9 && ai->CastSpell(MISDIRECTION,*pet)) )
+            out << " > Misdirection"; // give threat to pet
+        /*else if( FREEZING_TRAP>0 && ai->GetManaPercent()>=5 && !pTarget->HasAura(FREEZING_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(ARCANE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(BEAR_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && ai->CastSpell(FREEZING_TRAP,*pTarget) )
+            out << " > Freezing Trap"; // this can trap your bots too
+		else if( BEAR_TRAP>0 && !pTarget->HasAura(BEAR_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(ARCANE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(EXPLOSIVE_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(IMMOLATION_TRAP, EFFECT_INDEX_0) && !pTarget->HasAura(FROST_TRAP, EFFECT_INDEX_0) && ai->CastSpell(BEAR_TRAP,*pTarget) )
+            out << " > Bear Trap"; // this was just too annoying :)
+		else if( DISENGAGE>0 && pVictim && ai->GetManaPercent()>=5 && ai->CastSpell(DISENGAGE,*pTarget) )
+            out << " > Disengage!"; // attempt to return to ranged combat*/
+        else
+            out << " NONE!";
+    }
+    if( ai->GetManager()->m_confDebugWhisper )
+        ai->TellMaster( out.str().c_str() );
+} // end DoNextCombatManeuver
+
+void PlayerbotHunterAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    if( !ai )
+        return;
+
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // reset ranged combat state
+    if( !m_rangedCombat )
+        m_rangedCombat = true;
+
+    // buff group
+	if (TRUESHOT_AURA > 0)
+		(!m_bot->HasAura(TRUESHOT_AURA, EFFECT_INDEX_0) && ai->CastSpell (TRUESHOT_AURA, *m_bot));
+
+	// buff myself
+	if (ASPECT_OF_THE_HAWK > 0)
+		(!m_bot->HasAura(ASPECT_OF_THE_HAWK, EFFECT_INDEX_0) && ai->CastSpell (ASPECT_OF_THE_HAWK, *m_bot));
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+	Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+	else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, EFFECT_INDEX_0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(*fItem);
+        ai->SetIgnoreUpdateTime(8);
+        return;
+    }
+    else if (pItem == NULL && fItem == NULL && m_bot->getRace() == RACE_DRAENEI && !m_bot->HasAura(GIFT_OF_THE_NAARU, EFFECT_INDEX_0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I'm casting gift of the naaru.");
+        ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot);
+        return;
+    }
+
+    // check for pet
+    if( PET_SUMMON>0 && !m_petSummonFailed && HasPet(m_bot) )
+    {
+        // we can summon pet, and no critical summon errors before
+        Pet *pet = m_bot->GetPet();
+        if( !pet )
+        {
+            // summon pet
+            if( PET_SUMMON>0 && ai->CastSpell(PET_SUMMON,*m_bot) )
+                ai->TellMaster( "summoning pet." );
+            else
+            {
+                m_petSummonFailed = true;
+                ai->TellMaster( "summon pet failed!" );
+            }
+        }
+        else if( pet->getDeathState() != ALIVE )
+        {
+            // revive pet
+            if( PET_REVIVE>0 && ai->GetManaPercent()>=80 && ai->CastSpell(PET_REVIVE,*m_bot) )
+                ai->TellMaster( "reviving pet." );
+        }
+        else if( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+        {
+            // heal pet when health lower 50%
+            if( PET_MEND>0 && !pet->getDeathState() != ALIVE && !pet->HasAura(PET_MEND, EFFECT_INDEX_0) && ai->GetManaPercent()>=13 && ai->CastSpell(PET_MEND,*m_bot) )
+                ai->TellMaster( "healing pet." );
+        }
+        else if(pet->GetHappinessState() != HAPPY) // if pet is hungry
+        {
+            Unit *caster = (Unit*)m_bot;
+            // list out items in main backpack
+            for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+            {
+                Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (!pItemProto )
+                        continue;
+
+                    if(pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                    {
+                        //sLog.outDebug("Food for pet: %s",pItemProto->Name1);
+                        caster->CastSpell(caster,51284,true); // pet feed visual
+                        uint32 count = 1; // number of items used
+                        int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                        m_bot->DestroyItemCount(pItem,count,true); // remove item from inventory
+                        m_bot->CastCustomSpell(m_bot,PET_FEED,&benefit,NULL,NULL,true); // feed pet
+                        ai->TellMaster( "feeding pet." );
+                        ai->SetIgnoreUpdateTime(10);
+                        return;
+                    }
+                }
+            }
+            // list out items in other removable backpacks
+            for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+            {
+                const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                if (pBag)
+                {
+                    for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                    {
+                        Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                        if (pItem)
+                        {
+                            const ItemPrototype* const pItemProto = pItem->GetProto();
+                            if (!pItemProto )
+                                continue;
+
+                            if(pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                            {
+                                //sLog.outDebug("Food for pet: %s",pItemProto->Name1);
+                                caster->CastSpell(caster,51284,true); // pet feed visual
+				uint32 count = 1; // number of items used
+                                int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                                m_bot->DestroyItemCount(pItem,count,true); // remove item from inventory
+                                m_bot->CastCustomSpell(m_bot,PET_FEED,&benefit,NULL,NULL,true); // feed pet
+                                ai->TellMaster( "feeding pet." );
+                                ai->SetIgnoreUpdateTime(10);
+                                return;
+                            }
+                        }
+                    }
+                }
+            }
+            if( pet->HasAura(PET_MEND, EFFECT_INDEX_0) && !pet->HasAura(PET_FEED, EFFECT_INDEX_0))
+                ai->TellMaster( "..no pet food!" );
+            ai->SetIgnoreUpdateTime(7);
+        }
+    }
+} // end DoNonCombatActions
diff --git a/Core/src/game/PlayerbotHunterAI.h b/Core/src/game/PlayerbotHunterAI.h
new file mode 100644
index 0000000..680b2ea
--- /dev/null
+++ b/Core/src/game/PlayerbotHunterAI.h
@@ -0,0 +1,49 @@
+#ifndef _PLAYERHUNTERAI_H
+#define _PLAYERHUNTERAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_HUNTER
+};
+
+
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotHunterAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotHunterAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
+        virtual ~PlayerbotHunterAI();
+        bool HasPet(Player* bot);
+
+        // all combat actions go here
+        void DoNextCombatManeuver(Unit*);
+
+        // all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        // buff a specific player, usually a real PC who is not in group
+        //void BuffPlayer(Player *target);
+
+    private:
+        // Hunter
+        bool m_petSummonFailed;
+        bool m_rangedCombat;
+
+        uint32 PET_SUMMON, PET_DISMISS, PET_REVIVE, PET_MEND, PET_FEED, BAD_ATTITUDE, SONIC_BLAST, NETHER_SHOCK, DEMORALIZING_SCREECH, INTIMIDATION;
+        uint32 AUTO_SHOT, HUNTERS_MARK, ARCANE_SHOT, CONCUSSIVE_SHOT, DISTRACTING_SHOT, MULTI_SHOT, EXPLOSIVE_SHOT, SERPENT_STING, SCORPID_STING, VIPER_STING, WYVERN_STING, AIMED_SHOT, STEADY_SHOT, CHIMERA_SHOT, VOLLEY, BLACK_ARROW, KILL_SHOT;
+        uint32 RAPTOR_STRIKE, WING_CLIP, MONGOOSE_BITE, DISENGAGE, DETERRENCE;
+        uint32 BEAR_TRAP, FREEZING_TRAP, IMMOLATION_TRAP, FROST_TRAP, EXPLOSIVE_TRAP, ARCANE_TRAP, SNAKE_TRAP;
+        uint32 ASPECT_OF_THE_HAWK, ASPECT_OF_THE_MONKEY, RAPID_FIRE, TRUESHOT_AURA, MISDIRECTION;
+
+        // first aid
+        uint32 RECENTLY_BANDAGED;
+
+        // racial
+        uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+};
+
+#endif
+
diff --git a/Core/src/game/PlayerbotMageAI.cpp b/Core/src/game/PlayerbotMageAI.cpp
new file mode 100644
index 0000000..0eb1dfd
--- /dev/null
+++ b/Core/src/game/PlayerbotMageAI.cpp
@@ -0,0 +1,441 @@
+
+#include "PlayerbotMageAI.h"
+
+class PlayerbotAI;
+
+PlayerbotMageAI::PlayerbotMageAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    ARCANE_MISSILES         = ai->getSpellId("arcane missiles"); //ARCANE
+    ARCANE_EXPLOSION        = ai->getSpellId("arcane explosion");
+    COUNTERSPELL            = ai->getSpellId("counterspell");
+    SLOW                    = ai->getSpellId("slow");
+    ARCANE_BARRAGE          = ai->getSpellId("arcane barrage");
+    ARCANE_BLAST            = ai->getSpellId("arcane blast");
+    ARCANE_POWER            = ai->getSpellId("arcane power");
+    DAMPEN_MAGIC            = ai->getSpellId("dampen magic");
+    AMPLIFY_MAGIC           = ai->getSpellId("amplify magic");
+    MAGE_ARMOR              = ai->getSpellId("mage armor");
+    MIRROR_IMAGE            = ai->getSpellId("mirror image");
+    ARCANE_INTELLECT        = ai->getSpellId("arcane intellect");
+    ARCANE_BRILLIANCE       = ai->getSpellId("arcane brilliance");
+    DALARAN_INTELLECT       = ai->getSpellId("dalaran intellect");
+    DALARAN_BRILLIANCE      = ai->getSpellId("dalaran brilliance");
+    MANA_SHIELD             = ai->getSpellId("mana shield");
+    CONJURE_WATER           = ai->getSpellId("conjure water");
+    CONJURE_FOOD            = ai->getSpellId("conjure food");
+    FIREBALL                = ai->getSpellId("fireball"); //FIRE
+    FIRE_BLAST              = ai->getSpellId("fire blast");
+    FLAMESTRIKE             = ai->getSpellId("flamestrike");
+    SCORCH                  = ai->getSpellId("scorch");
+    PYROBLAST               = ai->getSpellId("pyroblast");
+    BLAST_WAVE              = ai->getSpellId("blast wave");
+    COMBUSTION              = ai->getSpellId("combustion");
+    DRAGONS_BREATH          = ai->getSpellId("dragon's breath");
+    LIVING_BOMB             = ai->getSpellId("living bomb");
+    FROSTFIRE_BOLT          = ai->getSpellId("frostfire bolt");
+    FIRE_WARD               = ai->getSpellId("fire ward");
+    MOLTEN_ARMOR            = ai->getSpellId("molten armor");
+    ICY_VEINS               = ai->getSpellId("icy veins"); //FROST
+    DEEP_FREEZE             = ai->getSpellId("deep freeze");
+    FROSTBOLT               = ai->getSpellId("frostbolt");
+    FROST_NOVA              = ai->getSpellId("frost nova");
+    BLIZZARD                = ai->getSpellId("blizzard");
+    CONE_OF_COLD            = ai->getSpellId("cone of cold");
+    ICE_BARRIER             = ai->getSpellId("ice barrier");
+    SUMMON_WATER_ELEMENTAL  = ai->getSpellId("summon water elemental");
+    FROST_WARD              = ai->getSpellId("frost ward");
+    ICE_LANCE               = ai->getSpellId("ice lance");
+    FROST_ARMOR             = ai->getSpellId("frost armor");
+    ICE_ARMOR               = ai->getSpellId("ice armor");
+    ICE_BLOCK               = ai->getSpellId("ice block");
+    COLD_SNAP               = ai->getSpellId("cold snap");
+
+    RECENTLY_BANDAGED       = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT          = ai->getSpellId("arcane torrent"); // blood elf
+    GIFT_OF_THE_NAARU       = ai->getSpellId("gift of the naaru"); // draenei
+    ESCAPE_ARTIST           = ai->getSpellId("escape artist"); // gnome
+    EVERY_MAN_FOR_HIMSELF   = ai->getSpellId("every man for himself"); // human
+    BERSERKING              = ai->getSpellId("berserking"); // troll
+    WILL_OF_THE_FORSAKEN    = ai->getSpellId("will of the forsaken"); // undead
+}
+
+PlayerbotMageAI::~PlayerbotMageAI() {}
+
+void PlayerbotMageAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (FIREBALL > 0)
+                ai->CastSpell(FIREBALL);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+	//ai->SetMovementOrder( PlayerbotAI::MOVEMENT_FOLLOW, GetMaster() ); // dont want to melee mob
+
+    // Damage Spells (primitive example)
+    ai->SetInFront( pTarget );
+    Player *m_bot = GetPlayerBot();
+	Unit* pVictim = pTarget->getVictim();
+	float dist = m_bot->GetDistance( pTarget );
+
+    switch (SpellSequence)
+    {
+        case SPELL_FROST:
+            if (ICY_VEINS > 0 && !m_bot->HasAura(ICY_VEINS, EFFECT_INDEX_0) && LastSpellFrost < 1 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell(ICY_VEINS, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost +1;
+                break;
+            }
+            else if (FROSTBOLT > 0 && LastSpellFrost < 2 && !pTarget->HasAura(FROSTBOLT, EFFECT_INDEX_0) && ai->GetManaPercent() >= 16)
+            {
+                ai->CastSpell(FROSTBOLT, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost +1;
+                break;
+            }
+			else if (FROST_WARD > 0 && LastSpellFrost < 3 && !m_bot->HasAura(FROST_WARD, EFFECT_INDEX_0) && ai->GetManaPercent() >= 19)
+            {
+                ai->CastSpell(FROST_WARD, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost +1;
+                break;
+            }
+            else if (FROST_NOVA > 0 && LastSpellFrost < 4 && dist <= ATTACK_DISTANCE && !pTarget->HasAura(FROST_NOVA, EFFECT_INDEX_0) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(FROST_NOVA, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost +1;
+                break;
+            }
+			else if (ICE_LANCE > 0 && LastSpellFrost < 5 && ai->GetManaPercent() >= 7)
+            {
+                ai->CastSpell(ICE_LANCE, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost +1;
+                break;
+            }
+            else if (BLIZZARD > 0 && LastSpellFrost < 6 && ai->GetAttackerCount()>=5 && ai->GetManaPercent() >= 89)
+            {
+                ai->CastSpell(BLIZZARD, *pTarget);
+				ai->SetIgnoreUpdateTime(8);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost +1;
+                break;
+            }
+            else if (CONE_OF_COLD > 0 && LastSpellFrost < 7 && dist <= ATTACK_DISTANCE && !pTarget->HasAura(CONE_OF_COLD, EFFECT_INDEX_0) && ai->GetManaPercent() >= 35)
+            {
+                ai->CastSpell(CONE_OF_COLD, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost +1;
+                break;
+            }
+			else if (DEEP_FREEZE > 0 && LastSpellFrost < 8 && pTarget->HasAura(AURA_STATE_FROZEN, EFFECT_INDEX_0) && !pTarget->HasAura(DEEP_FREEZE, EFFECT_INDEX_0) && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(DEEP_FREEZE, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost +1;
+                break;
+            }
+            else if (ICE_BARRIER > 0 && LastSpellFrost < 9 && pVictim == m_bot && !m_bot->HasAura(ICE_BARRIER, EFFECT_INDEX_0) && ai->GetHealthPercent() < 50 && ai->GetManaPercent() >= 30)
+            {
+                ai->CastSpell(ICE_BARRIER, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost +1;
+                break;
+            }
+            else if (SUMMON_WATER_ELEMENTAL > 0 && LastSpellFrost < 10 && ai->GetManaPercent() >= 16)
+            {
+                ai->CastSpell(SUMMON_WATER_ELEMENTAL);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost +1;
+                break;
+            }
+			else if (ICE_BLOCK > 0 && LastSpellFrost < 11 && pVictim == m_bot && !m_bot->HasAura(ICE_BLOCK, EFFECT_INDEX_0) && ai->GetHealthPercent() < 30)
+            {
+                ai->CastSpell(ICE_BLOCK, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost +1;
+                break;
+            }
+			else if (COLD_SNAP > 0 && LastSpellFrost < 12)
+            {
+                ai->CastSpell(COLD_SNAP, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost +1;
+                break;
+            }
+            LastSpellFrost = 0;
+            //SpellSequence = SPELL_FIRE;
+            //break;
+
+        case SPELL_FIRE:
+			if (FIRE_WARD > 0 && !m_bot->HasAura(FIRE_WARD, EFFECT_INDEX_0) && LastSpellFire < 1 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell(FIRE_WARD, *m_bot);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire +1;
+                break;
+            }
+			else if (COMBUSTION > 0 && !m_bot->HasAura(COMBUSTION, EFFECT_INDEX_0) && LastSpellFire < 2)
+            {
+                ai->CastSpell(COMBUSTION, *m_bot);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire +1;
+                break;
+            }
+            else if (FIREBALL > 0 && LastSpellFire < 3 && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(FIREBALL, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire +1;
+                break;
+            }
+            else if (FIRE_BLAST > 0 && LastSpellFire < 4 && ai->GetManaPercent() >= 25)
+            {
+                ai->CastSpell(FIRE_BLAST, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire +1;
+                break;
+            }
+            else if (FLAMESTRIKE > 0 && LastSpellFire < 5 && ai->GetManaPercent() >= 35)
+            {
+                ai->CastSpell(FLAMESTRIKE, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire +1;
+                break;
+            }
+            else if (SCORCH > 0 && LastSpellFire < 6 && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(SCORCH, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire +1;
+                break;
+            }
+            else if (PYROBLAST > 0 && LastSpellFire < 7 && !pTarget->HasAura(PYROBLAST, EFFECT_INDEX_0) && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(PYROBLAST, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire +1;
+                break;
+            }
+            else if (BLAST_WAVE > 0 && LastSpellFire < 8 && ai->GetAttackerCount()>=3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 34)
+            {
+                ai->CastSpell(BLAST_WAVE, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire +1;
+                break;
+            }
+            else if (DRAGONS_BREATH > 0 && LastSpellFire < 9 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 37)
+            {
+                ai->CastSpell(DRAGONS_BREATH, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire +1;
+                break;
+            }
+            else if (LIVING_BOMB > 0 && LastSpellFire < 10 && !pTarget->HasAura(LIVING_BOMB, EFFECT_INDEX_0) && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(LIVING_BOMB, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire +1;
+                break;
+            }
+            else if (FROSTFIRE_BOLT > 0 && LastSpellFire < 11 && !pTarget->HasAura(FROSTFIRE_BOLT, EFFECT_INDEX_0) && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell(FROSTFIRE_BOLT, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire +1;
+                break;
+            }
+            LastSpellFire = 0;
+            //SpellSequence = SPELL_ARCANE;
+            //break;
+
+        case SPELL_ARCANE:
+            if (ARCANE_POWER > 0 && LastSpellArcane < 1 && ai->GetManaPercent() >= 37)
+            {
+                ai->CastSpell(ARCANE_POWER, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane +1;
+                break;
+            }
+			else if (ARCANE_MISSILES > 0 && LastSpellArcane < 2 && ai->GetManaPercent() >= 37)
+            {
+                ai->CastSpell(ARCANE_MISSILES, *pTarget);
+				ai->SetIgnoreUpdateTime(3);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane +1;
+                break;
+            }
+            else if (ARCANE_EXPLOSION > 0 && LastSpellArcane < 3 && ai->GetAttackerCount()>=3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(ARCANE_EXPLOSION, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane +1;
+                break;
+            }
+            else if (COUNTERSPELL > 0 && pTarget->IsNonMeleeSpellCasted(true) && LastSpellArcane < 4 && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(COUNTERSPELL, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane +1;
+                break;
+            }
+            else if (SLOW > 0 && LastSpellArcane < 5 && !pTarget->HasAura(SLOW, EFFECT_INDEX_0) && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell(SLOW, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane +1;
+                break;
+            }
+            else if (ARCANE_BARRAGE > 0 && LastSpellArcane < 6 && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(ARCANE_BARRAGE, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane +1;
+                break;
+            }
+            else if (ARCANE_BLAST > 0 && LastSpellArcane < 7 && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(ARCANE_BLAST, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane +1;
+                break;
+            }
+            else if (MIRROR_IMAGE > 0 && LastSpellArcane < 8 && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(MIRROR_IMAGE);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane +1;
+                break;
+            }
+			else if (MANA_SHIELD > 0 && LastSpellArcane < 9 && ai->GetHealthPercent() < 70 && pVictim == m_bot && !m_bot->HasAura(MANA_SHIELD, EFFECT_INDEX_0) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(MANA_SHIELD, *m_bot);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane +1;
+                break;
+            }
+            else
+            {
+                LastSpellArcane = 0;
+                SpellSequence = SPELL_FROST;
+            }
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotMageAI::DoNonCombatActions()
+{
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    SpellSequence = SPELL_FROST;
+	PlayerbotAI* ai = GetAI();
+
+    // buff master
+	if (DALARAN_BRILLIANCE > 0)
+        (!GetMaster()->HasAura(DALARAN_BRILLIANCE, EFFECT_INDEX_0) && ai->GetManaPercent() >= 81 && ai->CastSpell (DALARAN_BRILLIANCE, *GetMaster()));
+	else if (ARCANE_BRILLIANCE > 0)
+        (!GetMaster()->HasAura(ARCANE_BRILLIANCE, EFFECT_INDEX_0) && !GetMaster()->HasAura(DALARAN_BRILLIANCE, EFFECT_INDEX_0) && ai->GetManaPercent() >= 97 && ai->CastSpell (ARCANE_BRILLIANCE, *GetMaster()));
+
+    // buff myself
+    if (DALARAN_INTELLECT > 0)
+        (!m_bot->HasAura(DALARAN_INTELLECT, EFFECT_INDEX_0) && !m_bot->HasAura(DALARAN_BRILLIANCE, EFFECT_INDEX_0) && !m_bot->HasAura(ARCANE_BRILLIANCE, EFFECT_INDEX_0) && ai->GetManaPercent() >= 31 && ai->CastSpell (DALARAN_INTELLECT, *m_bot));
+    else if (ARCANE_INTELLECT > 0)
+        (!m_bot->HasAura(ARCANE_INTELLECT, EFFECT_INDEX_0) && !m_bot->HasAura(DALARAN_BRILLIANCE, EFFECT_INDEX_0) && !m_bot->HasAura(ARCANE_BRILLIANCE, EFFECT_INDEX_0) && !m_bot->HasAura(DALARAN_INTELLECT, EFFECT_INDEX_0) && ai->GetManaPercent() >= 37 && ai->CastSpell (ARCANE_INTELLECT, *m_bot));
+
+    if (MOLTEN_ARMOR > 0)
+        (!m_bot->HasAura(MOLTEN_ARMOR, EFFECT_INDEX_0) && !m_bot->HasAura(MAGE_ARMOR, EFFECT_INDEX_0) && ai->GetManaPercent() >= 31 && ai->CastSpell (MOLTEN_ARMOR, *m_bot));
+	else if (MAGE_ARMOR > 0)
+        (!m_bot->HasAura(MAGE_ARMOR, EFFECT_INDEX_0) && !m_bot->HasAura(MOLTEN_ARMOR, EFFECT_INDEX_0) && ai->GetManaPercent() >= 31 && ai->CastSpell (MAGE_ARMOR, *m_bot));
+	else if (ICE_ARMOR > 0)
+        (!m_bot->HasAura(ICE_ARMOR, EFFECT_INDEX_0) && !m_bot->HasAura(MOLTEN_ARMOR, EFFECT_INDEX_0) && !m_bot->HasAura(MAGE_ARMOR, EFFECT_INDEX_0) && ai->GetManaPercent() >= 34 && ai->CastSpell (ICE_ARMOR, *m_bot));
+    else if (FROST_ARMOR > 0)
+        (!m_bot->HasAura(FROST_ARMOR, EFFECT_INDEX_0) && !m_bot->HasAura(MOLTEN_ARMOR, EFFECT_INDEX_0) && !m_bot->HasAura(MAGE_ARMOR, EFFECT_INDEX_0) && !m_bot->HasAura(ICE_ARMOR, EFFECT_INDEX_0) && ai->GetManaPercent() >= 34 && ai->CastSpell (FROST_ARMOR, *m_bot));
+
+	// buff master's group
+    if (GetMaster()->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = sObjectMgr.GetPlayer(uint64 (itr->guid));
+            if( !tPlayer || !tPlayer->isAlive() )
+                continue;
+			// buff
+			(!tPlayer->HasAura(ARCANE_INTELLECT, EFFECT_INDEX_0) && !tPlayer->HasAura(DALARAN_BRILLIANCE, EFFECT_INDEX_0) && !tPlayer->HasAura(ARCANE_BRILLIANCE, EFFECT_INDEX_0) && !tPlayer->HasAura(DALARAN_INTELLECT, EFFECT_INDEX_0) && ai->GetManaPercent() >= 37 && ai->CastSpell (ARCANE_INTELLECT, *tPlayer));
+			(!tPlayer->HasAura(DALARAN_INTELLECT, EFFECT_INDEX_0) && !tPlayer->HasAura(DALARAN_BRILLIANCE, EFFECT_INDEX_0) && !tPlayer->HasAura(ARCANE_BRILLIANCE, EFFECT_INDEX_0) && ai->GetManaPercent() >= 31 && ai->CastSpell (DALARAN_INTELLECT, *tPlayer));
+			(!tPlayer->HasAura(DAMPEN_MAGIC, EFFECT_INDEX_0) && !tPlayer->HasAura(AMPLIFY_MAGIC, EFFECT_INDEX_0) && ai->GetManaPercent() >= 32 && ai->CastSpell (DAMPEN_MAGIC, *tPlayer));
+			(!tPlayer->HasAura(AMPLIFY_MAGIC, EFFECT_INDEX_0) && !tPlayer->HasAura(DAMPEN_MAGIC, EFFECT_INDEX_0) && ai->GetManaPercent() >= 32 && ai->CastSpell (AMPLIFY_MAGIC, *tPlayer));
+        }
+    }
+
+    // conjure food & water
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+	Item* fItem = ai->FindBandage();
+
+    if (pItem == NULL && CONJURE_WATER && ai->GetBaseManaPercent() >= 48)
+    {
+        ai->TellMaster("I'm conjuring some water.");
+        ai->CastSpell(CONJURE_WATER, *m_bot);
+		ai->SetIgnoreUpdateTime(3);
+        return;
+    }
+    else if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+
+    pItem = ai->FindFood();
+
+    if (pItem == NULL && CONJURE_FOOD && ai->GetBaseManaPercent() >= 48)
+    {
+        ai->TellMaster("I'm conjuring some food.");
+        ai->CastSpell(CONJURE_FOOD, *m_bot);
+		ai->SetIgnoreUpdateTime(3);
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+	else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, EFFECT_INDEX_0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(*fItem);
+        ai->SetIgnoreUpdateTime(8);
+        return;
+    }
+
+} // end DoNonCombatActions
+
+void PlayerbotMageAI::BuffPlayer(Player* target)
+{
+    GetAI()->CastSpell(ARCANE_INTELLECT, *target);
+}
diff --git a/Core/src/game/PlayerbotMageAI.h b/Core/src/game/PlayerbotMageAI.h
new file mode 100644
index 0000000..a0955db
--- /dev/null
+++ b/Core/src/game/PlayerbotMageAI.h
@@ -0,0 +1,52 @@
+#ifndef _PlayerbotMageAI_H
+#define _PlayerbotMageAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_FROST,
+    SPELL_FIRE,
+    SPELL_ARCANE
+};
+
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotMageAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotMageAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
+        virtual ~PlayerbotMageAI();
+
+        // all combat actions go here
+        void DoNextCombatManeuver(Unit*);
+
+        // all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        // buff a specific player, usually a real PC who is not in group
+        void BuffPlayer(Player *target);
+
+    private:
+        // ARCANE
+        uint32 ARCANE_MISSILES, ARCANE_EXPLOSION, COUNTERSPELL, SLOW, ARCANE_BARRAGE, ARCANE_BLAST, MIRROR_IMAGE, ARCANE_POWER;
+
+        // FIRE
+        uint32 FIREBALL, FIRE_BLAST, FLAMESTRIKE, SCORCH, PYROBLAST, BLAST_WAVE, COMBUSTION, DRAGONS_BREATH, LIVING_BOMB, FROSTFIRE_BOLT, FIRE_WARD;
+
+        // FROST
+        uint32 DEEP_FREEZE, FROSTBOLT, FROST_NOVA, BLIZZARD, ICY_VEINS, CONE_OF_COLD, ICE_BARRIER, SUMMON_WATER_ELEMENTAL, ICE_LANCE, FROST_WARD, ICE_BLOCK, COLD_SNAP;
+
+        // buffs
+        uint32 FROST_ARMOR, ICE_ARMOR, MAGE_ARMOR, MOLTEN_ARMOR, ARCANE_INTELLECT, ARCANE_BRILLIANCE, DALARAN_INTELLECT, DALARAN_BRILLIANCE, MANA_SHIELD, DAMPEN_MAGIC, AMPLIFY_MAGIC;
+
+		// first aid
+		uint32 RECENTLY_BANDAGED;
+
+		// racial
+		uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+        uint32 SpellSequence, LastSpellArcane, LastSpellFire, LastSpellFrost, CONJURE_WATER, CONJURE_FOOD;
+};
+
+#endif
diff --git a/Core/src/game/PlayerbotMgr.cpp b/Core/src/game/PlayerbotMgr.cpp
new file mode 100644
index 0000000..c095eb1
--- /dev/null
+++ b/Core/src/game/PlayerbotMgr.cpp
@@ -0,0 +1,706 @@
+#include "Config/ConfigEnv.h"
+#include "Player.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotMgr.h"
+#include "WorldPacket.h"
+#include "Chat.h"
+#include "ObjectMgr.h"
+#include "GossipDef.h"
+#include "Chat.h"
+#include "Language.h"
+#include "Guild.h"
+
+class LoginQueryHolder;
+class CharacterHandler;
+
+
+PlayerbotMgr::PlayerbotMgr(Player* const master) : m_master(master)
+{
+    // load config variables
+    m_confMaxNumBots = sConfig.GetIntDefault( "PlayerbotAI.MaxNumBots", 9 );
+    m_confRestrictBotLevel = sConfig.GetIntDefault( "PlayerbotAI.RestrictBotLevel", 80 );
+    m_confDisableBots = sConfig.GetBoolDefault( "PlayerbotAI.DisableBots", false );
+    m_confDebugWhisper = sConfig.GetBoolDefault( "PlayerbotAI.DebugWhisper", false );
+    m_confFollowDistance[0] = sConfig.GetFloatDefault( "PlayerbotAI.FollowDistanceMin", 0.5f );
+    m_confFollowDistance[1] = sConfig.GetFloatDefault( "PlayerbotAI.FollowDistanceMin", 1.0f );
+}
+
+PlayerbotMgr::~PlayerbotMgr()
+{
+  LogoutAllBots();
+}
+
+void PlayerbotMgr::UpdateAI(const uint32 p_time) {}
+
+void PlayerbotMgr::HandleMasterIncomingPacket(const WorldPacket& packet)
+{
+    switch (packet.GetOpcode())
+    {
+        // if master is logging out, log out all bots
+        case CMSG_LOGOUT_REQUEST:
+        {
+            LogoutAllBots();
+            return;
+        }
+
+        // If master inspects one of his bots, give the master useful info in chat window
+        // such as inventory that can be equipped
+        case CMSG_INSPECT:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+            uint64 guid;
+            p >> guid;
+            Player* const bot = GetPlayerBot(guid);
+            if (bot) bot->GetPlayerbotAI()->SendNotEquipList(*bot);
+            return;
+        }
+
+        // handle emotes from the master
+        //case CMSG_EMOTE:
+        case CMSG_TEXT_EMOTE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+            uint32 emoteNum;
+            p >> emoteNum;
+
+            /* std::ostringstream out;
+            out << "emote is: " << emoteNum;
+            ChatHandler ch(m_master);
+            ch.SendSysMessage(out.str().c_str()); */
+
+            switch (emoteNum)
+            {
+                case TEXTEMOTE_BOW:
+                {
+                    // Buff anyone who bows before me. Useful for players not in bot's group
+                    // How do I get correct target???
+                    //Player* const pPlayer = GetPlayerBot(m_master->GetSelection());
+                    //if (pPlayer->GetPlayerbotAI()->GetClassAI())
+                    //    pPlayer->GetPlayerbotAI()->GetClassAI()->BuffPlayer(pPlayer);
+                    return;
+                }
+                /*
+                case TEXTEMOTE_BONK:
+                {
+                    Player* const pPlayer = GetPlayerBot(m_master->GetSelection());
+                    if (!pPlayer || !pPlayer->GetPlayerbotAI())
+                        return;
+                    PlayerbotAI* const pBot = pPlayer->GetPlayerbotAI();
+
+                    ChatHandler ch(m_master);
+                    {
+                        std::ostringstream out;
+                        out << "time(0): " << time(0)
+                            << " m_ignoreAIUpdatesUntilTime: " << pBot->m_ignoreAIUpdatesUntilTime;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "m_TimeDoneEating: " << pBot->m_TimeDoneEating
+                            << " m_TimeDoneDrinking: " << pBot->m_TimeDoneDrinking;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "m_CurrentlyCastingSpellId: " << pBot->m_CurrentlyCastingSpellId;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "IsBeingTeleported() " << pBot->GetPlayer()->IsBeingTeleported();
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        bool tradeActive = (pBot->GetPlayer()->GetTrader()) ? true : false;
+                        out << "tradeActive: " << tradeActive;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "IsCharmed() " << pBot->getPlayer()->isCharmed();
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    return;
+                }
+                */
+
+                case TEXTEMOTE_EAT:
+                case TEXTEMOTE_DRINK:
+                {
+                    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+                    {
+                        Player* const bot = it->second;
+                        bot->GetPlayerbotAI()->Feast();
+                    }
+                    return;
+                }
+
+                // emote to attack selected target
+                case TEXTEMOTE_POINT:
+                {
+                    uint64 attackOnGuid = m_master->GetSelection();
+                    if( !attackOnGuid ) return;
+
+                    Unit* thingToAttack = ObjectAccessor::GetUnit(*m_master, attackOnGuid);
+                    if( !thingToAttack ) return;
+
+                    Player *bot = 0;
+                    for( PlayerBotMap::iterator itr=m_playerBots.begin(); itr!=m_playerBots.end(); ++itr )
+                    {
+                        bot = itr->second;
+                        if (!bot->IsFriendlyTo(thingToAttack) && bot->IsWithinLOSInMap(thingToAttack))
+                            bot->GetPlayerbotAI()->GetCombatTarget( thingToAttack );
+                    }
+                    return;
+                }
+
+                // emote to stay
+                case TEXTEMOTE_STAND:
+                {
+                    Player* const bot = GetPlayerBot(m_master->GetSelection());
+                    if (bot)
+						bot->GetPlayerbotAI()->SetMovementOrder( PlayerbotAI::MOVEMENT_STAY );
+                    else
+                    {
+                        for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+                        {
+                            Player* const bot = it->second;
+                            bot->GetPlayerbotAI()->SetMovementOrder( PlayerbotAI::MOVEMENT_STAY );
+                        }
+                    }
+                    return;
+                }
+
+                // 324 is the followme emote (not defined in enum)
+                // if master has bot selected then only bot follows, else all bots follow
+                case 324:
+                case TEXTEMOTE_WAVE:
+                {
+                    Player* const bot = GetPlayerBot(m_master->GetSelection());
+                    if (bot)
+                        bot->GetPlayerbotAI()->SetMovementOrder( PlayerbotAI::MOVEMENT_FOLLOW, m_master );
+                    else
+                    {
+                        for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+                        {
+                            Player* const bot = it->second;
+                            bot->GetPlayerbotAI()->SetMovementOrder( PlayerbotAI::MOVEMENT_FOLLOW, m_master);
+                        }
+                    }
+                    return;
+                }
+            }
+            return;
+        } /* EMOTE ends here */
+
+        case CMSG_GAMEOBJ_USE:
+            {
+                WorldPacket p(packet);
+                p.rpos(0); // reset reader
+                uint64 objGUID;
+                p >> objGUID;
+
+                GameObject *obj = m_master->GetMap()->GetGameObject( objGUID );
+                if( !obj )
+                    return;
+
+                for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+
+                    if( obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER )
+                    {
+                        bot->GetPlayerbotAI()->TurnInQuests( obj );
+                    }
+                    // add other go types here, i.e.:
+                    // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
+                }
+            }
+            break;
+
+        // if master talks to an NPC
+        case CMSG_GOSSIP_HELLO:
+        case CMSG_QUESTGIVER_HELLO:
+        {
+               WorldPacket p(packet);
+               p.rpos(0); // reset reader
+               uint64 npcGUID;
+               p >> npcGUID;
+
+               WorldObject* pNpc = m_master->GetMap()->GetWorldObject( npcGUID );
+               if (!pNpc)
+                    return;
+
+               // for all master's bots
+               for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+               {
+                    Player* const bot = it->second;
+                    bot->GetPlayerbotAI()->TurnInQuests( pNpc );
+               }
+
+               return;
+        }
+
+        // if master accepts a quest, bots should also try to accept quest
+        case CMSG_QUESTGIVER_ACCEPT_QUEST:
+        {
+               WorldPacket p(packet);
+               p.rpos(0); // reset reader
+               uint64 guid;
+               uint32 quest;
+               p >> guid >> quest;
+               Quest const* qInfo = sObjectMgr.GetQuestTemplate(quest);
+               if (qInfo)
+               {
+                    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+                    {
+                          Player* const bot = it->second;
+
+                          if (bot->GetQuestStatus(quest) == QUEST_STATUS_COMPLETE)
+                                bot->GetPlayerbotAI()->TellMaster("I already completed that quest.");
+                          else if (! bot->CanTakeQuest(qInfo, false))
+                          {
+                                if (! bot->SatisfyQuestStatus(qInfo, false))
+                                      bot->GetPlayerbotAI()->TellMaster("I already have that quest.");
+                                else
+                                      bot->GetPlayerbotAI()->TellMaster("I can't take that quest.");
+                          }
+                          else if (! bot->SatisfyQuestLog(false))
+                                bot->GetPlayerbotAI()->TellMaster("My quest log is full.");
+                          else if (! bot->CanAddQuest(qInfo, false))
+                                bot->GetPlayerbotAI()->TellMaster("I can't take that quest because it requires that I take items, but my bags are full!");
+
+                          else
+                          {
+                                p.rpos(0); // reset reader
+                                bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
+                                bot->GetPlayerbotAI()->TellMaster("Got the quest.");
+                          }
+                    }
+               }
+               return;
+        }
+        case CMSG_LOOT_ROLL:
+        {
+
+               WorldPacket p(packet); //WorldPacket packet for CMSG_LOOT_ROLL, (8+4+1)
+               uint64 Guid;
+               uint32 NumberOfPlayers;
+               uint8 rollType;
+               p.rpos(0); //reset packet pointer
+               p >> Guid; //guid of the item rolled
+               p >> NumberOfPlayers; //number of players invited to roll
+               p >> rollType; //need,greed or pass on roll
+
+
+               for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+               {
+
+                    uint32 choice = urand(0,3); //returns 0,1,2 or 3
+
+                    Player* const bot = it->second;
+                    if(!bot)
+                         return;
+
+                    Group* group = bot->GetGroup();
+                    if(!group)
+                         return;
+
+                    group->CountRollVote(bot->GetGUID(), Guid, NumberOfPlayers, RollVote(choice));
+
+                    switch (choice)
+                    {
+                          case ROLL_NEED:
+                                  bot->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_NEED, 1);
+                                  break;
+                          case ROLL_GREED:
+                                  bot->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_GREED, 1);
+                                  break;
+                    }
+               }
+               return;
+        }
+        case CMSG_REPAIR_ITEM:
+        {
+
+               WorldPacket p(packet); // WorldPacket packet for CMSG_REPAIR_ITEM, (8+8+1)
+
+               sLog.outDebug("PlayerbotMgr: CMSG_REPAIR_ITEM");
+
+               uint64 npcGUID, itemGUID;
+               uint8 guildBank;
+
+               p.rpos(0); //reset packet pointer
+               p >> npcGUID;
+               p >> itemGUID;  // Not used for bot but necessary opcode data retrieval
+               p >> guildBank; // Flagged if guild repair selected
+
+               for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+               {
+
+                    Player* const bot = it->second;
+                    if(!bot)
+                         return;
+
+                    Group* group = bot->GetGroup();  // check if bot is a member of group
+                    if(!group)
+                         return;
+
+                    Creature *unit = bot->GetNPCIfCanInteractWith(npcGUID, UNIT_NPC_FLAG_REPAIR);
+                    if (!unit) // Check if NPC can repair bot or not
+                    {
+                         sLog.outDebug("PlayerbotMgr: HandleRepairItemOpcode - Unit (GUID: %u) not found or you can't interact with him.", uint32(GUID_LOPART(npcGUID)));
+                         return;
+                    }
+
+                    // remove fake death
+                    if(bot->hasUnitState(UNIT_STAT_DIED))
+                         bot->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
+
+                    // reputation discount
+                    float discountMod = bot->GetReputationPriceDiscount(unit);
+
+                    uint32 TotalCost = 0;
+                    if (itemGUID) // Handle redundant feature (repair individual item) for bot
+                    {
+                         sLog.outDebug("ITEM: Repair single item is not applicable for %s",bot->GetName());
+                         continue;
+                    }
+                    else  // Handle feature (repair all items) for bot
+                    {
+                         sLog.outDebug("ITEM: Repair all items, npcGUID = %u", GUID_LOPART(npcGUID));
+
+                         TotalCost = bot->DurabilityRepairAll(true,discountMod,guildBank>0?true:false);
+                    }
+                    if (guildBank) // Handle guild repair
+                    {
+                         uint32 GuildId = bot->GetGuildId();
+                         if (!GuildId)
+                              return;
+                         Guild *pGuild = sObjectMgr.GetGuildById(GuildId);
+                         if (!pGuild)
+                              return;
+                         pGuild->LogBankEvent(GUILD_BANK_LOG_REPAIR_MONEY, 0, bot->GetGUIDLow(), TotalCost);
+                         pGuild->SendMoneyInfo(bot->GetSession(), bot->GetGUIDLow());
+                    }
+
+               }
+               return;
+        }
+        case CMSG_SPIRIT_HEALER_ACTIVATE:
+        {
+               // sLog.outDebug("SpiritHealer is resurrecting the Player %s",m_master->GetName());
+               for( PlayerBotMap::iterator itr=m_playerBots.begin(); itr!=m_playerBots.end(); ++itr )
+               {
+                    Player* const bot = itr->second;
+                    Group *grp = bot->GetGroup();
+                    if(grp)
+                       grp->RemoveMember(bot->GetGUID(),1);
+               }
+               return;
+        }
+
+        /*
+        case CMSG_NAME_QUERY:
+        case MSG_MOVE_START_FORWARD:
+        case MSG_MOVE_STOP:
+        case MSG_MOVE_SET_FACING:
+        case MSG_MOVE_START_STRAFE_LEFT:
+        case MSG_MOVE_START_STRAFE_RIGHT:
+        case MSG_MOVE_STOP_STRAFE:
+        case MSG_MOVE_START_BACKWARD:
+        case MSG_MOVE_HEARTBEAT:
+        case CMSG_STANDSTATECHANGE:
+        case CMSG_QUERY_TIME:
+        case CMSG_CREATURE_QUERY:
+        case CMSG_GAMEOBJECT_QUERY:
+        case MSG_MOVE_JUMP:
+        case MSG_MOVE_FALL_LAND:
+            return;
+
+        default:
+        {
+            const char* oc = LookupOpcodeName(packet.GetOpcode());
+            // ChatHandler ch(m_master);
+            // ch.SendSysMessage(oc);
+
+            std::ostringstream out;
+            out << "masterin: " << oc;
+            sLog.outError(out.str().c_str());
+        }
+        */
+    }
+}
+void PlayerbotMgr::HandleMasterOutgoingPacket(const WorldPacket& packet)
+{
+	/*
+    switch (packet.GetOpcode())
+    {
+        // maybe our bots should only start looting after the master loots?
+        //case SMSG_LOOT_RELEASE_RESPONSE: {}
+        case SMSG_NAME_QUERY_RESPONSE:
+        case SMSG_MONSTER_MOVE:
+        case SMSG_COMPRESSED_UPDATE_OBJECT:
+        case SMSG_DESTROY_OBJECT:
+        case SMSG_UPDATE_OBJECT:
+        case SMSG_STANDSTATE_UPDATE:
+        case MSG_MOVE_HEARTBEAT:
+        case SMSG_QUERY_TIME_RESPONSE:
+        case SMSG_AURA_UPDATE_ALL:
+        case SMSG_CREATURE_QUERY_RESPONSE:
+        case SMSG_GAMEOBJECT_QUERY_RESPONSE:
+            return;
+        default:
+        {
+            const char* oc = LookupOpcodeName(packet.GetOpcode());
+
+            std::ostringstream out;
+            out << "masterout: " << oc;
+            sLog.outError(out.str().c_str());
+        }
+    }
+       */
+}
+
+void PlayerbotMgr::LogoutAllBots()
+{
+    while (true)
+    {
+        PlayerBotMap::const_iterator itr = GetPlayerBotsBegin();
+        if (itr == GetPlayerBotsEnd()) break;
+        Player* bot= itr->second;
+        LogoutPlayerBot(bot->GetGUID());
+    }
+}
+
+
+
+void PlayerbotMgr::Stay()
+{
+    for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
+    {
+        Player* bot= itr->second;
+        bot->GetMotionMaster()->Clear();
+    }
+}
+
+
+// Playerbot mod: logs out a Playerbot.
+void PlayerbotMgr::LogoutPlayerBot(uint64 guid)
+{
+    Player* bot= GetPlayerBot(guid);
+    if (bot)
+    {
+        WorldSession * botWorldSessionPtr = bot->GetSession();
+        m_playerBots.erase(guid);    // deletes bot player ptr inside this WorldSession PlayerBotMap
+        botWorldSessionPtr->LogoutPlayer(true); // this will delete the bot Player object and PlayerbotAI object
+        delete botWorldSessionPtr;  // finally delete the bot's WorldSession
+    }
+}
+
+// Playerbot mod: Gets a player bot Player object for this WorldSession master
+Player* PlayerbotMgr::GetPlayerBot(uint64 playerGuid) const
+{
+    PlayerBotMap::const_iterator it = m_playerBots.find(playerGuid);
+    return (it == m_playerBots.end()) ? 0 : it->second;
+}
+
+void PlayerbotMgr::OnBotLogin(Player * const bot)
+{
+    // give the bot some AI, object is owned by the player class
+    PlayerbotAI* ai = new PlayerbotAI(this, bot);
+    bot->SetPlayerbotAI(ai);
+
+    // tell the world session that they now manage this new bot
+    m_playerBots[bot->GetGUID()] = bot;
+
+    // if bot is in a group and master is not in group then
+    // have bot leave their group
+    if (bot->GetGroup() &&
+        (m_master->GetGroup() == NULL ||
+         m_master->GetGroup()->IsMember(bot->GetGUID()) == false))
+         bot->RemoveFromGroup();
+
+    // sometimes master can lose leadership, pass leadership to master check
+    const uint64 masterGuid = m_master->GetGUID();
+    if (m_master->GetGroup() &&
+        ! m_master->GetGroup()->IsLeader(masterGuid))
+        m_master->GetGroup()->ChangeLeader(masterGuid);
+}
+
+void PlayerbotMgr::RemoveAllBotsFromGroup()
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); m_master->GetGroup() && it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->IsInSameGroupWith(m_master))
+            m_master->GetGroup()->RemoveMember(bot->GetGUID(), 0);
+    }
+}
+
+bool ChatHandler::HandlePlayerbotCommand(const char* args)
+{
+    if(!(m_session->GetSecurity() > SEC_PLAYER))
+        if(sConfig.GetBoolDefault("PlayerbotAI.DisableBots", false))
+        {
+            PSendSysMessage("|cffff0000Playerbot system is currently disabled!");
+            SetSentErrorMessage(true);
+            return false;
+        }
+
+    if (! m_session)
+    {
+        PSendSysMessage("|cffff0000You may only add bots from an active session");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (!*args)
+    {
+        PSendSysMessage("|cffff0000usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    char *cmd = strtok ((char*)args, " ");
+    char *charname = strtok (NULL, " ");
+    if (!cmd || !charname)
+    {
+        PSendSysMessage("|cffff0000usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    std::string cmdStr = cmd;
+    std::string charnameStr = charname;
+
+    if(!normalizePlayerName(charnameStr))
+        return false;
+
+    uint64 guid = sObjectMgr.GetPlayerGUIDByName(charnameStr.c_str());
+    if (guid == 0 || (guid == m_session->GetPlayer()->GetGUID()))
+    {
+        SendSysMessage(LANG_PLAYER_NOT_FOUND);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    uint32 accountId = sObjectMgr.GetPlayerAccountIdByGUID(guid);
+    if (accountId != m_session->GetAccountId())
+    {
+        PSendSysMessage("|cffff0000You may only add bots from the same account.");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // create the playerbot manager if it doesn't already exist
+    PlayerbotMgr* mgr = m_session->GetPlayer()->GetPlayerbotMgr();
+    if (!mgr)
+    {
+        mgr = new PlayerbotMgr(m_session->GetPlayer());
+        m_session->GetPlayer()->SetPlayerbotMgr(mgr);
+    }
+
+    QueryResult *resultchar = CharacterDatabase.PQuery("SELECT Count(*) FROM characters WHERE online = 1 AND account = '%u'", m_session->GetAccountId());
+    if(resultchar)
+    {
+        Field *fields=resultchar->Fetch();
+        int acctcharcount = fields[0].GetUInt32();
+        if(!(m_session->GetSecurity() > SEC_PLAYER))
+            if((acctcharcount > sConfig.GetIntDefault("PlayerbotAI.MaxNumBots", 9)) && (cmdStr == "add" || cmdStr == "login"))
+            {
+                PSendSysMessage("|cffff0000You cannot summon anymore bots, for this account.");
+                SetSentErrorMessage(true);
+                delete resultchar;
+                return false;
+            }
+    }
+    delete resultchar;
+
+    QueryResult *resultlvl = CharacterDatabase.PQuery("SELECT level,name FROM characters WHERE guid = '%u'", guid);
+    if(resultlvl)
+    {
+        Field *fields=resultlvl->Fetch();
+        int charlvl = fields[0].GetUInt32();
+        if(!(m_session->GetSecurity() > SEC_PLAYER))
+            if(charlvl > sConfig.GetIntDefault("PlayerbotAI.RestrictBotLevel", 80))
+            {
+                PSendSysMessage("|cffff0000You cannot summon |cffffffff[%s]|cffff0000, it's level is too high.",fields[1].GetString());
+                SetSentErrorMessage(true);
+                delete resultlvl;
+                return false;
+            }
+    }
+    delete resultlvl;
+    // end of gmconfig patch
+    if (cmdStr == "add" || cmdStr == "login")
+    {
+        if (mgr->GetPlayerBot(guid))
+        {
+            PSendSysMessage("Bot already exists in world.");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        CharacterDatabase.DirectPExecute("UPDATE characters SET online = 1 WHERE guid = '%u'", guid);
+        mgr->AddPlayerBot(guid);
+        PSendSysMessage("Bot added successfully.");
+    }
+    else if (cmdStr == "remove" || cmdStr == "logout")
+    {
+        if (! mgr->GetPlayerBot(guid))
+        {
+            PSendSysMessage("|cffff0000Bot can not be removed because bot does not exist in world.");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        CharacterDatabase.DirectPExecute("UPDATE characters SET online = 0 WHERE guid = '%u'", guid);
+        mgr->LogoutPlayerBot(guid);
+        PSendSysMessage("Bot removed successfully.");
+    }
+    else if (cmdStr == "co" || cmdStr == "combatorder")
+    {
+        Unit *target = 0;
+        char *orderChar = strtok( NULL, " " );
+        if(!orderChar)
+        {
+            PSendSysMessage("|cffff0000Syntax error:|cffffffff .bot co <botName> <order=reset|tank|assist|heal|protect> [targetPlayer]");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        std::string orderStr = orderChar;
+        if(orderStr == "protect" || orderStr == "assist")
+        {
+            char *targetChar = strtok( NULL, " " );
+            uint64 targetGUID = m_session->GetPlayer()->GetSelection();
+            if(!targetChar && !targetGUID)
+            {
+                PSendSysMessage("|cffff0000Combat orders protect and assist expect a target either by selection or by giving target player in command string!");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            std::string targetStr = targetChar;
+            if(targetChar)
+            {
+                targetGUID = sObjectMgr.GetPlayerGUIDByName( targetStr.c_str() );
+            }
+            target = ObjectAccessor::GetUnit( *m_session->GetPlayer(), targetGUID );
+            if(!target)
+            {
+                PSendSysMessage("|cffff0000Invalid target for combat order protect or assist!");
+                SetSentErrorMessage(true);
+                return false;
+            }
+        }
+        if (mgr->GetPlayerBot(guid) == NULL)
+        {
+            PSendSysMessage("|cffff0000Bot can not receive combat order because bot does not exist in world.");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        mgr->GetPlayerBot( guid )->GetPlayerbotAI()->SetCombatOrderByStr( orderStr, target );
+    }
+    return true;
+}
diff --git a/Core/src/game/PlayerbotMgr.h b/Core/src/game/PlayerbotMgr.h
new file mode 100644
index 0000000..b169023
--- /dev/null
+++ b/Core/src/game/PlayerbotMgr.h
@@ -0,0 +1,58 @@
+#ifndef _PLAYERBOTMGR_H
+#define _PLAYERBOTMGR_H
+
+#include "Common.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+class PlayerbotClassAI;
+
+typedef UNORDERED_MAP<uint64, Player*> PlayerBotMap;
+
+class MANGOS_DLL_SPEC PlayerbotMgr
+{
+    public:
+        PlayerbotMgr(Player* const master);
+        virtual ~PlayerbotMgr();
+
+        // This is called from Unit.cpp and is called every second (I think)
+        void UpdateAI(const uint32 p_time);
+
+        // This is called whenever the master sends a packet to the server.
+        // These packets can be viewed, but not edited.
+        // It allows bot creators to craft AI in response to a master's actions.
+        // For a list of opcodes that can be caught see Opcodes.cpp (CMSG_* opcodes only)
+        // Notice: that this is static which means it is called once for all bots of the master.
+        void HandleMasterIncomingPacket(const WorldPacket& packet);
+        void HandleMasterOutgoingPacket(const WorldPacket& packet);
+
+        void AddPlayerBot(uint64 guid);
+        void LogoutPlayerBot(uint64 guid);
+        Player* GetPlayerBot (uint64 guid) const;
+        Player* GetMaster() const { return m_master; };
+        PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return m_playerBots.begin(); }
+        PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return m_playerBots.end();   }
+
+        void LogoutAllBots();
+        void RemoveAllBotsFromGroup();
+        void OnBotLogin(Player * const bot);
+        void Stay();
+
+    public:
+        // config variables
+        uint32 m_confRestrictBotLevel;
+	uint32 m_confDisableBotsInRealm;
+	uint32 m_confMaxNumBots;
+        bool m_confDisableBots;
+        bool m_confDebugWhisper;
+        float m_confFollowDistance[2];
+
+    private:
+        Player* const m_master;
+        PlayerBotMap m_playerBots;
+};
+
+#endif
diff --git a/Core/src/game/PlayerbotPaladinAI.cpp b/Core/src/game/PlayerbotPaladinAI.cpp
new file mode 100644
index 0000000..399ecce
--- /dev/null
+++ b/Core/src/game/PlayerbotPaladinAI.cpp
@@ -0,0 +1,447 @@
+    /*
+    Name    : PlayerbotPaladinAI.cpp
+    Complete: maybe around 27% :D
+    Author  : Natsukawa
+    Version : 0.35
+    */
+
+#include "PlayerbotPaladinAI.h"
+#include "PlayerbotMgr.h"
+
+class PlayerbotAI;
+
+PlayerbotPaladinAI::PlayerbotPaladinAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+
+    RETRIBUTION_AURA             = ai->getSpellId("retribution aura");// Retribution
+    CRUSADER_AURA                = ai->getSpellId("crusader aura");
+    CRUSADER_STRIKE              = ai->getSpellId("crusader strike");
+    SEAL_OF_COMMAND              = ai->getSpellId("command");
+    JUDGEMENT_OF_LIGHT           = ai->getSpellId("judgement of light");
+    JUDGEMENT_OF_WISDOM          = ai->getSpellId("judgement of wisdom");
+    JUDGEMENT_OF_JUSTICE         = ai->getSpellId("judgement of justice");
+    DIVINE_STORM                 = ai->getSpellId("divine storm");
+    BLESSING_OF_MIGHT            = ai->getSpellId("blessing of might");
+    GREATER_BLESSING_OF_MIGHT    = ai->getSpellId("greater blessing of might");
+    HAMMER_OF_WRATH              = ai->getSpellId("hammer of wrath");
+    FLASH_OF_LIGHT               = ai->getSpellId("flash of light"); // Holy
+    HOLY_LIGHT                   = ai->getSpellId("holy light");
+    HOLY_SHOCK                   = ai->getSpellId("shock");
+    HOLY_WRATH                   = ai->getSpellId("wrath");
+    DIVINE_FAVOR                 = ai->getSpellId("divine favor");
+    CONCENTRATION_AURA           = ai->getSpellId("concentration aura");
+    BLESSING_OF_WISDOM           = ai->getSpellId("blessing of wisdom");
+    GREATER_BLESSING_OF_WISDOM   = ai->getSpellId("greater blessing of wisdom");
+    CONSECRATION                 = ai->getSpellId("consecration");
+    AVENGING_WRATH               = ai->getSpellId("avenging wrath");
+    LAY_ON_HANDS                 = ai->getSpellId("lay on hands");
+    EXORCISM                     = ai->getSpellId("exorcism");
+    SACRED_SHIELD                = ai->getSpellId("sacred shield");
+    DIVINE_PLEA                  = ai->getSpellId("divine plea");
+    BLESSING_OF_KINGS            = ai->getSpellId("blessing of kings"); // Protection
+    GREATER_BLESSING_OF_KINGS    = ai->getSpellId("greater blessing of kings");
+    GREATER_BLESSING_OF_SANCTUARY= ai->getSpellId("greater blessing of sanctuary");
+    HAMMER_OF_JUSTICE            = ai->getSpellId("hammer of justice");
+    RIGHTEOUS_FURY               = ai->getSpellId("righteous fury");
+    RIGHTEOUS_DEFENSE            = ai->getSpellId("righteous defense");
+    SHADOW_RESISTANCE_AURA       = ai->getSpellId("shadow resistance aura");
+    DEVOTION_AURA                = ai->getSpellId("devotion aura");
+    FIRE_RESISTANCE_AURA         = ai->getSpellId("fire resistance aura");
+    FROST_RESISTANCE_AURA        = ai->getSpellId("frost resistance aura");
+    HAND_OF_PROTECTION           = ai->getSpellId("hand of protection");
+    DIVINE_PROTECTION            = ai->getSpellId("divine protection");
+    DIVINE_INTERVENTION          = ai->getSpellId("divine intervention");
+    DIVINE_SACRIFICE             = ai->getSpellId("divine");
+    DIVINE_SHIELD                = ai->getSpellId("divine shield");
+    HOLY_SHIELD                  = ai->getSpellId("holy shield");
+    AVENGERS_SHIELD              = ai->getSpellId("avenger's shield");
+    HAND_OF_SACRIFICE            = ai->getSpellId("hand of sacrifice");
+    SHIELD_OF_RIGHTEOUSNESS      = ai->getSpellId("shield of righteousness");
+    DEFENSIVE_STANCE             = 71; //Def Stance
+    BERSERKER_STANCE             = 2458; //Ber Stance
+    BATTLE_STANCE                = 2457; //Bat Stance
+
+    FORBEARANCE                  = 25771; // cannot be protected
+
+    RECENTLY_BANDAGED            = 11196; // first aid check
+
+	// racial
+    ARCANE_TORRENT               = ai->getSpellId("arcane torrent"); // blood elf
+    GIFT_OF_THE_NAARU            = ai->getSpellId("gift of the naaru"); // draenei
+    STONEFORM                    = ai->getSpellId("stoneform"); // dwarf
+    EVERY_MAN_FOR_HIMSELF        = ai->getSpellId("every man for himself"); // human
+}
+
+PlayerbotPaladinAI::~PlayerbotPaladinAI() {}
+
+void PlayerbotPaladinAI::HealTarget(Unit &target, uint8 hp)
+{
+    PlayerbotAI* ai = GetAI();
+
+	if (hp < 40 && HOLY_LIGHT > 0 && ai->GetManaPercent() >= 34)
+        ai->CastSpell(HOLY_LIGHT, target);
+
+	if (hp < 35 && HOLY_SHOCK > 0 && ai->GetManaPercent() >= 21)
+        ai->CastSpell(HOLY_SHOCK, target);
+
+	if (hp < 30 && FLASH_OF_LIGHT > 0 && ai->GetManaPercent() >= 8)
+        ai->CastSpell(FLASH_OF_LIGHT, target);
+
+	if (hp < 25 && LAY_ON_HANDS > 0 && ai->GetHealthPercent() > 30 && ai->GetManaPercent() >= 8)
+        ai->CastSpell(LAY_ON_HANDS, target);
+
+} // end HealTarget
+
+void PlayerbotPaladinAI::DoNextCombatManeuver(Unit *pTarget)
+{
+	Unit* pVictim = pTarget->getVictim();
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (HAMMER_OF_JUSTICE > 0)
+                ai->CastSpell(HAMMER_OF_JUSTICE);
+            return;
+    }
+
+    // damage spells
+    ai->SetInFront( pTarget );
+    Player *m_bot = GetPlayerBot();
+    Group *m_group = m_bot->GetGroup();
+    float dist = m_bot->GetDistance( pTarget );
+    std::ostringstream out;
+
+    //Shield master if low hp.
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+
+    if (GetMaster()->isAlive())
+        if (masterHP < 25 && HAND_OF_PROTECTION > 0 && !GetMaster()->HasAura(FORBEARANCE, EFFECT_INDEX_0) && !GetMaster()->HasAura(HAND_OF_PROTECTION, EFFECT_INDEX_0) && !GetMaster()->HasAura(DIVINE_PROTECTION, EFFECT_INDEX_0) && !GetMaster()->HasAura(DIVINE_SHIELD, EFFECT_INDEX_0))
+              ai->CastSpell(HAND_OF_PROTECTION, *GetMaster());
+
+	// heal group inside combat, but do not heal if tank
+    if( m_group && pVictim != m_bot ) // possible tank
+    {
+        Group::MemberSlotList const& groupSlot = m_group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *m_groupMember = sObjectMgr.GetPlayer( itr->guid );
+            if( !m_groupMember || !m_groupMember->isAlive() )
+                continue;
+
+            uint32 memberHP = m_groupMember->GetHealth()*100 / m_groupMember->GetMaxHealth();
+            if( memberHP < 40 && ai->GetManaPercent() >= 40 ) // do not heal bots without plenty of mana for master & self
+                HealTarget( *m_groupMember, memberHP );
+        }
+    }
+
+	if (RIGHTEOUS_FURY > 0 && !m_bot->HasAura(RIGHTEOUS_FURY, EFFECT_INDEX_0))
+        ai->CastSpell (RIGHTEOUS_FURY, *m_bot);
+
+    if (SHADOW_RESISTANCE_AURA > 0 && !m_bot->HasAura(SHADOW_RESISTANCE_AURA, EFFECT_INDEX_0) && pTarget->getClass() == CLASS_WARLOCK)
+        ai->CastSpell (SHADOW_RESISTANCE_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA, EFFECT_INDEX_0) && pTarget->getClass() == CLASS_WARRIOR)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (FIRE_RESISTANCE_AURA > 0 && !m_bot->HasAura(FIRE_RESISTANCE_AURA, EFFECT_INDEX_0) && pTarget->getClass() == CLASS_MAGE)
+        ai->CastSpell (FIRE_RESISTANCE_AURA, *m_bot);
+
+    if (RETRIBUTION_AURA > 0 && !m_bot->HasAura(RETRIBUTION_AURA, EFFECT_INDEX_0) && pTarget->getClass() == CLASS_PRIEST)
+        ai->CastSpell (RETRIBUTION_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA, EFFECT_INDEX_0) && pTarget->getClass() == CLASS_SHAMAN)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA, EFFECT_INDEX_0) && pTarget->getClass() == CLASS_ROGUE)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA, EFFECT_INDEX_0) && pTarget->getClass() == CLASS_PALADIN)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (ai->GetHealthPercent() <= 40 || GetMaster()->GetHealth() <= GetMaster()->GetMaxHealth()*0.4)
+        SpellSequence = Healing;
+    else
+        SpellSequence = Combat;
+
+    switch (SpellSequence)
+    {
+        case Combat:
+            if (JUDGEMENT_OF_LIGHT > 0 && !pTarget->HasAura(JUDGEMENT_OF_LIGHT, EFFECT_INDEX_0) && CombatCounter < 1 && ai->GetManaPercent() >=5)
+            {
+                ai->CastSpell (JUDGEMENT_OF_LIGHT, *pTarget);
+                out << " Judgement of Light";
+                CombatCounter++;
+                break;
+            }
+            else if (SEAL_OF_COMMAND > 0 && !m_bot->HasAura(SEAL_OF_COMMAND, EFFECT_INDEX_0) && CombatCounter < 2 && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell (SEAL_OF_COMMAND, *m_bot);
+                out << " Seal of Command";
+                CombatCounter++;
+                break;
+            }
+            else if (HAMMER_OF_JUSTICE > 0 && !pTarget->HasAura(HAMMER_OF_JUSTICE, EFFECT_INDEX_0) && CombatCounter < 3 && ai->GetManaPercent() >=3)
+            {
+                ai->CastSpell (HAMMER_OF_JUSTICE, *pTarget);
+                out << " Hammer of Justice";
+                CombatCounter++;
+                break;
+            }
+            else if (CRUSADER_STRIKE > 0 && CombatCounter < 4 && ai->GetManaPercent() >=5)
+            {
+                ai->CastSpell (CRUSADER_STRIKE, *pTarget);
+                out << " Crusader Strike";
+                CombatCounter++;
+                break;
+            }
+            else if (AVENGING_WRATH > 0 && CombatCounter < 5 && !m_bot->HasAura(AVENGING_WRATH, EFFECT_INDEX_0) && ai->GetManaPercent() >=8)
+            {
+                ai->CastSpell (AVENGING_WRATH, *m_bot);
+                out << " Avenging Wrath";
+                CombatCounter++;
+                break;
+            }
+            else if (SACRED_SHIELD > 0 && CombatCounter < 6 && pVictim == m_bot && ai->GetHealthPercent() < 70 && !m_bot->HasAura(SACRED_SHIELD, EFFECT_INDEX_0) && ai->GetManaPercent() >=12)
+            {
+                ai->CastSpell (SACRED_SHIELD, *m_bot);
+                out << " Sacred Shield";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_STORM > 0 && CombatCounter < 7 && ai->GetAttackerCount()>=3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >=12)
+            {
+                ai->CastSpell (DIVINE_STORM, *pTarget);
+                out << " Divine Storm";
+                CombatCounter++;
+                break;
+            }
+            else if (HAMMER_OF_WRATH > 0 && CombatCounter < 8 && pTarget->GetHealth() < pTarget->GetMaxHealth()*0.20 && ai->GetManaPercent() >=14)
+            {
+                ai->CastSpell (HAMMER_OF_WRATH, *pTarget);
+                out << " Hammer of Wrath";
+                CombatCounter++;
+                break;
+            }
+            else if (HOLY_WRATH > 0 && CombatCounter < 9 && ai->GetAttackerCount()>=3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >=24)
+            {
+                ai->CastSpell (HOLY_WRATH, *pTarget);
+                out << " Holy Wrath";
+                CombatCounter++;
+                break;
+            }
+            else if (HAND_OF_SACRIFICE > 0 && pVictim == GetMaster() && !GetMaster()->HasAura(HAND_OF_SACRIFICE, EFFECT_INDEX_0) && CombatCounter < 10 && ai->GetManaPercent() >=6)
+            {
+                ai->CastSpell (HAND_OF_SACRIFICE, *GetMaster());
+                out << " Hand of Sacrifice";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_PROTECTION > 0 && pVictim == m_bot && !m_bot->HasAura(FORBEARANCE, EFFECT_INDEX_0) && ai->GetHealthPercent() < 30 && CombatCounter < 11 && ai->GetManaPercent() >=3)
+            {
+                ai->CastSpell (DIVINE_PROTECTION, *m_bot);
+                out << " Divine Protection";
+                CombatCounter++;
+                break;
+            }
+            else if (RIGHTEOUS_DEFENSE > 0 && pVictim != m_bot && ai->GetHealthPercent() > 70 && CombatCounter < 12)
+            {
+                ai->CastSpell (RIGHTEOUS_DEFENSE, *pTarget);
+                out << " Righteous Defense";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_PLEA > 0 && !m_bot->HasAura(DIVINE_PLEA, EFFECT_INDEX_0) && ai->GetManaPercent() < 50 && CombatCounter < 13)
+            {
+                ai->CastSpell (DIVINE_PLEA, *m_bot);
+                out << " Divine Plea";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_FAVOR > 0 && !m_bot->HasAura(DIVINE_FAVOR, EFFECT_INDEX_0) && CombatCounter < 14)
+            {
+                ai->CastSpell (DIVINE_FAVOR, *m_bot);
+                out << " Divine Favor";
+                CombatCounter++;
+                break;
+            }
+            else if (CombatCounter > 15)
+            {
+                CombatCounter = 0;
+                //ai->TellMaster("CombatCounter Reset");
+                break;
+            }
+            else
+            {
+                CombatCounter = 0;
+                //ai->TellMaster("Counter = 0");
+                break;
+            }
+
+        case Healing:
+            if (ai->GetHealthPercent() <= 40)
+            {
+                HealTarget (*m_bot, ai->GetHealthPercent());
+                out << " ...healing bot";
+                break;
+            }
+            if (masterHP <= 40)
+            {
+                HealTarget (*GetMaster(), masterHP);
+                out << " ...healing master";
+                break;
+            }
+            else
+            {
+                CombatCounter = 0;
+                //ai->TellMaster("Counter = 0");
+                break;
+            }
+    }
+    if( ai->GetManager()->m_confDebugWhisper )
+        ai->TellMaster( out.str().c_str() );
+
+    if (AVENGING_WRATH > 0 && !m_bot->HasAura(AVENGING_WRATH, EFFECT_INDEX_0) && ai->GetManaPercent() >= 8)
+        ai->CastSpell(AVENGING_WRATH, *m_bot);
+
+    if (DIVINE_SHIELD > 0 && ai->GetHealthPercent() < 30 && pVictim == m_bot && !m_bot->HasAura(FORBEARANCE, EFFECT_INDEX_0) && !m_bot->HasAura(DIVINE_SHIELD, EFFECT_INDEX_0) && ai->GetManaPercent() >= 3)
+        ai->CastSpell(DIVINE_SHIELD, *m_bot);
+
+    if (DIVINE_SACRIFICE > 0 && ai->GetHealthPercent() > 50 && pVictim != m_bot && !m_bot->HasAura(DIVINE_SACRIFICE, EFFECT_INDEX_0))
+        ai->CastSpell(DIVINE_SACRIFICE, *m_bot);
+}
+
+void PlayerbotPaladinAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // buff myself
+	if (GREATER_BLESSING_OF_MIGHT > 0 && !m_bot->HasAura(GREATER_BLESSING_OF_MIGHT, EFFECT_INDEX_0))
+        ai->CastSpell (GREATER_BLESSING_OF_MIGHT, *m_bot);
+    else if (BLESSING_OF_MIGHT > 0 && !m_bot->HasAura(GREATER_BLESSING_OF_MIGHT, EFFECT_INDEX_0) && !m_bot->HasAura(BLESSING_OF_MIGHT, EFFECT_INDEX_0))
+        ai->CastSpell (BLESSING_OF_MIGHT, *m_bot);
+
+    if (DIVINE_FAVOR > 0 && !m_bot->HasAura(DIVINE_FAVOR, EFFECT_INDEX_0) && ai->GetManaPercent() >= 3)
+        ai->CastSpell(DIVINE_FAVOR , *m_bot);
+/*
+    if (SEAL_OF_COMMAND > 0)
+        ai->CastSpell (SEAL_OF_COMMAND, *m_bot); // interferes with drinking/eating
+*/
+    //Select Class buff seq.
+    ///Process Who is my master --> get the player class --> aura already present if not then proced --> cast the spell
+    //Priest
+    if (BLESSING_OF_WISDOM > 0 && GetMaster()->getClass() == CLASS_PRIEST && !GetMaster()->HasAura(GREATER_BLESSING_OF_WISDOM, EFFECT_INDEX_0) && !GetMaster()->HasAura(BLESSING_OF_WISDOM, EFFECT_INDEX_0))
+        ai->CastSpell (BLESSING_OF_WISDOM, *(GetMaster()));
+
+    if (GREATER_BLESSING_OF_WISDOM > 0 && GetMaster()->getClass() == CLASS_PRIEST && !GetMaster()->HasAura(GREATER_BLESSING_OF_WISDOM, EFFECT_INDEX_0))
+        ai->CastSpell (GREATER_BLESSING_OF_WISDOM, *(GetMaster()));
+
+    //Mage
+    if (BLESSING_OF_WISDOM > 0 && GetMaster()->getClass() == CLASS_MAGE && !GetMaster()->HasAura(GREATER_BLESSING_OF_WISDOM, EFFECT_INDEX_0) && !GetMaster()->HasAura(BLESSING_OF_WISDOM, EFFECT_INDEX_0))
+        ai->CastSpell (BLESSING_OF_WISDOM, *(GetMaster()));
+
+    if (GREATER_BLESSING_OF_WISDOM > 0 && GetMaster()->getClass() == CLASS_MAGE && !GetMaster()->HasAura(GREATER_BLESSING_OF_WISDOM, EFFECT_INDEX_0))
+        ai->CastSpell (GREATER_BLESSING_OF_WISDOM, *(GetMaster()));
+
+    //Paladin
+    if (BLESSING_OF_WISDOM > 0 && GetMaster()->getClass() == CLASS_PALADIN && !GetMaster()->HasAura(GREATER_BLESSING_OF_WISDOM, EFFECT_INDEX_0) && !GetMaster()->HasAura(BLESSING_OF_WISDOM, EFFECT_INDEX_0))
+        ai->CastSpell (BLESSING_OF_WISDOM, *(GetMaster()));
+
+    if (GREATER_BLESSING_OF_WISDOM > 0 && GetMaster()->getClass() == CLASS_PALADIN && !GetMaster()->HasAura(GREATER_BLESSING_OF_WISDOM, EFFECT_INDEX_0))
+        ai->CastSpell (GREATER_BLESSING_OF_WISDOM, *(GetMaster()));
+
+    //Warlock
+    if (BLESSING_OF_WISDOM > 0 && GetMaster()->getClass() == CLASS_WARLOCK && !GetMaster()->HasAura(GREATER_BLESSING_OF_WISDOM, EFFECT_INDEX_0) && !GetMaster()->HasAura(BLESSING_OF_WISDOM, EFFECT_INDEX_0))
+        ai->CastSpell (BLESSING_OF_WISDOM, *(GetMaster()));
+
+    if (GREATER_BLESSING_OF_WISDOM > 0 && GetMaster()->getClass() == CLASS_WARLOCK && !GetMaster()->HasAura(GREATER_BLESSING_OF_WISDOM, EFFECT_INDEX_0))
+        ai->CastSpell (GREATER_BLESSING_OF_WISDOM, *(GetMaster()));
+
+    //Warrior
+    if (BLESSING_OF_MIGHT > 0 && GetMaster()->getClass() == CLASS_WARRIOR && !GetMaster()->HasAura(GREATER_BLESSING_OF_MIGHT, EFFECT_INDEX_0) && !GetMaster()->HasAura(BLESSING_OF_MIGHT, EFFECT_INDEX_0) && !GetMaster()->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0))
+        ai->CastSpell (BLESSING_OF_MIGHT, *(GetMaster()));
+
+    if (GREATER_BLESSING_OF_MIGHT > 0 && GetMaster()->getClass() == CLASS_WARRIOR && !GetMaster()->HasAura(GREATER_BLESSING_OF_MIGHT, EFFECT_INDEX_0) && !GetMaster()->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0))
+        ai->CastSpell (GREATER_BLESSING_OF_MIGHT, *(GetMaster()));
+
+    if (BLESSING_OF_KINGS > 0 && GetMaster()->getClass() == CLASS_WARRIOR && !GetMaster()->HasAura(GREATER_BLESSING_OF_KINGS, EFFECT_INDEX_0) && !GetMaster()->HasAura(BLESSING_OF_KINGS, EFFECT_INDEX_0) && !GetMaster()->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0) && !GetMaster()->HasAura(BATTLE_STANCE, EFFECT_INDEX_0))
+        ai->CastSpell (BLESSING_OF_KINGS, *(GetMaster()));
+
+    if (GREATER_BLESSING_OF_KINGS > 0 && GetMaster()->getClass() == CLASS_WARRIOR && !GetMaster()->HasAura(GREATER_BLESSING_OF_KINGS, EFFECT_INDEX_0) && !GetMaster()->HasAura(BERSERKER_STANCE, EFFECT_INDEX_0) && !GetMaster()->HasAura(BATTLE_STANCE, EFFECT_INDEX_0))
+        ai->CastSpell (GREATER_BLESSING_OF_KINGS, *(GetMaster()));
+
+    //Rogue
+    if (BLESSING_OF_MIGHT > 0 && GetMaster()->getClass() == CLASS_ROGUE && !GetMaster()->HasAura(GREATER_BLESSING_OF_MIGHT, EFFECT_INDEX_0) && !GetMaster()->HasAura(BLESSING_OF_MIGHT, EFFECT_INDEX_0))
+        ai->CastSpell (BLESSING_OF_MIGHT, *(GetMaster()));
+
+    if (GREATER_BLESSING_OF_MIGHT > 0 && GetMaster()->getClass() == CLASS_ROGUE && !GetMaster()->HasAura(GREATER_BLESSING_OF_MIGHT, EFFECT_INDEX_0))
+        ai->CastSpell (GREATER_BLESSING_OF_MIGHT, *(GetMaster()));
+
+    //Shaman
+    if (BLESSING_OF_MIGHT > 0 && GetMaster()->getClass() == CLASS_SHAMAN && !GetMaster()->HasAura(GREATER_BLESSING_OF_MIGHT, EFFECT_INDEX_0) && !GetMaster()->HasAura(BLESSING_OF_MIGHT, EFFECT_INDEX_0))
+        ai->CastSpell (BLESSING_OF_MIGHT, *(GetMaster()));
+
+    if (GREATER_BLESSING_OF_MIGHT > 0 && GetMaster()->getClass() == CLASS_SHAMAN && !GetMaster()->HasAura(GREATER_BLESSING_OF_MIGHT, EFFECT_INDEX_0))
+        ai->CastSpell (GREATER_BLESSING_OF_MIGHT, *(GetMaster()));
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+	Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 40)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+
+    // hp check original
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 40)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, EFFECT_INDEX_0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(*fItem);
+        ai->SetIgnoreUpdateTime(8);
+        return;
+    }
+
+    // heal group
+    if (GetMaster()->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = sObjectMgr.GetPlayer(uint64 (itr->guid));
+            if( !tPlayer || !tPlayer->isAlive() )
+                continue;
+
+             // heal player
+             (HealTarget(*tPlayer, tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth()));
+        }
+    }
+}
+
+void PlayerbotPaladinAI::BuffPlayer(Player* target)
+{
+    GetAI()->CastSpell(BLESSING_OF_MIGHT, *target);
+}
diff --git a/Core/src/game/PlayerbotPaladinAI.h b/Core/src/game/PlayerbotPaladinAI.h
new file mode 100644
index 0000000..74a3a88
--- /dev/null
+++ b/Core/src/game/PlayerbotPaladinAI.h
@@ -0,0 +1,55 @@
+#ifndef _PlayerbotPaladinAI_H
+#define _PlayerbotPaladinAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    Combat,
+    Healing
+};
+
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotPaladinAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotPaladinAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
+        virtual ~PlayerbotPaladinAI();
+
+        // all combat actions go here
+        void DoNextCombatManeuver(Unit*);
+
+        // all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        // buff a specific player, usually a real PC who is not in group
+        void BuffPlayer(Player *target);
+
+    private:
+        // Heals the target based off its hps
+        void HealTarget (Unit& target, uint8 hp);
+
+        // Retribution
+        uint32 RETRIBUTION_AURA, SEAL_OF_COMMAND, JUDGEMENT_OF_LIGHT, JUDGEMENT_OF_WISDOM, GREATER_BLESSING_OF_WISDOM, GREATER_BLESSING_OF_MIGHT, BLESSING_OF_WISDOM, BLESSING_OF_MIGHT, HAMMER_OF_JUSTICE, RIGHTEOUS_FURY, CRUSADER_AURA, CRUSADER_STRIKE, AVENGING_WRATH, DIVINE_STORM, JUDGEMENT_OF_JUSTICE;
+
+        // Holy
+        uint32 FLASH_OF_LIGHT, HOLY_LIGHT, DIVINE_SHIELD, HAMMER_OF_WRATH, CONSECRATION, CONCENTRATION_AURA, DIVINE_FAVOR, SACRED_SHIELD, HOLY_SHOCK, HOLY_WRATH, LAY_ON_HANDS, EXORCISM, DIVINE_PLEA;
+
+        // Protection
+        uint32 GREATER_BLESSING_OF_KINGS, BLESSING_OF_KINGS, HAND_OF_PROTECTION, SHADOW_RESISTANCE_AURA, DEVOTION_AURA, FIRE_RESISTANCE_AURA, FROST_RESISTANCE_AURA, DEFENSIVE_STANCE, BERSERKER_STANCE, BATTLE_STANCE, DIVINE_SACRIFICE, DIVINE_PROTECTION, DIVINE_INTERVENTION, HOLY_SHIELD, AVENGERS_SHIELD, RIGHTEOUS_DEFENSE, GREATER_BLESSING_OF_SANCTUARY, HAND_OF_SACRIFICE, SHIELD_OF_RIGHTEOUSNESS;
+
+        // cannot be protected
+        uint32 FORBEARANCE;
+
+        // first aid
+        uint32 RECENTLY_BANDAGED;
+
+        // racial
+        uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+        uint32 SpellSequence, CombatCounter, HealCounter;
+};
+
+#endif
+
diff --git a/Core/src/game/PlayerbotPriestAI.cpp b/Core/src/game/PlayerbotPriestAI.cpp
new file mode 100644
index 0000000..fe24037
--- /dev/null
+++ b/Core/src/game/PlayerbotPriestAI.cpp
@@ -0,0 +1,474 @@
+
+#include "PlayerbotPriestAI.h"
+
+class PlayerbotAI;
+
+PlayerbotPriestAI::PlayerbotPriestAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    RENEW              = ai->getSpellId("renew");
+    if((HEAL = ai->getSpellId ("greater heal"))>0)
+        HEAL           = ai->getSpellId("greater heal");
+    else if((HEAL = ai->getSpellId ("heal"))>0 && (HEAL = ai->getSpellId ("greater heal"))==0)
+        HEAL           = ai->getSpellId("heal");
+    else if((HEAL = ai->getSpellId ("greater heal"))==0 && (HEAL = ai->getSpellId ("heal"))==0)
+        HEAL           = ai->getSpellId("lesser heal");
+
+    GREAT_HEAL         = ai->getSpellId("great heal");
+    FLASH_HEAL         = ai->getSpellId("flash heal");
+    REZZ               = ai->getSpellId("resurrection");
+    SMITE              = ai->getSpellId("smite");
+    MANA_BURN          = ai->getSpellId("mana burn");
+    HOLY_NOVA          = ai->getSpellId("holy nova");
+    HOLY_FIRE          = ai->getSpellId("holy fire");
+    DESPERATE_PRAYER   = ai->getSpellId("desperate prayer");
+    PRAYER_OF_HEALING  = ai->getSpellId("prayer of healing");
+    CIRCLE_OF_HEALING  = ai->getSpellId("circle of healing");
+    BINDING_HEAL       = ai->getSpellId("binding heal");
+    PRAYER_OF_MENDING  = ai->getSpellId("prayer of mending");
+    //SHADOWMAGIC
+    FADE               = ai->getSpellId("fade");
+    PAIN               = ai->getSpellId("shadow word: pain");
+    MIND_BLAST         = ai->getSpellId("mind blast");
+    SCREAM             = ai->getSpellId("psychic scream");
+    MIND_FLAY          = ai->getSpellId("mind flay");
+    DEVOURING_PLAGUE   = ai->getSpellId("devouring plague");
+    SHADOW_PROTECTION  = ai->getSpellId("shadow protection");
+    VAMPIRIC_TOUCH     = ai->getSpellId("vampiric touch");
+    PRAYER_OF_SHADOW_PROTECTION = ai->getSpellId("prayer of shadow protection");
+    SHADOWFIEND        = ai->getSpellId("shadowfiend");
+    MIND_SEAR          = ai->getSpellId("mind sear");
+    //DISCIPLINE
+    PENANCE         = ai->getSpellId("penance");
+    INNER_FIRE         = ai->getSpellId("inner fire");
+    PWS                = ai->getSpellId("power word: shield");
+    if((FORTITUDE = ai->getSpellId ("prayer of fortitude"))>0)
+        FORTITUDE      = ai->getSpellId("prayer of fortitude");
+    if((FORTITUDE = ai->getSpellId ("power word: fortitude"))>0 && (FORTITUDE = ai->getSpellId ("prayer of fortitude"))==0)
+        FORTITUDE      = ai->getSpellId("power word: fortitude");
+
+    FEAR_WARD          = ai->getSpellId("fear ward");
+    if((DSPIRIT = ai->getSpellId ("prayer of spirit"))>0)
+        DSPIRIT        = ai->getSpellId("prayer of spirit");
+    if((DSPIRIT = ai->getSpellId ("divine spirit"))>0 && (DSPIRIT = ai->getSpellId ("prayer of spirit"))==0)
+        DSPIRIT        = ai->getSpellId("divine spirit");
+
+    MASS_DISPEL        = ai->getSpellId("mass dispel");
+    POWER_INFUSION     = ai->getSpellId("power infusion");
+    DIVINE_SPIRIT      = ai->getSpellId("divine spirit");
+    INNER_FOCUS        = ai->getSpellId("inner focus");
+
+    RECENTLY_BANDAGED  = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT          = ai->getSpellId("arcane torrent"); // blood elf
+    GIFT_OF_THE_NAARU       = ai->getSpellId("gift of the naaru"); // draenei
+    STONEFORM               = ai->getSpellId("stoneform"); // dwarf
+    EVERY_MAN_FOR_HIMSELF   = ai->getSpellId("every man for himself"); // human
+    SHADOWMELD              = ai->getSpellId("shadowmeld"); // night elf
+    BERSERKING              = ai->getSpellId("berserking"); // troll
+    WILL_OF_THE_FORSAKEN    = ai->getSpellId("will of the forsaken"); // undead
+}
+
+PlayerbotPriestAI::~PlayerbotPriestAI() {}
+
+void PlayerbotPriestAI::HealTarget(Unit &target, uint8 hp)
+{
+    PlayerbotAI* ai = GetAI();
+
+//    return ((hp < 80 && !target.HasAura(RENEW, EFFECT_INDEX_0) &&  ai->CastSpell(RENEW, target)) ||
+//        (hp < 60 && ai->CastSpell(HEAL, target)) ||
+//        (hp < 30 && ai->CastSpell(FLASH_HEAL, target)) );
+
+    if (hp < 25 && FLASH_HEAL > 0 && ai->GetManaPercent() >= 20)
+    {
+        ai->TellMaster("I'm casting flash heal.");
+        ai->CastSpell(FLASH_HEAL, target);
+    }
+    else if (hp < 30 && GREAT_HEAL > 0 && ai->GetManaPercent() >= 36)
+    {
+        ai->TellMaster("I'm casting one of the sorted heal spells.");
+        ai->CastSpell(GREAT_HEAL, target);
+    }
+    else if (hp < 33 && BINDING_HEAL > 0 && ai->GetManaPercent() >= 27)
+    {
+        ai->TellMaster("I'm casting binding heal.");
+        ai->CastSpell(BINDING_HEAL, target);
+    }
+    else if (hp < 40 && PRAYER_OF_HEALING > 0 && ai->GetManaPercent() >= 54)
+    {
+        ai->TellMaster("I'm casting prayer of healing.");
+        ai->CastSpell(PRAYER_OF_HEALING, target);
+    }
+    else if (hp < 50 && CIRCLE_OF_HEALING > 0 && ai->GetManaPercent() >= 24)
+    {
+        ai->TellMaster("I'm casting circle of healing.");
+        ai->CastSpell(CIRCLE_OF_HEALING, target);
+    }
+    else if (hp < 60 && HEAL > 0 && ai->GetManaPercent() >= 36)
+    {
+        ai->TellMaster("I'm casting one of the sorted heal spells.");
+        ai->CastSpell(HEAL, target);
+    }
+    else if (hp < 80 && RENEW > 0 && ai->GetManaPercent() >= 19)
+    {
+        //ai->TellMaster("I'm casting renew.");
+        ai->CastSpell(RENEW, target);
+    }
+
+} // end HealTarget
+
+void PlayerbotPriestAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    Unit* pVictim = pTarget->getVictim();
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            (ai->HasAura(SCREAM,*pTarget) && ai->GetHealthPercent() < 60 && ai->CastSpell(HEAL)) ||
+                ai->CastSpell(PAIN) ||
+                (ai->GetHealthPercent() < 80 && ai->CastSpell(RENEW)) ||
+                (ai->GetPlayerBot()->GetDistance(pTarget) <= 5 && ai->CastSpell(SCREAM)) ||
+                ai->CastSpell(MIND_BLAST) ||
+                (ai->GetHealthPercent() < 20 && ai->CastSpell(GREAT_HEAL)) ||
+                ai->CastSpell(SMITE);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    ai->SetMovementOrder( PlayerbotAI::MOVEMENT_FOLLOW, GetMaster() ); // dont want to melee mob
+
+    Player *m_bot = GetPlayerBot();
+    Group *m_group = m_bot->GetGroup();
+
+    // Heal myself
+    if (ai->GetHealthPercent() < 15 && FADE > 0 && !m_bot->HasAura(FADE, EFFECT_INDEX_0))
+    {
+        ai->TellMaster("I'm casting fade.");
+        ai->CastSpell(FADE, *m_bot);
+    }
+    else if (ai->GetHealthPercent() < 25 && PWS > 0 && !m_bot->HasAura(PWS, EFFECT_INDEX_0))
+    {
+        ai->TellMaster("I'm casting pws on myself.");
+        ai->CastSpell(PWS);
+    }
+    else if (ai->GetHealthPercent() < 35 && DESPERATE_PRAYER > 0)
+    {
+        ai->TellMaster("I'm casting desperate prayer.");
+        ai->CastSpell(DESPERATE_PRAYER, *m_bot);
+    }
+    else if (ai->GetHealthPercent() < 80)
+        HealTarget (*m_bot, ai->GetHealthPercent());
+
+    // Heal master
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    if (GetMaster()->isAlive())
+    {
+        if (masterHP < 25 && PWS > 0 && !GetMaster()->HasAura(PWS, EFFECT_INDEX_0))
+                ai->CastSpell(PWS, *(GetMaster()));
+        else if (masterHP < 80)
+            HealTarget (*GetMaster(), masterHP);
+    }
+
+    // Heal group
+    if( m_group )
+    {
+        Group::MemberSlotList const& groupSlot = m_group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *m_groupMember = sObjectMgr.GetPlayer( itr->guid );
+            if( !m_groupMember || !m_groupMember->isAlive() )
+                continue;
+
+            uint32 memberHP = m_groupMember->GetHealth()*100 / m_groupMember->GetMaxHealth();
+            if( memberHP < 25 )
+                HealTarget( *m_groupMember, memberHP );
+        }
+    }
+
+    // Damage Spells
+    ai->SetInFront( pTarget );
+	float dist = m_bot->GetDistance( pTarget );
+
+    switch (SpellSequence)
+    {
+        case SPELL_HOLY:
+            if (SMITE > 0 && LastSpellHoly <1 && !pTarget->HasAura(SMITE, EFFECT_INDEX_0) && ai->GetManaPercent() >= 17)
+            {
+                ai->CastSpell(SMITE, *pTarget);
+                SpellSequence = SPELL_SHADOWMAGIC;
+                LastSpellHoly = LastSpellHoly +1;
+                break;
+            }
+            else if (MANA_BURN > 0 && LastSpellHoly <2 && pTarget->GetPower(POWER_MANA) > 0 && ai->GetManaPercent() < 70 && ai->GetManaPercent() >= 14)
+            {
+                //ai->TellMaster("I'm casting mana burn.");
+                ai->CastSpell(MANA_BURN, *pTarget);
+                ai->SetIgnoreUpdateTime(3);
+                SpellSequence = SPELL_SHADOWMAGIC;
+                LastSpellHoly = LastSpellHoly +1;
+                break;
+            }
+            else if (HOLY_NOVA > 0 && LastSpellHoly <3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 22)
+            {
+                //ai->TellMaster("I'm casting holy nova.");
+                ai->CastSpell(HOLY_NOVA);
+                SpellSequence = SPELL_SHADOWMAGIC;
+                LastSpellHoly = LastSpellHoly +1;
+                break;
+             }
+             else if (HOLY_FIRE > 0 && LastSpellHoly <4 && !pTarget->HasAura(HOLY_FIRE, EFFECT_INDEX_0) && ai->GetManaPercent() >= 13)
+             {
+                 //ai->TellMaster("I'm casting holy fire.");
+                 ai->CastSpell(HOLY_FIRE, *pTarget);
+                 SpellSequence = SPELL_SHADOWMAGIC;
+                 LastSpellHoly = LastSpellHoly +1;
+                 break;
+             }
+             else if (PRAYER_OF_MENDING > 0 && LastSpellHoly <5 && pVictim == GetMaster() && GetMaster()->GetHealth() <= GetMaster()->GetMaxHealth()*0.7 && !GetMaster()->HasAura(PRAYER_OF_MENDING, EFFECT_INDEX_0) && ai->GetManaPercent() >= 15)
+             {
+                 //ai->TellMaster("I'm casting prayer of mending on master.");
+                 ai->CastSpell(PRAYER_OF_MENDING, *GetMaster());
+                 SpellSequence = SPELL_SHADOWMAGIC;
+                 LastSpellHoly = LastSpellHoly +1;
+                 break;
+             }
+             else if (LastSpellHoly > 6)
+             {
+                 LastSpellHoly = 0;
+                 SpellSequence = SPELL_SHADOWMAGIC;
+                 break;
+             }
+             LastSpellHoly = LastSpellHoly + 1;
+             //SpellSequence = SPELL_SHADOWMAGIC;
+             //break;
+
+        case SPELL_SHADOWMAGIC:
+            if (PAIN > 0 && LastSpellShadowMagic <1 && !pTarget->HasAura(PAIN, EFFECT_INDEX_0) && ai->GetManaPercent() >= 25)
+            {
+                //ai->TellMaster("I'm casting pain.");
+                ai->CastSpell(PAIN, *pTarget);
+                SpellSequence = SPELL_DISCIPLINE;
+                LastSpellShadowMagic = LastSpellShadowMagic +1;
+                break;
+            }
+            else if (MIND_BLAST > 0 && LastSpellShadowMagic <2 && ai->GetManaPercent() >= 19)
+            {
+                //ai->TellMaster("I'm casting mind blast.");
+                ai->CastSpell(MIND_BLAST, *pTarget);
+                SpellSequence = SPELL_DISCIPLINE;
+                LastSpellShadowMagic = LastSpellShadowMagic +1;
+                break;
+            }
+           else if (SCREAM > 0 && LastSpellShadowMagic <3 && ai->GetAttackerCount()>=3 && ai->GetManaPercent() >= 15)
+            {
+                ai->TellMaster("I'm casting scream.");
+                ai->CastSpell(SCREAM);
+                SpellSequence = SPELL_DISCIPLINE;
+                (LastSpellShadowMagic = LastSpellShadowMagic +1);
+                break;
+            }
+
+            else if (MIND_FLAY > 0 && LastSpellShadowMagic <4 && !pTarget->HasAura(MIND_FLAY, EFFECT_INDEX_0) && ai->GetManaPercent() >= 10)
+            {
+                //ai->TellMaster("I'm casting mind flay.");
+                ai->CastSpell(MIND_FLAY, *pTarget);
+                ai->SetIgnoreUpdateTime(3);
+                SpellSequence = SPELL_DISCIPLINE;
+                LastSpellShadowMagic = LastSpellShadowMagic +1;
+                break;
+            }
+            else if (DEVOURING_PLAGUE > 0 && LastSpellShadowMagic <5 && !pTarget->HasAura(DEVOURING_PLAGUE, EFFECT_INDEX_0) && ai->GetManaPercent() >= 28)
+            {
+                ai->CastSpell(DEVOURING_PLAGUE, *pTarget);
+                SpellSequence = SPELL_DISCIPLINE;
+                LastSpellShadowMagic = LastSpellShadowMagic +1;
+                break;
+            }
+            else if (SHADOW_PROTECTION > 0 && LastSpellShadowMagic <6 && ai->GetManaPercent() >= 60)
+            {
+                ai->CastSpell(SHADOW_PROTECTION, *pTarget);
+                SpellSequence = SPELL_DISCIPLINE;
+                LastSpellShadowMagic = LastSpellShadowMagic +1;
+                break;
+            }
+            else if (VAMPIRIC_TOUCH > 0 && LastSpellShadowMagic <7 && !pTarget->HasAura(VAMPIRIC_TOUCH, EFFECT_INDEX_0) && ai->GetManaPercent() >= 18)
+            {
+                ai->CastSpell(VAMPIRIC_TOUCH, *pTarget);
+                SpellSequence = SPELL_DISCIPLINE;
+                LastSpellShadowMagic = LastSpellShadowMagic +1;
+                break;
+            }
+            else if (SHADOWFIEND > 0 && LastSpellShadowMagic <8)
+            {
+                ai->CastSpell(SHADOWFIEND);
+                SpellSequence = SPELL_DISCIPLINE;
+                LastSpellShadowMagic = LastSpellShadowMagic +1;
+                break;
+            }
+            else if (MIND_SEAR > 0 && LastSpellShadowMagic <9 && ai->GetAttackerCount()>=3 && ai->GetManaPercent() >= 28)
+            {
+                ai->CastSpell(MIND_SEAR, *pTarget);
+                ai->SetIgnoreUpdateTime(5);
+                SpellSequence = SPELL_DISCIPLINE;
+                LastSpellShadowMagic = LastSpellShadowMagic +1;
+                break;
+            }
+            else if (LastSpellShadowMagic > 10)
+            {
+                LastSpellShadowMagic = 0;
+                SpellSequence = SPELL_DISCIPLINE;
+                break;
+            }
+            LastSpellShadowMagic = LastSpellShadowMagic +1;
+            //SpellSequence = SPELL_DISCIPLINE;
+            //break;
+
+        case SPELL_DISCIPLINE:
+            if (FEAR_WARD > 0 && LastSpellDiscipline <1 && ai->GetManaPercent() >= 3)
+            {
+                //ai->TellMaster("I'm casting fear ward");
+                ai->CastSpell(FEAR_WARD, *(GetMaster()));
+                SpellSequence = SPELL_HOLY;
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+                break;
+            }
+            else if (POWER_INFUSION > 0 && LastSpellDiscipline <2 && ai->GetManaPercent() >= 16)
+            {
+                //ai->TellMaster("I'm casting power infusion");
+                ai->CastSpell(POWER_INFUSION, *(GetMaster()));
+                SpellSequence = SPELL_HOLY;
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+                break;
+            }
+            else if (MASS_DISPEL > 0 && LastSpellDiscipline <3 && ai->GetManaPercent() >= 33)
+            {
+                //ai->TellMaster("I'm casting mass dispel");
+                ai->CastSpell(MASS_DISPEL);
+                SpellSequence = SPELL_HOLY;
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+                break;
+            }
+            else if (INNER_FOCUS > 0 && !m_bot->HasAura(INNER_FOCUS, EFFECT_INDEX_0) && LastSpellDiscipline <4)
+            {
+                //ai->TellMaster("I'm casting inner focus");
+                ai->CastSpell(INNER_FOCUS, *m_bot);
+                SpellSequence = SPELL_HOLY;
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+                break;
+            }
+            else if (PENANCE > 0 && LastSpellDiscipline <5 && ai->GetManaPercent() >= 16)
+            {
+                //ai->TellMaster("I'm casting PENANCE");
+                ai->CastSpell(PENANCE);
+                SpellSequence = SPELL_HOLY;
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+                break;
+            }
+            else if (LastSpellDiscipline > 6)
+            {
+                LastSpellDiscipline = 0;
+                SpellSequence = SPELL_HOLY;
+                break;
+            }
+            else
+            {
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+                SpellSequence = SPELL_HOLY;
+            }
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotPriestAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    SpellSequence = SPELL_HOLY;
+
+    // buff myself
+    if (FORTITUDE > 0)
+        (!m_bot->HasAura(FORTITUDE, EFFECT_INDEX_0) && ai->CastSpell (FORTITUDE, *m_bot));
+
+    if (INNER_FIRE > 0)
+        (!m_bot->HasAura(INNER_FIRE, EFFECT_INDEX_0) && ai->CastSpell (INNER_FIRE, *m_bot));
+
+    // buff master
+    if (FORTITUDE > 0)
+        (!GetMaster()->HasAura(FORTITUDE, EFFECT_INDEX_0) && ai->CastSpell(FORTITUDE,*(GetMaster())) );
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, EFFECT_INDEX_0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(*fItem);
+        ai->SetIgnoreUpdateTime(8);
+        return;
+    }
+
+    // buff and heal master's group
+    if (GetMaster()->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = sObjectMgr.GetPlayer(uint64 (itr->guid));
+            if( !tPlayer )
+                continue;
+
+            // first rezz em
+            if ( !tPlayer->isAlive() && !tPlayer->GetPlayerbotAI() )
+            {
+                std::string msg = "rezzing ";
+                msg += tPlayer->GetName();
+                GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+                ai->CastSpell(REZZ, *tPlayer);
+                // rez is only 10 sec, but give time for lag
+                ai->SetIgnoreUpdateTime(17);
+            }
+            else if( tPlayer->isAlive() )
+            {
+                // buff and heal
+                (!tPlayer->HasAura(FORTITUDE, EFFECT_INDEX_0) && ai->CastSpell (FORTITUDE, *tPlayer));
+                (HealTarget(*tPlayer, tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth()));
+            }
+        }
+    }
+} // end DoNonCombatActions
+
+void PlayerbotPriestAI::BuffPlayer(Player* target)
+{
+    GetAI()->CastSpell(FORTITUDE, *target);
+}
diff --git a/Core/src/game/PlayerbotPriestAI.h b/Core/src/game/PlayerbotPriestAI.h
new file mode 100644
index 0000000..c49ba76
--- /dev/null
+++ b/Core/src/game/PlayerbotPriestAI.h
@@ -0,0 +1,52 @@
+#ifndef _PLAYERBOTPRIESTAI_H
+#define _PLAYERBOTPRIESTAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_HOLY,
+    SPELL_SHADOWMAGIC,
+    SPELL_DISCIPLINE
+};
+
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotPriestAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotPriestAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
+        virtual ~PlayerbotPriestAI();
+
+        // all combat actions go here
+        void DoNextCombatManeuver(Unit*);
+
+        // all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        // buff a specific player, usually a real PC who is not in group
+        void BuffPlayer(Player *target);
+
+    private:
+        // Heals the target based off its hps
+        void HealTarget (Unit& target, uint8 hp);
+
+        // holy
+        uint32 GREAT_HEAL, RENEW, HEAL, FLASH_HEAL, REZZ, SMITE, CLEARCASTING, HOLY_NOVA, HOLY_FIRE, DESPERATE_PRAYER, PRAYER_OF_HEALING, CIRCLE_OF_HEALING, BINDING_HEAL, PRAYER_OF_MENDING, MANA_BURN;
+
+        // shadowmagic
+        uint32 FADE, PAIN, MIND_BLAST, SCREAM, MIND_FLAY, DEVOURING_PLAGUE, SHADOW_PROTECTION, VAMPIRIC_TOUCH, PRAYER_OF_SHADOW_PROTECTION, SHADOWFIEND, MIND_SEAR;
+
+        // discipline
+        uint32 PWS, INNER_FIRE, FORTITUDE, TOUCH_OF_WEAKNESS, FEAR_WARD, DSPIRIT, POWER_INFUSION, MASS_DISPEL, PENANCE, DIVINE_SPIRIT, INNER_FOCUS;
+
+        // first aid
+        uint32 RECENTLY_BANDAGED;
+
+        // racial
+        uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+        uint32 SpellSequence, LastSpellHoly, LastSpellShadowMagic, LastSpellDiscipline;
+};
+
+#endif
diff --git a/Core/src/game/PlayerbotRogueAI.cpp b/Core/src/game/PlayerbotRogueAI.cpp
new file mode 100644
index 0000000..4d76180
--- /dev/null
+++ b/Core/src/game/PlayerbotRogueAI.cpp
@@ -0,0 +1,349 @@
+    /*
+    Name    : PlayerbotRogueAI.cpp
+    Complete: maybe around 28%
+    Author    : Natsukawa
+    Version : 0.37
+    */
+#include "PlayerbotRogueAI.h"
+#include "PlayerbotMgr.h"
+
+class PlayerbotAI;
+PlayerbotRogueAI::PlayerbotRogueAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+
+    SINISTER_STRIKE     = ai->getSpellId("sinister strike"); //COMBAT
+    BACKSTAB            = ai->getSpellId("backstab");
+    KICK                = ai->getSpellId("kick");
+    FEINT               = ai->getSpellId("feint");
+    FAN_OF_KNIVES       = ai->getSpellId("fan of knives");
+//    DEADLY_POISON       = 20844; //ItemID
+    DEADLY_POISON       = 25351; //SpellID
+//    CRIPPLING_POISON    = 3775; //ItemID
+    CRIPPLING_POISON    = 3408; //SpellID
+    MIND_NUMBING_POISON = 5761; //SpellID
+    GOUGE               = ai->getSpellId("gouge");
+    SPRINT              = ai->getSpellId("sprint");
+
+    SHADOWSTEP          = ai->getSpellId("shadowstep"); //SUBTLETY
+    STEALTH             = ai->getSpellId("stealth");
+    VANISH              = ai->getSpellId("vanish");
+    EVASION             = ai->getSpellId("evasion");
+    CLOAK_OF_SHADOWS    = ai->getSpellId("cloak of shadows");
+    HEMORRHAGE          = ai->getSpellId("hemorrhage");
+    GHOSTLY_STRIKE      = ai->getSpellId("ghostly strike");
+    SHADOW_DANCE        = ai->getSpellId("shadow dance");
+    BLIND               = ai->getSpellId("blind");
+    DISTRACT            = ai->getSpellId("distract");
+    PREPARATION         = ai->getSpellId("preparation");
+    PREMEDITATION       = ai->getSpellId("premeditation");
+
+    EVISCERATE          = ai->getSpellId("eviscerate"); //ASSASSINATION
+    KIDNEY_SHOT         = ai->getSpellId("kidney shot");
+    SLICE_DICE          = ai->getSpellId("slice and dice");
+    GARROTE             = ai->getSpellId("garrote");
+    EXPOSE_ARMOR        = ai->getSpellId("expose armor");
+    RUPTURE             = ai->getSpellId("rupture");
+    DISMANTLE           = ai->getSpellId("dismantle");
+    CHEAP_SHOT          = ai->getSpellId("cheap shot");
+    AMBUSH              = ai->getSpellId("ambush");
+    MUTILATE            = ai->getSpellId("mutilate");
+
+    RECENTLY_BANDAGED   = 11196; // first aid check
+    // racial
+    ARCANE_TORRENT          = ai->getSpellId("arcane torrent"); // blood elf
+    STONEFORM               = ai->getSpellId("stoneform"); // dwarf
+    ESCAPE_ARTIST           = ai->getSpellId("escape artist"); // gnome
+    EVERY_MAN_FOR_HIMSELF   = ai->getSpellId("every man for himself"); // human
+    SHADOWMELD              = ai->getSpellId("shadowmeld"); // night elf
+    BLOOD_FURY              = ai->getSpellId("blood fury"); // orc
+    BERSERKING              = ai->getSpellId("berserking"); // troll
+    WILL_OF_THE_FORSAKEN    = ai->getSpellId("will of the forsaken"); // undead
+}
+
+PlayerbotRogueAI::~PlayerbotRogueAI() {}
+
+bool PlayerbotRogueAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+
+    if( STEALTH>0 && !m_bot->HasAura( STEALTH ) && ai->CastSpell(STEALTH, *m_bot) )
+    {
+        if( ai->GetManager()->m_confDebugWhisper )
+            ai->TellMaster( "First > Stealth (%d)", STEALTH );
+        return false;
+    }
+
+    return false;
+}
+
+void PlayerbotRogueAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if( !pTarget )
+        return;
+
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (SINISTER_STRIKE > 0)
+                ai->CastSpell(SINISTER_STRIKE);
+            return;
+    }
+
+    ai->SetInFront( pTarget );
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    float fTargetDist = m_bot->GetDistance( pTarget );
+
+    // TODO: make this work better...
+    /*if (pVictim)
+    {
+        if( pVictim!=m_bot && !m_bot->hasUnitState(UNIT_STAT_FOLLOW) && !pTarget->isInBackInMap(m_bot,10) ) {
+            GetAI()->TellMaster( "getting behind target" );
+            m_bot->GetMotionMaster()->Clear( true );
+            m_bot->GetMotionMaster()->MoveFollow( pTarget, 1, 2*M_PI );
+        }
+        else if( pVictim==m_bot && m_bot->hasUnitState(UNIT_STAT_FOLLOW) )
+        {
+            GetAI()->TellMaster( "chasing attacking target" );
+            m_bot->GetMotionMaster()->Clear( true );
+            m_bot->GetMotionMaster()->MoveChase( pTarget );
+        }
+    }*/
+
+    //Rouge like behaviour. ^^
+/*    if (VANISH > 0 && GetMaster()->isDead()) { //Causes the server to crash :( removed for now.
+        m_bot->AttackStop();
+        m_bot->RemoveAllAttackers();
+        ai->CastSpell(VANISH);
+//        m_bot->RemoveAllSpellCooldown();
+        GetAI()->TellMaster("AttackStop, CombatStop, Vanish");
+    }*/
+
+    // decide what to do:
+    if( pVictim==m_bot && CLOAK_OF_SHADOWS>0 && pVictim->HasAura(SPELL_AURA_PERIODIC_DAMAGE) && !m_bot->HasAura(CLOAK_OF_SHADOWS, EFFECT_INDEX_0) && ai->CastSpell(CLOAK_OF_SHADOWS))
+    {
+        if( ai->GetManager()->m_confDebugWhisper )
+            ai->TellMaster( "CoS!" );
+        return;
+    }
+    else if( m_bot->HasAura( STEALTH ) )
+        SpellSequence = RogueStealth;
+    else if( pTarget->IsNonMeleeSpellCasted(true) )
+        SpellSequence = RogueSpellPreventing;
+    else if( pVictim==m_bot && ai->GetHealthPercent()<40 )
+        SpellSequence = RogueThreat;
+    else
+        SpellSequence = RogueCombat;
+
+    // we fight in melee, target is not in range, skip the next part!
+    if( fTargetDist > ATTACK_DISTANCE )
+        return;
+
+    std::ostringstream out;
+    switch (SpellSequence)
+    {
+        case RogueStealth:
+            out << "Case Stealth";
+            if( PREMEDITATION>0 && ai->CastSpell(PREMEDITATION,*pTarget) )
+                out << " > Premeditation";
+            else if( AMBUSH>0 && ai->GetEnergyAmount()>=60 && ai->CastSpell(AMBUSH,*pTarget) )
+                out << " > Ambush";
+            else if( CHEAP_SHOT>0 && !pTarget->HasAura(CHEAP_SHOT, EFFECT_INDEX_0) && ai->GetEnergyAmount()>=60 && ai->CastSpell(CHEAP_SHOT,*pTarget) )
+                out << " > Cheap Shot";
+            else if( GARROTE>0 && ai->GetEnergyAmount()>=50 && ai->CastSpell(GARROTE,*pTarget) )
+                out << " > Garrote";
+            else
+                out << " NONE!";
+            break;
+        case RogueThreat:
+            out << "Case Threat";
+            if( GOUGE>0 && ai->GetEnergyAmount()>=45 && !pTarget->HasAura(GOUGE, EFFECT_INDEX_0) && ai->CastSpell(GOUGE,*pTarget) )
+                 out << " > Gouge";
+            else if( EVASION>0 && ai->GetHealthPercent()<=35 && !m_bot->HasAura(EVASION, EFFECT_INDEX_0) && ai->CastSpell(EVASION) )
+                out << " > Evasion";
+            else if( BLIND>0 && ai->GetHealthPercent()<=30 && !pTarget->HasAura(BLIND, EFFECT_INDEX_0) && ai->GetEnergyAmount()>=30 && ai->CastSpell(BLIND,*pTarget) )
+                out << " > Blind";
+            else if( FEINT>0 && ai->GetHealthPercent()<=25 && ai->GetEnergyAmount()>=20 && ai->CastSpell(FEINT) )
+                out << " > Feint";
+            else if( VANISH>0 && ai->GetHealthPercent()<=20 && !m_bot->HasAura(FEINT, EFFECT_INDEX_0) && ai->CastSpell(VANISH) )
+                out << " > Vanish";
+            else if( PREPARATION>0 && ai->CastSpell(PREPARATION) )
+                out << " > Preparation";
+            else if( m_bot->getRace() == RACE_NIGHTELF && ai->GetHealthPercent()<=15 && !m_bot->HasAura( SHADOWMELD, EFFECT_INDEX_0) && ai->CastSpell( SHADOWMELD, *m_bot ) )
+                out << " > Shadowmeld";
+            else
+                out << " NONE!";
+            break;
+        case RogueSpellPreventing:
+            out << "Case Prevent";
+            if( KIDNEY_SHOT>0 && ai->GetEnergyAmount()>=25 && m_bot->GetComboPoints()>=2 && ai->CastSpell(KIDNEY_SHOT,*pTarget) )
+                out << " > Kidney Shot";
+            else if( KICK>0 && ai->GetEnergyAmount()>=25  && ai->CastSpell(KICK,*pTarget) )
+                out << " > Kick";
+            else
+                out << " NONE!";
+            break;
+        case RogueCombat:
+        default:
+            out << "Case Combat";
+            if( m_bot->GetComboPoints()<=4 )
+            {
+            if( SHADOW_DANCE>0 && !m_bot->HasAura(SHADOW_DANCE, EFFECT_INDEX_0) && ai->CastSpell(SHADOW_DANCE,*m_bot) )
+                    out << " > Shadow Dance";
+            else if( CHEAP_SHOT>0 && m_bot->HasAura(SHADOW_DANCE, EFFECT_INDEX_0) && !pTarget->HasAura(CHEAP_SHOT, EFFECT_INDEX_0) && ai->GetEnergyAmount()>=60 && ai->CastSpell(CHEAP_SHOT,*pTarget) )
+                    out << " > Cheap Shot";
+            else if( AMBUSH>0 && m_bot->HasAura(SHADOW_DANCE, EFFECT_INDEX_0) && ai->GetEnergyAmount()>=60 && ai->CastSpell(AMBUSH,*pTarget) )
+                    out << " > Ambush";
+            else if( GARROTE>0 && m_bot->HasAura(SHADOW_DANCE, EFFECT_INDEX_0) && ai->GetEnergyAmount()>=50 && ai->CastSpell(GARROTE,*pTarget) )
+                    out << " > Garrote";
+            else if( BACKSTAB>0 && pTarget->isInBackInMap(m_bot,1) && ai->GetEnergyAmount()>=60 && ai->CastSpell(BACKSTAB,*pTarget) )
+                    out << " > Backstab";
+            else if( MUTILATE>0 && ai->GetEnergyAmount()>=60 && ai->CastSpell(MUTILATE,*pTarget) )
+                    out << " > Mutilate";
+            else if( SINISTER_STRIKE>0 && ai->GetEnergyAmount()>=45 && ai->CastSpell(SINISTER_STRIKE,*pTarget) )
+                    out << " > Sinister Strike";
+            else if( GHOSTLY_STRIKE>0 && ai->GetEnergyAmount()>=40 && ai->CastSpell(GHOSTLY_STRIKE,*pTarget) )
+                    out << " > Ghostly Strike";
+            else if( HEMORRHAGE>0 && ai->GetEnergyAmount()>=35 && ai->CastSpell(HEMORRHAGE,*pTarget) )
+                    out << " > Hemorrhage";
+            else if( DISMANTLE>0 && !pTarget->HasFlag(UNIT_FIELD_FLAGS,UNIT_FLAG_DISARMED) && ai->GetEnergyAmount()>=25 && ai->CastSpell(DISMANTLE,*pTarget) )
+                    out << " > Dismantle";
+            else if( SHADOWSTEP>0 && ai->GetEnergyAmount()>=10 && ai->CastSpell(SHADOWSTEP,*pTarget) )
+                    out << " > Shadowstep";
+            else if( m_bot->getRace() == RACE_BLOODELF && !pTarget->HasAura( ARCANE_TORRENT, EFFECT_INDEX_0) && ai->CastSpell( ARCANE_TORRENT,*pTarget ) )
+                    out << " > Arcane Torrent";
+            else if( m_bot->getRace() == RACE_HUMAN && m_bot->hasUnitState( UNIT_STAT_STUNNED ) || m_bot->HasAuraType( SPELL_AURA_MOD_FEAR ) || m_bot->HasAuraType( SPELL_AURA_MOD_DECREASE_SPEED ) || m_bot->HasAuraType( SPELL_AURA_MOD_CHARM ) && ai->CastSpell( EVERY_MAN_FOR_HIMSELF, *m_bot ) )
+                    out << " > Every Man for Himself";
+            else if( m_bot->getRace() == RACE_UNDEAD_PLAYER && m_bot->HasAuraType( SPELL_AURA_MOD_FEAR ) || m_bot->HasAuraType( SPELL_AURA_MOD_CHARM ) && ai->CastSpell( WILL_OF_THE_FORSAKEN, *m_bot ) )
+                    out << " > Will of the Forsaken";
+            else if( m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState( AURA_STATE_DEADLY_POISON ) && ai->CastSpell( STONEFORM, *m_bot ) )
+                    out << " > Stoneform";
+            else if( m_bot->getRace() == RACE_GNOME && m_bot->hasUnitState( UNIT_STAT_STUNNED ) || m_bot->HasAuraType( SPELL_AURA_MOD_DECREASE_SPEED ) && ai->CastSpell( ESCAPE_ARTIST, *m_bot ) )
+                    out << " > Escape Artist";
+            else if( m_bot->getRace() == RACE_ORC && !m_bot->HasAura( BLOOD_FURY, EFFECT_INDEX_0) && ai->CastSpell( BLOOD_FURY, *m_bot ) )
+                    out << " > Blood Fury";
+            else if( m_bot->getRace() == RACE_TROLL && !m_bot->HasAura( BERSERKING, EFFECT_INDEX_0) && ai->CastSpell( BERSERKING, *m_bot ) )
+                    out << " > Berserking";
+            else
+                    out << " NONE!";
+            }
+            else
+            {
+                if( EVISCERATE>0 && pTarget->getClass()==CLASS_ROGUE && ai->GetEnergyAmount()>=35 && ai->CastSpell(EVISCERATE,*pTarget) )
+                    out << " > Rogue Eviscerate";
+                else if( EVISCERATE>0 && pTarget->getClass()==CLASS_DRUID && ai->GetEnergyAmount()>=35 && ai->CastSpell(EVISCERATE,*pTarget) )
+                    out << " > Druid Eviscerate";
+                else if( KIDNEY_SHOT>0 && pTarget->getClass()==CLASS_SHAMAN && ai->GetEnergyAmount()>=25 && ai->CastSpell(KIDNEY_SHOT,*pTarget) )
+                    out << " > Shaman Kidney";
+                else if (SLICE_DICE>0 && pTarget->getClass()==CLASS_WARLOCK && ai->GetEnergyAmount()>=25 && ai->CastSpell(SLICE_DICE, *pTarget) )
+                    out << " > Warlock Slice & Dice";
+                else if (SLICE_DICE>0 && pTarget->getClass()==CLASS_HUNTER && ai->GetEnergyAmount()>=25 && ai->CastSpell(SLICE_DICE, *pTarget) )
+                    out << " > Hunter Slice & Dice";
+                else if (EXPOSE_ARMOR>0 && pTarget->getClass()==CLASS_WARRIOR && !pTarget->HasAura(EXPOSE_ARMOR, EFFECT_INDEX_0) && ai->GetEnergyAmount()>=25 && ai->CastSpell(EXPOSE_ARMOR, *pTarget) )
+                    out << " > Warrior Expose Armor";
+                else if (EXPOSE_ARMOR>0 && pTarget->getClass()==CLASS_PALADIN && !pTarget->HasAura(EXPOSE_ARMOR, EFFECT_INDEX_0) && ai->GetEnergyAmount()>=25 && ai->CastSpell(EXPOSE_ARMOR, *pTarget) )
+                    out << " > Paladin Expose Armor";
+                else if (EXPOSE_ARMOR>0 && pTarget->getClass()==CLASS_DEATH_KNIGHT && !pTarget->HasAura(EXPOSE_ARMOR, EFFECT_INDEX_0) && ai->GetEnergyAmount()>=25 && ai->CastSpell(EXPOSE_ARMOR, *pTarget) )
+                    out << " > DK Expose Armor";
+                else if (RUPTURE>0 && pTarget->getClass()==CLASS_MAGE && ai->GetEnergyAmount()>=25 && ai->CastSpell(RUPTURE, *pTarget) )
+                    out << " > Mage Rupture";
+                else if (RUPTURE>0 && pTarget->getClass()==CLASS_PRIEST && ai->GetEnergyAmount()>=25 && ai->CastSpell(RUPTURE, *pTarget) )
+                    out << " > Priest Rupture";
+                else if( EVISCERATE>0 && ai->GetEnergyAmount()>=35 && ai->CastSpell(EVISCERATE, *pTarget) )
+                    out << " > Eviscerate";
+                else
+                    out << " NONE!";
+            }
+            break;
+    }
+    if( ai->GetManager()->m_confDebugWhisper )
+        ai->TellMaster( out.str().c_str() );
+}
+
+// end DoNextCombatManeuver
+
+void PlayerbotRogueAI::DoNonCombatActions()
+{
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // remove stealth
+    if( m_bot->HasAura( STEALTH ) )
+        m_bot->RemoveSpellsCausingAura( SPELL_AURA_MOD_STEALTH );
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = GetAI()->FindFood();
+    Item* fItem = GetAI()->FindBandage();
+
+    if (pItem != NULL && GetAI()->GetHealthPercent() < 30)
+    {
+        GetAI()->TellMaster("I could use some food.");
+        GetAI()->UseItem(*pItem);
+        GetAI()->SetIgnoreUpdateTime(30);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, EFFECT_INDEX_0) && GetAI()->GetHealthPercent() < 70)
+    {
+        GetAI()->TellMaster("I could use first aid.");
+        GetAI()->UseItem(*fItem);
+        GetAI()->SetIgnoreUpdateTime(8);
+        return;
+    }
+/*
+    // Poison check //Not working needs some mor testing...i think need to tell the bott where "slot" to apply poison.
+
+    enum EquipmentSlots                                         // 19 slots
+    {
+        EQUIPMENT_SLOT_START        = 0,
+        EQUIPMENT_SLOT_HEAD         = 0,
+        EQUIPMENT_SLOT_NECK         = 1,
+        EQUIPMENT_SLOT_SHOULDERS    = 2,
+        EQUIPMENT_SLOT_BODY         = 3,
+        EQUIPMENT_SLOT_CHEST        = 4,
+        EQUIPMENT_SLOT_WAIST        = 5,
+        EQUIPMENT_SLOT_LEGS         = 6,
+        EQUIPMENT_SLOT_FEET         = 7,
+        EQUIPMENT_SLOT_WRISTS       = 8,
+        EQUIPMENT_SLOT_HANDS        = 9,
+        EQUIPMENT_SLOT_FINGER1      = 10,
+        EQUIPMENT_SLOT_FINGER2      = 11,
+        EQUIPMENT_SLOT_TRINKET1     = 12,
+        EQUIPMENT_SLOT_TRINKET2     = 13,
+        EQUIPMENT_SLOT_BACK         = 14,
+        EQUIPMENT_SLOT_MAINHAND     = 15,
+        EQUIPMENT_SLOT_OFFHAND      = 16,
+        EQUIPMENT_SLOT_RANGED       = 17,
+        EQUIPMENT_SLOT_TABARD       = 18,
+        EQUIPMENT_SLOT_END          = 19
+    };
+
+//thi is only a guess, dont get how to apply temp enchant on weapons.
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = GetAI()->FindPoison();
+    Item* item = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+    if (pItem != NULL)
+    {
+        GetAI()->TellMaster("I could use some poison.");
+//        GetAI()->UseItem(*pItem);
+        m_bot->ApplyEnchantment(item,TEMP_ENCHANTMENT_SLOT,true);
+        GetAI()->SetIgnoreUpdateTime(10);
+        return;
+    }
+*/
+
+} // end DoNonCombatActions
+
+void PlayerbotRogueAI::BuffPlayer(Player* target) {
+}
diff --git a/Core/src/game/PlayerbotRogueAI.h b/Core/src/game/PlayerbotRogueAI.h
new file mode 100644
index 0000000..862453e
--- /dev/null
+++ b/Core/src/game/PlayerbotRogueAI.h
@@ -0,0 +1,52 @@
+
+#ifndef _PlayerbotRogueAI_H
+#define _PlayerbotRogueAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    RogueCombat,
+    RogueSpellPreventing,
+    RogueThreat,
+    RogueStealth
+};
+
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotRogueAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotRogueAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
+        virtual ~PlayerbotRogueAI();
+
+        // all combat actions go here
+        bool DoFirstCombatManeuver(Unit*);
+        void DoNextCombatManeuver(Unit*);
+
+        // all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        // buff a specific player, usually a real PC who is not in group
+        void BuffPlayer(Player *target);
+
+    private:
+        // COMBAT
+        uint32 SINISTER_STRIKE, BACKSTAB, GOUGE, EVASION, SPRINT, KICK, FEINT, SHIV, FAN_OF_KNIVES;
+
+        // SUBTLETY
+        uint32 SHADOWSTEP, STEALTH, VANISH, HEMORRHAGE, BLIND, SHADOW_DANCE, CLOAK_OF_SHADOWS, TRICK_TRADE, CRIPPLING_POISON, DEADLY_POISON, MIND_NUMBING_POISON, GHOSTLY_STRIKE, DISTRACT, PREPARATION, PREMEDITATION;
+
+        // ASSASSINATION
+        uint32 EVISCERATE, SLICE_DICE, GARROTE, EXPOSE_ARMOR, AMBUSH, RUPTURE, DISMANTLE, CHEAP_SHOT, KIDNEY_SHOT, MUTILATE, ENVENOM, DEADLY_THROW;
+
+        // first aid
+        uint32 RECENTLY_BANDAGED;
+
+        // racial
+        uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+        uint32 SpellSequence, LastSpellCombat, LastSpellSubtlety, LastSpellAssassination, Aura;
+};
+
+#endif
diff --git a/Core/src/game/PlayerbotShamanAI.cpp b/Core/src/game/PlayerbotShamanAI.cpp
new file mode 100644
index 0000000..52b7dcd
--- /dev/null
+++ b/Core/src/game/PlayerbotShamanAI.cpp
@@ -0,0 +1,532 @@
+
+#include "PlayerbotShamanAI.h"
+
+class PlayerbotAI;
+PlayerbotShamanAI::PlayerbotShamanAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    // restoration
+    CHAIN_HEAL               = ai->getSpellId("chain heal");
+    HEALING_WAVE             = ai->getSpellId("healing wave");
+    LESSER_HEALING_WAVE      = ai->getSpellId("lesser healing wave");
+    RIPTIDE                  = ai->getSpellId("riptide");
+    ANCESTRAL_SPIRIT         = ai->getSpellId("ancestral spirit");
+    EARTH_SHIELD             = ai->getSpellId("earth shield");
+    WATER_SHIELD             = ai->getSpellId("water shield");
+    EARTHLIVING_WEAPON       = ai->getSpellId("earthliving weapon");
+    TREMOR_TOTEM             = ai->getSpellId("tremor totem"); // totems
+    HEALING_STREAM_TOTEM     = ai->getSpellId("healing stream totem");
+    MANA_SPRING_TOTEM        = ai->getSpellId("mana spring totem");
+    MANA_TIDE_TOTEM          = ai->getSpellId("mana tide totem");
+    // enhancement
+    FOCUSED                  = ai->getSpellId("focused");
+    STORMSTRIKE              = ai->getSpellId("stormstrike");
+    LAVA_LASH                = ai->getSpellId("lava lash");
+    SHAMANISTIC_RAGE         = ai->getSpellId("shamanistic rage");
+    BLOODLUST                = ai->getSpellId("bloodlust");
+    HEROISM                  = ai->getSpellId("heroism");
+    FERAL_SPIRIT             = ai->getSpellId("feral spirit");
+    LIGHTNING_SHIELD         = ai->getSpellId("lightning");
+    ROCKBITER_WEAPON         = ai->getSpellId("rockbiter");
+    FLAMETONGUE_WEAPON       = ai->getSpellId("flametongue weapon");
+    FROSTBRAND_WEAPON        = ai->getSpellId("frostbrand weapon");
+    WINDFURY_WEAPON          = ai->getSpellId("windfury weapon");
+    STONESKIN_TOTEM          = ai->getSpellId("stoneskin totem"); // totems
+    STRENGTH_OF_EARTH_TOTEM  = ai->getSpellId("strength of earth totem");
+    FROST_RESISTANCE_TOTEM   = ai->getSpellId("frost resistance totem");
+    FLAMETONGUE_TOTEM        = ai->getSpellId("flametongue totem");
+    FIRE_RESISTANCE_TOTEM    = ai->getSpellId("fire resistance totem");
+    GROUNDING_TOTEM          = ai->getSpellId("grounding totem");
+    NATURE_RESISTANCE_TOTEM  = ai->getSpellId("nature resistance totem");
+    WIND_FURY_TOTEM          = ai->getSpellId("wind fury totem");
+    STONESKIN_TOTEM          = ai->getSpellId("stoneskin totem");
+    WRATH_OF_AIR_TOTEM       = ai->getSpellId("wrath of air totem");
+    EARTH_ELEMENTAL_TOTEM    = ai->getSpellId("earth elemental totem");
+    // elemental
+    LIGHTNING_BOLT           = ai->getSpellId("lightning bolt");
+    EARTH_SHOCK              = ai->getSpellId("earth shock");
+    FLAME_SHOCK              = ai->getSpellId("flame shock");
+    PURGE                    = ai->getSpellId("purge");
+    WIND_SHOCK               = ai->getSpellId("wind shock");
+    FROST_SHOCK              = ai->getSpellId("frost shock");
+    CHAIN_LIGHTNING          = ai->getSpellId("chain lightning");
+    LAVA_BURST               = ai->getSpellId("lava burst");
+    HEX                      = ai->getSpellId("hex");
+    STONECLAW_TOTEM          = ai->getSpellId("stoneclaw totem"); // totems
+    SEARING_TOTEM            = ai->getSpellId("searing totem");
+    FIRE_NOVA_TOTEM          = ai->getSpellId("fire nova totem");
+    MAGMA_TOTEM              = ai->getSpellId("magma totem");
+    EARTHBIND_TOTEM          = ai->getSpellId("earthbind totem");
+    TOTEM_OF_WRATH           = ai->getSpellId("totem of wrath");
+    FIRE_ELEMENTAL_TOTEM     = ai->getSpellId("fire elemental totem");
+
+    RECENTLY_BANDAGED        = 11196; // first aid check
+
+    // racial
+    GIFT_OF_THE_NAARU        = ai->getSpellId("gift of the naaru"); // draenei
+    BLOOD_FURY               = ai->getSpellId("blood fury"); // orc
+    WAR_STOMP                = ai->getSpellId("war stomp"); // tauren
+    BERSERKING               = ai->getSpellId("berserking"); // troll
+}
+
+PlayerbotShamanAI::~PlayerbotShamanAI() {}
+
+void PlayerbotShamanAI::HealTarget(Unit &target, uint8 hp)
+{
+    PlayerbotAI* ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+
+    if (hp < 30 && HEALING_WAVE > 0 && ai->GetManaPercent() >= 32)
+        ai->CastSpell(HEALING_WAVE, target);
+    else if (hp < 45 && LESSER_HEALING_WAVE > 0 && ai->GetManaPercent() >= 19)
+        ai->CastSpell(LESSER_HEALING_WAVE, target);
+    else if (hp < 55 && RIPTIDE > 0 && !target.HasAura(RIPTIDE, EFFECT_INDEX_0) && ai->GetManaPercent() >= 21)
+        ai->CastSpell(RIPTIDE, target);
+    else if (hp < 70 && CHAIN_HEAL > 0 && ai->GetManaPercent() >= 24)
+        ai->CastSpell(CHAIN_HEAL, target);
+    // end HealTarget
+}
+
+void PlayerbotShamanAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(LIGHTNING_BOLT);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    ai->SetMovementOrder( PlayerbotAI::MOVEMENT_FOLLOW, GetMaster() ); // dont want to melee mob <----changed
+
+    Player *m_bot = GetPlayerBot();
+    Group *m_group = m_bot->GetGroup();
+
+    // Heal myself
+    if (ai->GetHealthPercent() < 30 && ai->GetManaPercent() >= 32)
+    {
+        ai->CastSpell(HEALING_WAVE);
+    }
+    else if (ai->GetHealthPercent() < 50 && ai->GetManaPercent() >= 19)
+    {
+        ai->CastSpell(LESSER_HEALING_WAVE);
+    }
+    else if (ai->GetHealthPercent() < 70)
+        HealTarget (*m_bot, ai->GetHealthPercent());
+
+    // Heal master
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    if (GetMaster()->isAlive())
+    {
+        if (masterHP < 30 && ai->GetManaPercent() >= 32)
+                ai->CastSpell(HEALING_WAVE, *(GetMaster()));
+        else if (masterHP < 70)
+            HealTarget (*GetMaster(), masterHP);
+    }
+
+    // Heal group
+    if( m_group )
+    {
+        Group::MemberSlotList const& groupSlot = m_group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *m_groupMember = sObjectMgr.GetPlayer( itr->guid );
+            if( !m_groupMember || !m_groupMember->isAlive() )
+                continue;
+
+            uint32 memberHP = m_groupMember->GetHealth()*100 / m_groupMember->GetMaxHealth();
+            if( memberHP < 30 )
+                HealTarget( *m_groupMember, memberHP );
+        }
+    }
+
+    // Damage Spells
+    ai->SetInFront( pTarget );
+
+    switch (SpellSequence)
+    {
+        case SPELL_ENHANCEMENT:
+			if (STRENGTH_OF_EARTH_TOTEM > 0 && LastSpellEnhancement == 1 && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(STRENGTH_OF_EARTH_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (STONESKIN_TOTEM > 0 && LastSpellEnhancement == 5 && (!m_bot->HasAura(STONESKIN_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(STONESKIN_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (FOCUSED > 0 && LastSpellEnhancement == 2)
+            {
+                ai->CastSpell(FOCUSED, *pTarget);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (FROST_RESISTANCE_TOTEM > 0 && LastSpellEnhancement == 10 && (!m_bot->HasAura(FROST_RESISTANCE_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(TOTEM_OF_WRATH, EFFECT_INDEX_0)) && (!m_bot->HasAura(FLAMETONGUE_TOTEM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(FROST_RESISTANCE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (FLAMETONGUE_TOTEM > 0 && LastSpellEnhancement == 15 && (!m_bot->HasAura(FLAMETONGUE_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(TOTEM_OF_WRATH, EFFECT_INDEX_0)) && (!m_bot->HasAura(FROST_RESISTANCE_TOTEM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell(FLAMETONGUE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (FIRE_RESISTANCE_TOTEM > 0 && LastSpellEnhancement == 20 && (!m_bot->HasAura(FIRE_RESISTANCE_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(HEALING_STREAM_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(MANA_SPRING_TOTEM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(FIRE_RESISTANCE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (GROUNDING_TOTEM > 0 && LastSpellEnhancement == 25 && (!m_bot->HasAura(GROUNDING_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(WIND_FURY_TOTEM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(GROUNDING_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (NATURE_RESISTANCE_TOTEM > 0 && LastSpellEnhancement == 30 && (!m_bot->HasAura(NATURE_RESISTANCE_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(GROUNDING_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(WIND_FURY_TOTEM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(NATURE_RESISTANCE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (WIND_FURY_TOTEM > 0 && LastSpellEnhancement == 35 && (!m_bot->HasAura(WIND_FURY_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(GROUNDING_TOTEM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 11)
+            {
+                ai->CastSpell(WIND_FURY_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (STORMSTRIKE > 0 && LastSpellEnhancement == 4 && (!pTarget->HasAura(STORMSTRIKE, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(STORMSTRIKE, *pTarget);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (LAVA_LASH > 0 && LastSpellEnhancement == 6 && ai->GetManaPercent() >= 4)
+            {
+                ai->CastSpell(LAVA_LASH, *pTarget);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (FERAL_SPIRIT > 0 && LastSpellEnhancement == 7 && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell(FERAL_SPIRIT);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (WRATH_OF_AIR_TOTEM > 0 && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(GROUNDING_TOTEM, EFFECT_INDEX_0)) && LastSpellEnhancement == 40)
+            {
+                ai->CastSpell(WRATH_OF_AIR_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (EARTH_ELEMENTAL_TOTEM > 0 && LastSpellEnhancement == 45 && ai->GetManaPercent() >= 24)
+            {
+                ai->CastSpell(EARTH_ELEMENTAL_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (BLOODLUST > 0 && LastSpellEnhancement == 8 && (!GetMaster()->HasAura(BLOODLUST, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 26)
+            {
+                ai->CastSpell(BLOODLUST);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (HEROISM > 0 && LastSpellEnhancement == 10 && (!GetMaster()->HasAura(HEROISM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 26)
+            {
+                ai->CastSpell(HEROISM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (SHAMANISTIC_RAGE > 0 && (!m_bot->HasAura(SHAMANISTIC_RAGE, EFFECT_INDEX_0)) && LastSpellEnhancement == 11)
+            {
+                ai->CastSpell(SHAMANISTIC_RAGE, *m_bot);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement +1;
+                break;
+            }
+            else if (LastSpellEnhancement > 50)
+            {
+                LastSpellEnhancement = 1;
+                SpellSequence = SPELL_RESTORATION;
+                break;
+            }
+            LastSpellEnhancement = LastSpellEnhancement + 1;
+            //SpellSequence = SPELL_RESTORATION;
+            //break;
+
+        case SPELL_RESTORATION:
+            if (HEALING_STREAM_TOTEM > 0 && LastSpellRestoration < 3 && ai->GetHealthPercent() < 50 && (!m_bot->HasAura(HEALING_STREAM_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(MANA_SPRING_TOTEM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 4)
+            {
+                ai->CastSpell(HEALING_STREAM_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration +1;
+                break;
+            }
+            else if (MANA_SPRING_TOTEM > 0 && LastSpellRestoration < 4 && (!m_bot->HasAura(MANA_SPRING_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(HEALING_STREAM_TOTEM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(MANA_SPRING_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration +1;
+                break;
+            }
+            else if (MANA_TIDE_TOTEM > 0 && LastSpellRestoration < 5 && ai->GetManaPercent() < 50 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell(MANA_TIDE_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration +1;
+                break;
+            }
+            /*else if (TREMOR_TOTEM > 0 && LastSpellRestoration < 6 && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 2)
+            {
+                ai->CastSpell(TREMOR_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration +1;
+                break;
+            }*/
+            else if (LastSpellRestoration > 6)
+            {
+                LastSpellRestoration = 0;
+                SpellSequence = SPELL_ELEMENTAL;
+                break;
+            }
+            LastSpellRestoration = LastSpellRestoration +1;
+            //SpellSequence = SPELL_ELEMENTAL;
+            //break;
+
+        case SPELL_ELEMENTAL:
+            if (LIGHTNING_BOLT > 0 && LastSpellElemental == 1 && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(LIGHTNING_BOLT, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (SEARING_TOTEM > 0 && LastSpellElemental == 2 && (!pTarget->HasAura(SEARING_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(TOTEM_OF_WRATH, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(SEARING_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (STONECLAW_TOTEM > 0 && ai->GetHealthPercent() < 51 && LastSpellElemental == 3 && (!pTarget->HasAura(STONECLAW_TOTEM, EFFECT_INDEX_0)) && (!pTarget->HasAura(EARTHBIND_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(STONECLAW_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FLAME_SHOCK > 0 && LastSpellElemental == 4 && (!pTarget->HasAura(FLAME_SHOCK, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 22)
+            {
+                ai->CastSpell(FLAME_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (LAVA_BURST > 0 && LastSpellElemental == 5 && (pTarget->HasAura(FLAME_SHOCK, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(LAVA_BURST, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (MAGMA_TOTEM > 0 && LastSpellElemental == 6 && (!m_bot->HasAura(TOTEM_OF_WRATH, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 35)
+            {
+                ai->CastSpell(MAGMA_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (EARTHBIND_TOTEM > 0 && LastSpellElemental == 7 && (!pTarget->HasAura(EARTHBIND_TOTEM, EFFECT_INDEX_0)) && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(EARTHBIND_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (EARTH_SHOCK > 0 && LastSpellElemental == 8 && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(EARTH_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (PURGE > 0 && LastSpellElemental == 9 && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(PURGE, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (WIND_SHOCK > 0 && LastSpellElemental == 10 && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(WIND_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FIRE_NOVA_TOTEM > 0 && LastSpellElemental == 11 && ai->GetManaPercent() >= 33)
+            {
+                ai->CastSpell(FIRE_NOVA_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FROST_SHOCK > 0 && LastSpellElemental == 12 && (!pTarget->HasAura(FROST_SHOCK, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(FROST_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (CHAIN_LIGHTNING > 0 && LastSpellElemental == 13 && ai->GetManaPercent() >= 33)
+            {
+                ai->CastSpell(CHAIN_LIGHTNING, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (TOTEM_OF_WRATH > 0 && LastSpellElemental == 14 && (!m_bot->HasAura(TOTEM_OF_WRATH, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(TOTEM_OF_WRATH);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FIRE_ELEMENTAL_TOTEM > 0 && LastSpellElemental == 15 && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(FIRE_ELEMENTAL_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            /*else if (HEX > 0 && LastSpellElemental == 16 && (!pTarget->HasAura(HEX, EFFECT_INDEX_0)) && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell(HEX);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }*/
+            else if (LastSpellElemental > 16)
+            {
+                LastSpellElemental = 1;
+                SpellSequence = SPELL_ENHANCEMENT;
+                break;
+            }
+            else
+            {
+                LastSpellElemental = LastSpellElemental + 1;
+                SpellSequence = SPELL_ENHANCEMENT;
+            }
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotShamanAI::DoNonCombatActions()
+{
+	PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    SpellSequence = SPELL_ENHANCEMENT;
+
+    // buff master with EARTH_SHIELD
+    if (EARTH_SHIELD > 0)
+		(!GetMaster()->HasAura(EARTH_SHIELD, EFFECT_INDEX_0) && ai->CastSpell(EARTH_SHIELD,*(GetMaster())) );
+
+    // buff myself with WATER_SHIELD, LIGHTNING_SHIELD
+    if (WATER_SHIELD > 0)
+        (!m_bot->HasAura(WATER_SHIELD, EFFECT_INDEX_0) && !m_bot->HasAura(LIGHTNING_SHIELD, EFFECT_INDEX_0) && ai->CastSpell(WATER_SHIELD,*m_bot) );
+    else if (LIGHTNING_SHIELD > 0)
+        (!m_bot->HasAura(LIGHTNING_SHIELD, EFFECT_INDEX_0) && !m_bot->HasAura(WATER_SHIELD, EFFECT_INDEX_0) && ai->CastSpell(LIGHTNING_SHIELD,*m_bot) );
+/*
+       // buff myself weapon
+       if (ROCKBITER_WEAPON > 0)
+            (!m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(EARTHLIVING_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(WINDFURY_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && ai->CastSpell(ROCKBITER_WEAPON,*m_bot) );
+       else if (EARTHLIVING_WEAPON > 0)
+            (!m_bot->HasAura(EARTHLIVING_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(EARTHLIVING_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && ai->CastSpell(WINDFURY_WEAPON,*m_bot) );
+       else if (WINDFURY_WEAPON > 0)
+            (!m_bot->HasAura(WINDFURY_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(EARTHLIVING_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && ai->CastSpell(WINDFURY_WEAPON,*m_bot) );
+       else if (FLAMETONGUE_WEAPON > 0)
+            (!m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(EARTHLIVING_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(WINDFURY_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && ai->CastSpell(FLAMETONGUE_WEAPON,*m_bot) );
+       else if (FROSTBRAND_WEAPON > 0)
+            (!m_bot->HasAura(FROSTBRAND_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(EARTHLIVING_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(WINDFURY_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, EFFECT_INDEX_0) && !m_bot->HasAura(ROCKBITER_WEAPON, EFFECT_INDEX_0) && ai->CastSpell(FROSTBRAND_WEAPON,*m_bot) );
+*/
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, EFFECT_INDEX_0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(*fItem);
+        ai->SetIgnoreUpdateTime(8);
+        return;
+    }
+
+    // heal master's group
+    if (GetMaster()->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = sObjectMgr.GetPlayer(uint64 (itr->guid));
+            if( !tPlayer || !tPlayer->isAlive() )
+                continue;
+
+             // heal
+             (HealTarget(*tPlayer, tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth()));
+        }
+    }
+} // end DoNonCombatActions
+
+void PlayerbotShamanAI::BuffPlayer(Player* target) {
+}
diff --git a/Core/src/game/PlayerbotShamanAI.h b/Core/src/game/PlayerbotShamanAI.h
new file mode 100644
index 0000000..d133838
--- /dev/null
+++ b/Core/src/game/PlayerbotShamanAI.h
@@ -0,0 +1,52 @@
+#ifndef _PLAYERBOTSHAMANAI_H
+#define _PLAYERBOTSHAMANAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_ENHANCEMENT,
+    SPELL_RESTORATION,
+    SPELL_ELEMENTAL
+};
+
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotShamanAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotShamanAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
+        virtual ~PlayerbotShamanAI();
+
+        // all combat actions go here
+        void DoNextCombatManeuver(Unit*);
+
+        // all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        // buff a specific player, usually a real PC who is not in group
+        void BuffPlayer(Player *target);
+
+    private:
+        // Heals the target based off its hps
+        void HealTarget (Unit& target, uint8 hp);
+
+        // ENHANCEMENT
+        uint32 ROCKBITER_WEAPON, STONESKIN_TOTEM, LIGHTNING_SHIELD, FLAMETONGUE_WEAPON, STRENGTH_OF_EARTH_TOTEM, FOCUSED, FROSTBRAND_WEAPON, FROST_RESISTANCE_TOTEM, FLAMETONGUE_TOTEM, FIRE_RESISTANCE_TOTEM, WINDFURY_WEAPON, GROUNDING_TOTEM, NATURE_RESISTANCE_TOTEM, WIND_FURY_TOTEM, STORMSTRIKE, LAVA_LASH, SHAMANISTIC_RAGE, WRATH_OF_AIR_TOTEM, EARTH_ELEMENTAL_TOTEM, BLOODLUST, HEROISM, FERAL_SPIRIT;
+
+        // RESTORATION
+        uint32 HEALING_WAVE, LESSER_HEALING_WAVE, ANCESTRAL_SPIRIT, TREMOR_TOTEM, HEALING_STREAM_TOTEM, MANA_SPRING_TOTEM, CHAIN_HEAL, MANA_TIDE_TOTEM, EARTH_SHIELD, WATER_SHIELD, EARTHLIVING_WEAPON, RIPTIDE;
+
+        // ELEMENTAL
+        uint32 LIGHTNING_BOLT, EARTH_SHOCK, STONECLAW_TOTEM, FLAME_SHOCK, SEARING_TOTEM, PURGE, FIRE_NOVA_TOTEM, WIND_SHOCK, FROST_SHOCK, MAGMA_TOTEM, CHAIN_LIGHTNING, TOTEM_OF_WRATH, FIRE_ELEMENTAL_TOTEM, LAVA_BURST, EARTHBIND_TOTEM, HEX;
+
+        // first aid
+        uint32 RECENTLY_BANDAGED;
+
+        // racial
+        uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+        uint32 SpellSequence, LastSpellEnhancement, LastSpellRestoration, LastSpellElemental;
+};
+
+#endif
diff --git a/Core/src/game/PlayerbotWarlockAI.cpp b/Core/src/game/PlayerbotWarlockAI.cpp
new file mode 100644
index 0000000..31d53e7
--- /dev/null
+++ b/Core/src/game/PlayerbotWarlockAI.cpp
@@ -0,0 +1,464 @@
+
+#include "PlayerbotWarlockAI.h"
+
+class PlayerbotAI;
+PlayerbotWarlockAI::PlayerbotWarlockAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    // DESTRUCTION
+    SHADOW_BOLT           = ai->getSpellId("shadow bolt");
+    IMMOLATE              = ai->getSpellId("immolate");
+    INCINERATE            = ai->getSpellId("incinerate");
+    SEARING_PAIN          = ai->getSpellId("searing pain");
+    CONFLAGRATE           = ai->getSpellId("conflagrate");
+    SHADOWFURY            = ai->getSpellId("shadowfury");
+    CHAOS_BOLT            = ai->getSpellId("chaos bolt");
+    SHADOWFLAME           = ai->getSpellId("shadowflame");
+    HELLFIRE              = ai->getSpellId("hellfire");
+    RAIN_OF_FIRE          = ai->getSpellId("rain of fire");
+    SOUL_FIRE             = ai->getSpellId("soul fire"); // soul shard spells
+    SHADOWBURN            = ai->getSpellId("shadowburn");
+    // CURSE
+    CURSE_OF_WEAKNESS     = ai->getSpellId("curse of weakness");
+    CURSE_OF_THE_ELEMENTS = ai->getSpellId("curse of the elements");
+    CURSE_OF_AGONY        = ai->getSpellId("curse of agony");
+    CURSE_OF_EXHAUSTION   = ai->getSpellId("curse of exhaustion");
+    CURSE_OF_TONGUES      = ai->getSpellId("curse of tongues");
+    CURSE_OF_DOOM         = ai->getSpellId("curse of doom");
+    // AFFLICTION
+    CORRUPTION            = ai->getSpellId("corruption");
+    DRAIN_SOUL            = ai->getSpellId("drain soul");
+    DRAIN_LIFE            = ai->getSpellId("drain life");
+    DRAIN_MANA            = ai->getSpellId("drain mana");
+    LIFE_TAP              = ai->getSpellId("life tap");
+    UNSTABLE_AFFLICTION   = ai->getSpellId("unstable affliction");
+    HAUNT                 = ai->getSpellId("haunt");
+    ATROCITY              = ai->getSpellId("atrocity");
+    SEED_OF_CORRUPTION    = ai->getSpellId("seed of corruption");
+    DARK_PACT             = ai->getSpellId("dark pact");
+    HOWL_OF_TERROR        = ai->getSpellId("howl of terror");
+    FEAR                  = ai->getSpellId("fear");
+    // DEMONOLOGY
+    DEMON_SKIN            = ai->getSpellId("demon skin");
+    DEMON_ARMOR           = ai->getSpellId("demon armor");
+    FEL_ARMOR             = ai->getSpellId("fel armor");
+    SHADOW_WARD           = ai->getSpellId("shadow ward");
+    SOULSHATTER           = ai->getSpellId("soulshatter");
+    SOUL_LINK             = ai->getSpellId("soul link");
+    HEALTH_FUNNEL         = ai->getSpellId("health funnel");
+    DETECT_INVISIBILITY   = ai->getSpellId("detect invisibility");
+    // demon summon
+    SUMMON_IMP            = ai->getSpellId("summon imp");
+    SUMMON_VOIDWALKER     = ai->getSpellId("summon voidwalker");
+    SUMMON_SUCCUBUS       = ai->getSpellId("summon succubus");
+    SUMMON_FELHUNTER      = ai->getSpellId("summon felhunter");
+    SUMMON_FELGUARD       = ai->getSpellId("summon felguard");
+    // demon skills
+    BLOOD_PACT            = ai->getSpellId("blood pact"); // imp skill
+    CONSUME_SHADOWS       = ai->getSpellId("consume shadows"); // voidwalker skill
+    FEL_INTELLIGENCE      = ai->getSpellId("fel intelligence"); // felhunter skill
+
+    RECENTLY_BANDAGED     = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT        = ai->getSpellId("arcane torrent"); // blood elf
+    ESCAPE_ARTIST         = ai->getSpellId("escape artist"); // gnome
+    EVERY_MAN_FOR_HIMSELF = ai->getSpellId("every man for himself"); // human
+    BLOOD_FURY            = ai->getSpellId("blood fury"); // orc
+    WILL_OF_THE_FORSAKEN  = ai->getSpellId("will of the forsaken"); // undead
+
+    m_demonSummonFailed = false;
+}
+
+PlayerbotWarlockAI::~PlayerbotWarlockAI() {}
+
+void PlayerbotWarlockAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (SHADOW_BOLT > 0)
+                ai->CastSpell(SHADOW_BOLT);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+	//ai->SetMovementOrder( PlayerbotAI::MOVEMENT_FOLLOW, GetMaster() ); // dont want to melee mob
+
+    ai->SetInFront( pTarget );
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    Pet *pet = m_bot->GetPet();
+
+    // Damage Spells
+    ai->SetInFront( pTarget );
+
+    switch (SpellSequence)
+    {
+        case SPELL_CURSES:
+             if (CURSE_OF_AGONY > 0 && !pTarget->HasAura(CURSE_OF_AGONY, EFFECT_INDEX_0) && !pTarget->HasAura(SHADOWFLAME, EFFECT_INDEX_0) && LastSpellCurse < 1 && ai->GetManaPercent() >= 14)
+             {
+                 ai->CastSpell(CURSE_OF_AGONY, *pTarget);
+                 SpellSequence = SPELL_AFFLICTION;
+                 LastSpellCurse = LastSpellCurse +1;
+                 break;
+             }
+             else if (CURSE_OF_THE_ELEMENTS > 0 && !pTarget->HasAura(CURSE_OF_THE_ELEMENTS, EFFECT_INDEX_0) && !pTarget->HasAura(SHADOWFLAME, EFFECT_INDEX_0) && !pTarget->HasAura(CURSE_OF_AGONY, EFFECT_INDEX_0) && !pTarget->HasAura(CURSE_OF_WEAKNESS, EFFECT_INDEX_0) && LastSpellCurse < 2 && ai->GetManaPercent() >= 10)
+             {
+                 ai->CastSpell(CURSE_OF_THE_ELEMENTS, *pTarget);
+                 SpellSequence = SPELL_AFFLICTION;
+                 LastSpellCurse = LastSpellCurse +1;
+                 break;
+             }
+             else if (CURSE_OF_EXHAUSTION > 0 && !pTarget->HasAura(CURSE_OF_EXHAUSTION, EFFECT_INDEX_0) && !pTarget->HasAura(SHADOWFLAME, EFFECT_INDEX_0) && !pTarget->HasAura(CURSE_OF_WEAKNESS, EFFECT_INDEX_0) && !pTarget->HasAura(CURSE_OF_AGONY, EFFECT_INDEX_0) && !pTarget->HasAura(CURSE_OF_THE_ELEMENTS, EFFECT_INDEX_0) && LastSpellCurse < 3 && ai->GetManaPercent() >= 6)
+             {
+                 ai->CastSpell(CURSE_OF_EXHAUSTION, *pTarget);
+                 SpellSequence = SPELL_AFFLICTION;
+                 LastSpellCurse = LastSpellCurse +1;
+                 break;
+             }
+             else if (CURSE_OF_WEAKNESS > 0 && !pTarget->HasAura(CURSE_OF_WEAKNESS, EFFECT_INDEX_0) && !pTarget->HasAura(SHADOWFLAME, EFFECT_INDEX_0) && !pTarget->HasAura(CURSE_OF_EXHAUSTION, EFFECT_INDEX_0) && !pTarget->HasAura(CURSE_OF_AGONY, EFFECT_INDEX_0) && !pTarget->HasAura(CURSE_OF_THE_ELEMENTS, EFFECT_INDEX_0) && LastSpellCurse < 4 && ai->GetManaPercent() >= 14)
+             {
+                 ai->CastSpell(CURSE_OF_WEAKNESS, *pTarget);
+                 SpellSequence = SPELL_AFFLICTION;
+                 LastSpellCurse = LastSpellCurse +1;
+                 break;
+             }
+             else if (CURSE_OF_TONGUES > 0 && !pTarget->HasAura(CURSE_OF_TONGUES, EFFECT_INDEX_0) && !pTarget->HasAura(SHADOWFLAME, EFFECT_INDEX_0) && !pTarget->HasAura(CURSE_OF_WEAKNESS, EFFECT_INDEX_0) && !pTarget->HasAura(CURSE_OF_EXHAUSTION, EFFECT_INDEX_0) && !pTarget->HasAura(CURSE_OF_AGONY, EFFECT_INDEX_0) && !pTarget->HasAura(CURSE_OF_THE_ELEMENTS, EFFECT_INDEX_0) && LastSpellCurse < 5 && ai->GetManaPercent() >= 4)
+             {
+                 ai->CastSpell(CURSE_OF_TONGUES, *pTarget);
+                 SpellSequence = SPELL_AFFLICTION;
+                 LastSpellCurse = LastSpellCurse +1;
+                 break;
+             }
+             LastSpellCurse = 0;
+             //SpellSequence = SPELL_AFFLICTION;
+             //break;
+
+        case SPELL_AFFLICTION:
+             if (LIFE_TAP > 0 && LastSpellAffliction < 1 && ai->GetManaPercent() <= 50)
+             {
+                 ai->CastSpell(LIFE_TAP, *m_bot);
+                 SpellSequence = SPELL_DESTRUCTION;
+                 LastSpellAffliction = LastSpellAffliction +1;
+                 break;
+             }
+             else if (CORRUPTION > 0 && !pTarget->HasAura(CORRUPTION, EFFECT_INDEX_0) && !pTarget->HasAura(SHADOWFLAME, EFFECT_INDEX_0) && !pTarget->HasAura(SEED_OF_CORRUPTION, EFFECT_INDEX_0) && LastSpellAffliction < 2 && ai->GetManaPercent() >= 19)
+             {
+                 ai->CastSpell(CORRUPTION, *pTarget);
+                 SpellSequence = SPELL_DESTRUCTION;
+                 LastSpellAffliction = LastSpellAffliction +1;
+                 break;
+             }
+             else if (DRAIN_SOUL > 0 && pTarget->GetHealth() < pTarget->GetMaxHealth()*0.40 && !pTarget->HasAura(DRAIN_SOUL, EFFECT_INDEX_0) && LastSpellAffliction < 3 && ai->GetManaPercent() >= 19)
+             {
+                 ai->CastSpell(DRAIN_SOUL, *pTarget);
+                 ai->SetIgnoreUpdateTime(15);
+                 SpellSequence = SPELL_DESTRUCTION;
+                 LastSpellAffliction = LastSpellAffliction +1;
+                 break;
+             }
+             else if (DRAIN_LIFE > 0 && LastSpellAffliction < 4 && !pTarget->HasAura(DRAIN_SOUL, EFFECT_INDEX_0) && !pTarget->HasAura(SEED_OF_CORRUPTION, EFFECT_INDEX_0) && !pTarget->HasAura(DRAIN_LIFE, EFFECT_INDEX_0) && !pTarget->HasAura(DRAIN_MANA, EFFECT_INDEX_0) && ai->GetHealthPercent() <= 70 && ai->GetManaPercent() >= 23)
+             {
+                 ai->CastSpell(DRAIN_LIFE, *pTarget);
+                 ai->SetIgnoreUpdateTime(5);
+                 SpellSequence = SPELL_DESTRUCTION;
+                 LastSpellAffliction = LastSpellAffliction +1;
+                 break;
+             }
+             else if (DRAIN_MANA > 0 && pTarget->GetPower(POWER_MANA) > 0 && !pTarget->HasAura(DRAIN_SOUL, EFFECT_INDEX_0) && !pTarget->HasAura(DRAIN_MANA, EFFECT_INDEX_0) && !pTarget->HasAura(SEED_OF_CORRUPTION, EFFECT_INDEX_0) && !pTarget->HasAura(DRAIN_LIFE, EFFECT_INDEX_0) && LastSpellAffliction < 5 && ai->GetManaPercent() < 70 && ai->GetManaPercent() >= 17)
+             {
+                 ai->CastSpell(DRAIN_MANA, *pTarget);
+                 ai->SetIgnoreUpdateTime(5);
+                 SpellSequence = SPELL_DESTRUCTION;
+                 LastSpellAffliction = LastSpellAffliction +1;
+                 break;
+             }
+             else if (UNSTABLE_AFFLICTION > 0 && LastSpellAffliction < 6 && !pTarget->HasAura(UNSTABLE_AFFLICTION, EFFECT_INDEX_0) && !pTarget->HasAura(SHADOWFLAME, EFFECT_INDEX_0) && ai->GetManaPercent() >= 20)
+             {
+                 ai->CastSpell(UNSTABLE_AFFLICTION, *pTarget);
+                 SpellSequence = SPELL_DESTRUCTION;
+                 LastSpellAffliction = LastSpellAffliction +1;
+                 break;
+             }
+             else if (HAUNT > 0 && LastSpellAffliction < 7 && !pTarget->HasAura(HAUNT, EFFECT_INDEX_0) && ai->GetManaPercent() >= 12)
+             {
+                 ai->CastSpell(HAUNT, *pTarget);
+                 SpellSequence = SPELL_DESTRUCTION;
+                 LastSpellAffliction = LastSpellAffliction +1;
+                 break;
+             }
+             else if (ATROCITY > 0 && !pTarget->HasAura(ATROCITY, EFFECT_INDEX_0) && LastSpellAffliction < 8 && ai->GetManaPercent() >= 21)
+             {
+                 ai->CastSpell(ATROCITY, *pTarget);
+                 SpellSequence = SPELL_DESTRUCTION;
+                 LastSpellAffliction = LastSpellAffliction +1;
+                 break;
+             }
+             else if (SEED_OF_CORRUPTION > 0 && !pTarget->HasAura(SEED_OF_CORRUPTION, EFFECT_INDEX_0) && LastSpellAffliction < 9 && ai->GetManaPercent() >= 34)
+             {
+                 ai->CastSpell(SEED_OF_CORRUPTION, *pTarget);
+                 SpellSequence = SPELL_DESTRUCTION;
+                 LastSpellAffliction = LastSpellAffliction +1;
+                 break;
+             }
+             else if (HOWL_OF_TERROR > 0 && !pTarget->HasAura(HOWL_OF_TERROR, EFFECT_INDEX_0) && ai->GetAttackerCount()>3 && LastSpellAffliction < 10 && ai->GetManaPercent() >= 11)
+             {
+                 ai->CastSpell(HOWL_OF_TERROR, *pTarget);
+                 ai->TellMaster("casting howl of terror!");
+                 SpellSequence = SPELL_DESTRUCTION;
+                 LastSpellAffliction = LastSpellAffliction +1;
+                 break;
+             }
+             else if (FEAR > 0 && !pTarget->HasAura(FEAR, EFFECT_INDEX_0) && pVictim==m_bot && ai->GetAttackerCount()>=2 && LastSpellAffliction < 11 && ai->GetManaPercent() >= 12)
+             {
+                 ai->CastSpell(FEAR, *pTarget);
+                 //ai->TellMaster("casting fear!");
+                 ai->SetIgnoreUpdateTime(1.5);
+                 SpellSequence = SPELL_DESTRUCTION;
+                 LastSpellAffliction = LastSpellAffliction +1;
+                 break;
+             }
+             else if(( pet )
+                 && (DARK_PACT > 0 && ai->GetManaPercent() <= 50 && LastSpellAffliction < 12 && pet->GetPower(POWER_MANA) > 0))
+             {
+                 ai->CastSpell(DARK_PACT, *m_bot);
+                 SpellSequence = SPELL_DESTRUCTION;
+                 LastSpellAffliction = LastSpellAffliction +1;
+                 break;
+             }
+             LastSpellAffliction = 0;
+             //SpellSequence = SPELL_DESTRUCTION;
+             //break;
+
+        case SPELL_DESTRUCTION:
+             if (SHADOWFURY > 0 && LastSpellDestruction < 1 && !pTarget->HasAura(SHADOWFURY, EFFECT_INDEX_0) && ai->GetManaPercent() >= 37)
+             {
+                  ai->CastSpell(SHADOWFURY, *pTarget);
+                  SpellSequence = SPELL_CURSES;
+                  LastSpellDestruction = LastSpellDestruction + 1;
+                  break;
+              }
+              else if (SHADOW_BOLT > 0 && LastSpellDestruction < 2 && ai->GetManaPercent() >= 23)
+              {
+                  ai->CastSpell(SHADOW_BOLT, *pTarget);
+                  SpellSequence = SPELL_CURSES;
+                  LastSpellDestruction = LastSpellDestruction + 1;
+                  break;
+              }
+              else if (RAIN_OF_FIRE > 0 && LastSpellDestruction < 3 && ai->GetAttackerCount()>=3 && ai->GetManaPercent() >= 77)
+              {
+                  ai->CastSpell(RAIN_OF_FIRE, *pTarget);
+                  //ai->TellMaster("casting rain of fire!");
+                  ai->SetIgnoreUpdateTime(8);
+                  SpellSequence = SPELL_CURSES;
+                  LastSpellDestruction = LastSpellDestruction + 1;
+                  break;
+              }
+              else if (SHADOWFLAME > 0 && !pTarget->HasAura(SHADOWFLAME, EFFECT_INDEX_0) && LastSpellDestruction < 4 && ai->GetManaPercent() >= 25)
+              {
+                  ai->CastSpell(SHADOWFLAME, *pTarget);
+                  SpellSequence = SPELL_CURSES;
+                  LastSpellDestruction = LastSpellDestruction + 1;
+                  break;
+              }
+              else if (IMMOLATE > 0 && !pTarget->HasAura(IMMOLATE, EFFECT_INDEX_0) && !pTarget->HasAura(SHADOWFLAME, EFFECT_INDEX_0) && LastSpellDestruction < 5 && ai->GetManaPercent() >= 23)
+              {
+                  ai->CastSpell(IMMOLATE, *pTarget);
+                  SpellSequence = SPELL_CURSES;
+                  LastSpellDestruction = LastSpellDestruction + 1;
+                  break;
+              }
+              else if (CONFLAGRATE > 0 && LastSpellDestruction < 6 && ai->GetManaPercent() >= 16)
+              {
+                  ai->CastSpell(CONFLAGRATE, *pTarget);
+                  SpellSequence = SPELL_CURSES;
+                  LastSpellDestruction = LastSpellDestruction + 1;
+                  break;
+              }
+              else if (INCINERATE > 0 && LastSpellDestruction < 7 && ai->GetManaPercent() >= 19)
+              {
+                  ai->CastSpell(INCINERATE, *pTarget);
+                  SpellSequence = SPELL_CURSES;
+                  LastSpellDestruction = LastSpellDestruction + 1;
+                  break;
+              }
+              else if (SEARING_PAIN > 0 && LastSpellDestruction < 8 && ai->GetManaPercent() >= 11)
+              {
+                  ai->CastSpell(SEARING_PAIN, *pTarget);
+                  SpellSequence = SPELL_CURSES;
+                  LastSpellDestruction = LastSpellDestruction + 1;
+                  break;
+              }
+              else if (SOUL_FIRE > 0 && LastSpellDestruction < 9 && ai->GetManaPercent() >= 13)
+              {
+                  ai->CastSpell(SOUL_FIRE, *pTarget);
+                  ai->SetIgnoreUpdateTime(6);
+                  SpellSequence = SPELL_CURSES;
+                  LastSpellDestruction = LastSpellDestruction + 1;
+                  break;
+              }
+              else if (CHAOS_BOLT > 0 && LastSpellDestruction < 10 && ai->GetManaPercent() >= 9)
+              {
+                  ai->CastSpell(CHAOS_BOLT, *pTarget);
+                  SpellSequence = SPELL_CURSES;
+                  LastSpellDestruction = LastSpellDestruction + 1;
+                  break;
+              }
+              else if (SHADOWBURN > 0 && LastSpellDestruction < 11 && pTarget->GetHealth() < pTarget->GetMaxHealth()*0.20 && !pTarget->HasAura(SHADOWBURN, EFFECT_INDEX_0) && ai->GetManaPercent() >= 27)
+              {
+                  ai->CastSpell(SHADOWBURN, *pTarget);
+                  SpellSequence = SPELL_CURSES;
+                  LastSpellDestruction = LastSpellDestruction + 1;
+                  break;
+              }
+              else if (HELLFIRE > 0 && LastSpellDestruction < 12 && !m_bot->HasAura(HELLFIRE, EFFECT_INDEX_0) && ai->GetAttackerCount()>=5 && ai->GetHealthPercent() >= 10 && ai->GetManaPercent() >= 87)
+              {
+                  ai->CastSpell(HELLFIRE);
+                  ai->TellMaster("casting hellfire!");
+                  ai->SetIgnoreUpdateTime(15);
+                  SpellSequence = SPELL_CURSES;
+                  LastSpellDestruction = LastSpellDestruction + 1;
+                  break;
+              }
+              else
+              {
+                  LastSpellDestruction = 0;
+                  SpellSequence = SPELL_CURSES;
+              }
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotWarlockAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    if( !ai )
+        return;
+
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    SpellSequence = SPELL_CURSES;
+
+    Pet *pet = m_bot->GetPet();
+
+    // buff myself DEMON_SKIN, DEMON_ARMOR, FEL_ARMOR
+    if (FEL_ARMOR > 0)
+        (!m_bot->HasAura(FEL_ARMOR, EFFECT_INDEX_0) && ai->CastSpell(FEL_ARMOR, *m_bot));
+    else if (DEMON_ARMOR > 0)
+        (!m_bot->HasAura(DEMON_ARMOR, EFFECT_INDEX_0) && !m_bot->HasAura(FEL_ARMOR, EFFECT_INDEX_0) && ai->CastSpell(DEMON_ARMOR, *m_bot));
+    else if (DEMON_SKIN > 0)
+        (!m_bot->HasAura(DEMON_SKIN, EFFECT_INDEX_0) && !m_bot->HasAura(FEL_ARMOR, EFFECT_INDEX_0) && !m_bot->HasAura(DEMON_ARMOR, EFFECT_INDEX_0) && ai->CastSpell(DEMON_SKIN, *m_bot));
+
+    // buff myself & master DETECT_INVISIBILITY
+    if (DETECT_INVISIBILITY > 0)
+        (!m_bot->HasAura(DETECT_INVISIBILITY, EFFECT_INDEX_0) && ai->GetManaPercent() >= 2 && ai->CastSpell(DETECT_INVISIBILITY, *m_bot));
+    if (DETECT_INVISIBILITY > 0)
+        (!GetMaster()->HasAura(DETECT_INVISIBILITY, EFFECT_INDEX_0) && ai->GetManaPercent() >= 2 && ai->CastSpell(DETECT_INVISIBILITY, *GetMaster()));
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+	Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 25)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+    else if(( pet )
+        && (pItem == NULL && DARK_PACT>0 && ai->GetManaPercent() <= 50 && pet->GetPower(POWER_MANA) > 0) )
+    {
+        ai->CastSpell(DARK_PACT, *m_bot);
+        //ai->TellMaster("casting dark pact.");
+        return;
+    }
+    else if(( !pet )
+        && (pItem == NULL && LIFE_TAP>0 && ai->GetManaPercent() <= 50 && ai->GetHealthPercent() > 25) )
+    {
+        ai->CastSpell(LIFE_TAP, *m_bot);
+        //ai->TellMaster("casting life tap.");
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, EFFECT_INDEX_0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(*fItem);
+        ai->SetIgnoreUpdateTime(8);
+        return;
+    }
+    else if(( pet )
+        && (pItem == NULL && fItem == NULL && CONSUME_SHADOWS>0 && !m_bot->HasAura(CONSUME_SHADOWS, EFFECT_INDEX_0) && ai->GetHealthPercent() < 75) )
+    {
+        ai->CastSpell(CONSUME_SHADOWS, *m_bot);
+        //ai->TellMaster("casting consume shadows.");
+        return;
+    }
+
+    // check for demon
+    if( SUMMON_FELGUARD>0 || SUMMON_FELHUNTER>0 || SUMMON_SUCCUBUS>0 || SUMMON_VOIDWALKER>0 || SUMMON_IMP>0 && !m_demonSummonFailed )
+    {
+        if( !pet )
+        {
+            // summon demon
+            if( SUMMON_FELGUARD>0 && ai->CastSpell(SUMMON_FELGUARD,*m_bot) )
+                ai->TellMaster( "summoning felguard." );
+            else if( SUMMON_FELHUNTER>0 && ai->CastSpell(SUMMON_FELHUNTER,*m_bot) )
+                ai->TellMaster( "summoning felhunter." );
+            else if( SUMMON_SUCCUBUS>0 && ai->CastSpell(SUMMON_SUCCUBUS,*m_bot) )
+                ai->TellMaster( "summoning succubus." );
+            else if( SUMMON_VOIDWALKER>0 && ai->CastSpell(SUMMON_VOIDWALKER,*m_bot) )
+                ai->TellMaster( "summoning voidwalker." );
+            else if( SUMMON_IMP>0 && ai->GetManaPercent() >= 64 && ai->CastSpell(SUMMON_IMP,*m_bot) )
+                ai->TellMaster( "summoning imp." );
+            else
+            {
+                m_demonSummonFailed = true;
+                //ai->TellMaster( "summon demon failed!" );
+            }
+        }
+    }
+
+    // check for buffs with demon
+    if(( pet )
+        && ( SOUL_LINK>0 && !m_bot->HasAura(SOUL_LINK, EFFECT_INDEX_0) && ai->GetManaPercent() >= 16 && ai->CastSpell(SOUL_LINK,*m_bot) ))
+    {
+        //ai->TellMaster( "casting soul link." );
+        return;
+    }
+    else if(( pet )
+        && ( BLOOD_PACT>0 && !m_bot->HasAura(BLOOD_PACT, EFFECT_INDEX_0) && ai->CastSpell(BLOOD_PACT,*m_bot) ))
+    {
+        //ai->TellMaster( "casting blood pact." );
+        return;
+    }
+    else if(( pet )
+        && ( FEL_INTELLIGENCE>0 && !m_bot->HasAura(FEL_INTELLIGENCE, EFFECT_INDEX_0) && ai->CastSpell(FEL_INTELLIGENCE,*m_bot) ))
+    {
+        //ai->TellMaster( "casting fel intelligence." );
+        return;
+    }
+} // end DoNonCombatActions
diff --git a/Core/src/game/PlayerbotWarlockAI.h b/Core/src/game/PlayerbotWarlockAI.h
new file mode 100644
index 0000000..8058c4b
--- /dev/null
+++ b/Core/src/game/PlayerbotWarlockAI.h
@@ -0,0 +1,61 @@
+#ifndef _PlayerbotWarlockAI_H
+#define _PlayerbotWarlockAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_CURSES,
+    SPELL_AFFLICTION,
+    SPELL_DESTRUCTION,
+    SPELL_DEMONOLOGY
+};
+
+//class Player;
+class MANGOS_DLL_SPEC PlayerbotWarlockAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotWarlockAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
+        virtual ~PlayerbotWarlockAI();
+
+        // all combat actions go here
+        void DoNextCombatManeuver(Unit*);
+
+        // all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        // buff a specific player, usually a real PC who is not in group
+        //void BuffPlayer(Player *target);
+
+    private:
+
+        bool m_demonSummonFailed;
+
+        // CURSES
+        uint32 CURSE_OF_WEAKNESS, CURSE_OF_AGONY, CURSE_OF_EXHAUSTION, CURSE_OF_TONGUES, CURSE_OF_THE_ELEMENTS, CURSE_OF_DOOM;
+
+        // AFFLICTION
+        uint32 CORRUPTION, DRAIN_SOUL, DRAIN_LIFE, DRAIN_MANA, LIFE_TAP, UNSTABLE_AFFLICTION, HAUNT, ATROCITY, SEED_OF_CORRUPTION, DARK_PACT, HOWL_OF_TERROR, FEAR;
+
+        // DESTRUCTION
+        uint32 SHADOW_BOLT, IMMOLATE, INCINERATE, SEARING_PAIN, CONFLAGRATE, SOUL_FIRE, SHADOWFURY, CHAOS_BOLT, SHADOWFLAME, HELLFIRE, RAIN_OF_FIRE, SHADOWBURN;
+
+        // DEMONOLOGY
+        uint32 DEMON_SKIN, DEMON_ARMOR, SHADOW_WARD, FEL_ARMOR, SOULSHATTER, SOUL_LINK, HEALTH_FUNNEL, DETECT_INVISIBILITY;
+
+        // DEMON SUMMON
+        uint32 SUMMON_IMP, SUMMON_VOIDWALKER, SUMMON_SUCCUBUS, SUMMON_FELHUNTER, SUMMON_FELGUARD;
+
+        // DEMON SKILLS
+        uint32 BLOOD_PACT, CONSUME_SHADOWS, FEL_INTELLIGENCE;
+
+        // first aid
+        uint32 RECENTLY_BANDAGED;
+
+        // racial
+        uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+        uint32 SpellSequence, LastSpellCurse, LastSpellAffliction, LastSpellDestruction;
+};
+
+#endif
diff --git a/Core/src/game/PlayerbotWarriorAI.cpp b/Core/src/game/PlayerbotWarriorAI.cpp
new file mode 100644
index 0000000..742bce6
--- /dev/null
+++ b/Core/src/game/PlayerbotWarriorAI.cpp
@@ -0,0 +1,365 @@
+    /*
+    Name    : PlayerbotWarriorAI.cpp
+    Complete: maybe around 37%
+    Author  : Natsukawa
+    Version : 0.39
+    */
+#include "PlayerbotWarriorAI.h"
+#include "PlayerbotMgr.h"
+
+class PlayerbotAI;
+PlayerbotWarriorAI::PlayerbotWarriorAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    BATTLE_STANCE           = ai->getSpellId("battle stance"); //ARMS
+    CHARGE                  = ai->getSpellId("charge"); //ARMS
+    OVERPOWER               = ai->getSpellId("overpower"); // ARMS
+    HEROIC_STRIKE           = ai->getSpellId("heroic strike"); //ARMS
+    REND                    = ai->getSpellId("rend"); //ARMS
+    THUNDER_CLAP            = ai->getSpellId("thunder");  //ARMS
+    HAMSTRING               = ai->getSpellId("hamstring");  //ARMS
+    MOCKING_BLOW            = ai->getSpellId("mocking blow");  //ARMS
+    RETALIATION             = ai->getSpellId("retaliation");  //ARMS
+    SWEEPING_STRIKES        = ai->getSpellId("sweeping strikes"); //ARMS
+    MORTAL_STRIKE           = ai->getSpellId("mortal strike");  //ARMS
+    BLADESTORM              = ai->getSpellId("bladestorm");  //ARMS
+    HEROIC_THROW            = ai->getSpellId("heroic throw");  //ARMS
+    SHATTERING_THROW        = ai->getSpellId("shattering throw");  //ARMS
+    BLOODRAGE               = ai->getSpellId("bloodrage"); //PROTECTION
+    DEFENSIVE_STANCE        = ai->getSpellId("defensive stance"); //PROTECTION
+    DEVASTATE               = ai->getSpellId("devastate"); //PROTECTION
+    SUNDER_ARMOR            = ai->getSpellId("sunder armor"); //PROTECTION
+    TAUNT                   = ai->getSpellId("taunt"); //PROTECTION
+    SHIELD_BASH             = ai->getSpellId("shield bash"); //PROTECTION
+    REVENGE                 = ai->getSpellId("revenge"); //PROTECTION
+    SHIELD_BLOCK            = ai->getSpellId("shield block"); //PROTECTION
+    DISARM                  = ai->getSpellId("disarm"); //PROTECTION
+    SHIELD_WALL             = ai->getSpellId("shield wall"); //PROTECTION
+    SHIELD_SLAM             = ai->getSpellId("shield slam"); //PROTECTION
+    VIGILANCE               = ai->getSpellId("vigilance"); //PROTECTION
+    DEVASTATE               = ai->getSpellId("devastate"); //PROTECTION
+    SHOCKWAVE               = ai->getSpellId("shockwave"); //PROTECTION
+    CONCUSSION_BLOW         = ai->getSpellId("blow"); //PROTECTION
+    SPELL_REFLECTION        = ai->getSpellId("spell reflection"); //PROTECTION
+    LAST_STAND              = ai->getSpellId("last stand"); //PROTECTION
+    BATTLE_SHOUT            = ai->getSpellId("battle shout"); //FURY
+    DEMORALIZING_SHOUT      = ai->getSpellId("demoralizing shout"); //FURY
+    CLEAVE                  = ai->getSpellId("cleave"); //FURY
+    INTIMIDATING_SHOUT      = ai->getSpellId("shout"); //FURY
+    EXECUTE                 = ai->getSpellId("execute"); //FURY
+    CHALLENGING_SHOUT       = ai->getSpellId("challenging shout"); //FURY
+    SLAM                    = ai->getSpellId("slam"); //FURY
+    BERSERKER_STANCE        = ai->getSpellId("berserker stance"); //FURY
+    INTERCEPT               = ai->getSpellId("intercept"); //FURY
+    DEATH_WISH              = ai->getSpellId("death wish");//FURY
+    BERSERKER_RAGE          = ai->getSpellId("berserker rage");//FURY
+    WHIRLWIND               = ai->getSpellId("whirlwind");//FURY
+    PUMMEL                  = ai->getSpellId("pummel"); //FURY
+    BLOODTHIRST             = ai->getSpellId("bloodthirst"); //FURY
+    RECKLESSNESS            = ai->getSpellId("recklessness"); //FURY
+    RAMPAGE                 = ai->getSpellId("rampage"); //FURY
+    HEROIC_FURY             = ai->getSpellId("heroic fury"); //FURY
+    COMMANDING_SHOUT        = ai->getSpellId("commanding shout"); //FURY
+    ENRAGED_REGENERATION    = ai->getSpellId("enraged regeneration"); //FURY
+    PIERCING_HOWL           = ai->getSpellId("piercing howl"); //FURY
+
+    RECENTLY_BANDAGED       = 11196; // first aid check
+
+    // racial
+    GIFT_OF_THE_NAARU       = ai->getSpellId("gift of the naaru"); // draenei
+    STONEFORM               = ai->getSpellId("stoneform"); // dwarf
+    ESCAPE_ARTIST           = ai->getSpellId("escape artist"); // gnome
+    EVERY_MAN_FOR_HIMSELF   = ai->getSpellId("every man for himself"); // human
+    SHADOWMELD              = ai->getSpellId("shadowmeld"); // night elf
+    BLOOD_FURY              = ai->getSpellId("blood fury"); // orc
+    WAR_STOMP               = ai->getSpellId("war stomp"); // tauren
+    BERSERKING              = ai->getSpellId("berserking"); // troll
+    WILL_OF_THE_FORSAKEN    = ai->getSpellId("will of the forsaken"); // undead
+}
+PlayerbotWarriorAI::~PlayerbotWarriorAI() {}
+
+bool PlayerbotWarriorAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    Player *m_bot = GetPlayerBot();
+    PlayerbotAI *ai = GetAI();
+    PlayerbotAI::CombatOrderType co = ai->GetCombatOrder();
+    float fTargetDist = m_bot->GetDistance( pTarget );
+
+    if( (co&PlayerbotAI::ORDERS_TANK) && DEFENSIVE_STANCE>0 && !m_bot->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0) && ai->CastSpell(DEFENSIVE_STANCE) )
+    {
+        if( ai->GetManager()->m_confDebugWhisper )
+            ai->TellMaster( "First > Defensive Stance (%d)", DEFENSIVE_STANCE );
+        return true;
+    }
+    else if( (co&PlayerbotAI::ORDERS_TANK) && TAUNT>0 && m_bot->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0) && ai->CastSpell(TAUNT,*pTarget) )
+    {
+        if( ai->GetManager()->m_confDebugWhisper )
+            ai->TellMaster( "First > Taunt (%d)", TAUNT );
+        return false;
+    }
+    else if( BATTLE_STANCE>0 && !m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0) && ai->CastSpell(BATTLE_STANCE) )
+    {
+        if( ai->GetManager()->m_confDebugWhisper )
+            ai->TellMaster( "First > Battle Stance (%d)", BATTLE_STANCE );
+        return true;
+    }
+    else if( BATTLE_STANCE>0 && CHARGE>0 && m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0) )
+    {
+        if( fTargetDist<8.0f )
+            return false;
+        else if( fTargetDist>25.0f )
+            return true;
+        else if( CHARGE>0 && ai->CastSpell(CHARGE,*pTarget) )
+        {
+            float x, y, z;
+            pTarget->GetContactPoint( m_bot, x, y, z, 3.666666f );
+            m_bot->Relocate( x, y, z );
+
+            if( ai->GetManager()->m_confDebugWhisper )
+                ai->TellMaster( "First > Charge (%d)", CHARGE );
+            return false;
+        }
+    }
+
+    return false;
+}
+
+void PlayerbotWarriorAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (HEROIC_STRIKE > 0)
+                ai->CastSpell(HEROIC_STRIKE);
+            return;
+    }
+    // ------- Non Duel combat ----------
+
+    //ai->SetMovementOrder( PlayerbotAI::MOVEMENT_FOLLOW, GetMaster() ); // dont want to melee mob
+
+    // Damage Attacks
+
+    ai->SetInFront( pTarget );
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    float fTargetDist = m_bot->GetDistance( pTarget );
+    PlayerbotAI::CombatOrderType co = ai->GetCombatOrder();
+
+    // decide what stance to use
+    if( (co&PlayerbotAI::ORDERS_TANK) && !m_bot->HasAura(DEFENSIVE_STANCE, EFFECT_INDEX_0) && ai->CastSpell(DEFENSIVE_STANCE) )
+        if( ai->GetManager()->m_confDebugWhisper )
+            ai->TellMaster( "Stance > Defensive" );
+    else if( !(co&PlayerbotAI::ORDERS_TANK) && !m_bot->HasAura(BATTLE_STANCE, EFFECT_INDEX_0) && ai->CastSpell(BATTLE_STANCE) )
+        if( ai->GetManager()->m_confDebugWhisper )
+            ai->TellMaster( "Stance > Battle" );
+
+    // get spell sequence
+    if( pTarget->IsNonMeleeSpellCasted(true) )
+        SpellSequence = WarriorSpellPreventing;
+    else if( m_bot->HasAura( BATTLE_STANCE, EFFECT_INDEX_0) )
+        SpellSequence = WarriorBattle;
+    else if( m_bot->HasAura( DEFENSIVE_STANCE, EFFECT_INDEX_0) )
+        SpellSequence = WarriorDefensive;
+    else if( m_bot->HasAura( BERSERKER_STANCE, EFFECT_INDEX_0) )
+        SpellSequence = WarriorBerserker;
+
+    // do shouts, berserker rage, etc...
+    if( BERSERKER_RAGE>0 && !m_bot->HasAura( BERSERKER_RAGE, EFFECT_INDEX_0) && ai->CastSpell( BERSERKER_RAGE ) )
+        if( ai->GetManager()->m_confDebugWhisper )
+            ai->TellMaster( "Pre > Berseker Rage" );
+    else if( DEMORALIZING_SHOUT>0 && ai->GetRageAmount()>=10 && !pTarget->HasAura( DEMORALIZING_SHOUT, EFFECT_INDEX_0) && ai->CastSpell( DEMORALIZING_SHOUT ) )
+        if( ai->GetManager()->m_confDebugWhisper )
+            ai->TellMaster( "Pre > Demoralizing Shout" );
+    else if( BATTLE_SHOUT>0 && ai->GetRageAmount()>=10 && !m_bot->HasAura( BATTLE_SHOUT, EFFECT_INDEX_0) && ai->CastSpell( BATTLE_SHOUT ) )
+        if( ai->GetManager()->m_confDebugWhisper )
+            ai->TellMaster( "Pre > Battle Shout" );
+
+    std::ostringstream out;
+    switch (SpellSequence)
+    {
+        case WarriorSpellPreventing:
+            out << "Case Prevent";
+            if( SHIELD_BASH>0 && ai->GetRageAmount()>=10 && ai->CastSpell( SHIELD_BASH, *pTarget ) )
+                out << " > Shield Bash";
+            else if( PUMMEL>0 && ai->GetRageAmount()>=10 && ai->CastSpell( PUMMEL, *pTarget ) )
+                out << " > Pummel";
+            else if( SPELL_REFLECTION>0 && ai->GetRageAmount()>=15 && !m_bot->HasAura( SPELL_REFLECTION, EFFECT_INDEX_0) && ai->CastSpell( SPELL_REFLECTION, *m_bot ) )
+                out << " > Spell Reflection";
+            else
+                out << " > NONE";
+            break;
+
+        case WarriorBattle:
+                out << "Case Battle";
+            if( EXECUTE>0 && ai->GetRageAmount()>=15 && pTarget->GetHealth() < pTarget->GetMaxHealth()*0.2 && ai->CastSpell( EXECUTE, *pTarget ) )
+                out << " > Execute!";
+            else if( LAST_STAND>0 && !m_bot->HasAura( LAST_STAND, EFFECT_INDEX_0) && m_bot->GetHealth() < m_bot->GetMaxHealth()*0.5 && ai->CastSpell( LAST_STAND, *m_bot ) )
+                out << " > Last Stand!";
+            else if( BLOODRAGE>0 && ai->GetRageAmount()<50 && !m_bot->HasAura( BLOODRAGE, EFFECT_INDEX_0) && ai->CastSpell( BLOODRAGE, *m_bot ) )
+                out << " > Bloodrage";
+            else if( DEATH_WISH>0 && ai->GetRageAmount()>=10 && !m_bot->HasAura( DEATH_WISH, EFFECT_INDEX_0) && ai->CastSpell( DEATH_WISH, *m_bot ) )
+                out << " > Death Wish";
+            else if( RETALIATION>0 && pVictim == m_bot && ai->GetAttackerCount()>=2 && !m_bot->HasAura( RETALIATION, EFFECT_INDEX_0) && ai->CastSpell( RETALIATION, *m_bot ) )
+                out << " > Retaliation";
+            else if( DEMORALIZING_SHOUT>0 && ai->GetRageAmount()>=10 && !pTarget->HasAura( DEMORALIZING_SHOUT, EFFECT_INDEX_0) && ai->CastSpell( DEMORALIZING_SHOUT, *pTarget ) )
+                out << " > Demoralizing Shout";
+            else if( SWEEPING_STRIKES>0 && ai->GetRageAmount()>=30 && ai->GetAttackerCount()>=2 && !m_bot->HasAura( SWEEPING_STRIKES, EFFECT_INDEX_0) && ai->CastSpell( SWEEPING_STRIKES, *m_bot ) )
+                out << " > Sweeping Strikes!";
+            else if( BLADESTORM>0 && ai->GetRageAmount()>=25 && pVictim == m_bot && !m_bot->HasAura( BLADESTORM, EFFECT_INDEX_0) && ai->GetAttackerCount()>=3 && ai->CastSpell( BLADESTORM, *pTarget ) )
+                out << " > Bladestorm!";
+            else if( MORTAL_STRIKE>0 && ai->GetRageAmount()>=30 && !pTarget->HasAura( MORTAL_STRIKE, EFFECT_INDEX_0) && ai->CastSpell( MORTAL_STRIKE, *pTarget ) )
+                out << " > Mortal Strike";
+            else if( INTIMIDATING_SHOUT>0 && ai->GetRageAmount()>=25 && ai->GetAttackerCount()>5 && ai->CastSpell( INTIMIDATING_SHOUT, *pTarget ) )
+                out << " > Intimidating Shout";
+            else if( THUNDER_CLAP>0 && ai->GetRageAmount()>=20 && pVictim == m_bot && !pTarget->HasAura( THUNDER_CLAP, EFFECT_INDEX_0) && ai->CastSpell( THUNDER_CLAP, *pTarget ) )
+                out << " > Thunder Clap";
+            else if( ENRAGED_REGENERATION>0 && ai->GetRageAmount()>=15 && !m_bot->HasAura( BERSERKER_RAGE, EFFECT_INDEX_0) && !m_bot->HasAura( ENRAGED_REGENERATION, EFFECT_INDEX_0) && m_bot->GetHealth() < m_bot->GetMaxHealth()*0.5 && ai->CastSpell( ENRAGED_REGENERATION, *m_bot ) )
+                out << " > Enraged Regeneration";
+            else if( SHOCKWAVE>0 && ai->GetRageAmount()>=15 && pVictim == m_bot && !pTarget->HasAura( WAR_STOMP, EFFECT_INDEX_0) && !pTarget->HasAura( PIERCING_HOWL, EFFECT_INDEX_0) && !pTarget->HasAura( SHOCKWAVE, EFFECT_INDEX_0) && !pTarget->HasAura( CONCUSSION_BLOW, EFFECT_INDEX_0) && ai->CastSpell( SHOCKWAVE, *pTarget ) )
+                out << " > Shockwave";
+            else if( REND>0 && ai->GetRageAmount()>=10 && !pTarget->HasAura( REND, EFFECT_INDEX_0) && ai->CastSpell( REND, *pTarget ) )
+                out << " > Rend";
+            else if( HAMSTRING>0 && ai->GetRageAmount()>=10 && !pTarget->HasAura( HAMSTRING, EFFECT_INDEX_0) && ai->CastSpell( HAMSTRING, *pTarget ) )
+                out << " > Hamstring";
+            else if( CHALLENGING_SHOUT>0 && ai->GetRageAmount()>=5 && pVictim != m_bot && ai->GetHealthPercent() > 25 && !pTarget->HasAura( MOCKING_BLOW, EFFECT_INDEX_0) && !pTarget->HasAura( CHALLENGING_SHOUT, EFFECT_INDEX_0) && ai->CastSpell( CHALLENGING_SHOUT, *pTarget ) )
+                out << " > Challenging Shout";
+            else if( BLOODTHIRST>0 && ai->GetRageAmount()>=20 && !m_bot->HasAura( BLOODTHIRST, EFFECT_INDEX_0) && m_bot->GetHealth() < m_bot->GetMaxHealth()*0.7 && ai->CastSpell( BLOODTHIRST, *pTarget ) )
+                out << " > Bloodthrist";
+            else if( CLEAVE>0 && ai->GetRageAmount()>=20 && ai->CastSpell( CLEAVE, *pTarget ) )
+                out << " > Cleave";
+            else if( HEROIC_STRIKE>0 && ai->GetRageAmount()>=15 && ai->CastSpell( HEROIC_STRIKE, *pTarget ) )
+                out << " > Heroic Strike";
+            else if( CONCUSSION_BLOW>0 && ai->GetRageAmount()>=15 && !pTarget->HasAura( WAR_STOMP, EFFECT_INDEX_0) && !pTarget->HasAura( PIERCING_HOWL, EFFECT_INDEX_0) && !pTarget->HasAura( SHOCKWAVE, EFFECT_INDEX_0) && !pTarget->HasAura( CONCUSSION_BLOW, EFFECT_INDEX_0) && ai->CastSpell( CONCUSSION_BLOW, *pTarget ) )
+                out << " > Concussion Blow";
+            else if( SLAM>0 && ai->GetRageAmount()>=15 && ai->CastSpell( SLAM, *pTarget ) )
+                out << " > Slam";
+            else if( PIERCING_HOWL>0 && ai->GetRageAmount()>=10 && ai->GetAttackerCount()>=3 && !pTarget->HasAura( WAR_STOMP, EFFECT_INDEX_0) && !pTarget->HasAura( PIERCING_HOWL, EFFECT_INDEX_0) && !pTarget->HasAura( SHOCKWAVE, EFFECT_INDEX_0) && !pTarget->HasAura( CONCUSSION_BLOW, EFFECT_INDEX_0) && ai->CastSpell( PIERCING_HOWL, *pTarget ) )
+                out << " > Piercing Howl";
+            else if( MOCKING_BLOW>0 && ai->GetRageAmount()>=10 && pVictim != m_bot && ai->GetHealthPercent() > 25 && !pTarget->HasAura( MOCKING_BLOW, EFFECT_INDEX_0) && !pTarget->HasAura( CHALLENGING_SHOUT, EFFECT_INDEX_0) && ai->CastSpell( MOCKING_BLOW, *pTarget ) )
+                out << " > Mocking Blow";
+            else if( OVERPOWER>0 && ai->GetRageAmount()>=5 && ai->CastSpell( OVERPOWER, *pTarget ) )
+                out << " > Overpower";
+            else if( SUNDER_ARMOR>0 && ai->CastSpell( SUNDER_ARMOR, *pTarget ) )
+                out << " > Sunder Armor";
+            else if( SHATTERING_THROW>0 && !pTarget->HasAura( SHATTERING_THROW, EFFECT_INDEX_0) && ai->CastSpell( SHATTERING_THROW, *pTarget ) )
+                out << " > Shattering Throw";
+            else if( HEROIC_THROW>0 && ai->CastSpell( HEROIC_THROW, *pTarget ) )
+                out << " > Heroic Throw";
+            else if( m_bot->getRace() == RACE_TAUREN && !pTarget->HasAura( WAR_STOMP, EFFECT_INDEX_0) && !pTarget->HasAura( PIERCING_HOWL, EFFECT_INDEX_0) && !pTarget->HasAura( SHOCKWAVE, EFFECT_INDEX_0) && !pTarget->HasAura( CONCUSSION_BLOW, EFFECT_INDEX_0) && ai->CastSpell( WAR_STOMP, *pTarget ) )
+                out << " > War Stomp";
+            else if( m_bot->getRace() == RACE_HUMAN && m_bot->hasUnitState( UNIT_STAT_STUNNED ) || m_bot->HasAuraType( SPELL_AURA_MOD_FEAR ) || m_bot->HasAuraType( SPELL_AURA_MOD_DECREASE_SPEED ) || m_bot->HasAuraType( SPELL_AURA_MOD_CHARM ) && ai->CastSpell( EVERY_MAN_FOR_HIMSELF, *m_bot ) )
+                out << " > Every Man for Himself";
+            else if( m_bot->getRace() == RACE_UNDEAD_PLAYER && m_bot->HasAuraType( SPELL_AURA_MOD_FEAR ) || m_bot->HasAuraType( SPELL_AURA_MOD_CHARM ) && ai->CastSpell( WILL_OF_THE_FORSAKEN, *m_bot ) )
+                out << " > Will of the Forsaken";
+            else if( m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState( AURA_STATE_DEADLY_POISON ) && ai->CastSpell( STONEFORM, *m_bot ) )
+                out << " > Stoneform";
+            else if( m_bot->getRace() == RACE_GNOME && m_bot->hasUnitState( UNIT_STAT_STUNNED ) || m_bot->HasAuraType( SPELL_AURA_MOD_DECREASE_SPEED ) && ai->CastSpell( ESCAPE_ARTIST, *m_bot ) )
+                out << " > Escape Artist";
+            else if( m_bot->getRace() == RACE_NIGHTELF && pVictim == m_bot && ai->GetHealthPercent() < 25 && !m_bot->HasAura( SHADOWMELD, EFFECT_INDEX_0) && ai->CastSpell( SHADOWMELD, *m_bot ) )
+                out << " > Shadowmeld";
+            else if( m_bot->getRace() == RACE_ORC && !m_bot->HasAura( BLOOD_FURY, EFFECT_INDEX_0) && ai->CastSpell( BLOOD_FURY, *m_bot ) )
+                out << " > Blood Fury";
+            else if( m_bot->getRace() == RACE_TROLL && !m_bot->HasAura( BERSERKING, EFFECT_INDEX_0) && ai->CastSpell( BERSERKING, *m_bot ) )
+                out << " > Berserking";
+            else if( m_bot->getRace() == RACE_DRAENEI && ai->GetHealthPercent() < 25 && !m_bot->HasAura(GIFT_OF_THE_NAARU, EFFECT_INDEX_0) && ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot) )
+                out << " > Gift of the Naaru";
+            else
+                out << " > NONE";
+            break;
+
+        case WarriorDefensive:
+            out << "Case Defensive";
+            if( DISARM>0 && ai->GetRageAmount()>=15 && !pTarget->HasAura( DISARM, EFFECT_INDEX_0) && ai->CastSpell( DISARM, *pTarget ) )
+                out << " > Disarm";
+            else if( SUNDER_ARMOR>0 && ai->GetRageAmount()>=15 && ai->CastSpell( SUNDER_ARMOR, *pTarget ) )
+                out << " > Sunder Armor";
+            else if( REVENGE>0 && ai->GetRageAmount()>=5 && ai->CastSpell( REVENGE, *pTarget ) )
+                out << " > Revenge";
+            else if( SHIELD_BLOCK>0 && !m_bot->HasAura( SHIELD_BLOCK, EFFECT_INDEX_0) && ai->CastSpell( SHIELD_BLOCK, *m_bot ) )
+                out << " > Shield Block";
+            else if( SHIELD_WALL>0 && !m_bot->HasAura( SHIELD_WALL, EFFECT_INDEX_0) && ai->CastSpell( SHIELD_WALL, *m_bot ) )
+                out << " > Shield Wall";
+            else
+                out << " > NONE";
+            break;
+
+        case WarriorBerserker:
+                out << "Case Berserker";
+            if( WHIRLWIND>0 && ai->GetRageAmount()>=25 && ai->CastSpell( WHIRLWIND, *pTarget ) )
+                out << " > Whirlwind";
+            out << " > NONE";
+            break;
+    }
+    if( ai->GetManager()->m_confDebugWhisper )
+        ai->TellMaster( out.str().c_str() );
+}
+
+void PlayerbotWarriorAI::DoNonCombatActions()
+{
+	PlayerbotAI *ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // TODO (by Runsttren): check if shout aura bot has is casted by this bot,
+    // otherwise cast other useful shout
+    // If the bot is protect talented, she/he needs stamina not attack power.
+    // With stance change can the shout change to.
+    // Inserted line to battle shout m_bot->HasAura( COMMANDING_SHOUT, EFFECT_INDEX_0)
+    // Natsukawa
+    if( ( (COMMANDING_SHOUT>0 && !m_bot->HasAura( COMMANDING_SHOUT, EFFECT_INDEX_0)) ||
+        (BATTLE_SHOUT>0 && !m_bot->HasAura( BATTLE_SHOUT, EFFECT_INDEX_0)) ) &&
+        ai->GetRageAmount()<10 && BLOODRAGE>0 && !m_bot->HasAura( BLOODRAGE, EFFECT_INDEX_0) )
+    {
+        // we do have a useful shout, no rage coming but can cast bloodrage... do it
+        ai->CastSpell( BLOODRAGE, *m_bot );
+    }
+    else if( COMMANDING_SHOUT>0 && !m_bot->HasAura( COMMANDING_SHOUT, EFFECT_INDEX_0) )
+    {
+        // use commanding shout now
+        ai->CastSpell( COMMANDING_SHOUT, *m_bot );
+    }
+    else if( BATTLE_SHOUT>0 && !m_bot->HasAura( BATTLE_SHOUT, EFFECT_INDEX_0) && !m_bot->HasAura( COMMANDING_SHOUT, EFFECT_INDEX_0) )
+    {
+        // use battle shout
+        ai->CastSpell( BATTLE_SHOUT, *m_bot );
+    }
+
+    // buff master with VIGILANCE
+    if (VIGILANCE > 0)
+        (!GetMaster()->HasAura( VIGILANCE, EFFECT_INDEX_0) && ai->CastSpell( VIGILANCE, *GetMaster() ) );
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindFood();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(*pItem);
+        ai->SetIgnoreUpdateTime(30);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, EFFECT_INDEX_0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(*fItem);
+        ai->SetIgnoreUpdateTime(8);
+        return;
+    }
+    else if (pItem == NULL && fItem == NULL && m_bot->getRace() == RACE_DRAENEI && !m_bot->HasAura(GIFT_OF_THE_NAARU, EFFECT_INDEX_0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I'm casting gift of the naaru.");
+        ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot);
+        return;
+    }
+} // end DoNonCombatActions
+
+void PlayerbotWarriorAI::BuffPlayer(Player* target) {
+}
diff --git a/Core/src/game/PlayerbotWarriorAI.h b/Core/src/game/PlayerbotWarriorAI.h
new file mode 100644
index 0000000..ce82c24
--- /dev/null
+++ b/Core/src/game/PlayerbotWarriorAI.h
@@ -0,0 +1,52 @@
+#ifndef _PlayerbotWarriorAI_H
+#define _PlayerbotWarriorAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    WarriorSpellPreventing,
+    WarriorBattle,
+    WarriorDefensive,
+    WarriorBerserker
+};
+
+
+//class Player;
+
+class MANGOS_DLL_SPEC PlayerbotWarriorAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotWarriorAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
+        virtual ~PlayerbotWarriorAI();
+
+        // all combat actions go here
+        bool DoFirstCombatManeuver(Unit*);
+        void DoNextCombatManeuver(Unit*);
+
+        // all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        // buff a specific player, usually a real PC who is not in group
+        void BuffPlayer(Player *target);
+
+    private:
+        // ARMS
+        uint32 BATTLE_STANCE, CHARGE, HEROIC_STRIKE, REND, THUNDER_CLAP, HAMSTRING, MOCKING_BLOW, RETALIATION, SWEEPING_STRIKES, MORTAL_STRIKE, BLADESTORM, HEROIC_THROW, SHATTERING_THROW;
+
+        // PROTECTION
+        uint32 DEFENSIVE_STANCE, BLOODRAGE, SUNDER_ARMOR, TAUNT, SHIELD_BASH, REVENGE, SHIELD_BLOCK, DISARM, SHIELD_WALL, SHIELD_SLAM, VIGILANCE, DEVASTATE, SHOCKWAVE, CONCUSSION_BLOW, SPELL_REFLECTION, LAST_STAND;
+
+        // FURY
+        uint32 BERSERKER_STANCE, BATTLE_SHOUT, DEMORALIZING_SHOUT, OVERPOWER, CLEAVE, INTIMIDATING_SHOUT, EXECUTE, CHALLENGING_SHOUT, SLAM, INTERCEPT, DEATH_WISH, BERSERKER_RAGE, WHIRLWIND, PUMMEL, BLOODTHIRST, RECKLESSNESS, RAMPAGE, HEROIC_FURY, COMMANDING_SHOUT, ENRAGED_REGENERATION, PIERCING_HOWL;
+
+        // first aid
+        uint32 RECENTLY_BANDAGED;
+
+        // racial
+        uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+        uint32 SpellSequence;
+};
+
+#endif
diff --git a/mangos/src/game/QueryHandler.cpp b/Core/src/game/QueryHandler.cpp
index e8719cb..8688d4c 100644
--- a/mangos/src/game/QueryHandler.cpp
+++ b/Core/src/game/QueryHandler.cpp
@@ -331,7 +331,7 @@ void WorldSession::HandleNpcTextQueryOpcode( WorldPacket & recv_data )
 
     GossipText const* pGossip = sObjectMgr.GetGossipText(textID);
 
-    WorldPacket data( SMSG_NPC_TEXT_UPDATE, 100 );          // guess size
+    WorldPacket data( SMSG_NPC_TEXT_UPDATE, 100 );         // guess size
     data << textID;
 
     if (!pGossip)
diff --git a/mangos/src/game/QuestHandler.cpp b/Core/src/game/QuestHandler.cpp
index a0b7872..fb36da8 100644
--- a/mangos/src/game/QuestHandler.cpp
+++ b/Core/src/game/QuestHandler.cpp
@@ -30,6 +30,9 @@
 #include "ScriptCalls.h"
 #include "Group.h"
 
+// Playerbot mod:
+#include "PlayerbotAI.h"
+
 void WorldSession::HandleQuestgiverStatusQueryOpcode( WorldPacket & recv_data )
 {
     uint64 guid;
@@ -518,8 +521,12 @@ void WorldSession::HandlePushQuestToParty(WorldPacket& recvPacket)
                     continue;
                 }
 
-                pPlayer->PlayerTalkClass->SendQuestGiverQuestDetails(pQuest, _player->GetGUID(), true);
                 pPlayer->SetDivider(_player->GetGUID());
+
+                if (pPlayer->GetPlayerbotAI())
+                    pPlayer->GetPlayerbotAI()->AcceptQuest( pQuest, _player );
+                else
+                    pPlayer->PlayerTalkClass->SendQuestGiverQuestDetails( pQuest, _player->GetGUID(), true );
             }
         }
     }
diff --git a/mangos/src/game/RandomMovementGenerator.cpp b/Core/src/game/RandomMovementGenerator.cpp
index 4ada553..9bf6a6d 100644
--- a/mangos/src/game/RandomMovementGenerator.cpp
+++ b/Core/src/game/RandomMovementGenerator.cpp
@@ -68,26 +68,10 @@ RandomMovementGenerator<Creature>::_setRandomLocation(Creature &creature)
     //else if (is_water_ok)                                 // 3D system under water and above ground (swimming mode)
     else                                                    // 2D only
     {
-        dist = dist >= 100.0f ? 10.0f : sqrtf(dist);        // 10.0 is the max that vmap high can check (MAX_CAN_FALL_DISTANCE)
-
-        // The fastest way to get an accurate result 90% of the time.
-        // Better result can be obtained like 99% accuracy with a ray light, but the cost is too high and the code is too long.
-        nz = map->GetHeight(nx, ny, Z+dist-2.0f, false);
-
-        if (fabs(nz-Z) > dist)                              // Map check
-        {
-            nz = map->GetHeight(nx, ny, Z-2.0f, true);      // Vmap Horizontal or above
-
-            if (fabs(nz-Z) > dist)
-            {
-                // Vmap Higher
-                nz = map->GetHeight(nx, ny, Z+dist-2.0f, true);
-
-                // let's forget this bad coords where a z cannot be find and retry at next tick
-                if (fabs(nz-Z) > dist)
-                    return;
-            }
-        }
+        nz = Z;
+        if(!map->IsNextZcoordOK(nx, ny, nz, dist))
+            return;                                         // let's forget this bad coords where a z cannot be find and retry at next tick
+        creature.UpdateGroundPositionZ(nx, ny, nz, dist);
     }
 
     Traveller<Creature> traveller(creature);
diff --git a/mangos/src/game/ReactorAI.cpp b/Core/src/game/ReactorAI.cpp
index f39cd1a..0aae0ed 100644
--- a/mangos/src/game/ReactorAI.cpp
+++ b/Core/src/game/ReactorAI.cpp
@@ -116,11 +116,13 @@ ReactorAI::EnterEvadeMode()
         DEBUG_FILTER_LOG(LOG_FILTER_AI_AND_MOVEGENSS, "Creature stopped attacking, victim %s [guid=%u]", victim->isAlive() ? "out run him" : "is dead", m_creature->GetGUIDLow());
     }
 
+    m_creature->ExitVehicle();
     m_creature->RemoveAllAuras();
     m_creature->DeleteThreatList();
     i_victimGuid = 0;
     m_creature->CombatStop(true);
     m_creature->SetLootRecipient(NULL);
+    m_creature->ResetObtainedDamage();
 
     // Remove ChaseMovementGenerator from MotionMaster stack list, and add HomeMovementGenerator instead
     if (m_creature->GetMotionMaster()->GetCurrentMovementGeneratorType() == CHASE_MOTION_TYPE)
diff --git a/mangos/src/game/ReputationMgr.cpp b/Core/src/game/ReputationMgr.cpp
index d0d7c2f..d9578b6 100644
--- a/mangos/src/game/ReputationMgr.cpp
+++ b/Core/src/game/ReputationMgr.cpp
@@ -238,6 +238,8 @@ bool ReputationMgr::SetReputation(FactionEntry const* factionEntry, int32 standi
             if(factionEntryCalc)
                 res = SetOneFactionReputation(factionEntryCalc, standing, incremental);
         }
+        if (factionEntry->ID == 1037 || factionEntry->ID == 1052)
+            res = SetOneFactionReputation(factionEntry, standing, incremental);
         return res;
     }
     else
@@ -310,7 +312,8 @@ void ReputationMgr::SetVisible(FactionEntry const *factionEntry)
 void ReputationMgr::SetVisible(FactionState* faction)
 {
     // always invisible or hidden faction can't be make visible
-    if(faction->Flags & (FACTION_FLAG_INVISIBLE_FORCED|FACTION_FLAG_HIDDEN))
+    // except if faction has FACTION_FLAG_SPECIAL
+    if(faction->Flags & (FACTION_FLAG_INVISIBLE_FORCED|FACTION_FLAG_HIDDEN) && !(faction->Flags & FACTION_FLAG_SPECIAL) )
         return;
 
     // already set
diff --git a/mangos/src/game/ReputationMgr.h b/Core/src/game/ReputationMgr.h
index 37d4312..b0ac23e 100644
--- a/mangos/src/game/ReputationMgr.h
+++ b/Core/src/game/ReputationMgr.h
@@ -32,7 +32,8 @@ enum FactionFlags
     FACTION_FLAG_INVISIBLE_FORCED   = 0x08,                 // always overwrite FACTION_FLAG_VISIBLE and hide faction in rep.list, used for hide opposite team factions
     FACTION_FLAG_PEACE_FORCED       = 0x10,                 // always overwrite FACTION_FLAG_AT_WAR, used for prevent war with own team factions
     FACTION_FLAG_INACTIVE           = 0x20,                 // player controlled, state stored in characters.data ( CMSG_SET_FACTION_INACTIVE )
-    FACTION_FLAG_RIVAL              = 0x40                  // flag for the two competing outland factions
+    FACTION_FLAG_RIVAL              = 0x40,                 // flag for the two competing outland factions
+    FACTION_FLAG_SPECIAL            = 0x80
 };
 
 typedef uint32 RepListID;
diff --git a/mangos/src/game/SharedDefines.h b/Core/src/game/SharedDefines.h
index e7c3c4f..65185b3 100644
--- a/mangos/src/game/SharedDefines.h
+++ b/Core/src/game/SharedDefines.h
@@ -517,6 +517,13 @@ enum Language
 
 #define LANGUAGES_COUNT   19
 
+enum TeamId
+{
+    TEAM_ALLIANCE = 0,
+    TEAM_HORDE,
+    TEAM_NEUTRAL,
+};
+
 enum Team
 {
     HORDE               = 67,
@@ -526,8 +533,9 @@ enum Team
     //TEAM_HORDE_FORCES        = 892,
     //TEAM_SANCTUARY           = 936,
     //TEAM_OUTLAND             = 980,
-    //TEAM_OTHER               = 0,                         // if ReputationListId > 0 && Flags != FACTION_FLAG_TEAM_HEADER
+    TEAM_OTHER               = 0,                         // if ReputationListId > 0 && Flags != FACTION_FLAG_TEAM_HEADER
 };
+const Team TeamId2Team[3] = {ALLIANCE, HORDE, TEAM_OTHER};
 
 enum SpellEffects
 {
@@ -915,7 +923,7 @@ enum AuraState
     AURA_STATE_SWIFTMEND                    = 15,           //   T |
     AURA_STATE_DEADLY_POISON                = 16,           //   T |
     AURA_STATE_ENRAGE                       = 17,           // C   |
-    //AURA_STATE_UNKNOWN18                  = 18,           // C  t|
+    AURA_STATE_MECHANIC_BLEED               = 18,           // C  t|
     //AURA_STATE_UNKNOWN19                  = 19,           //     | not used
     //AURA_STATE_UNKNOWN20                  = 20,           //  c  | only (45317 Suicide)
     //AURA_STATE_UNKNOWN21                  = 21,           //     | not used
@@ -934,7 +942,7 @@ enum Mechanics
     MECHANIC_FEAR             = 5,
     MECHANIC_GRIP             = 6,
     MECHANIC_ROOT             = 7,
-    MECHANIC_PACIFY           = 8,                          //0 spells use this mechanic
+    MECHANIC_SLOWATTACK       = 8,                          //0 spells use this mechanic, but some SPELL_AURA_MOD_HASTE and SPELL_AURA_MOD_RANGED_HASTE use as effect mechanic 
     MECHANIC_SILENCE          = 9,
     MECHANIC_SLEEP            = 10,
     MECHANIC_SNARE            = 11,
@@ -963,7 +971,7 @@ enum Mechanics
 // Used for spell 42292 Immune Movement Impairment and Loss of Control (0x49967da6)
 #define IMMUNE_TO_MOVEMENT_IMPAIRMENT_AND_LOSS_CONTROL_MASK ( \
     (1<<(MECHANIC_CHARM   -1))|(1<<(MECHANIC_DISORIENTED-1))|(1<<(MECHANIC_FEAR  -1))| \
-    (1<<(MECHANIC_ROOT    -1))|(1<<(MECHANIC_PACIFY     -1))|(1<<(MECHANIC_SLEEP -1))| \
+    (1<<(MECHANIC_ROOT    -1))|(1<<(MECHANIC_SLOWATTACK -1))|(1<<(MECHANIC_SLEEP -1))| \
     (1<<(MECHANIC_SNARE   -1))|(1<<(MECHANIC_STUN       -1))|(1<<(MECHANIC_FREEZE-1))| \
     (1<<(MECHANIC_KNOCKOUT-1))|(1<<(MECHANIC_POLYMORPH  -1))|(1<<(MECHANIC_BANISH-1))| \
     (1<<(MECHANIC_SHACKLE -1))|(1<<(MECHANIC_TURN       -1))|(1<<(MECHANIC_HORROR-1))| \
@@ -983,10 +991,10 @@ enum Mechanics
 
 // Daze and all croud control spells except polymorph are not removed
 #define MECHANIC_NOT_REMOVED_BY_SHAPESHIFT ( \
-    (1<<(MECHANIC_CHARM -1))|(1<<(MECHANIC_DISORIENTED-1))|(1<<(MECHANIC_FEAR  -1))| \
-    (1<<(MECHANIC_PACIFY-1))|(1<<(MECHANIC_STUN       -1))|(1<<(MECHANIC_FREEZE-1))| \
-    (1<<(MECHANIC_BANISH-1))|(1<<(MECHANIC_SHACKLE    -1))|(1<<(MECHANIC_HORROR-1))| \
-    (1<<(MECHANIC_TURN  -1))|(1<<(MECHANIC_DAZE       -1))|(1<<(MECHANIC_SAPPED-1)))
+    (1<<(MECHANIC_CHARM  -1))|(1<<(MECHANIC_DISORIENTED-1))|(1<<(MECHANIC_FEAR  -1))| \
+    (1<<(MECHANIC_STUN   -1))|(1<<(MECHANIC_FREEZE     -1))|(1<<(MECHANIC_BANISH-1))| \
+    (1<<(MECHANIC_SHACKLE-1))|(1<<(MECHANIC_HORROR     -1))|(1<<(MECHANIC_TURN  -1))| \
+    (1<<(MECHANIC_DAZE   -1))|(1<<(MECHANIC_SAPPED     -1)))
 
 // Spell dispell type
 enum DispelType
@@ -1104,6 +1112,7 @@ enum Targets
     TARGET_SELF2                       = 87,
     TARGET_DIRECTLY_FORWARD            = 89,
     TARGET_NONCOMBAT_PET               = 90,
+    TARGET_RANDOM_POINT_AROUND_CASTER  = 91,                // currently used only for Freya spell waves, should work simmilar like 73
     TARGET_IN_FRONT_OF_CASTER_30       = 104,
 };
 
@@ -1213,8 +1222,8 @@ enum GameObjectFlags
     GO_FLAG_TRIGGERED       = 0x00000040,                   //typically, summoned objects. Triggered by spell or other events
     GO_FLAG_UNK_8           = 0x00000080,
     GO_FLAG_UNK_9           = 0x00000100,                   //? Seen on type 33, possible meaning "destruct in progress"
-    GO_FLAG_UNK_10          = 0x00000200,                   //? Seen on type 33
-    GO_FLAG_UNK_11          = 0x00000400                    //? Seen on type 33, possibly meaning "destructed"
+    GO_FLAG_DAMAGED         = 0x00000200,
+    GO_FLAG_DESTROYED       = 0x00000400
 };
 
 enum TextEmotes
@@ -2457,6 +2466,30 @@ enum DiminishingGroup
     DIMINISHING_LIMITONLY
 };
 
+
+/* NOTE : vehicles and seats has their own flags in DBC,
+but for now, they are too unknown for us, to use them */
+enum CustomVehicleFLags
+{
+    VF_CANT_MOVE                    = 0x0001,                   // vehicle cant move, only turn, maybe handle by some auras?
+    VF_FACTION                      = 0x0002,                   // vehicle retain its own faction
+    VF_DESPAWN_NPC                  = 0x0004,                   // vehicle will delete npc on spellclick
+    VF_DESPAWN_AT_LEAVE             = 0x0008,                   // vehicle will be deleted when rider leaves
+    VF_CAN_BE_HEALED                = 0x0010,                   // vehicle can be healed
+    VF_GIVE_EXP                     = 0x0020,                   // vehicle will give exp for killing enemies
+    VF_MOVEMENT                     = 0x0040,                   // vehicle will move on its own, not depending on rider, however rider can cast spells
+    VF_NON_SELECTABLE               = 0x0080,                    // vehicle will be not selectable after rider enter
+    VF_ALLOW_MELEE                  = 0x0100                    // Allow melee for players on vehicle   
+    //VF_HAS_FUEL                     = 0x0200,                   // TODO : find out what energy type is fuel and implement this
+};
+
+enum CustomVehicleSeatFLags
+{
+    SF_MAIN_RIDER                   = 0x0001,                   // the one who controlls vehicle, can also cast spells
+    SF_UNATTACKABLE                 = 0x0002,                   // hided inside, and unatackable until vehicle is destroyed
+    SF_CAN_CAST                     = 0x0004,                   // player/npc can rotate, and cast OWN spells
+    SF_UNACCESSIBLE                 = 0x0008                    // player cant enter this seat by normal way (only by script)
+};
 enum ResponseCodes
 {
     RESPONSE_SUCCESS                                       = 0x00,
@@ -2670,33 +2703,6 @@ enum TotemSlot
 
 #define MAX_TOTEM_SLOT  4
 
-enum TradeStatus
-{
-    TRADE_STATUS_BUSY           = 0,
-    TRADE_STATUS_BEGIN_TRADE    = 1,
-    TRADE_STATUS_OPEN_WINDOW    = 2,
-    TRADE_STATUS_TRADE_CANCELED = 3,
-    TRADE_STATUS_TRADE_ACCEPT   = 4,
-    TRADE_STATUS_BUSY_2         = 5,
-    TRADE_STATUS_NO_TARGET      = 6,
-    TRADE_STATUS_BACK_TO_TRADE  = 7,
-    TRADE_STATUS_TRADE_COMPLETE = 8,
-    // 9?
-    TRADE_STATUS_TARGET_TO_FAR  = 10,
-    TRADE_STATUS_WRONG_FACTION  = 11,
-    TRADE_STATUS_CLOSE_WINDOW   = 12,
-    // 13?
-    TRADE_STATUS_IGNORE_YOU     = 14,
-    TRADE_STATUS_YOU_STUNNED    = 15,
-    TRADE_STATUS_TARGET_STUNNED = 16,
-    TRADE_STATUS_YOU_DEAD       = 17,
-    TRADE_STATUS_TARGET_DEAD    = 18,
-    TRADE_STATUS_YOU_LOGOUT     = 19,
-    TRADE_STATUS_TARGET_LOGOUT  = 20,
-    TRADE_STATUS_TRIAL_ACCOUNT  = 21,                       // Trial accounts can not perform that action
-    TRADE_STATUS_ONLY_CONJURED  = 22                        // You can only trade conjured items... (cross realm BG related).
-};
-
 // we need to stick to 1 version or half of the stuff will work for someone
 // others will not and opposite
 // will only support WoW, WoW:TBC and WoW:WotLK 3.3.3 client build 11723...
diff --git a/mangos/src/game/Spell.cpp b/Core/src/game/Spell.cpp
index 6597d88..3f457d5 100644
--- a/mangos/src/game/Spell.cpp
+++ b/Core/src/game/Spell.cpp
@@ -44,6 +44,7 @@
 #include "VMapFactory.h"
 #include "BattleGround.h"
 #include "Util.h"
+#include "Vehicle.h"
 
 #define SPELL_CHANNEL_UPDATE_INTERVAL (1 * IN_MILLISECONDS)
 
@@ -120,7 +121,8 @@ SpellCastTargets::SpellCastTargets()
     m_itemTargetGUID   = 0;
     m_itemTargetEntry  = 0;
 
-    m_srcX = m_srcY = m_srcZ = m_destX = m_destY = m_destZ = 0.0f;
+    m_srcX = m_srcY = m_srcZ = m_srcO = m_destX = m_destY = m_destZ = 0.0f;
+    m_elevation = m_speed = 0.0f;
     m_strTarget = "";
     m_targetMask = 0;
 }
@@ -176,15 +178,6 @@ void SpellCastTargets::setItemTarget(Item* item)
     m_targetMask |= TARGET_FLAG_ITEM;
 }
 
-void SpellCastTargets::setTradeItemTarget(Player* caster)
-{
-    m_itemTargetGUID = ObjectGuid(uint64(TRADE_SLOT_NONTRADED));
-    m_itemTargetEntry = 0;
-    m_targetMask |= TARGET_FLAG_TRADE_ITEM;
-
-    Update(caster);
-}
-
 void SpellCastTargets::setCorpseTarget(Corpse* corpse)
 {
     m_CorpseTargetGUID = corpse->GetGUID();
@@ -198,20 +191,17 @@ void SpellCastTargets::Update(Unit* caster)
     NULL;
 
     m_itemTarget = NULL;
-    if (caster->GetTypeId() == TYPEID_PLAYER)
+    if(caster->GetTypeId() == TYPEID_PLAYER)
     {
-        Player *player = ((Player*)caster);
-
-        if (m_targetMask & TARGET_FLAG_ITEM)
-            m_itemTarget = player->GetItemByGuid(m_itemTargetGUID);
-        else if (m_targetMask & TARGET_FLAG_TRADE_ITEM)
+        if(m_targetMask & TARGET_FLAG_ITEM)
+            m_itemTarget = ((Player*)caster)->GetItemByGuid(m_itemTargetGUID);
+        else if(m_targetMask & TARGET_FLAG_TRADE_ITEM)
         {
-            if (TradeData* pTrade = player->GetTradeData())
-                if (m_itemTargetGUID.GetRawValue() < TRADE_SLOT_COUNT)
-                    m_itemTarget = pTrade->GetTraderData()->GetItem(TradeSlots(m_itemTargetGUID.GetRawValue()));
+            Player* pTrader = ((Player*)caster)->GetTrader();
+            if(pTrader && m_itemTargetGUID.GetRawValue() < TRADE_SLOT_COUNT)
+                m_itemTarget = pTrader->GetItemByTradeSlot(uint32(m_itemTargetGUID.GetRawValue()));
         }
-
-        if (m_itemTarget)
+        if(m_itemTarget)
             m_itemTargetEntry = m_itemTarget->GetEntry();
     }
 }
@@ -257,6 +247,21 @@ void SpellCastTargets::read( ByteBuffer& data, Unit *caster )
         data >> m_destX >> m_destY >> m_destZ;
         if(!MaNGOS::IsValidMapCoord(m_destX, m_destY, m_destZ))
             throw ByteBufferException(false, data.rpos(), 0, data.size());
+
+        //somethings wrong here... Typhoon spell has this flag in packet,
+        //but cast fails because packet is too short....strange spell,
+        //dunno about any other like this
+        if( m_targetMask & TARGET_FLAG_SOURCE_LOCATION && caster->getClass() != CLASS_DRUID) // <- cant get to spell proto, but this data are not used for now anyway... :/
+        {
+            if(data.rpos() + 4 + 4 <= data.size())
+            {
+                data >> m_elevation >> m_speed;
+                // TODO: should also read
+                m_srcO = caster->GetOrientation();
+                //*data >> uint16 >> uint8 >> uint32 >> uint32;
+                //*data >> float >> float >> float >> float...
+            }
+        }
     }
 
     if( m_targetMask & TARGET_FLAG_STRING )
@@ -335,6 +340,7 @@ Spell::Spell( Unit* caster, SpellEntry const *info, bool triggered, ObjectGuid o
     else
         m_spellInfo = info;
 
+    m_destroyed = false;
     m_caster = caster;
     m_selfContainer = NULL;
     m_triggeringContainer = triggeringContainer;
@@ -409,10 +415,10 @@ Spell::Spell( Unit* caster, SpellEntry const *info, bool triggered, ObjectGuid o
             if (m_spellInfo->Effect[j] == 0)
                 continue;
 
-            if(!IsPositiveTarget(m_spellInfo->EffectImplicitTargetA[j], m_spellInfo->EffectImplicitTargetB[j]))
-                m_canReflect = true;
+            if(IsPositiveTarget(m_spellInfo->EffectImplicitTargetA[j], m_spellInfo->EffectImplicitTargetB[j]) && !(m_spellInfo->AttributesEx & SPELL_ATTR_EX_NEGATIVE))
+                continue;
             else
-                m_canReflect = (m_spellInfo->AttributesEx & SPELL_ATTR_EX_NEGATIVE) ? true : false;
+                m_canReflect = true;
 
             if(m_canReflect)
                 continue;
@@ -426,6 +432,7 @@ Spell::Spell( Unit* caster, SpellEntry const *info, bool triggered, ObjectGuid o
 
 Spell::~Spell()
 {
+    m_destroyed = true;
 }
 
 template<typename T>
@@ -437,7 +444,7 @@ WorldObject* Spell::FindCorpseUsing()
 
     WorldObject* result = NULL;
 
-    T u_check(m_caster, max_range);
+    T u_check(((Player*)m_caster), max_range);
     MaNGOS::WorldObjectSearcher<T> searcher(m_caster, result, u_check);
 
     Cell::VisitGridObjects(m_caster, searcher, max_range);
@@ -448,6 +455,46 @@ WorldObject* Spell::FindCorpseUsing()
     return result;
 }
 
+void Spell::FillCustomTargetMap(uint32 i, UnitList &targetUnitMap)
+{
+    float radius;
+
+    if (m_spellInfo->EffectRadiusIndex[i])
+        radius = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
+    else
+        radius = GetSpellMaxRange(sSpellRangeStore.LookupEntry(m_spellInfo->rangeIndex));
+    // Resulting effect depends on spell that we want to cast
+    switch (m_spellInfo->Id)
+    {
+        case 46584: // Raise Dead
+        {
+            WorldObject* result = FindCorpseUsing <MaNGOS::RaiseDeadObjectCheck>  ();
+
+            if(result)
+            {
+                switch(result->GetTypeId())
+                {
+                    case TYPEID_UNIT:
+                        targetUnitMap.push_back((Unit*)result);
+                        break;
+                    default:
+                        break;
+                }
+            }
+            break;
+        }
+        case 47496: // Ghoul's explode
+        {
+            FillAreaTargets(targetUnitMap,m_targets.m_destX, m_targets.m_destY,radius,PUSH_DEST_CENTER,SPELL_TARGETS_AOE_DAMAGE);
+            break;
+        }
+        break;
+    }
+}
+
+// explicitly instantiate for use in SpellEffects.cpp
+template WorldObject* Spell::FindCorpseUsing<MaNGOS::RaiseDeadObjectCheck>();
+
 void Spell::FillTargetMap()
 {
     // TODO: ADD the correct target FILLS!!!!!!
@@ -518,6 +565,10 @@ void Spell::FillTargetMap()
                     case TARGET_EFFECT_SELECT:
                         SetTargetMap(SpellEffectIndex(i), m_spellInfo->EffectImplicitTargetA[i], tmpUnitMap);
                         break;
+                    case TARGET_AREAEFFECT_CUSTOM:
+                    case TARGET_ALL_ENEMY_IN_AREA_INSTANT:
+                        FillCustomTargetMap(i,tmpUnitMap);
+                        break;
                     case TARGET_INNKEEPER_COORDINATES:
                     case TARGET_TABLE_X_Y_Z_COORDINATES:
                     case TARGET_CASTER_COORDINATES:
@@ -549,7 +600,9 @@ void Spell::FillTargetMap()
                         // Note: this hack with search required until GO casting not implemented
                         // environment damage spells already have around enemies targeting but this not help in case not existed GO casting support
                         // currently each enemy selected explicitly and self cast damage
-                        if (m_spellInfo->Effect[i] == SPELL_EFFECT_ENVIRONMENTAL_DAMAGE)
+                        if (m_spellInfo->Effect[i] == SPELL_EFFECT_ENVIRONMENTAL_DAMAGE
+                        // Paralyze - Svala channelers
+                        || m_spellInfo->Id == 48278)
                         {
                             if(m_targets.getUnitTarget())
                                 tmpUnitMap.push_back(m_targets.getUnitTarget());
@@ -595,6 +648,9 @@ void Spell::FillTargetMap()
                     case TARGET_EFFECT_SELECT:
                         SetTargetMap(SpellEffectIndex(i), m_spellInfo->EffectImplicitTargetA[i], tmpUnitMap);
                         break;
+                    case TARGET_RANDOM_NEARBY_DEST: 
+                        SetTargetMap(SpellEffectIndex(i), m_spellInfo->EffectImplicitTargetA[i], tmpUnitMap);
+                        break;
                     // most A/B target pairs is self->negative and not expect adding caster to target list
                     default:
                         SetTargetMap(SpellEffectIndex(i), m_spellInfo->EffectImplicitTargetB[i], tmpUnitMap);
@@ -664,6 +720,18 @@ void Spell::FillTargetMap()
         for(std::list<Unit*>::const_iterator iunit = tmpUnitMap.begin(); iunit != tmpUnitMap.end(); ++iunit)
             AddUnitTarget((*iunit), SpellEffectIndex(i));
     }
+/*
+    for(tbb::concurrent_vector<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    {
+        error_log("GUID: %u", ihit->targetGUID.GetRawValue());
+        if(ihit->targetGUID.IsPlayer())
+            error_log("    PLAYER!");
+        else if(ihit->targetGUID.IsCreature())
+            error_log("    CREATURE!");
+        else if(ihit->targetGUID.IsVehicle())
+            error_log("    VEHICLE!");
+    }
+*/
 }
 
 void Spell::prepareDataForTriggerSystem()
@@ -716,8 +784,7 @@ void Spell::prepareDataForTriggerSystem()
                 break;
             case SPELLFAMILY_HUNTER:
                 // Hunter Rapid Killing/Explosive Trap Effect/Immolation Trap Effect/Frost Trap Aura/Snake Trap Effect/Explosive Shot
-                if ((m_spellInfo->SpellFamilyFlags & UI64LIT(0x0100200000000214)) ||
-                    m_spellInfo->SpellFamilyFlags2 & 0x200)
+                if ((m_spellInfo->SpellFamilyFlags & UI64LIT(0x0100000000000000)) || m_spellInfo->SpellFamilyFlags2 & 0x200)
                     m_canTrigger = true;
                 break;
             case SPELLFAMILY_PALADIN:
@@ -776,16 +843,20 @@ void Spell::prepareDataForTriggerSystem()
         if (!IsPositiveEffect(m_spellInfo->Id, SpellEffectIndex(i)))
             m_negativeEffectMask |= (1<<i);
 
-    // Hunter traps spells (for Entrapment trigger)
-    // Gives your Immolation Trap, Frost Trap, Explosive Trap, and Snake Trap ....
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_HUNTER && (m_spellInfo->SpellFamilyFlags & UI64LIT(0x000020000000001C)))
+    // Hunter traps spells: Immolation Trap Effect, Frost Trap (triggering spell!!),
+    // Freezing Trap Effect(+ Freezing Arrow Effect), Explosive Trap Effect, Snake Trap Effect
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_HUNTER && (m_spellInfo->SpellFamilyFlags & UI64LIT(0x0000200000002008) || m_spellInfo->SpellFamilyFlags2 & 0x00064000))
         m_procAttacker |= PROC_FLAG_ON_TRAP_ACTIVATION;
 }
 
 void Spell::CleanupTargetList()
 {
-    m_UniqueTargetInfo.clear();
-    m_UniqueGOTargetInfo.clear();
+    for(tbb::concurrent_vector<TargetInfo>::iterator itr = m_UniqueTargetInfo.begin(); itr != m_UniqueTargetInfo.end(); ++itr)
+        itr->deleted = true;
+
+    for(tbb::concurrent_vector<GOTargetInfo>::iterator itr = m_UniqueGOTargetInfo.begin(); itr != m_UniqueGOTargetInfo.end(); ++itr)
+        itr->deleted = true;
+
     m_UniqueItemInfo.clear();
     m_delayMoment = 0;
 }
@@ -797,12 +868,19 @@ void Spell::AddUnitTarget(Unit* pVictim, SpellEffectIndex effIndex)
 
     // Check for effect immune skip if immuned
     bool immuned = pVictim->IsImmunedToSpellEffect(m_spellInfo, effIndex);
+    
+    //Deep Freeze dmg if immune to stun
+    if(m_spellInfo->Id == 44572 && immuned && pVictim->GetTypeId() != TYPEID_PLAYER)
+        m_caster->CastSpell(pVictim, 71757, true);
 
     ObjectGuid targetGUID = pVictim->GetObjectGuid();
 
     // Lookup target in already in list
-    for(std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    for(tbb::concurrent_vector<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
     {
+        if (ihit->deleted == true)
+            continue;
+
         if (targetGUID == ihit->targetGUID)                 // Found in list
         {
             if (!immuned)
@@ -818,9 +896,13 @@ void Spell::AddUnitTarget(Unit* pVictim, SpellEffectIndex effIndex)
     target.targetGUID = targetGUID;                         // Store target GUID
     target.effectMask = immuned ? 0 : (1 << effIndex);      // Store index of effect if not immuned
     target.processed  = false;                              // Effects not apply on target
+    target.deleted    = false;
 
     // Calculate hit result
-    target.missCondition = m_caster->SpellHitResult(pVictim, m_spellInfo, m_canReflect);
+
+    // Procs can miss, weapon enchants can miss, triggered spells and effects cannot miss (miss already calculated in triggering spell)
+    bool canMiss = (m_triggeredByAuraSpell || !m_IsTriggeredSpell);
+    target.missCondition = m_caster->SpellHitResult(pVictim, m_spellInfo, m_canReflect, canMiss);
 
     // Spell have speed - need calculate incoming time
     if (m_spellInfo->speed > 0.0f)
@@ -871,8 +953,11 @@ void Spell::AddGOTarget(GameObject* pVictim, SpellEffectIndex effIndex)
     ObjectGuid targetGUID = pVictim->GetObjectGuid();
 
     // Lookup target in already in list
-    for(std::list<GOTargetInfo>::iterator ihit = m_UniqueGOTargetInfo.begin(); ihit != m_UniqueGOTargetInfo.end(); ++ihit)
+    for(tbb::concurrent_vector<GOTargetInfo>::iterator ihit = m_UniqueGOTargetInfo.begin(); ihit != m_UniqueGOTargetInfo.end(); ++ihit)
     {
+        if (ihit->deleted == true)
+            continue;
+
         if (targetGUID == ihit->targetGUID)                 // Found in list
         {
             ihit->effectMask |= (1 << effIndex);            // Add only effect mask
@@ -918,7 +1003,7 @@ void Spell::AddItemTarget(Item* pitem, SpellEffectIndex effIndex)
         return;
 
     // Lookup target in already in list
-    for(std::list<ItemTargetInfo>::iterator ihit = m_UniqueItemInfo.begin(); ihit != m_UniqueItemInfo.end(); ++ihit)
+    for(tbb::concurrent_vector<ItemTargetInfo>::iterator ihit = m_UniqueItemInfo.begin(); ihit != m_UniqueItemInfo.end(); ++ihit)
     {
         if (pitem == ihit->item)                            // Found in list
         {
@@ -937,8 +1022,12 @@ void Spell::AddItemTarget(Item* pitem, SpellEffectIndex effIndex)
 
 void Spell::DoAllEffectOnTarget(TargetInfo *target)
 {
-    if (target->processed)                                  // Check target
+    if (this->m_spellInfo->Id <= 0 || this->m_spellInfo->Id > MAX_SPELL_ID ||  m_spellInfo->Id == 32 || m_spellInfo->Id == 80)
+        return;
+
+    if (!target || target == (TargetInfo*)0x10 || target->processed)
         return;
+
     target->processed = true;                               // Target checked in apply effects procedure
 
     // Get mask of effects for target
@@ -987,10 +1076,26 @@ void Spell::DoAllEffectOnTarget(TargetInfo *target)
 
     if (missInfo==SPELL_MISS_NONE)                          // In case spell hit target, do all effect on that target
         DoSpellHitOnUnit(unit, mask);
-    else if (missInfo == SPELL_MISS_REFLECT)                // In case spell reflect from target, do all effect on caster (if hit)
+    else
     {
-        if (target->reflectResult == SPELL_MISS_NONE)       // If reflected spell hit caster -> do all effect on him
+        if (missInfo == SPELL_MISS_REFLECT && target->reflectResult == SPELL_MISS_NONE)       // In case spell reflect from target, do all effect on caster (if hit)
             DoSpellHitOnUnit(m_caster, mask);
+
+        else if (missInfo != SPELL_MISS_EVADE && target->reflectResult != SPELL_MISS_EVADE && real_caster)   // We still need to start combat (not for evade...)
+        {
+            if (!unit->IsStandState() && !unit->hasUnitState(UNIT_STAT_STUNNED))
+                unit->SetStandState(UNIT_STAND_STATE_STAND);
+
+            if (!unit->isInCombat() && unit->GetTypeId() != TYPEID_PLAYER && ((Creature*)unit)->AI())
+                ((Creature*)unit)->AI()->AttackedBy(real_caster);
+
+            unit->AddThreat(real_caster);
+            unit->SetInCombatWith(real_caster);
+            real_caster->SetInCombatWith(unit);
+
+            if (Player *attackedPlayer = unit->GetCharmerOrOwnerPlayerOrPlayerItself())
+                real_caster->SetContestedPvP(attackedPlayer);
+        }
     }
 
     // All calculated do it!
@@ -1053,8 +1158,15 @@ void Spell::DoAllEffectOnTarget(TargetInfo *target)
             (m_spellInfo->SpellFamilyFlags & UI64LIT(0x0004000000000000)))
             if(Aura* dummy = unitTarget->GetDummyAura(m_spellInfo->Id))
                 dummy->GetModifier()->m_amount = damageInfo.damage;
-
-        caster->DealSpellDamage(&damageInfo, true);
+                caster->DealSpellDamage(&damageInfo, true);
+                
+        // Divine Storm (use m_healthLeech to store damage for all targets)
+        if (m_spellInfo->Id == 53385)
+        {
+            m_healthLeech += damageInfo.damage;
+            if(Aura * pGlyph = caster->GetAura(63220, EFFECT_INDEX_0))
+                m_healthLeech += (m_healthLeech * pGlyph->GetModifier()->m_amount / 100);
+        }
 
         // Scourge Strike, here because needs to use final damage in second part of the spell
         if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && m_spellInfo->SpellFamilyFlags & UI64LIT(0x0800000000000000))
@@ -1087,6 +1199,14 @@ void Spell::DoAllEffectOnTarget(TargetInfo *target)
         if (m_canTrigger && missInfo != SPELL_MISS_REFLECT)
             caster->ProcDamageAndSpell(unit, real_caster ? procAttacker : PROC_FLAG_NONE, procVictim, procEx, 0, m_attackType, m_spellInfo);
     }
+    // remove Arcane Blast buffs at any non-Arcane Blast arcane damage spell.
+    // NOTE: it removed at hit instead cast because currently spell done-damage calculated at hit instead cast
+    // For arcane missiles its removed in Aura::HandleAuraDummy();
+    if ((m_spellInfo->SchoolMask & SPELL_SCHOOL_MASK_ARCANE) && !(m_spellInfo->SpellFamilyFlags & UI64LIT(0x20000000))
+        && !m_IsTriggeredSpell && !IsChanneledSpell(m_spellInfo))
+    {
+        m_caster->RemoveAurasDueToSpell(36032); // Arcane Blast buff
+    }
 
     // Call scripted function for AI if this spell is casted upon a creature
     if (unit->GetTypeId() == TYPEID_UNIT)
@@ -1108,6 +1228,9 @@ void Spell::DoAllEffectOnTarget(TargetInfo *target)
 
 void Spell::DoSpellHitOnUnit(Unit *unit, const uint32 effectMask)
 {
+    if (m_caster->HasAura(5384)) // Feign Death
+        return;
+    
     if (!unit || !effectMask)
         return;
 
@@ -1116,7 +1239,8 @@ void Spell::DoSpellHitOnUnit(Unit *unit, const uint32 effectMask)
     // Recheck immune (only for delayed spells)
     if (m_spellInfo->speed && (
         unit->IsImmunedToDamage(GetSpellSchoolMask(m_spellInfo)) ||
-        unit->IsImmunedToSpell(m_spellInfo)))
+        unit->IsImmunedToSpell(m_spellInfo) && !(m_spellInfo->Id == 64380 || m_spellInfo->Id == 64382 ||
+        m_spellInfo->Id == 32375 || m_spellInfo->Id == 32592 || m_spellInfo->Id == 39897 || m_spellInfo->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)))
     {
         if (realCaster)
             realCaster->SendSpellMiss(unit, m_spellInfo->Id, SPELL_MISS_IMMUNE);
@@ -1124,6 +1248,24 @@ void Spell::DoSpellHitOnUnit(Unit *unit, const uint32 effectMask)
         ResetEffectDamageAndHeal();
         return;
     }
+    
+    // Recheck deflection (only for delayed spells)
+    if (m_spellInfo->speed && unit->HasAura(19263))
+    {
+        if (realCaster)
+            realCaster->SendSpellMiss(unit, m_spellInfo->Id, SPELL_MISS_DEFLECT);
+        return;
+    }
+
+    // Recheck deflection (only for delayed spells)
+    if (m_spellInfo->speed && unit->HasAura(19263))
+    {
+        if (realCaster)
+            realCaster->SendSpellMiss(unit, m_spellInfo->Id, SPELL_MISS_DEFLECT);
+
+        ResetEffectDamageAndHeal();
+        return;
+    }
 
     if (unit->GetTypeId() == TYPEID_PLAYER)
     {
@@ -1158,7 +1300,7 @@ void Spell::DoSpellHitOnUnit(Unit *unit, const uint32 effectMask)
             }
 
             // not break stealth by cast targeting
-            if (!(m_spellInfo->AttributesEx & SPELL_ATTR_EX_NOT_BREAK_STEALTH))
+            if ((!(m_spellInfo->AttributesEx & SPELL_ATTR_EX_NOT_BREAK_STEALTH) && m_spellInfo->Id != 51690 && m_spellInfo->Id != 53198 && m_spellInfo->Id != 3600 && m_spellInfo->Id != 53055 && m_spellInfo->Id != 44416 && m_spellInfo->Id != 32835 ) || (m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && m_spellInfo->SpellFamilyFlags == SPELLFAMILYFLAG_ROGUE_SAP))
                 unit->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
 
             // can cause back attack (if detected), stealth removed at Spell::cast if spell break it
@@ -1357,8 +1499,11 @@ bool Spell::IsAliveUnitPresentInTargetList()
 
     uint8 needAliveTargetMask = m_needAliveTargetMask;
 
-    for(std::list<TargetInfo>::const_iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    for(tbb::concurrent_vector<TargetInfo>::const_iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
     {
+        if (ihit->deleted == true)
+            continue;
+
         if( ihit->missCondition == SPELL_MISS_NONE && (needAliveTargetMask & ihit->effectMask) )
         {
             Unit *unit = m_caster->GetObjectGuid() == ihit->targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, ihit->targetGUID);
@@ -1460,6 +1605,10 @@ void Spell::SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList&
                 case 31347:                                 // Doom TODO: exclude top threat target from target selection
                 case 33711:                                 // Murmur's Touch
                 case 38794:                                 // Murmur's Touch (h)
+				case 63018:                                 // XT002's Light Bomb
+				case 65121:                                 // XT002's Light Bomb (h)
+				case 63024:                                 // XT002's Gravitiy Bomb
+				case 64234:                                 // XT002's Gravitiy Bomb (h)
                 case 50988:                                 // Glare of the Tribunal (Halls of Stone)
                 case 59870:                                 // Glare of the Tribunal (h) (Halls of Stone)
                     unMaxTargets = 1;
@@ -1488,8 +1637,17 @@ void Spell::SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList&
                 case 25991:                                 // Poison Bolt Volley (Pincess Huhuran)
                     unMaxTargets = 15;
                     break;
+        case 62240:                                 // Solar Flare
+        case 62920:                                 // Solar Flare (h)
+        {
+          if(Aura *pAura = m_caster->GetAura(62251, EFFECT_INDEX_0))
+            unMaxTargets = pAura->GetStackAmount();
+          else unMaxTargets = 1;
+          break;
+        }
             }
             break;
+        
         }
         case SPELLFAMILY_PALADIN:
             if (m_spellInfo->Id == 20424)                   // Seal of Command (2 more target for single targeted spell)
@@ -1524,10 +1682,13 @@ void Spell::SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList&
     switch(targetMode)
     {
         case TARGET_RANDOM_NEARBY_LOC:
-            radius *= sqrtf(rand_norm_f()); // Get a random point in circle. Use sqrt(rand) to correct distribution when converting polar to Cartesian coordinates.
-                                         // no 'break' expected since we use code in case TARGET_RANDOM_CIRCUMFERENCE_POINT!!!
+            // Get a random point IN circle around the CASTER(!). Use sqrt(rand) to correct distribution when converting polar to Cartesian coordinates.
+            radius *= sqrtf(rand_norm_f());
+            // no 'break' expected since we use code in case TARGET_RANDOM_CIRCUMFERENCE_POINT!!! 
+        case TARGET_RANDOM_POINT_AROUND_CASTER:  
         case TARGET_RANDOM_CIRCUMFERENCE_POINT:
         {
+            // Get a random point AT the CIRCUMREFERENCE(!).
             float angle = 2.0f * M_PI_F * rand_norm_f();
             float dest_x, dest_y, dest_z;
             m_caster->GetClosePoint(dest_x, dest_y, dest_z, 0.0f, radius, angle);
@@ -1538,20 +1699,21 @@ void Spell::SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList&
         }
         case TARGET_RANDOM_NEARBY_DEST:
         {
-            radius *= sqrtf(rand_norm_f()); // Get a random point in circle. Use sqrt(rand) to correct distribution when converting polar to Cartesian coordinates.
-            float angle = 2.0f * M_PI_F * rand_norm_f();
-            float dest_x = m_targets.m_destX + cos(angle) * radius;
-            float dest_y = m_targets.m_destY + sin(angle) * radius;
-            float dest_z = m_caster->GetPositionZ();
-            m_caster->UpdateGroundPositionZ(dest_x, dest_y, dest_z);
-            m_targets.setDestination(dest_x, dest_y, dest_z);
-
-            if (radius > 0.0f)
-            {
-                // caster included here?
-                FillAreaTargets(targetUnitMap, dest_x, dest_y, radius, PUSH_DEST_CENTER, SPELL_TARGETS_AOE_DAMAGE);
-            }
-            else
+            // Get a random point IN the CIRCEL around current M_TARGETS COORDINATES(!).
+            if (radius > 0)
+            {
+                // Use sqrt(rand) to correct distribution when converting polar to Cartesian coordinates.
+                radius *= sqrtf(rand_norm_f());
+                float angle = 2.0f * M_PI_F * rand_norm_f();
+                float dest_x = m_targets.m_destX + cos(angle) * radius;
+                float dest_y = m_targets.m_destY + sin(angle) * radius;
+                float dest_z = m_caster->GetPositionZ();
+                m_caster->UpdateGroundPositionZ(dest_x, dest_y, dest_z);
+                m_targets.setDestination(dest_x, dest_y, dest_z);
+            }
+            // This targetMode is often used as 'last' implicitTarget for positive spells, that just require coordinates
+            // and no unitTarget (e.g. summon effects). As MaNGOS always needs a unitTarget we add just the caster here.
+            if (IsPositiveSpell(m_spellInfo->Id))
                 targetUnitMap.push_back(m_caster);
 
             break;
@@ -1562,9 +1724,15 @@ void Spell::SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList&
         case TARGET_TOTEM_FIRE:
         case TARGET_SELF:
         case TARGET_SELF2:
-        case TARGET_AREAEFFECT_CUSTOM_2:
-            targetUnitMap.push_back(m_caster);
-            break;
+        case TARGET_AREAEFFECT_CUSTOM_2:		
+        {
+            // used for targeting gameobjects
+            if (m_spellInfo->EffectImplicitTargetA[effIndex] == TARGET_EFFECT_SELECT && m_spellInfo->EffectImplicitTargetB[effIndex] == TARGET_AREAEFFECT_CUSTOM)
+		       FillAreaTargets(targetUnitMap, m_caster->GetPositionX(), m_caster->GetPositionY(), radius, PUSH_SELF_CENTER, SPELL_TARGETS_AOE_DAMAGE);
+            else
+			    targetUnitMap.push_back(m_caster);
+		    break;
+        }
         case TARGET_RANDOM_ENEMY_CHAIN_IN_AREA:
         {
             m_targets.m_targetMask = 0;
@@ -1766,6 +1934,10 @@ void Spell::SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList&
             if (IsPositiveEffect(m_spellInfo->Id, effIndex))
                 targetB = SPELL_TARGETS_FRIENDLY;
 
+            // hack - spell for quest 10233
+            if (m_spellInfo->Id == 34526)
+                targetB = SPELL_TARGETS_ALL;
+
             FillAreaTargets(targetUnitMap, m_caster->GetPositionX(), m_caster->GetPositionY(), radius, PUSH_DEST_CENTER, targetB);
 
             // exclude caster
@@ -1833,13 +2005,18 @@ void Spell::SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList&
                     break;
                 default:
                     FillAreaTargets(targetUnitMap, m_targets.m_destX, m_targets.m_destY, radius, PUSH_DEST_CENTER, SPELL_TARGETS_AOE_DAMAGE);
+
+                    // exclude caster (this can be important if this not original caster, for example vehicle)
+                    targetUnitMap.remove(m_caster);
                     break;
             }
             break;
         }
         case TARGET_DUELVSPLAYER_COORDINATES:
         {
-            if(Unit* currentTarget = m_targets.getUnitTarget())
+            if(m_spellInfo->Id == 71610)
+                break;
+            else if(Unit* currentTarget = m_targets.getUnitTarget())
                 m_targets.setDestination(currentTarget->GetPositionX(), currentTarget->GetPositionY(), currentTarget->GetPositionZ());
             break;
         }
@@ -1887,17 +2064,21 @@ void Spell::SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList&
         case TARGET_ALL_FRIENDLY_UNITS_AROUND_CASTER:
             switch (m_spellInfo->Id)
             {
-                case 56153:                                 // Guardian Aura - Ahn'Kahet
+                case 56153:                                     // Guardian Aura - Ahn'Kahet
                     FillAreaTargets(targetUnitMap, m_targets.m_destX, m_targets.m_destY, radius, PUSH_SELF_CENTER, SPELL_TARGETS_FRIENDLY);
                     targetUnitMap.remove(m_caster);
                     break;
                 case 64844:                                 // Divine Hymn
                     // target amount stored in parent spell dummy effect but hard to access
-                    FillRaidOrPartyHealthPriorityTargets(targetUnitMap, m_caster, m_caster, radius, 3, true, false, false);
+                    FillRaidOrPartyHealthPriorityTargets(targetUnitMap, m_caster, m_caster, radius, 3, true, false, true);
                     break;
                 case 64904:                                 // Hymn of Hope
                     // target amount stored in parent spell dummy effect but hard to access
-                    FillRaidOrPartyManaPriorityTargets(targetUnitMap, m_caster, m_caster, radius, 3, true, false, false);
+                    FillRaidOrPartyManaPriorityTargets(targetUnitMap, m_caster, m_caster, radius, 3, true, false, true);
+                    break;
+                case 45662:
+                    // encapsulate hack, to aoivd other hacks in spellbonusdmg-, crit-, etc. calc.
+                    FillAreaTargets(targetUnitMap, m_targets.m_destX, m_targets.m_destY, radius, PUSH_SELF_CENTER, SPELL_TARGETS_HOSTILE);
                     break;
                 default:
                     // selected friendly units (for casting objects) around casting object
@@ -1906,8 +2087,46 @@ void Spell::SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList&
             }
             break;
         case TARGET_ALL_FRIENDLY_UNITS_IN_AREA:
+            // Echoes of Light
+            if (m_spellInfo->Id == 71610)
+            {
+                CellPair  p(MaNGOS::ComputeCellPair(m_caster->GetPositionX(),  m_caster->GetPositionY()));
+                Cell cell(p);
+                cell.data.Part.reserved = ALL_DISTRICT;
+                cell.SetNoCreate();
+                std::list<Unit*> tempTargetUnitMap;
+                {
+                    MaNGOS::AnyFriendlyUnitInObjectRangeCheck  u_check(m_caster, radius);
+                    MaNGOS::UnitListSearcher<MaNGOS::AnyFriendlyUnitInObjectRangeCheck>  searcher(m_caster, tempTargetUnitMap, u_check);
+
+                    TypeContainerVisitor<MaNGOS::UnitListSearcher<MaNGOS::AnyFriendlyUnitInObjectRangeCheck>,  WorldTypeMapContainer > world_unit_searcher(searcher);
+                    TypeContainerVisitor<MaNGOS::UnitListSearcher<MaNGOS::AnyFriendlyUnitInObjectRangeCheck>,  GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+                    cell.Visit(p, world_unit_searcher,  *m_caster->GetMap(), *m_caster, radius);
+                    cell.Visit(p, grid_unit_searcher,  *m_caster->GetMap(), *m_caster, radius);
+                }
+
+                if(tempTargetUnitMap.empty())
+                    break;
+
+                tempTargetUnitMap.sort(TargetDistanceOrder(m_caster));
+
+                //Now to get us a random target that's in the initial  range of the spell
+                uint32 t = 0;
+                std::list<Unit*>::iterator itr =  tempTargetUnitMap.begin();
+                while(itr != tempTargetUnitMap.end() &&  (*itr)->IsWithinDist(m_caster, radius))
+                    ++t, ++itr;
+
+                if(!t)
+                    break;
+
+                itr = tempTargetUnitMap.begin();
+                std::advance(itr, rand() % t);
+                Unit *pUnitTarget = *itr;
+                targetUnitMap.push_back(pUnitTarget);
+            }
             // Death Pact (in fact selection by player selection)
-            if (m_spellInfo->Id == 48743)
+            else if (m_spellInfo->Id == 48743)
             {
                 // checked in Spell::CheckCast
                 if (m_caster->GetTypeId()==TYPEID_PLAYER)
@@ -2014,8 +2233,13 @@ void Spell::SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList&
             FillAreaTargets(targetUnitMap, m_caster->GetPositionX(), m_caster->GetPositionY(), radius, PUSH_IN_FRONT_15, SPELL_TARGETS_AOE_DAMAGE);
             break;
         case TARGET_IN_FRONT_OF_CASTER_30:
-            FillAreaTargets(targetUnitMap, m_caster->GetPositionX(), m_caster->GetPositionY(), radius, PUSH_IN_FRONT_30, SPELL_TARGETS_AOE_DAMAGE);
+        {
+            if (m_spellInfo->SpellFamilyName == SPELLFAMILY_GENERIC)
+                FillAreaTargets(targetUnitMap, m_caster->GetPositionX(), m_caster->GetPositionY(), radius, PUSH_IN_FRONT_30, SPELL_TARGETS_AOE_DAMAGE);
+            else
+                FillAreaTargets(targetUnitMap, m_caster->GetPositionX(), m_caster->GetPositionY(), radius, PUSH_IN_FRONT_90, SPELL_TARGETS_AOE_DAMAGE);
             break;
+        }
         case TARGET_DUELVSPLAYER:
         {
             Unit *target = m_targets.getUnitTarget();
@@ -2306,7 +2530,13 @@ void Spell::SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList&
         case TARGET_DYNAMIC_OBJECT_LEFT_SIDE:
         case TARGET_DYNAMIC_OBJECT_RIGHT_SIDE:
         {
-            if (!(m_targets.m_targetMask & TARGET_FLAG_DEST_LOCATION))
+            //This should be targeting of destructible objects by vehicles (ram spells...)
+            if(m_spellInfo->EffectImplicitTargetB[effIndex] == TARGET_AREAEFFECT_CUSTOM_2)
+            {
+                //FIXME
+                break;
+            }
+            else if (!(m_targets.m_targetMask & TARGET_FLAG_DEST_LOCATION))
             {
                 float angle = m_caster->GetOrientation();
                 switch(targetMode)
@@ -2379,6 +2609,11 @@ void Spell::SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList&
         {
             // add here custom effects that need default target.
             // FOR EVERY TARGET TYPE THERE IS A DIFFERENT FILL!!
+            if (m_spellInfo->SpellFamilyFlags2 & UI64LIT (0x00000020) && m_spellInfo->SpellIconID == 3217)
+            {
+                targetUnitMap.push_back(m_caster);
+                break;
+            }
             switch(m_spellInfo->Effect[effIndex])
             {
                 case SPELL_EFFECT_DUMMY:
@@ -2563,7 +2798,7 @@ void Spell::SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList&
         if (removed_utarget && m_targets.getUnitTarget())
             targetUnitMap.push_back(m_targets.getUnitTarget());
     }
-}
+    }
 
 void Spell::prepare(SpellCastTargets const* targets, Aura* triggeredByAura)
 {
@@ -2591,12 +2826,26 @@ void Spell::prepare(SpellCastTargets const* targets, Aura* triggeredByAura)
         return;
     }
 
+    if(uint8 result = sObjectMgr.IsSpellDisabled(m_spellInfo->Id))
+    {
+        if(m_caster->GetTypeId() == TYPEID_PLAYER)
+        {
+            sLog.outDebug("Player %s cast a spell %u which was disabled by server administrator",   m_caster->GetName(), m_spellInfo->Id);
+            if(result == 2)
+            sLog.outChar("Player %s cast a spell %u which was disabled by server administrator and marked as CheatSpell",   m_caster->GetName(), m_spellInfo->Id);
+        }
+        SendCastResult(SPELL_FAILED_SPELL_UNAVAILABLE);
+        finish(false);
+        return;
+    }
+
     // Fill cost data
     m_powerCost = CalculatePowerCost();
 
     SpellCastResult result = CheckCast(true);
     if(result != SPELL_CAST_OK && !IsAutoRepeat())          //always cast autorepeat dummy for triggering
     {
+        //error_log("Spatne 1, spell %s", m_spellInfo->SpellName[0]);
         if(triggeredByAura)
         {
             SendChannelUpdate(0);
@@ -2619,10 +2868,7 @@ void Spell::prepare(SpellCastTargets const* targets, Aura* triggeredByAura)
     // stealth must be removed at cast starting (at show channel bar)
     // skip triggered spell (item equip spell casting and other not explicit character casts/item uses)
     if ( !m_IsTriggeredSpell && isSpellBreakStealth(m_spellInfo) )
-    {
-        m_caster->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
-        m_caster->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
-    }
+        m_caster->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_CAST);
 
     // add non-triggered (with cast time and without)
     if (!m_IsTriggeredSpell)
@@ -2632,6 +2878,9 @@ void Spell::prepare(SpellCastTargets const* targets, Aura* triggeredByAura)
 
         // will show cast bar
         SendSpellStart();
+
+        if (m_caster->GetTypeId() == TYPEID_PLAYER)
+            ((Player*)m_caster)->AddGlobalCooldown(m_spellInfo,this);
     }
     // execute triggered without cast time explicitly in call point
     else if(m_timer == 0)
@@ -2658,8 +2907,11 @@ void Spell::cancel()
 
         case SPELL_STATE_CASTING:
         {
-            for(std::list<TargetInfo>::const_iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+            for(tbb::concurrent_vector<TargetInfo>::const_iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
             {
+                if (ihit->deleted == true)
+                    continue;
+
                 if( ihit->missCondition == SPELL_MISS_NONE )
                 {
                     Unit* unit = m_caster->GetObjectGuid() == (*ihit).targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, ihit->targetGUID);
@@ -2677,6 +2929,8 @@ void Spell::cancel()
         {
         } break;
     }
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        ((Player*)m_caster)->RemoveGlobalCooldown(m_spellInfo);
 
     finish(false);
     m_caster->RemoveDynObject(m_spellInfo->Id);
@@ -2685,6 +2939,13 @@ void Spell::cancel()
 
 void Spell::cast(bool skipCheck)
 {
+    if(m_spellInfo->Id <= 0 || m_spellInfo->Id > MAX_SPELL_ID)
+        return;
+
+    SpellEntry const* spellInfo = sSpellStore.LookupEntry(m_spellInfo->Id);
+    if(!spellInfo)
+        return;
+
     SetExecutedCurrently(true);
 
     if (!m_caster->CheckAndIncreaseCastCounter())
@@ -2739,6 +3000,14 @@ void Spell::cast(bool skipCheck)
         }
     }
 
+    if (m_spellInfo->Id == 27827)
+        if(const SpellEntry* spellInfo = sSpellStore.LookupEntry(m_spellInfo->Id))
+            const_cast<SpellEntry*>(spellInfo)->AuraInterruptFlags = 0;
+
+    if (m_spellInfo->Id == 32592)
+        if(const SpellEntry* spellInfo = sSpellStore.LookupEntry(m_spellInfo->Id))
+            const_cast<SpellEntry*>(spellInfo)->Attributes |= SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY;
+
     // different triggred (for caster) and precast (casted before apply effect to target) cases
     switch(m_spellInfo->SpellFamilyName)
     {
@@ -2746,10 +3015,14 @@ void Spell::cast(bool skipCheck)
         {
             if (m_spellInfo->Mechanic == MECHANIC_BANDAGE)  // Bandages
                 AddPrecastSpell(11196);                     // Recently Bandaged
+            else if(m_spellInfo->Id == 7744)                // Will of the Forsaken
+                AddTriggeredSpell(72757);                   // PvP trinket Cooldown
             else if(m_spellInfo->Id == 20594)               // Stoneskin
                 AddTriggeredSpell(65116);                   // Stoneskin - armor 10% for 8 sec
             else if(m_spellInfo->Id == 71904)               // Chaos Bane strength buff
                 AddTriggeredSpell(73422);
+            else if(m_spellInfo->Id == 42292)               // PvP trinket
+                AddTriggeredSpell(72752);                   // Will of the Forsaken Cooldown
             break;
         }
         case SPELLFAMILY_MAGE:
@@ -2757,6 +3030,32 @@ void Spell::cast(bool skipCheck)
             // Ice Block
             if (m_spellInfo->SpellFamilyFlags & UI64LIT(0x0000008000000000))
                 AddPrecastSpell(41425);                     // Hypothermia
+
+            // Fingers of Frost
+            else if (m_spellInfo->Id == 44544)
+                AddPrecastSpell(74396);
+
+            // Mirror Image (glyph)
+            if (m_spellInfo->Id == 55342 && m_caster->HasAura(63093))
+                AddPrecastSpell(65047);                     // Mirror Image (summon 4th immage)
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+        {
+            // Item - Warrior T10 Melee 4P Bonus
+            if (m_spellInfo->Id == 46916 || m_spellInfo->Id == 52437)
+            {
+                if (Aura *aur = m_caster->GetAura(70847, EFFECT_INDEX_0))
+                {
+                    if (roll_chance_i(aur->GetModifier()->m_amount))
+                    {
+                        AddTriggeredSpell(70849);
+                    }
+                }
+            }
+            // Shattering Throw
+            else if (m_spellInfo->Id == 64382)
+                AddPrecastSpell(64380);
             break;
         }
         case SPELLFAMILY_PRIEST:
@@ -2786,9 +3085,25 @@ void Spell::cast(bool skipCheck)
         }
         case SPELLFAMILY_DRUID:
         {
+           if (m_spellInfo->SpellIconID == 2852 && (m_spellInfo->AttributesEx & 0x28020)) // Berserk
+               AddPrecastSpell(58923); // Hit 3 targets at once with mangle in dire bear form
+
             // Faerie Fire (Feral)
             if (m_spellInfo->Id == 16857 && m_caster->m_form != FORM_CAT)
                 AddTriggeredSpell(60089);
+            // Item - Druid T10 Balance 2P Bonus
+            else if (m_spellInfo->Id == 16870 && m_caster->HasAura(70718))
+                AddTriggeredSpell(70721);
+            // Berserk (Bear Mangle part)
+            else if (m_spellInfo->Id == 50334 && (m_caster->m_form == FORM_BEAR || m_caster->m_form == FORM_DIREBEAR))
+                AddTriggeredSpell(58923); 
+            break;
+        }
+        case SPELLFAMILY_HUNTER:
+        {
+            // Deterrence
+            if (m_spellInfo->Id == 19263)
+                AddTriggeredSpell(67801);
             break;
         }
         case SPELLFAMILY_ROGUE:
@@ -2823,6 +3138,22 @@ void Spell::cast(bool skipCheck)
             // Avenging Wrath
             else if (m_spellInfo->SpellFamilyFlags & UI64LIT(0x0000200000000000))
                 AddPrecastSpell(61987);                     // Avenging Wrath Marker
+            // Lay on Hands
+            else if (m_spellInfo->SpellFamilyFlags & UI64LIT(0x000000008000))
+            {
+                if (m_targets.getUnitTarget() && m_targets.getUnitTarget() == m_caster)
+                {
+                    AddPrecastSpell(25771);                 // Forbearance
+                    AddPrecastSpell(61987);                 // Avenging Wrath Marker
+                }
+            }
+            // Aura Mastery 
+            else if (m_spellInfo->Id == 31821) 
+            { 
+                // get Concentration Aura 
+                if (m_caster->GetAura(SPELL_AURA_REDUCE_PUSHBACK, SPELLFAMILY_PALADIN, UI64LIT(0x00020000), (0x00000020), m_caster->GetGUID())) 
+                    AddTriggeredSpell(64364);               // Aura Mastery - immunity part 
+            }
             break;
         }
         case SPELLFAMILY_SHAMAN:
@@ -2844,7 +3175,7 @@ void Spell::cast(bool skipCheck)
         }
         case SPELLFAMILY_DEATHKNIGHT:
         {
-            // Chains of Ice
+            // Frost Fever at Chains of Ice
             if (m_spellInfo->Id == 45524)
                 AddTriggeredSpell(55095);                   // Frost Fever
             break;
@@ -2883,18 +3214,27 @@ void Spell::cast(bool skipCheck)
     SendCastResult(castResult);
     SendSpellGo();                                          // we must send smsg_spell_go packet before m_castItem delete in TakeCastItem()...
 
+    // Cache combo points used for spell and clear real one to prevent mutlti-casting delayed spells
+    if(m_caster->GetTypeId() != TYPEID_PLAYER && ((Creature*)m_caster)->isVehicle() && NeedsComboPoints(m_spellInfo))
+    {
+    ((Vehicle*)m_caster)->m_comboPointsForCast = ((Player*)m_caster->GetCharmer())->GetComboPoints();
+    ((Player*)m_caster->GetCharmer())->ClearComboPoints();
+    }
+    
     InitializeDamageMultipliers();
 
     // Okay, everything is prepared. Now we need to distinguish between immediate and evented delayed spells
-    if (m_spellInfo->speed > 0.0f)
+    if (m_spellInfo->speed > 0.0f || m_spellInfo->Id == 14157)
     {
 
         // Remove used for cast item if need (it can be already NULL after TakeReagents call
         // in case delayed spell remove item at cast delay start
         TakeCastItem();
+        if(m_caster->GetTypeId() != TYPEID_PLAYER && ((Creature*)m_caster)->isVehicle() && NeedsComboPoints(m_spellInfo))
+                ((Player*)m_caster->GetCharmer())->ClearComboPoints();
 
         // fill initial spell damage from caster for delayed casted spells
-        for(std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+        for(tbb::concurrent_vector<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin();ihit != m_UniqueTargetInfo.end();++ihit)
             HandleDelayedSpellLaunch(&(*ihit));
 
         // Okay, maps created, now prepare flags
@@ -2914,6 +3254,13 @@ void Spell::cast(bool skipCheck)
 
 void Spell::handle_immediate()
 {
+    if (m_spellInfo->Id <= 0 || m_spellInfo->Id > MAX_SPELL_ID || m_spellInfo->Id == 32 || m_spellInfo->Id == 48 || m_spellInfo->Id == 576 || m_spellInfo->Id == 80 || m_spellInfo->Id == 160)
+        return;
+
+    SpellEntry const* spellInfo = sSpellStore.LookupEntry(m_spellInfo->Id);
+    if (!spellInfo)
+        return;
+
     // start channeling if applicable
     if(IsChanneledSpell(m_spellInfo))
     {
@@ -2931,11 +3278,27 @@ void Spell::handle_immediate()
     // process immediate effects (items, ground, etc.) also initialize some variables
     _handle_immediate_phase();
 
-    for(std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    for (tbb::concurrent_vector<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin();ihit != m_UniqueTargetInfo.end();++ihit)
+    {
+        if (m_destroyed == true || ihit == m_UniqueTargetInfo.end() || m_UniqueTargetInfo.size() == 0)
+            break;
+
+        if (ihit->deleted == true)
+            continue;
+
         DoAllEffectOnTarget(&(*ihit));
+    }
+
+    for (tbb::concurrent_vector<GOTargetInfo>::iterator ihit= m_UniqueGOTargetInfo.begin();ihit != m_UniqueGOTargetInfo.end();++ihit)
+    {
+        if (m_destroyed == true || ihit == m_UniqueGOTargetInfo.end() || m_UniqueGOTargetInfo.size() == 0)
+            break;
+
+        if (ihit->deleted == true)
+            continue;
 
-    for(std::list<GOTargetInfo>::iterator ihit = m_UniqueGOTargetInfo.begin(); ihit != m_UniqueGOTargetInfo.end(); ++ihit)
         DoAllEffectOnTarget(&(*ihit));
+    }
 
     // spell is finished, perform some last features of the spell here
     _handle_finish_phase();
@@ -2958,7 +3321,7 @@ uint64 Spell::handle_delayed(uint64 t_offset)
     }
 
     // now recheck units targeting correctness (need before any effects apply to prevent adding immunity at first effect not allow apply second spell effect and similar cases)
-    for(std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    for(tbb::concurrent_vector<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end();++ihit)
     {
         if (ihit->processed == false)
         {
@@ -2970,7 +3333,7 @@ uint64 Spell::handle_delayed(uint64 t_offset)
     }
 
     // now recheck gameobject targeting correctness
-    for(std::list<GOTargetInfo>::iterator ighit = m_UniqueGOTargetInfo.begin(); ighit != m_UniqueGOTargetInfo.end(); ++ighit)
+    for(tbb::concurrent_vector<GOTargetInfo>::iterator ighit= m_UniqueGOTargetInfo.begin(); ighit != m_UniqueGOTargetInfo.end();++ighit)
     {
         if (ighit->processed == false)
         {
@@ -3026,7 +3389,7 @@ void Spell::_handle_immediate_phase()
     m_diminishGroup = DIMINISHING_NONE;
 
     // process items
-    for(std::list<ItemTargetInfo>::iterator ihit = m_UniqueItemInfo.begin(); ihit != m_UniqueItemInfo.end(); ++ihit)
+    for(tbb::concurrent_vector<ItemTargetInfo>::iterator ihit = m_UniqueItemInfo.begin(); ihit != m_UniqueItemInfo.end(); ++ihit)
         DoAllEffectOnTarget(&(*ihit));
 
     // process ground
@@ -3097,6 +3460,9 @@ void Spell::update(uint32 difftime)
         {
             if(m_timer)
             {
+                if (m_targets.getUnitTarget() && !m_targets.getUnitTarget()->isVisibleForOrDetect(m_caster, m_caster, false))
+                    cancel();
+
                 if(difftime >= m_timer)
                     m_timer = 0;
                 else
@@ -3149,8 +3515,11 @@ void Spell::update(uint32 difftime)
                 {
                     if ( Player* p = m_caster->GetCharmerOrOwnerPlayerOrPlayerItself() )
                     {
-                        for(std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                        for(tbb::concurrent_vector<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
                         {
+                            if (ihit->deleted == true)
+                                continue;
+
                             TargetInfo* target = &*ihit;
                             if(!target->targetGUID.IsCreature())
                                 continue;
@@ -3162,8 +3531,11 @@ void Spell::update(uint32 difftime)
                             p->RewardPlayerAndGroupAtCast(unit, m_spellInfo->Id);
                         }
 
-                        for(std::list<GOTargetInfo>::iterator ihit = m_UniqueGOTargetInfo.begin(); ihit != m_UniqueGOTargetInfo.end(); ++ihit)
+                        for(tbb::concurrent_vector<GOTargetInfo>::iterator ihit = m_UniqueGOTargetInfo.begin(); ihit != m_UniqueGOTargetInfo.end(); ++ihit)
                         {
+                            if (ihit->deleted == true)
+                                continue;
+
                             GOTargetInfo* target = &*ihit;
 
                             GameObject* go = m_caster->GetMap()->GetGameObject(target->targetGUID);
@@ -3208,8 +3580,11 @@ void Spell::finish(bool ok)
     {
         if (!(*i)->isAffectedOnSpell(m_spellInfo))
             continue;
-        for(std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+        for(tbb::concurrent_vector<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
         {
+            if (ihit->deleted == true)
+                continue;
+
             if( ihit->missCondition == SPELL_MISS_NONE )
             {
                 // check m_caster->GetGUID() let load auras at login and speedup most often case
@@ -3230,7 +3605,7 @@ void Spell::finish(bool ok)
 
     // Heal caster for all health leech from all targets
     if (m_healthLeech)
-        m_caster->DealHeal(m_caster, uint32(m_healthLeech), m_spellInfo);
+		m_caster->DealHeal(m_caster, uint32(m_healthLeech), m_spellInfo);
 
     if (IsMeleeAttackResetSpell())
     {
@@ -3243,14 +3618,17 @@ void Spell::finish(bool ok)
         m_caster->resetAttackTimer(RANGED_ATTACK);*/
 
     // Clear combo at finish state
-    if(m_caster->GetTypeId() == TYPEID_PLAYER && NeedsComboPoints(m_spellInfo))
+    if((m_caster->GetTypeId() == TYPEID_PLAYER || ((Creature*)m_caster)->isVehicle()) && NeedsComboPoints(m_spellInfo))
     {
         // Not drop combopoints if negative spell and if any miss on enemy exist
         bool needDrop = true;
         if (!IsPositiveSpell(m_spellInfo->Id))
         {
-            for(std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+            for(tbb::concurrent_vector<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
             {
+                if (ihit->deleted == true)
+                    continue;
+
                 if (ihit->missCondition != SPELL_MISS_NONE && ihit->targetGUID != m_caster->GetObjectGuid())
                 {
                     needDrop = false;
@@ -3259,7 +3637,10 @@ void Spell::finish(bool ok)
             }
         }
         if (needDrop)
-            ((Player*)m_caster)->ClearComboPoints();
+        {
+            if(m_caster->GetTypeId() == TYPEID_PLAYER)
+                ((Player*)m_caster)->ClearComboPoints();						
+        }
     }
 
     // potions disabled by client, send event "not in combat" if need
@@ -3273,6 +3654,39 @@ void Spell::finish(bool ok)
     // Stop Attack for some spells
     if( m_spellInfo->Attributes & SPELL_ATTR_STOP_ATTACK_TARGET )
         m_caster->AttackStop();
+
+    // hack for Fingers of Frost stacks remove
+    if(m_caster->HasAura(74396) && !m_IsTriggeredSpell && m_spellInfo->SpellFamilyName == SPELLFAMILY_MAGE)
+        if (Aura *aur = m_caster->GetAura(74396, EFFECT_INDEX_0))
+            if(aur->DropAuraCharge())
+                m_caster->RemoveAura(aur);
+
+    // hack for SPELL_AURA_IGNORE_UNIT_STATE charges
+    bool break_for = false;
+    Unit::AuraList const& stateAuras = m_caster->GetAurasByType(SPELL_AURA_IGNORE_UNIT_STATE);
+    for(Unit::AuraList::const_iterator j = stateAuras.begin();j != stateAuras.end(); ++j)
+    {
+        switch((*j)->GetId())
+        {
+            case 52437:        //Sudden death should disappear after execute
+                if (m_spellInfo->SpellIconID == 1648)
+                {
+                    m_caster->RemoveAura((*j));
+                    break_for = true;
+                }
+                break;
+            case 60503:        // Taste for blood 
+            case 68051:        // Glyph of overpower - Both should disappear after overpower
+                if(m_spellInfo->Id == 7384)
+                {
+                    m_caster->RemoveAura((*j));
+                    break_for = true;
+                }
+                break;
+        }
+        if(break_for)
+            break;
+    }
 }
 
 void Spell::SendCastResult(SpellCastResult result)
@@ -3323,6 +3737,11 @@ void Spell::SendCastResult(Player* caster, SpellEntry const* spellInfo, uint8 ca
                     break;
             }
             break;
+        case SPELL_FAILED_REAGENTS:
+            // normally client checks reagents, just some script effects here
+            if(spellInfo->Id == 46584)                      // Raise Dead
+                data << uint32(37201);                      // Corpse Dust
+            break;
         case SPELL_FAILED_TOTEMS:
             for(int i = 0; i < MAX_SPELL_TOTEMS; ++i)
                 if(spellInfo->Totem[i])
@@ -3358,13 +3777,15 @@ void Spell::SendSpellStart()
     if (m_spellInfo->runeCostID)
         castFlags |= CAST_FLAG_UNKNOWN10;
 
+    Unit *caster = (m_originalCaster && m_IsTriggeredSpell) ? m_originalCaster : m_caster;
+
     WorldPacket data(SMSG_SPELL_START, (8+8+4+4+2));
     if (m_CastItem)
         data << m_CastItem->GetPackGUID();
     else
-        data << m_caster->GetPackGUID();
+        data << caster->GetPackGUID();
 
-    data << m_caster->GetPackGUID();
+    data << caster->GetPackGUID();
     data << uint8(m_cast_count);                            // pending spell cast?
     data << uint32(m_spellInfo->Id);                        // spellId
     data << uint32(castFlags);                              // cast flags
@@ -3420,14 +3841,16 @@ void Spell::SendSpellGo()
         castFlags |= CAST_FLAG_UNKNOWN7;                    // rune cooldowns list
     }
 
+    Unit *caster = (m_originalCaster && m_IsTriggeredSpell) ? m_originalCaster : m_caster;
+
     WorldPacket data(SMSG_SPELL_GO, 50);                    // guess size
 
     if(m_CastItem)
         data << m_CastItem->GetPackGUID();
     else
-        data << m_caster->GetPackGUID();
+        data << caster->GetPackGUID();
 
-    data << m_caster->GetPackGUID();
+    data << caster->GetPackGUID();
     data << uint8(m_cast_count);                            // pending spell cast?
     data << uint32(m_spellInfo->Id);                        // spellId
     data << uint32(castFlags);                              // cast flags
@@ -3438,7 +3861,7 @@ void Spell::SendSpellGo()
     data << m_targets;
 
     if ( castFlags & CAST_FLAG_UNKNOWN6 )                   // unknown wotlk, predicted power?
-        data << uint32(0);
+        data << uint32(m_caster->GetPower(m_caster->getPowerType())); // Yes, it is really predicted power.
 
     if ( castFlags & CAST_FLAG_UNKNOWN7 )                   // rune cooldowns list
     {
@@ -3556,7 +3979,7 @@ void Spell::WriteSpellGoTargets( WorldPacket * data )
     // m_needAliveTargetMask req for stop channeling if one target die
     uint32 hit  = m_UniqueGOTargetInfo.size(); // Always hits on GO
     uint32 miss = 0;
-    for(std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    for(tbb::concurrent_vector<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
     {
         if ((*ihit).effectMask == 0)                  // No effect apply - all immuned add state
         {
@@ -3571,7 +3994,7 @@ void Spell::WriteSpellGoTargets( WorldPacket * data )
     }
 
     *data << (uint8)hit;
-    for(std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    for(tbb::concurrent_vector<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
     {
         if ((*ihit).missCondition == SPELL_MISS_NONE)       // Add only hits
         {
@@ -3580,11 +4003,11 @@ void Spell::WriteSpellGoTargets( WorldPacket * data )
         }
     }
 
-    for(std::list<GOTargetInfo>::const_iterator ighit = m_UniqueGOTargetInfo.begin(); ighit != m_UniqueGOTargetInfo.end(); ++ighit)
+    for(tbb::concurrent_vector<GOTargetInfo>::const_iterator ighit = m_UniqueGOTargetInfo.begin(); ighit != m_UniqueGOTargetInfo.end(); ++ighit)
         *data << ighit->targetGUID;                         // Always hits
 
     *data << (uint8)miss;
-    for(std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    for(tbb::concurrent_vector<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
     {
         if( ihit->missCondition != SPELL_MISS_NONE )        // Add only miss
         {
@@ -3752,8 +4175,11 @@ void Spell::SendChannelStart(uint32 duration)
     // select first not resisted target from target list for _0_ effect
     if(!m_UniqueTargetInfo.empty())
     {
-        for(std::list<TargetInfo>::const_iterator itr = m_UniqueTargetInfo.begin(); itr != m_UniqueTargetInfo.end(); ++itr)
+        for(tbb::concurrent_vector<TargetInfo>::const_iterator itr = m_UniqueTargetInfo.begin(); itr != m_UniqueTargetInfo.end(); ++itr)
         {
+            if (itr->deleted == true)
+                continue;
+
             if( (itr->effectMask & (1 << 0)) && itr->reflectResult == SPELL_MISS_NONE && itr->targetGUID != m_caster->GetObjectGuid())
             {
                 target = ObjectAccessor::GetUnit(*m_caster, itr->targetGUID);
@@ -3763,8 +4189,11 @@ void Spell::SendChannelStart(uint32 duration)
     }
     else if(!m_UniqueGOTargetInfo.empty())
     {
-        for(std::list<GOTargetInfo>::const_iterator itr = m_UniqueGOTargetInfo.begin(); itr != m_UniqueGOTargetInfo.end(); ++itr)
+        for(tbb::concurrent_vector<GOTargetInfo>::const_iterator itr = m_UniqueGOTargetInfo.begin(); itr != m_UniqueGOTargetInfo.end(); ++itr)
         {
+            if (itr->deleted)
+                continue;
+
             if(itr->effectMask & (1 << 0) )
             {
                 target = m_caster->GetMap()->GetGameObject(itr->targetGUID);
@@ -4136,13 +4565,17 @@ void Spell::CastPreCastSpells(Unit* target)
 
 SpellCastResult Spell::CheckCast(bool strict)
 {
+   // Ebonweave
+   if(m_spellInfo->Id==56002 && m_caster->GetAreaId()==4167) return SPELL_CAST_OK;
+
     // check cooldowns to prevent cheating (ignore passive spells, that client side visual only)
     if (m_caster->GetTypeId()==TYPEID_PLAYER && !(m_spellInfo->Attributes & SPELL_ATTR_PASSIVE) &&
-        ((Player*)m_caster)->HasSpellCooldown(m_spellInfo->Id))
+        ((Player*)m_caster)->HasSpellCooldown(m_spellInfo->Id) && !m_caster->isIgnoreUnitState(m_spellInfo) ||
+         (m_caster->GetTypeId()==TYPEID_PLAYER && strict && !m_IsTriggeredSpell && ((Player*)m_caster)->HasGlobalCooldown(m_spellInfo)))
     {
         if(m_triggeredByAuraSpell)
             return SPELL_FAILED_DONT_REPORT;
-        else
+        else if(!m_IsTriggeredSpell || m_CastItem)
             return SPELL_FAILED_NOT_READY;
     }
 
@@ -4199,6 +4632,10 @@ SpellCastResult Spell::CheckCast(bool strict)
         else if(m_caster->HasAura(m_spellInfo->excludeCasterAuraSpell))
             return SPELL_FAILED_CASTER_AURASTATE;
     }
+    //Check Caster for combat
+    if(m_caster->isInCombat() && IsNonCombatSpell(m_spellInfo) && !m_caster->isIgnoreUnitState(m_spellInfo) && !m_IsTriggeredSpell
+       && (!(m_spellInfo->SpellFamilyFlags & SPELLFAMILYFLAG_ROGUE_STEALTH)) && m_spellInfo->SpellFamilyFlags & SPELLFAMILYFLAG_ROGUE_VANISH)  // Vanish hack
+        return SPELL_FAILED_AFFECTING_COMBAT;
 
     // cancel autorepeat spells if cast start when moving
     // (not wand currently autorepeat cast delayed to moving stop anyway in spell update code)
@@ -4241,7 +4678,7 @@ SpellCastResult Spell::CheckCast(bool strict)
         if(non_caster_target)
         {
             // target state requirements (apply to non-self only), to allow cast affects to self like Dirty Deeds
-            if(m_spellInfo->TargetAuraState && !target->HasAuraStateForCaster(AuraState(m_spellInfo->TargetAuraState),m_caster->GetGUID()))
+            if(m_spellInfo->TargetAuraState && !target->HasAuraStateForCaster(AuraState(m_spellInfo->TargetAuraState),m_caster->GetGUID()) && !m_caster->isIgnoreUnitState(m_spellInfo))
                 return SPELL_FAILED_TARGET_AURASTATE;
 
             // Not allow casting on flying player
@@ -4379,7 +4816,7 @@ SpellCastResult Spell::CheckCast(bool strict)
             }
             // TODO: this check can be applied and for player to prevent cheating when IsPositiveSpell will return always correct result.
             // check target for pet/charmed casts (not self targeted), self targeted cast used for area effects and etc
-            if (!explicit_target_mode && m_caster->GetTypeId() == TYPEID_UNIT && m_caster->GetCharmerOrOwnerGUID())
+            if (!explicit_target_mode && m_caster->GetTypeId() == TYPEID_UNIT && m_caster->GetCharmerOrOwnerGUID() && !IsDispelSpell(m_spellInfo))
             {
                 // check correctness positive/negative cast target (pet cast real check and cheating check)
                 if(IsPositiveSpell(m_spellInfo->Id))
@@ -4447,11 +4884,31 @@ SpellCastResult Spell::CheckCast(bool strict)
         return locRes;
 
     // not let players cast spells at mount (and let do it to creatures)
-    if (m_caster->IsMounted() && m_caster->GetTypeId()==TYPEID_PLAYER && !m_IsTriggeredSpell &&
+    if ((m_caster->IsMounted() || m_caster->GetVehicleGUID()) && m_caster->GetTypeId()==TYPEID_PLAYER && !m_IsTriggeredSpell &&
         !IsPassiveSpell(m_spellInfo->Id) && !(m_spellInfo->Attributes & SPELL_ATTR_CASTABLE_WHILE_MOUNTED))
     {
         if (m_caster->isInFlight())
+        {
             return SPELL_FAILED_NOT_ON_TAXI;
+        }			
+        else if(m_caster->GetVehicleGUID())
+        {
+            if(!(m_caster->m_movementInfo.GetVehicleSeatFlags() & SF_CAN_CAST))
+                return SPELL_FAILED_NOT_MOUNTED;
+        }
+        else if ((sWorld.getConfig(CONFIG_BOOL_ALLOW_FLYING_MOUNTS_EVERYWHERE)) && (m_spellInfo->Id==55884))
+        {
+            Player* player = (Player*)m_caster;
+            uint32 spellToLearn = ((m_spellInfo->Id==SPELL_ID_GENERIC_LEARN) || (m_spellInfo->Id==SPELL_ID_GENERIC_LEARN_PET)) ? damage : m_spellInfo->EffectTriggerSpell[0];
+            SpellEntry const *sEntry = sSpellStore.LookupEntry(spellToLearn);
+            if(sEntry)
+            {
+                if(player->isFlyingSpell(sEntry) || player->isFlyingFormSpell(sEntry))
+                {
+                    return SPELL_CAST_OK;
+                }
+            }
+        }
         else
             return SPELL_FAILED_NOT_MOUNTED;
     }
@@ -4682,7 +5139,7 @@ SpellCastResult Spell::CheckCast(bool strict)
             {
                 if(m_spellInfo->SpellIconID == 1648)        // Execute
                 {
-                    if(!m_targets.getUnitTarget() || m_targets.getUnitTarget()->GetHealth() > m_targets.getUnitTarget()->GetMaxHealth()*0.2)
+                    if(!m_targets.getUnitTarget() || m_targets.getUnitTarget()->GetHealth() > m_targets.getUnitTarget()->GetMaxHealth()*0.2 && !m_caster->isIgnoreUnitState(m_spellInfo))
                         return SPELL_FAILED_BAD_TARGETS;
                 }
                 else if (m_spellInfo->Id == 51582)          // Rocket Boots Engaged
@@ -4690,6 +5147,12 @@ SpellCastResult Spell::CheckCast(bool strict)
                     if(m_caster->IsInWater())
                         return SPELL_FAILED_ONLY_ABOVEWATER;
                 }
+                else if (m_spellInfo->SpellFamilyFlags == UI64LIT(0x2000)) // Death Coil (DeathKnight)
+                {
+                    Unit* target = m_targets.getUnitTarget();
+                    if (!target || (target->IsFriendlyTo(m_caster) && target->GetCreatureType() != CREATURE_TYPE_UNDEAD))
+                        return SPELL_FAILED_BAD_TARGETS;
+                }
                 else if(m_spellInfo->SpellIconID == 156)    // Holy Shock
                 {
                     // spell different for friends and enemies
@@ -4966,6 +5429,17 @@ SpellCastResult Spell::CheckCast(bool strict)
 
                 break;
             }
+            case SPELL_EFFECT_SUMMON_OBJECT_SLOT1:
+            case SPELL_EFFECT_SUMMON_OBJECT_SLOT2:
+            case SPELL_EFFECT_SUMMON_OBJECT_SLOT3:
+            case SPELL_EFFECT_SUMMON_OBJECT_SLOT4:
+            {
+                if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                    if (((Player*)m_caster)->HasMovementFlag(MOVEFLAG_ONTRANSPORT))
+                        return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+                    
+                break;
+            }
             case SPELL_EFFECT_SUMMON_PET:
             {
                 if(m_caster->GetPetGUID())                  //let warlock do a replacement summon
@@ -5014,24 +5488,16 @@ SpellCastResult Spell::CheckCast(bool strict)
             case SPELL_EFFECT_LEAP:
             case SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER:
             {
-                float dis = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
-                float fx = m_caster->GetPositionX() + dis * cos(m_caster->GetOrientation());
-                float fy = m_caster->GetPositionY() + dis * sin(m_caster->GetOrientation());
-                // teleport a bit above terrain level to avoid falling below it
-                float fz = m_caster->GetBaseMap()->GetHeight(fx, fy, m_caster->GetPositionZ(), true);
-                if(fz <= INVALID_HEIGHT)                    // note: this also will prevent use effect in instances without vmaps height enabled
-                    return SPELL_FAILED_TRY_AGAIN;
-
-                float caster_pos_z = m_caster->GetPositionZ();
-                // Control the caster to not climb or drop when +-fz > 8
-                if(!(fz <= caster_pos_z + 8 && fz >= caster_pos_z - 8))
-                    return SPELL_FAILED_TRY_AGAIN;
-
                 // not allow use this effect at battleground until battleground start
                 if(m_caster->GetTypeId() == TYPEID_PLAYER)
+                {
                     if(BattleGround const *bg = ((Player*)m_caster)->GetBattleGround())
                         if(bg->GetStatus() != STATUS_IN_PROGRESS)
                             return SPELL_FAILED_TRY_AGAIN;
+
+                    if(((Player*)m_caster)->HasMovementFlag(MOVEFLAG_ONTRANSPORT))
+                        return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+                }
                 break;
             }
             case SPELL_EFFECT_STEAL_BENEFICIAL_BUFF:
@@ -5040,6 +5506,23 @@ SpellCastResult Spell::CheckCast(bool strict)
                     return SPELL_FAILED_BAD_TARGETS;
                 break;
             }
+            case SPELL_EFFECT_LEAP_BACK:
+            {
+                if(m_spellInfo->Id == 781)
+                    if(!m_caster->isInCombat()) 
+                        return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW; 
+                break;
+            }
+            case SPELL_EFFECT_TRANS_DOOR:
+            {
+                if(m_caster->GetTypeId() == TYPEID_PLAYER)
+                {
+                    if(m_spellInfo->Id == 698)
+                        if(((Player*)m_caster)->GetMap()->IsBattleGround())
+                            return SPELL_FAILED_NOT_HERE;
+                }
+                break;
+            }
             default:break;
         }
     }
@@ -5192,36 +5675,19 @@ SpellCastResult Spell::CheckCast(bool strict)
 
                 break;
             }
+            case SPELL_AURA_MOD_INCREASE_SPEED:
+            {
+                // Dash in Cat Form check
+                if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && m_spellInfo->SpellIconID == 959)
+                    if ( m_caster->m_form != FORM_CAT)
+                        return SPELL_FAILED_ONLY_SHAPESHIFT;
+                break;
+            }
             default:
                 break;
         }
     }
 
-    // check trade slot case (last, for allow catch any another cast problems)
-    if (m_targets.m_targetMask & TARGET_FLAG_TRADE_ITEM)
-    {
-        if (m_caster->GetTypeId() != TYPEID_PLAYER)
-            return SPELL_FAILED_NOT_TRADING;
-
-        Player *pCaster = ((Player*)m_caster);
-        TradeData* my_trade = pCaster->GetTradeData();
-
-        if (!my_trade)
-            return SPELL_FAILED_NOT_TRADING;
-
-        TradeSlots slot = TradeSlots(m_targets.getItemTargetGUID());
-        if (slot != TRADE_SLOT_NONTRADED)
-            return SPELL_FAILED_ITEM_NOT_READY;
-
-        // if trade not complete then remember it in trade data
-        if (!my_trade->IsInAcceptProcess())
-        {
-            // Spell will be casted at completing the trade. Silently ignore at this place
-            my_trade->SetSpell(m_spellInfo->Id, m_CastItem);
-            return SPELL_FAILED_DONT_REPORT;
-        }
-    }
-
     // all ok
     return SPELL_CAST_OK;
 }
@@ -5271,33 +5737,48 @@ SpellCastResult Spell::CheckPetCast(Unit* target)
             if(!_target->isAlive())
                 return SPELL_FAILED_BAD_TARGETS;
 
-            if(IsPositiveSpell(m_spellInfo->Id))
-            {
-                if(m_caster->IsHostileTo(_target))
-                    return SPELL_FAILED_BAD_TARGETS;
-            }
-            else
-            {
-                bool duelvsplayertar = false;
-                for(int j = 0; j < MAX_EFFECT_INDEX; ++j)
-                {
-                                                            //TARGET_DUELVSPLAYER is positive AND negative
-                    duelvsplayertar |= (m_spellInfo->EffectImplicitTargetA[j] == TARGET_DUELVSPLAYER);
-                }
-                if(m_caster->IsFriendlyTo(target) && !duelvsplayertar)
-                {
-                    return SPELL_FAILED_BAD_TARGETS;
-                }
-            }
+			if(!IsValidSingleTargetSpell(_target))
+				return SPELL_FAILED_BAD_TARGETS;
         }
                                                             //cooldown
         if(((Creature*)m_caster)->HasSpellCooldown(m_spellInfo->Id))
             return SPELL_FAILED_NOT_READY;
     }
 
+    // NOTE : this is done twice, also in spell->prepare(&(spell->m_targets));
     return CheckCast(true);
 }
 
+bool Spell::IsValidSingleTargetEffect(Unit const* target, Targets type) const
+{
+    switch(type)
+    {
+        case TARGET_CHAIN_DAMAGE:
+            return !m_caster->IsFriendlyTo(target);
+        case TARGET_SINGLE_FRIEND:
+        case TARGET_AREAEFFECT_PARTY:
+            return m_caster->IsFriendlyTo(target);
+       case TARGET_SINGLE_PARTY:
+            return m_caster != target && m_caster->IsInPartyWith(target);
+        case TARGET_SINGLE_FRIEND_2:
+            return m_caster->IsInRaidWith(target);
+    }
+    return true;
+}
+
+bool Spell::IsValidSingleTargetSpell(Unit const* target) const
+{
+    for(int i = 0; i < 3; ++i)
+    {
+        if(!IsValidSingleTargetEffect(target, Targets(m_spellInfo->EffectImplicitTargetA[i])))
+            return false;
+        // Need to check B?
+        //if(!IsValidSingleTargetEffect(m_spellInfo->EffectImplicitTargetB[i], target)
+        //    return false;
+    }
+    return true;
+}
+
 SpellCastResult Spell::CheckCasterAuras() const
 {
     // Flag drop spells totally immuned to caster auras
@@ -5328,15 +5809,20 @@ SpellCastResult Spell::CheckCasterAuras() const
                 dispel_immune |= GetDispellMask(DispelType(m_spellInfo->EffectMiscValue[i]));
         }
         // immune movement impairment and loss of control
-        if (m_spellInfo->Id == 42292)                       // PvP Trinket
+        if (m_spellInfo->Id == 42292 || m_spellInfo->Id ==  59752)
             mechanic_immune = IMMUNE_TO_MOVEMENT_IMPAIRMENT_AND_LOSS_CONTROL_MASK;
     }
 
+    // Caster with Cyclone can only use PvP trinket
+    if (m_caster->HasAura(33786) && mechanic_immune != IMMUNE_TO_MOVEMENT_IMPAIRMENT_AND_LOSS_CONTROL_MASK)
+        return SPELL_FAILED_STUNNED;
+
     // Check whether the cast should be prevented by any state you might have.
     SpellCastResult prevented_reason = SPELL_CAST_OK;
     // Have to check if there is a stun aura. Otherwise will have problems with ghost aura apply while logging out
     uint32 unitflag = m_caster->GetUInt32Value(UNIT_FIELD_FLAGS);     // Get unit state
-    if (unitflag & UNIT_FLAG_STUNNED && !(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_STUNNED))
+    if (unitflag & UNIT_FLAG_STUNNED && (!(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_STUNNED) ||
+        (m_spellInfo->Id == 33206 && !m_caster->HasAura(63248))))
         prevented_reason = SPELL_FAILED_STUNNED;
     else if (unitflag & UNIT_FLAG_CONFUSED && !(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_CONFUSED))
         prevented_reason = SPELL_FAILED_CONFUSED;
@@ -5446,9 +5932,14 @@ bool Spell::CanAutoCast(Unit* target)
     {
         FillTargetMap();
         //check if among target units, our WANTED target is as well (->only self cast spells return false)
-        for(std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-            if( ihit->targetGUID == targetguid )
+        for(tbb::concurrent_vector<TargetInfo>::const_iterator ihit= m_UniqueTargetInfo.begin();ihit != m_UniqueTargetInfo.end();++ihit)
+        {
+            if (ihit->deleted == true)
+                continue;
+
+            if (ihit->targetGUID == targetguid)
                 return true;
+        }
     }
     return false;                                           //target invalid
 }
@@ -5615,19 +6106,12 @@ SpellCastResult Spell::CheckPower()
 
 bool Spell::IgnoreItemRequirements() const
 {
-    /// Check if it's an enchant scroll. These have no required reagents even though their spell does.
-    if (m_CastItem && m_CastItem->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_ENCHANT_SCROLL))
-        return true;
-
     if (m_IsTriggeredSpell)
-    {
-        /// Not own traded item (in trader trade slot) req. reagents including triggered spell case
-        if (Item* targetItem = m_targets.getItemTarget())
-            if (targetItem->GetOwnerGUID() != m_caster->GetGUID())
-                return false;
+        return true;
 
+    /// Check if it's an enchant scroll. These have no required reagents even though their spell does.
+    if (m_CastItem && m_CastItem->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_ENCHANT_SCROLL))
         return true;
-    }
 
     return false;
 }
@@ -5636,8 +6120,23 @@ SpellCastResult Spell::CheckItems()
 {
     if (m_caster->GetTypeId() != TYPEID_PLAYER)
         return SPELL_CAST_OK;
-
+        
     Player* p_caster = (Player*)m_caster;
+    bool isScrollItem = false;
+    bool isVellumTarget = false;
+
+    if ((sWorld.getConfig(CONFIG_BOOL_ALLOW_FLYING_MOUNTS_EVERYWHERE)) && (m_spellInfo->Id==55884))
+    {
+        uint32 spellToLearn = ((m_spellInfo->Id==SPELL_ID_GENERIC_LEARN) || (m_spellInfo->Id==SPELL_ID_GENERIC_LEARN_PET)) ? damage : m_spellInfo->EffectTriggerSpell[0];
+        SpellEntry const *sEntry = sSpellStore.LookupEntry(spellToLearn);
+        if(sEntry)
+        {
+            if(p_caster->isFlyingSpell(sEntry) || p_caster->isFlyingFormSpell(sEntry))
+            {
+                return SPELL_CAST_OK;
+            }
+        }
+    }
 
     // cast item checks
     if(m_CastItem)
@@ -5650,6 +6149,8 @@ SpellCastResult Spell::CheckItems()
         if(!proto)
             return SPELL_FAILED_ITEM_NOT_FOUND;
 
+        if(proto->Flags & ITEM_FLAGS_ENCHANT_SCROLL) isScrollItem = true;
+
         for (int i = 0; i < 5; ++i)
             if (proto->Spells[i].SpellCharges)
                 if(m_CastItem->GetSpellCharges(i) == 0)
@@ -5716,8 +6217,13 @@ SpellCastResult Spell::CheckItems()
         if(!m_targets.getItemTarget())
             return SPELL_FAILED_ITEM_GONE;
 
+        isVellumTarget = m_targets.getItemTarget()->GetProto()->IsVellum();
+
         if(!m_targets.getItemTarget()->IsFitToSpellRequirements(m_spellInfo))
             return SPELL_FAILED_EQUIPPED_ITEM_CLASS;
+
+        if(isVellumTarget && isScrollItem)
+            return SPELL_FAILED_BAD_TARGETS;
     }
     // if not item target then required item must be equipped
     else
@@ -5870,6 +6376,17 @@ SpellCastResult Spell::CheckItems()
 
                 if( targetItem->GetProto()->ItemLevel < m_spellInfo->baseLevel )
                     return SPELL_FAILED_LOWLEVEL;
+
+		if(isVellumTarget && m_spellInfo->EffectItemType[i])
+                {
+                    ItemPosCountVec dest;
+                    uint8 msg = p_caster->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, m_spellInfo->EffectItemType[i], 1 );
+                    if(msg != EQUIP_ERR_OK)
+                    {
+                        p_caster->SendEquipError( msg, NULL, NULL );
+                        return SPELL_FAILED_DONT_REPORT;
+                    }
+                }
                 // Not allow enchant in trade slot for some enchant type
                 if( targetItem->GetOwner() != m_caster )
                 {
@@ -5879,6 +6396,8 @@ SpellCastResult Spell::CheckItems()
                         return SPELL_FAILED_ERROR;
                     if (pEnchant->slot & ENCHANTMENT_CAN_SOULBOUND)
                         return SPELL_FAILED_NOT_TRADEABLE;
+                    if (isVellumTarget)
+                        return SPELL_FAILED_BAD_TARGETS;
                 }
                 break;
             }
@@ -6113,8 +6632,11 @@ void Spell::DelayedChannel()
 
     DEBUG_FILTER_LOG(LOG_FILTER_SPELL_CAST, "Spell %u partially interrupted for %i ms, new duration: %u ms", m_spellInfo->Id, delaytime, m_timer);
 
-    for(std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    for(tbb::concurrent_vector<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
     {
+        if (ihit->deleted == true)
+            continue;
+
         if ((*ihit).missCondition == SPELL_MISS_NONE)
         {
             if (Unit* unit = m_caster->GetObjectGuid() == ihit->targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, ihit->targetGUID))
@@ -6227,7 +6749,8 @@ bool Spell::CheckTarget( Unit* target, SpellEffectIndex eff )
             m_spellInfo->EffectImplicitTargetA[eff] != TARGET_SCRIPT &&
             m_spellInfo->EffectImplicitTargetB[eff] != TARGET_SCRIPT &&
             m_spellInfo->EffectImplicitTargetA[eff] != TARGET_AREAEFFECT_CUSTOM &&
-            m_spellInfo->EffectImplicitTargetB[eff] != TARGET_AREAEFFECT_CUSTOM )
+            m_spellInfo->EffectImplicitTargetB[eff] != TARGET_AREAEFFECT_CUSTOM &&
+            m_spellInfo->EffectImplicitTargetA[eff] != TARGET_MASTER )
             return false;
     }
 
@@ -6241,6 +6764,11 @@ bool Spell::CheckTarget( Unit* target, SpellEffectIndex eff )
             return false;
     }
 
+    // Check Sated & Exhaustion debuffs
+    if (((m_spellInfo->Id == 2825) && (target->HasAura(57724))) ||
+        ((m_spellInfo->Id == 32182) && (target->HasAura(57723))))
+        return false;
+
     // Check targets for LOS visibility (except spells without range limitations )
     switch(m_spellInfo->Effect[eff])
     {
@@ -6296,17 +6824,32 @@ bool Spell::IsTriggeredSpellWithRedundentData() const
 
 bool Spell::HaveTargetsForEffect(SpellEffectIndex effect) const
 {
-    for(std::list<TargetInfo>::const_iterator itr = m_UniqueTargetInfo.begin(); itr != m_UniqueTargetInfo.end(); ++itr)
+    for(tbb::concurrent_vector<TargetInfo>::const_iterator itr = m_UniqueTargetInfo.begin(); itr != m_UniqueTargetInfo.end(); ++itr)
+    {
+        if(itr->deleted == true)
+            continue;
+
         if(itr->effectMask & (1 << effect))
             return true;
+    }
+
+    for(tbb::concurrent_vector<GOTargetInfo>::const_iterator itr = m_UniqueGOTargetInfo.begin(); itr != m_UniqueGOTargetInfo.end(); ++itr)
+    {
+        if(itr->deleted == true)
+            continue;
 
-    for(std::list<GOTargetInfo>::const_iterator itr = m_UniqueGOTargetInfo.begin(); itr != m_UniqueGOTargetInfo.end(); ++itr)
         if(itr->effectMask & (1 << effect))
             return true;
+    }
+
+    for(tbb::concurrent_vector<ItemTargetInfo>::const_iterator itr = m_UniqueItemInfo.begin(); itr != m_UniqueItemInfo.end(); ++itr)
+    {
+        if(itr->deleted == true)
+            continue;
 
-    for(std::list<ItemTargetInfo>::const_iterator itr = m_UniqueItemInfo.begin(); itr != m_UniqueItemInfo.end(); ++itr)
         if(itr->effectMask & (1 << effect))
             return true;
+    }
 
     return false;
 }
diff --git a/mangos/src/game/Spell.h b/Core/src/game/Spell.h
index cea75be..fd3cffc 100644
--- a/mangos/src/game/Spell.h
+++ b/Core/src/game/Spell.h
@@ -24,6 +24,11 @@
 #include "DBCEnums.h"
 #include "ObjectGuid.h"
 
+#include "../../dep/tbb/include/tbb/concurrent_vector.h"
+#include <memory>
+
+#define MAX_SPELL_ID	100000
+
 class WorldSession;
 class Unit;
 class DynamicObj;
@@ -170,7 +175,6 @@ class SpellCastTargets
         Item* getItemTarget() const { return m_itemTarget; }
         uint32 getItemTargetEntry() const { return m_itemTargetEntry; }
         void setItemTarget(Item* item);
-        void setTradeItemTarget(Player* caster);
         void updateTradeSlotItem()
         {
             if(m_itemTarget && (m_targetMask & TARGET_FLAG_TRADE_ITEM))
@@ -184,8 +188,9 @@ class SpellCastTargets
 
         void Update(Unit* caster);
 
-        float m_srcX, m_srcY, m_srcZ;
+        float m_srcX, m_srcY, m_srcZ, m_srcO;
         float m_destX, m_destY, m_destZ;
+        float m_elevation, m_speed;
         std::string m_strTarget;
 
         uint32 m_targetMask;
@@ -360,6 +365,11 @@ class Spell
         void EffectPlayMusic(SpellEffectIndex eff_idx);
         void EffectSpecCount(SpellEffectIndex eff_idx);
         void EffectActivateSpec(SpellEffectIndex eff_idx);
+        void EffectSummonPossessed(SpellEffectIndex eff_idx); 
+        void EffectSummonVehicle(SpellEffectIndex eff_idx);
+        void EffectSummonSnakes(SpellEffectIndex eff_idx);
+        void EffectWMODamage(SpellEffectIndex eff_idx);
+        void EffectWMORepair(SpellEffectIndex eff_idx);
 
         Spell( Unit* caster, SpellEntry const *info, bool triggered, ObjectGuid originalCasterGUID = ObjectGuid(), Spell** triggeringContainer = NULL );
         ~Spell();
@@ -375,6 +385,9 @@ class Spell
 
         SpellCastResult CheckCast(bool strict);
         SpellCastResult CheckPetCast(Unit* target);
+        bool IsValidSingleTargetEffect(Unit const* target, Targets type) const;
+        bool IsValidSingleTargetSpell(Unit const* target) const;
+
 
         // handlers
         void handle_immediate();
@@ -410,6 +423,7 @@ class Spell
 
         typedef std::list<Unit*> UnitList;
         void FillTargetMap();
+        void FillCustomTargetMap(uint32 i, UnitList &targetUnitMap); 
         void SetTargetMap(SpellEffectIndex effIndex, uint32 targetMode, UnitList &targetUnitMap);
 
         void FillAreaTargets(UnitList &targetUnitMap, float x, float y, float radius, SpellNotifyPushType pushType, SpellTargets spellTargets, WorldObject* originalCaster = NULL);
@@ -588,9 +602,11 @@ class Spell
             SpellMissInfo reflectResult:8;
             uint8  effectMask:8;
             bool   processed:1;
+            bool   deleted:1;
         };
-        std::list<TargetInfo> m_UniqueTargetInfo;
+        tbb::concurrent_vector<TargetInfo> m_UniqueTargetInfo;
         uint8 m_needAliveTargetMask;                        // Mask req. alive targets
+        bool m_destroyed;
 
         struct GOTargetInfo
         {
@@ -598,15 +614,18 @@ class Spell
             uint64 timeDelay;
             uint8  effectMask:8;
             bool   processed:1;
+            bool   deleted:1;
         };
-        std::list<GOTargetInfo> m_UniqueGOTargetInfo;
+        tbb::concurrent_vector<GOTargetInfo> m_UniqueGOTargetInfo;
 
         struct ItemTargetInfo
         {
             Item  *item;
             uint8 effectMask;
+            bool   processed:1;
+            bool   deleted:1;
         };
-        std::list<ItemTargetInfo> m_UniqueItemInfo;
+        tbb::concurrent_vector<ItemTargetInfo> m_UniqueItemInfo;
 
         void AddUnitTarget(Unit* target, SpellEffectIndex effIndex);
         void AddUnitTarget(uint64 unitGUID, SpellEffectIndex effIndex);
diff --git a/mangos/src/game/SpellAuraDefines.h b/Core/src/game/SpellAuraDefines.h
index d57e1d5..a93ee35 100644
--- a/mangos/src/game/SpellAuraDefines.h
+++ b/Core/src/game/SpellAuraDefines.h
@@ -289,7 +289,7 @@ enum AuraType
     SPELL_AURA_COMPREHEND_LANGUAGE = 244,
     SPELL_AURA_MOD_DURATION_OF_MAGIC_EFFECTS = 245,
     SPELL_AURA_MOD_DURATION_OF_EFFECTS_BY_DISPEL = 246,
-    SPELL_AURA_247 = 247,
+    SPELL_AURA_CLONE_CASTER = 247,
     SPELL_AURA_MOD_COMBAT_RESULT_CHANCE = 248,
     SPELL_AURA_CONVERT_RUNE = 249,
     SPELL_AURA_MOD_INCREASE_HEALTH_2 = 250,
@@ -304,7 +304,7 @@ enum AuraType
     SPELL_AURA_259 = 259,
     SPELL_AURA_SCREEN_EFFECT = 260,
     SPELL_AURA_PHASE = 261,
-    SPELL_AURA_262 = 262,
+    SPELL_AURA_IGNORE_UNIT_STATE = 262,
     SPELL_AURA_ALLOW_ONLY_ABILITY = 263,
     SPELL_AURA_264 = 264,
     SPELL_AURA_265 = 265,
@@ -321,20 +321,20 @@ enum AuraType
     SPELL_AURA_276 = 276,                                   // Only "Test Mod Damage % Mechanic" spell, possible mod damage done
     SPELL_AURA_MOD_MAX_AFFECTED_TARGETS = 277,
     SPELL_AURA_MOD_DISARM_RANGED = 278,
-    SPELL_AURA_279 = 279,
+    SPELL_AURA_INITIALIZE_IMAGES = 279,
     SPELL_AURA_MOD_TARGET_ARMOR_PCT = 280,
     SPELL_AURA_MOD_HONOR_GAIN = 281,
     SPELL_AURA_MOD_BASE_HEALTH_PCT = 282,
     SPELL_AURA_MOD_HEALING_RECEIVED = 283,                  // Possibly only for some spell family class spells
-    SPELL_AURA_284,
+    SPELL_AURA_LINKED = 284,
     SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR = 285,
     SPELL_AURA_ABILITY_PERIODIC_CRIT = 286,
     SPELL_AURA_DEFLECT_SPELLS = 287,
-    SPELL_AURA_288 = 288,
+    SPELL_AURA_DEFLECT_RANGED_HIT = 288,
     SPELL_AURA_289 = 289,
     SPELL_AURA_MOD_ALL_CRIT_CHANCE = 290,
     SPELL_AURA_MOD_QUEST_XP_PCT = 291,
-    SPELL_AURA_292 = 292,
+    SPELL_AURA_OPEN_STABLE = 292,
     SPELL_AURA_293 = 293,
     SPELL_AURA_294 = 294,
     SPELL_AURA_295 = 295,
@@ -343,7 +343,7 @@ enum AuraType
     SPELL_AURA_298 = 298,
     SPELL_AURA_299 = 299,
     SPELL_AURA_300 = 300,
-    SPELL_AURA_301 = 301,
+    SPELL_AURA_SCHOOL_HEAL_ABSORB = 301,
     SPELL_AURA_302 = 302,
     SPELL_AURA_303 = 303,
     SPELL_AURA_304 = 304,
@@ -358,7 +358,7 @@ enum AuraType
     SPELL_AURA_313 = 313,
     SPELL_AURA_314 = 314,
     SPELL_AURA_315 = 315,
-    SPELL_AURA_316 = 316,
+    SPELL_AURA_APPLY_HASTE_TO_AURA = 316,
     TOTAL_AURAS = 317
 };
 
diff --git a/mangos/src/game/SpellAuras.cpp b/Core/src/game/SpellAuras.cpp
index f6badb4..8cccd23 100644
--- a/mangos/src/game/SpellAuras.cpp
+++ b/Core/src/game/SpellAuras.cpp
@@ -38,6 +38,7 @@
 #include "Creature.h"
 #include "Formulas.h"
 #include "BattleGround.h"
+#include "OutdoorPvPMgr.h"
 #include "CreatureAI.h"
 #include "ScriptCalls.h"
 #include "Util.h"
@@ -64,7 +65,7 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleModTaunt,                                  // 11 SPELL_AURA_MOD_TAUNT
     &Aura::HandleAuraModStun,                               // 12 SPELL_AURA_MOD_STUN
     &Aura::HandleModDamageDone,                             // 13 SPELL_AURA_MOD_DAMAGE_DONE
-    &Aura::HandleNoImmediateEffect,                         // 14 SPELL_AURA_MOD_DAMAGE_TAKEN   implemented in Unit::MeleeDamageBonusTaken and Unit::SpellBaseDamageBonusTaken
+    &Aura::HandleNoImmediateEffect,                         // 14 SPELL_AURA_MOD_DAMAGE_TAKEN   implemented in Unit::MeleeDamageBonus and Unit::SpellBaseDamageBonusForVictim
     &Aura::HandleNoImmediateEffect,                         // 15 SPELL_AURA_DAMAGE_SHIELD      implemented in Unit::DealMeleeDamage
     &Aura::HandleModStealth,                                // 16 SPELL_AURA_MOD_STEALTH
     &Aura::HandleNoImmediateEffect,                         // 17 SPELL_AURA_MOD_STEALTH_DETECT implemented in Unit::isVisibleForOrDetect
@@ -109,7 +110,7 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleAuraTransform,                             // 56 SPELL_AURA_TRANSFORM
     &Aura::HandleModSpellCritChance,                        // 57 SPELL_AURA_MOD_SPELL_CRIT_CHANCE
     &Aura::HandleAuraModIncreaseSwimSpeed,                  // 58 SPELL_AURA_MOD_INCREASE_SWIM_SPEED
-    &Aura::HandleNoImmediateEffect,                         // 59 SPELL_AURA_MOD_DAMAGE_DONE_CREATURE implemented in Unit::MeleeDamageBonusDone and Unit::SpellDamageBonusDone
+    &Aura::HandleNoImmediateEffect,                         // 59 SPELL_AURA_MOD_DAMAGE_DONE_CREATURE implemented in Unit::MeleeDamageBonus and Unit::SpellDamageBonus
     &Aura::HandleAuraModPacifyAndSilence,                   // 60 SPELL_AURA_MOD_PACIFY_SILENCE
     &Aura::HandleAuraModScale,                              // 61 SPELL_AURA_MOD_SCALE
     &Aura::HandlePeriodicHealthFunnel,                      // 62 SPELL_AURA_PERIODIC_HEALTH_FUNNEL
@@ -137,7 +138,7 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleModRegen,                                  // 84 SPELL_AURA_MOD_REGEN
     &Aura::HandleModPowerRegen,                             // 85 SPELL_AURA_MOD_POWER_REGEN
     &Aura::HandleChannelDeathItem,                          // 86 SPELL_AURA_CHANNEL_DEATH_ITEM
-    &Aura::HandleNoImmediateEffect,                         // 87 SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN implemented in Unit::MeleeDamageBonusTaken and Unit::SpellDamageBonusTaken
+    &Aura::HandleNoImmediateEffect,                         // 87 SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN implemented in Unit::MeleeDamageBonus and Unit::SpellDamageBonus
     &Aura::HandleNoImmediateEffect,                         // 88 SPELL_AURA_MOD_HEALTH_REGEN_PERCENT implemented in Player::RegenerateHealth
     &Aura::HandlePeriodicDamagePCT,                         // 89 SPELL_AURA_PERIODIC_DAMAGE_PERCENT
     &Aura::HandleUnused,                                    // 90 unused (3.0.8a-3.2.2a) old SPELL_AURA_MOD_RESIST_CHANCE
@@ -152,7 +153,7 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleAuraModAttackPower,                        // 99 SPELL_AURA_MOD_ATTACK_POWER
     &Aura::HandleUnused,                                    //100 SPELL_AURA_AURAS_VISIBLE obsolete 3.x? all player can see all auras now, but still have 2 spells including GM-spell (1852,2855)
     &Aura::HandleModResistancePercent,                      //101 SPELL_AURA_MOD_RESISTANCE_PCT
-    &Aura::HandleNoImmediateEffect,                         //102 SPELL_AURA_MOD_MELEE_ATTACK_POWER_VERSUS implemented in Unit::MeleeDamageBonusDone
+    &Aura::HandleNoImmediateEffect,                         //102 SPELL_AURA_MOD_MELEE_ATTACK_POWER_VERSUS implemented in Unit::MeleeDamageBonus
     &Aura::HandleAuraModTotalThreat,                        //103 SPELL_AURA_MOD_TOTAL_THREAT
     &Aura::HandleAuraWaterWalk,                             //104 SPELL_AURA_WATER_WALK
     &Aura::HandleAuraFeatherFall,                           //105 SPELL_AURA_FEATHER_FALL
@@ -163,30 +164,30 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleModPowerRegenPCT,                          //110 SPELL_AURA_MOD_POWER_REGEN_PERCENT
     &Aura::HandleNoImmediateEffect,                         //111 SPELL_AURA_ADD_CASTER_HIT_TRIGGER implemented in Unit::SelectMagnetTarget
     &Aura::HandleNoImmediateEffect,                         //112 SPELL_AURA_OVERRIDE_CLASS_SCRIPTS implemented in diff functions.
-    &Aura::HandleNoImmediateEffect,                         //113 SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN implemented in Unit::MeleeDamageBonusTaken
-    &Aura::HandleNoImmediateEffect,                         //114 SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN_PCT implemented in Unit::MeleeDamageBonusTaken
-    &Aura::HandleNoImmediateEffect,                         //115 SPELL_AURA_MOD_HEALING                 implemented in Unit::SpellBaseHealingBonusTaken
+    &Aura::HandleNoImmediateEffect,                         //113 SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN implemented in Unit::MeleeDamageBonus
+    &Aura::HandleNoImmediateEffect,                         //114 SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN_PCT implemented in Unit::MeleeDamageBonus
+    &Aura::HandleNoImmediateEffect,                         //115 SPELL_AURA_MOD_HEALING                 implemented in Unit::SpellBaseHealingBonusForVictim
     &Aura::HandleNoImmediateEffect,                         //116 SPELL_AURA_MOD_REGEN_DURING_COMBAT     imppemented in Player::RegenerateAll and Player::RegenerateHealth
     &Aura::HandleNoImmediateEffect,                         //117 SPELL_AURA_MOD_MECHANIC_RESISTANCE     implemented in Unit::MagicSpellHitResult
-    &Aura::HandleNoImmediateEffect,                         //118 SPELL_AURA_MOD_HEALING_PCT             implemented in Unit::SpellHealingBonusTaken
+    &Aura::HandleNoImmediateEffect,                         //118 SPELL_AURA_MOD_HEALING_PCT             implemented in Unit::SpellHealingBonus
     &Aura::HandleUnused,                                    //119 unused (3.0.8a-3.2.2a) old SPELL_AURA_SHARE_PET_TRACKING
     &Aura::HandleAuraUntrackable,                           //120 SPELL_AURA_UNTRACKABLE
     &Aura::HandleAuraEmpathy,                               //121 SPELL_AURA_EMPATHY
     &Aura::HandleModOffhandDamagePercent,                   //122 SPELL_AURA_MOD_OFFHAND_DAMAGE_PCT
     &Aura::HandleModTargetResistance,                       //123 SPELL_AURA_MOD_TARGET_RESISTANCE
     &Aura::HandleAuraModRangedAttackPower,                  //124 SPELL_AURA_MOD_RANGED_ATTACK_POWER
-    &Aura::HandleNoImmediateEffect,                         //125 SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN implemented in Unit::MeleeDamageBonusTaken
-    &Aura::HandleNoImmediateEffect,                         //126 SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN_PCT implemented in Unit::MeleeDamageBonusTaken
-    &Aura::HandleNoImmediateEffect,                         //127 SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS implemented in Unit::MeleeDamageBonusDone
+    &Aura::HandleNoImmediateEffect,                         //125 SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN implemented in Unit::MeleeDamageBonus
+    &Aura::HandleNoImmediateEffect,                         //126 SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN_PCT implemented in Unit::MeleeDamageBonus
+    &Aura::HandleNoImmediateEffect,                         //127 SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS implemented in Unit::MeleeDamageBonus
     &Aura::HandleModPossessPet,                             //128 SPELL_AURA_MOD_POSSESS_PET
     &Aura::HandleAuraModIncreaseSpeed,                      //129 SPELL_AURA_MOD_SPEED_ALWAYS
     &Aura::HandleAuraModIncreaseMountedSpeed,               //130 SPELL_AURA_MOD_MOUNTED_SPEED_ALWAYS
-    &Aura::HandleNoImmediateEffect,                         //131 SPELL_AURA_MOD_RANGED_ATTACK_POWER_VERSUS implemented in Unit::MeleeDamageBonusDone
+    &Aura::HandleNoImmediateEffect,                         //131 SPELL_AURA_MOD_RANGED_ATTACK_POWER_VERSUS implemented in Unit::MeleeDamageBonus
     &Aura::HandleAuraModIncreaseEnergyPercent,              //132 SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT
     &Aura::HandleAuraModIncreaseHealthPercent,              //133 SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT
     &Aura::HandleAuraModRegenInterrupt,                     //134 SPELL_AURA_MOD_MANA_REGEN_INTERRUPT
     &Aura::HandleModHealingDone,                            //135 SPELL_AURA_MOD_HEALING_DONE
-    &Aura::HandleNoImmediateEffect,                         //136 SPELL_AURA_MOD_HEALING_DONE_PERCENT   implemented in Unit::SpellHealingBonusDone
+    &Aura::HandleNoImmediateEffect,                         //136 SPELL_AURA_MOD_HEALING_DONE_PERCENT   implemented in Unit::SpellHealingBonus
     &Aura::HandleModTotalPercentStat,                       //137 SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE
     &Aura::HandleHaste,                                     //138 SPELL_AURA_MOD_HASTE
     &Aura::HandleForceReaction,                             //139 SPELL_AURA_FORCE_REACTION
@@ -215,22 +216,22 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleAuraPowerBurn,                             //162 SPELL_AURA_POWER_BURN_MANA
     &Aura::HandleNoImmediateEffect,                         //163 SPELL_AURA_MOD_CRIT_DAMAGE_BONUS      implemented in Unit::CalculateMeleeDamage and Unit::SpellCriticalDamageBonus
     &Aura::HandleUnused,                                    //164 unused (3.0.8a-3.2.2a), only one test spell 10654
-    &Aura::HandleNoImmediateEffect,                         //165 SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS implemented in Unit::MeleeDamageBonusDone
+    &Aura::HandleNoImmediateEffect,                         //165 SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS implemented in Unit::MeleeDamageBonus
     &Aura::HandleAuraModAttackPowerPercent,                 //166 SPELL_AURA_MOD_ATTACK_POWER_PCT
     &Aura::HandleAuraModRangedAttackPowerPercent,           //167 SPELL_AURA_MOD_RANGED_ATTACK_POWER_PCT
-    &Aura::HandleNoImmediateEffect,                         //168 SPELL_AURA_MOD_DAMAGE_DONE_VERSUS            implemented in Unit::SpellDamageBonusDone, Unit::MeleeDamageBonusDone
+    &Aura::HandleNoImmediateEffect,                         //168 SPELL_AURA_MOD_DAMAGE_DONE_VERSUS            implemented in Unit::SpellDamageBonus, Unit::MeleeDamageBonus
     &Aura::HandleNoImmediateEffect,                         //169 SPELL_AURA_MOD_CRIT_PERCENT_VERSUS           implemented in Unit::DealDamageBySchool, Unit::DoAttackDamage, Unit::SpellCriticalBonus
     &Aura::HandleNULL,                                      //170 SPELL_AURA_DETECT_AMORE       different spells that ignore transformation effects
     &Aura::HandleAuraModIncreaseSpeed,                      //171 SPELL_AURA_MOD_SPEED_NOT_STACK
     &Aura::HandleAuraModIncreaseMountedSpeed,               //172 SPELL_AURA_MOD_MOUNTED_SPEED_NOT_STACK
     &Aura::HandleUnused,                                    //173 unused (3.0.8a-3.2.2a) no spells, old SPELL_AURA_ALLOW_CHAMPION_SPELLS  only for Proclaim Champion spell
-    &Aura::HandleModSpellDamagePercentFromStat,             //174 SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT  implemented in Unit::SpellBaseDamageBonusDone
-    &Aura::HandleModSpellHealingPercentFromStat,            //175 SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT implemented in Unit::SpellBaseHealingBonusDone
+    &Aura::HandleModSpellDamagePercentFromStat,             //174 SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT  implemented in Unit::SpellBaseDamageBonus
+    &Aura::HandleModSpellHealingPercentFromStat,            //175 SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT implemented in Unit::SpellBaseHealingBonus
     &Aura::HandleSpiritOfRedemption,                        //176 SPELL_AURA_SPIRIT_OF_REDEMPTION   only for Spirit of Redemption spell, die at aura end
     &Aura::HandleNULL,                                      //177 SPELL_AURA_AOE_CHARM (22 spells)
     &Aura::HandleNoImmediateEffect,                         //178 SPELL_AURA_MOD_DEBUFF_RESISTANCE          implemented in Unit::MagicSpellHitResult
     &Aura::HandleNoImmediateEffect,                         //179 SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE implemented in Unit::SpellCriticalBonus
-    &Aura::HandleNoImmediateEffect,                         //180 SPELL_AURA_MOD_FLAT_SPELL_DAMAGE_VERSUS   implemented in Unit::SpellDamageBonusDone
+    &Aura::HandleNoImmediateEffect,                         //180 SPELL_AURA_MOD_FLAT_SPELL_DAMAGE_VERSUS   implemented in Unit::SpellDamageBonus
     &Aura::HandleUnused,                                    //181 unused (3.0.8a-3.2.2a) old SPELL_AURA_MOD_FLAT_SPELL_CRIT_DAMAGE_VERSUS
     &Aura::HandleAuraModResistenceOfStatPercent,            //182 SPELL_AURA_MOD_RESISTANCE_OF_STAT_PERCENT
     &Aura::HandleNoImmediateEffect,                         //183 SPELL_AURA_MOD_CRITICAL_THREAT only used in 28746, implemented in ThreatCalcHelper::calcThreat
@@ -279,7 +280,7 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleAuraPeriodicDummy,                         //226 SPELL_AURA_PERIODIC_DUMMY
     &Aura::HandlePeriodicTriggerSpellWithValue,             //227 SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE
     &Aura::HandleNoImmediateEffect,                         //228 SPELL_AURA_DETECT_STEALTH
-    &Aura::HandleNoImmediateEffect,                         //229 SPELL_AURA_MOD_AOE_DAMAGE_AVOIDANCE        implemented in Unit::SpellDamageBonusTaken
+    &Aura::HandleNoImmediateEffect,                         //229 SPELL_AURA_MOD_AOE_DAMAGE_AVOIDANCE        implemented in Unit::SpellDamageBonus
     &Aura::HandleAuraModIncreaseMaxHealth,                  //230 Commanding Shout
     &Aura::HandleNoImmediateEffect,                         //231 SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE
     &Aura::HandleNoImmediateEffect,                         //232 SPELL_AURA_MECHANIC_DURATION_MOD           implement in Unit::CalculateSpellDuration
@@ -287,8 +288,8 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleNoImmediateEffect,                         //234 SPELL_AURA_MECHANIC_DURATION_MOD_NOT_STACK implement in Unit::CalculateSpellDuration
     &Aura::HandleAuraModDispelResist,                       //235 SPELL_AURA_MOD_DISPEL_RESIST               implement in Unit::MagicSpellHitResult
     &Aura::HandleAuraControlVehicle,                        //236 SPELL_AURA_CONTROL_VEHICLE
-    &Aura::HandleModSpellDamagePercentFromAttackPower,      //237 SPELL_AURA_MOD_SPELL_DAMAGE_OF_ATTACK_POWER  implemented in Unit::SpellBaseDamageBonusDone
-    &Aura::HandleModSpellHealingPercentFromAttackPower,     //238 SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER implemented in Unit::SpellBaseHealingBonusDone
+    &Aura::HandleModSpellDamagePercentFromAttackPower,      //237 SPELL_AURA_MOD_SPELL_DAMAGE_OF_ATTACK_POWER  implemented in Unit::SpellBaseDamageBonus
+    &Aura::HandleModSpellHealingPercentFromAttackPower,     //238 SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER implemented in Unit::SpellBaseHealingBonus
     &Aura::HandleAuraModScale,                              //239 SPELL_AURA_MOD_SCALE_2 only in Noggenfogger Elixir (16595) before 2.3.0 aura 61
     &Aura::HandleAuraModExpertise,                          //240 SPELL_AURA_MOD_EXPERTISE
     &Aura::HandleForceMoveForward,                          //241 Forces the player to move forward
@@ -297,7 +298,7 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleComprehendLanguage,                        //244 SPELL_AURA_COMPREHEND_LANGUAGE
     &Aura::HandleNoImmediateEffect,                         //245 SPELL_AURA_MOD_DURATION_OF_MAGIC_EFFECTS     implemented in Unit::CalculateSpellDuration
     &Aura::HandleNoImmediateEffect,                         //246 SPELL_AURA_MOD_DURATION_OF_EFFECTS_BY_DISPEL implemented in Unit::CalculateSpellDuration
-    &Aura::HandleNULL,                                      //247 target to become a clone of the caster
+    &Aura::HandleAuraCloneCaster,                           //247 SPELL_AURA_CLONE_CASTER
     &Aura::HandleNoImmediateEffect,                         //248 SPELL_AURA_MOD_COMBAT_RESULT_CHANCE         implemented in Unit::RollMeleeOutcomeAgainst
     &Aura::HandleAuraConvertRune,                           //249 SPELL_AURA_CONVERT_RUNE
     &Aura::HandleAuraModIncreaseHealth,                     //250 SPELL_AURA_MOD_INCREASE_HEALTH_2
@@ -305,14 +306,14 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleModCombatSpeedPct,                         //252 SPELL_AURA_SLOW_ALL
     &Aura::HandleNoImmediateEffect,                         //253 SPELL_AURA_MOD_BLOCK_CRIT_CHANCE             implemented in Unit::CalculateMeleeDamage
     &Aura::HandleNULL,                                      //254 SPELL_AURA_MOD_DISARM_SHIELD disarm Shield
-    &Aura::HandleNoImmediateEffect,                         //255 SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT    implemented in Unit::SpellDamageBonusTaken
+    &Aura::HandleNoImmediateEffect,                         //255 SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT    implemented in Unit::SpellDamageBonus
     &Aura::HandleNoReagentUseAura,                          //256 SPELL_AURA_NO_REAGENT_USE Use SpellClassMask for spell select
     &Aura::HandleNULL,                                      //257 SPELL_AURA_MOD_TARGET_RESIST_BY_SPELL_CLASS Use SpellClassMask for spell select
     &Aura::HandleNULL,                                      //258 SPELL_AURA_MOD_SPELL_VISUAL
     &Aura::HandleNULL,                                      //259 corrupt healing over time spell
     &Aura::HandleNoImmediateEffect,                         //260 SPELL_AURA_SCREEN_EFFECT (miscvalue = id in ScreenEffect.dbc) not required any code
     &Aura::HandlePhase,                                     //261 SPELL_AURA_PHASE undetectable invisibility?     implemented in Unit::isVisibleForOrDetect
-    &Aura::HandleNULL,                                      //262 ignore combat/aura state?
+    &Aura::HandleIgnoreUnitState,                           //262 SPELL_AURA_IGNORE_UNIT_STATE Allows some abilities which are avaible only in some cases.... implemented in Unit::isIgnoreUnitState & Spell::CheckCast
     &Aura::HandleAllowOnlyAbility,                          //263 SPELL_AURA_ALLOW_ONLY_ABILITY player can use only abilities set in SpellClassMask
     &Aura::HandleUnused,                                    //264 unused (3.0.8a-3.2.2a)
     &Aura::HandleUnused,                                    //265 unused (3.0.8a-3.2.2a)
@@ -321,7 +322,7 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleAuraModAttackPowerOfStatPercent,           //268 SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT
     &Aura::HandleNoImmediateEffect,                         //269 SPELL_AURA_MOD_IGNORE_DAMAGE_REDUCTION_SCHOOL   implemented in Unit::CalcNotIgnoreDamageRedunction
     &Aura::HandleUnused,                                    //270 SPELL_AURA_MOD_IGNORE_TARGET_RESIST (unused in 3.2.2a)
-    &Aura::HandleNoImmediateEffect,                         //271 SPELL_AURA_MOD_DAMAGE_FROM_CASTER    implemented in Unit::SpellDamageBonusTaken
+    &Aura::HandleNoImmediateEffect,                         //271 SPELL_AURA_MOD_DAMAGE_FROM_CASTER    implemented in Unit::SpellDamageBonus
     &Aura::HandleNoImmediateEffect,                         //272 SPELL_AURA_MAELSTROM_WEAPON (unclear use for aura, it used in (3.2.2a...3.3.0) in single spell 53817 that spellmode stacked and charged spell expected to be drop as stack
     &Aura::HandleNoImmediateEffect,                         //273 SPELL_AURA_X_RAY (client side implementation)
     &Aura::HandleNULL,                                      //274 proc free shot?
@@ -329,20 +330,20 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleNULL,                                      //276 mod damage % mechanic?
     &Aura::HandleNoImmediateEffect,                         //277 SPELL_AURA_MOD_MAX_AFFECTED_TARGETS Use SpellClassMask for spell select
     &Aura::HandleNULL,                                      //278 SPELL_AURA_MOD_DISARM_RANGED disarm ranged weapon
-    &Aura::HandleNULL,                                      //279 visual effects? 58836 and 57507
+    &Aura::HandleAuraInitializeImages,                      //279 SPELL_AURA_INITIALIZE_IMAGES
     &Aura::HandleModTargetArmorPct,                         //280 SPELL_AURA_MOD_TARGET_ARMOR_PCT
     &Aura::HandleNoImmediateEffect,                         //281 SPELL_AURA_MOD_HONOR_GAIN             implemented in Player::RewardHonor
     &Aura::HandleAuraIncreaseBaseHealthPercent,             //282 SPELL_AURA_INCREASE_BASE_HEALTH_PERCENT
     &Aura::HandleNoImmediateEffect,                         //283 SPELL_AURA_MOD_HEALING_RECEIVED       implemented in Unit::SpellHealingBonusTaken
-    &Aura::HandleNULL,                                      //284 51 spells
+    &Aura::HandleAuraLinked,                                //284 SPELL_AURA_LINKED
     &Aura::HandleAuraModAttackPowerOfArmor,                 //285 SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR  implemented in Player::UpdateAttackPowerAndDamage
     &Aura::HandleNoImmediateEffect,                         //286 SPELL_AURA_ABILITY_PERIODIC_CRIT      implemented in Aura::IsCritFromAbilityAura called from Aura::PeriodicTick
     &Aura::HandleNoImmediateEffect,                         //287 SPELL_AURA_DEFLECT_SPELLS             implemented in Unit::MagicSpellHitResult and Unit::MeleeSpellHitResult
-    &Aura::HandleNULL,                                      //288 increase parry/deflect, prevent attack (single spell used 67801)
+    &Aura::HandleNoImmediateEffect,                         //288 SPELL_AURA_DEFLECT_RANGED_HIT
     &Aura::HandleUnused,                                    //289 unused (3.2.2a)
     &Aura::HandleAuraModAllCritChance,                      //290 SPELL_AURA_MOD_ALL_CRIT_CHANCE
     &Aura::HandleNoImmediateEffect,                         //291 SPELL_AURA_MOD_QUEST_XP_PCT           implemented in Player::GiveXP
-    &Aura::HandleNULL,                                      //292 call stabled pet
+    &Aura::HandleAuraOpenStable,                            //292 call stabled pet
     &Aura::HandleNULL,                                      //293 3 spells
     &Aura::HandleNULL,                                      //294 2 spells, possible prevent mana regen
     &Aura::HandleUnused,                                    //295 unused (3.2.2a)
@@ -351,7 +352,7 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleUnused,                                    //298 unused (3.2.2a)
     &Aura::HandleUnused,                                    //299 unused (3.2.2a)
     &Aura::HandleNULL,                                      //300 3 spells (share damage?)
-    &Aura::HandleNULL,                                      //301 5 spells
+    &Aura::HandleNoImmediateEffect,                         //301 SPELL_AURA_SCHOOL_HEAL_ABSORB         implemented in Unit::CalculateHealAbsorb
     &Aura::HandleUnused,                                    //302 unused (3.2.2a)
     &Aura::HandleNULL,                                      //303 17 spells
     &Aura::HandleNULL,                                      //304 2 spells (alcohol effect?)
@@ -366,14 +367,14 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleNULL,                                      //313 0 spells in 3.3
     &Aura::HandleNULL,                                      //314 1 test spell (reduce duration of silince/magic)
     &Aura::HandleNULL,                                      //315 underwater walking
-    &Aura::HandleNULL                                       //316 makes haste affect HOT/DOT ticks
+    &Aura::HandleNoImmediateEffect,                         //316 SPELL_AURA_APPLY_HASTE_TO_AURA makes haste affect HOT/DOT ticks
 };
 
 static AuraType const frozenAuraTypes[] = { SPELL_AURA_MOD_ROOT, SPELL_AURA_MOD_STUN, SPELL_AURA_NONE };
 
 Aura::Aura(SpellEntry const* spellproto, SpellEffectIndex eff, int32 *currentBasePoints, Unit *target, Unit *caster, Item* castItem) :
 m_spellmod(NULL), m_caster_guid(0), m_target(target), m_castItemGuid(castItem?castItem->GetGUID():0),
-m_timeCla(1000), m_periodicTimer(0), m_periodicTick(0), m_removeMode(AURA_REMOVE_BY_DEFAULT), m_AuraDRGroup(DIMINISHING_NONE),
+m_timeCla(1000), m_periodicTimer(0), m_periodicTick(0), m_origDuration(0), m_removeMode(AURA_REMOVE_BY_DEFAULT), m_AuraDRGroup(DIMINISHING_NONE),
 m_effIndex(eff), m_auraSlot(MAX_AURAS), m_auraFlags(AFLAG_NONE), m_auraLevel(1), m_procCharges(0), m_stackAmount(1),
 m_positive(false), m_permanent(false), m_isPeriodic(false), m_isAreaAura(false), m_isPersistent(false),
 m_isRemovedOnShapeLost(true), m_in_use(0), m_deleted(false)
@@ -437,6 +438,8 @@ m_isRemovedOnShapeLost(true), m_in_use(0), m_deleted(false)
 
     Player* modOwner = caster ? caster->GetSpellModOwner() : NULL;
 
+    m_origDuration = m_maxduration;
+
     if(!m_permanent && modOwner)
     {
         modOwner->ApplySpellMod(GetId(), SPELLMOD_DURATION, m_maxduration);
@@ -451,10 +454,35 @@ m_isRemovedOnShapeLost(true), m_in_use(0), m_deleted(false)
 
     SetModifier(AuraType(m_spellProto->EffectApplyAuraName[eff]), damage, m_spellProto->EffectAmplitude[eff], m_spellProto->EffectMiscValue[eff]);
 
-    // Apply periodic time mod
-    if(modOwner && m_modifier.periodictime)
+    bool applyHaste = GetSpellProto()->AttributesEx & (SPELL_ATTR_EX_CHANNELED_1 | SPELL_ATTR_EX_CHANNELED_2);
+    //SPELL_AURA_APPLY_HASTE_TO_AURA implentation
+    if(caster)
+    {
+        Unit::AuraList const& stateAuras = caster->GetAurasByType(SPELL_AURA_APPLY_HASTE_TO_AURA);
+        for(Unit::AuraList::const_iterator j = stateAuras.begin();j != stateAuras.end(); ++j)
+        {
+            if((*j)->isAffectedOnSpell(GetSpellProto()))
+            {
+                applyHaste = true;
+                break;
+            }
+        }
+    }
+
+    //Apply haste
+    if(applyHaste && m_modifier.periodictime)
+        ApplyHasteToPeriodic();
+    // Apply periodic time mod, for channeled spells its in Aura::ApplyHasteToPeriodic()
+    else if(modOwner && m_modifier.periodictime)
         modOwner->ApplySpellMod(GetId(), SPELLMOD_ACTIVATION_TIME, m_modifier.periodictime);
 
+    //Must be after haste
+    m_duration = m_maxduration;
+
+    //Apply haste to channeled spells
+    if(GetSpellProto()->AttributesEx & (SPELL_ATTR_EX_CHANNELED_1 | SPELL_ATTR_EX_CHANNELED_2) && m_modifier.periodictime)
+        ApplyHasteToPeriodic();
+
     // Start periodic on next tick or at aura apply
     if (!(m_spellProto->AttributesEx5 & SPELL_ATTR_EX5_START_PERIODIC_AT_APPLY))
         m_periodicTimer += m_modifier.periodictime;
@@ -939,8 +967,17 @@ bool Aura::IsNeedVisibleSlot(Unit const* caster) const
         case SPELL_EFFECT_APPLY_AREA_AURA_FRIEND:
         case SPELL_EFFECT_APPLY_AREA_AURA_PARTY:
         case SPELL_EFFECT_APPLY_AREA_AURA_RAID:
-            // passive auras (except totem auras) do not get placed in caster slot
-            return (m_target != caster || totemAura || !m_isPassive) && m_modifier.m_auraname != SPELL_AURA_NONE;
+            // passive auras must be placed in caster slot
+            return (totemAura || m_isPassive) && m_modifier.m_auraname != SPELL_AURA_NONE;
+        default:
+            break;
+    }
+
+    // special aura type cases
+    switch (m_spellProto->EffectApplyAuraName[GetEffIndex()])
+    {
+        case SPELL_AURA_IGNORE_UNIT_STATE:
+            return true;    // requires visible slot to enable client side effect
         default:
             break;
     }
@@ -1048,6 +1085,10 @@ void Aura::_AddAura()
             if (m_spellProto->SpellFamilyName == SPELLFAMILY_DRUID && (m_spellProto->SpellFamilyFlags & UI64LIT(0x0000000000000400)))
                 m_target->ModifyAuraState(AURA_STATE_FAERIE_FIRE, true);
 
+            // Sting (hunter's pet ability)
+            if (m_spellProto->Category == 1133)
+                m_target->ModifyAuraState(AURA_STATE_FAERIE_FIRE, true);
+
             // Victorious
             if (m_spellProto->SpellFamilyName == SPELLFAMILY_WARRIOR && (m_spellProto->SpellFamilyFlags & UI64LIT(0x0004000000000000)))
                 m_target->ModifyAuraState(AURA_STATE_WARRIOR_VICTORY_RUSH, true);
@@ -1063,6 +1104,10 @@ void Aura::_AddAura()
             // Enrage aura state
             if(m_spellProto->Dispel == DISPEL_ENRAGE)
                 m_target->ModifyAuraState(AURA_STATE_ENRAGE, true);
+
+            // Mechanic bleed aura state
+            if(GetAllSpellMechanicMask(m_spellProto) & (1 << (MECHANIC_BLEED-1)))
+                m_target->ModifyAuraState(AURA_STATE_MECHANIC_BLEED, true);
         }
     }
 }
@@ -1140,6 +1185,22 @@ bool Aura::_RemoveAura()
         if(m_spellProto->Dispel == DISPEL_ENRAGE)
             m_target->ModifyAuraState(AURA_STATE_ENRAGE, false);
 
+        // Mechanic bleed aura state
+        if(GetAllSpellMechanicMask(m_spellProto) & (1 << (MECHANIC_BLEED-1)))
+        {
+            bool found = false;
+            Unit::AuraList const& mPerDmg = m_target->GetAurasByType(SPELL_AURA_PERIODIC_DAMAGE);
+            for(Unit::AuraList::const_iterator i = mPerDmg.begin(); i != mPerDmg.end(); ++i)
+            {
+                if(GetAllSpellMechanicMask((*i)->m_spellProto) & (1 << (MECHANIC_BLEED-1)))
+                {
+                    found = true;
+                    break;
+                }
+            }
+            if(!found)
+                m_target->ModifyAuraState(AURA_STATE_MECHANIC_BLEED, false);
+        }
         uint32 removeState = 0;
         uint64 removeFamilyFlag = m_spellProto->SpellFamilyFlags;
         uint32 removeFamilyFlag2 = m_spellProto->SpellFamilyFlags2;
@@ -1213,6 +1274,35 @@ bool Aura::_RemoveAura()
     return true;
 }
 
+void Aura::SendFakeAuraUpdate(uint32 auraId, bool remove)
+{
+    WorldPacket data(SMSG_AURA_UPDATE);
+    data << m_target->GetPackGUID();
+    data << uint8(64);
+    data << uint32(remove ? 0 : auraId);
+    if(remove)
+    {
+        m_target->SendMessageToSet(&data, true);
+        return;
+    }
+    uint8 auraFlags = GetAuraFlags();
+    data << uint8(auraFlags);
+    data << uint8(GetAuraLevel());
+    data << uint8(m_procCharges ? m_procCharges : m_stackAmount);
+
+    if(!(auraFlags & AFLAG_NOT_CASTER))
+    {
+        data << uint8(0);                                   // pguid
+    }
+
+    if(auraFlags & AFLAG_DURATION)
+    {
+        data << uint32(GetAuraMaxDuration());
+        data << uint32(GetAuraDuration());
+    }
+    m_target->SendMessageToSet(&data, true);
+}
+
 void Aura::SendAuraUpdate(bool remove)
 {
     WorldPacket data(SMSG_AURA_UPDATE);
@@ -1261,7 +1351,10 @@ void Aura::SetStackAmount(uint8 stackAmount)
         if (amount!=m_modifier.m_amount)
         {
             ApplyModifier(false, true);
-            m_modifier.m_amount = amount;
+
+            // Lifebloom has special amount calculation in final bloom
+            if(m_spellProto->SpellFamilyName != SPELLFAMILY_DRUID && !(m_spellProto->SpellFamilyFlags & UI64LIT(0x1000000000)))
+                m_modifier.m_amount = amount;
             ApplyModifier(true, true);
         }
     }
@@ -1328,7 +1421,7 @@ void Aura::ReapplyAffectedPassiveAuras( Unit* target, bool owner_mode )
             // non deleted and not same aura (any with same spell id)
             !itr->second->IsDeleted() && itr->second->GetId() != GetId() &&
             // and affected by aura
-            isAffectedOnSpell(itr->second->GetSpellProto()))
+            isAffectedOnSpell(itr->second->GetSpellProto()) && !itr->second->m_castItemGuid)
         {
             // only applied by self or aura caster
             if (itr->second->GetCasterGUID() == target->GetGUID())
@@ -1440,6 +1533,10 @@ void Aura::HandleAddModifier(bool apply, bool Real)
     if(m_modifier.m_miscvalue >= MAX_SPELLMOD)
         return;
 
+    // Aura Mastery - Remove immunity effect 
+    if (!apply && m_spellProto->Id == 31821) 
+        m_target->RemoveAurasDueToSpell(64364); 
+
     if (apply)
     {
         // Add custom charges for some mod aura
@@ -1473,6 +1570,15 @@ void Aura::HandleAddModifier(bool apply, bool Real)
     ((Player*)GetTarget())->AddSpellMod(m_spellmod, apply);
 
     ReapplyAffectedPassiveAuras();
+
+    if(m_spellProto->SpellFamilyName == SPELLFAMILY_DRUID && (m_spellmod->mask2 & UI64LIT(0x20000)))
+    {
+        m_target->RemoveAurasDueToSpell(66530);
+
+        // Aura 66530 is immediately applied ONLY when "Improved Barkskin" is learned in Caster/Travel Form
+        if(apply && (m_target->m_form == FORM_NONE || m_target->m_form == FORM_TRAVEL))
+            m_target->CastSpell(m_target,66530,true);
+    }
 }
 
 void Aura::TriggerSpell()
@@ -2144,6 +2250,28 @@ void Aura::TriggerSpell()
 
                 break;
             }
+            // Earthen Power (from Earthbind Totem Passive)
+            case 6474:
+            {
+                Unit *owner = target->GetOwner();
+
+                if (!owner)
+                    break;
+
+                Unit::AuraList const& dummyAuras = owner->GetAurasByType(SPELL_AURA_DUMMY);
+                for(Unit::AuraList::const_iterator itr = dummyAuras.begin(); itr != dummyAuras.end(); ++itr)
+                {
+                    if ((*itr)->GetSpellProto()->SpellIconID == 2289 && (*itr)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_SHAMAN)
+                    {
+                        if (!roll_chance_i((*itr)->GetModifier()->m_amount))
+                            break;
+
+                        target->CastSpell(target, 59566, true, NULL, this);
+                        break;
+                    }
+                 }
+                break;
+             }
             // Mana Tide
             case 16191:
             {
@@ -2161,6 +2289,10 @@ void Aura::TriggerSpell()
                     caster->CastSpell(triggerTarget, trigger_spell_id, true, NULL, this);
                 return;
             }
+            // Intense Cold
+            case 48094:
+                target->CastSpell(target, trigger_spell_id, true, NULL, this);
+                return;
             // Beacon of Light
             case 53563:
                 // original caster must be target (beacon)
@@ -2174,7 +2306,20 @@ void Aura::TriggerSpell()
                 triggerTarget->CastCustomSpell(triggerTarget, trigger_spell_id, &mana, NULL, NULL, true, NULL, this);
                 return;
             }
-        }
+			// Guardian Swarm
+			case 64396:
+			{
+			   if (Unit* caster = GetCaster())
+               {
+                  // Summon Swarming Guardian
+                  Creature* pCreature = caster->SummonCreature(34034, caster->GetPositionX(), caster->GetPositionY(), caster->GetPositionZ(), caster->GetOrientation(), TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 10000);               				  
+        
+		          if (pCreature)
+				      pCreature->AddThreat(target, 10000.0f);
+				}
+                return;
+			}	
+		}
     }
 
     // All ok cast by default case
@@ -2243,6 +2388,33 @@ void Aura::HandleAuraDummy(bool apply, bool Real)
                         if (Unit* caster = GetCaster())
                             caster->CastSpell(caster, 13138, true, NULL, this);
                         return;
+                    case 28832:                             // Mark of Korth'azz
+                    case 28833:                             // Mark of Blaumeux
+                    case 28834:                             // Mark of Rivendare
+                    case 28835:                             // Mark of Zeliek
+                    {
+                         Aura* aur = m_target->GetAura(GetId(), EFFECT_INDEX_0);
+                         if (!aur)
+                             return;
+
+                         uint8 stacks = aur->GetStackAmount();
+                         int32 damage = 0;
+
+                         if (stacks == 2)
+                            damage = 500;
+                         else if (stacks == 3)
+                            damage = 1500;
+                         else if (stacks == 4)
+                            damage = 4000;
+                         else if (stacks == 5)
+                            damage = 12500;
+                         else if (stacks > 5)
+                            damage = 20000 + 1000 * (stacks - 6);
+
+                         if (Unit* caster = GetCaster())
+                              m_target->CastCustomSpell(m_target, 28836, &damage, NULL, NULL, true, NULL, this, caster->GetGUID());
+                         return;
+                    }
                     case 39850:                             // Rocket Blast
                         if (roll_chance_i(20))              // backfire stun
                             target->CastSpell(target, 51581, true, NULL, this);
@@ -2271,14 +2443,60 @@ void Aura::HandleAuraDummy(bool apply, bool Real)
                             // not use ammo and not allow use
                             ((Player*)target)->RemoveAmmo();
                         return;
+                    case 47977:                             // Magic Broom
+                        Spell::SelectMountByAreaAndSkill(m_target, 42680, 42683, 42667, 42668, 0);
+                        return;
                     case 48025:                             // Headless Horseman's Mount
                         Spell::SelectMountByAreaAndSkill(target, 51621, 48024, 51617, 48023, 0);
                         return;
+                    case 52921:                             // Arc Lightning (Halls of Lighning: Loken)
+                        m_target->CastSpell(m_target, 52924, false);
+                        return;
+                    case 55328:                                 // Stoneclaw Totem I
+                        m_target->CastSpell(m_target, 5728, true);
+                        return;
+                    case 55329:                                 // Stoneclaw Totem II
+                        m_target->CastSpell(m_target, 6397, true);
+                        return;
+                    case 55330:                                 // Stoneclaw Totem III
+                        m_target->CastSpell(m_target, 6398, true);
+                        return;
+                    case 55332:                                 // Stoneclaw Totem IV
+                        m_target->CastSpell(m_target, 6399, true);
+                        return;
+                    case 55333:                                 // Stoneclaw Totem V
+                        m_target->CastSpell(m_target, 10425, true);
+                        return;
+                    case 55335:                                 // Stoneclaw Totem VI
+                        m_target->CastSpell(m_target, 10426, true);
+                        return;
+                    case 55278:                                 // Stoneclaw Totem VII
+                        m_target->CastSpell(m_target, 25513, true);
+                        return;
+                    case 58589:                                 // Stoneclaw Totem VIII
+                        m_target->CastSpell(m_target, 58583, true);
+                        return;
+                    case 58590:                                 // Stoneclaw Totem IX
+                        m_target->CastSpell(m_target, 58584, true);
+                        return;
+                    case 58591:                                 // Stoneclaw Totem X
+                        m_target->CastSpell(m_target, 58585, true);
+                        return;
                     case 62061:                             // Festive Holiday Mount
                         if (target->HasAuraType(SPELL_AURA_MOUNTED))
                             // Reindeer Transformation
                             target->CastSpell(target, 25860, true, NULL, this);
                         return;
+                    case 63322:
+                    {
+                        int32 multiplier = pow(2.0f,  GetStackAmount());
+                        int32 damage = 50 * multiplier;
+                        int32 energize = 100 * multiplier;
+
+                        m_target->CastCustomSpell(m_target, 63338, &damage, 0, 0 ,true);
+                        m_target->CastCustomSpell(m_target, 63337, &energize, 0, 0, true);
+                        return;
+                    }
                     case 63624:                             // Learn a Second Talent Specialization
                         // Teach Learn Talent Specialization Switches, required for client triggered casts, allow after 30 sec delay
                         if (target->GetTypeId() == TYPEID_PLAYER)
@@ -2301,6 +2519,9 @@ void Aura::HandleAuraDummy(bool apply, bool Real)
                     case 75614:                             // Celestial Steed
                         Spell::SelectMountByAreaAndSkill(target, 75619, 75620, 75617, 75618, 76153);
                         return;
+                    case 75973:                             // X-53 Touring Rocket 
+                        Spell::SelectMountByAreaAndSkill(m_target, 0, 0, 75957, 75972, 76154);
+                        return;
                 }
                 break;
             }
@@ -2341,6 +2562,19 @@ void Aura::HandleAuraDummy(bool apply, bool Real)
                 }
                 break;
             }
+            case SPELLFAMILY_MAGE:
+            {
+                // hack for Fingers of Frost stacks
+                if (GetId() == 74396)
+                {
+                    if (Aura *aur = m_target->GetAura(74396, EFFECT_INDEX_0))
+                    {
+                        if (aur->GetStackAmount() < 3)
+                            SetAuraCharges(3);
+                    }
+                }
+                break;
+            }
             case SPELLFAMILY_SHAMAN:
             {
                 // Tidal Force
@@ -2370,6 +2604,33 @@ void Aura::HandleAuraDummy(bool apply, bool Real)
                 }
                 break;
             }
+            case SPELLFAMILY_DEATHKNIGHT:
+            {
+                // Hungering Cold - disease apply
+                if(GetId() == 51209)
+                {
+                    Unit *caster = GetCaster();
+                    if(!caster)
+                        return;
+
+                    caster->CastSpell(m_target, 55095, true);
+                }
+                break;
+            }
+            case SPELLFAMILY_ROGUE:
+            {
+                if (GetId() == 52916) // Honor Among Thieves
+                {
+                    if(m_target->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        if (Unit * target = Unit::GetUnit(*m_target,((Player*)m_target)->GetComboTarget()))
+                            m_target->CastSpell(target, 51699, true);
+                        else if( Unit * target = m_target->getVictim() )
+                            m_target->CastSpell(target, 51699, true);
+                    }
+                }
+                break;
+            }
         }
     }
     // AT REMOVE
@@ -2487,6 +2748,12 @@ void Aura::HandleAuraDummy(bool apply, bool Real)
                 target->CastSpell(target, 45472, true);
                 return;
             }
+            case 74396:                                     // Fingers of Frost effect remove
+            {
+                if (GetAuraCharges() <= 0)
+                    m_target->RemoveAurasDueToSpell(44544);
+                return;
+            }
         }
 
         // Living Bomb
@@ -2499,15 +2766,34 @@ void Aura::HandleAuraDummy(bool apply, bool Real)
 
             return;
         }
+        // Arcane Missiles
+        if (m_spellProto->SpellFamilyName == SPELLFAMILY_MAGE && (m_spellProto->SpellFamilyFlags & UI64LIT(0x0000000000000800)))
+
+        // Vampiric Touch
+        if ((GetSpellProto()->SpellFamilyFlags & UI64LIT(0x40000000000)) && m_removeMode==AURA_REMOVE_BY_DISPEL)
+        {
+            Unit* caster = GetCaster();
+            if (!caster)
+                return;
+
+            int32 basepoints = GetSpellProto()->EffectBasePoints[1] * 8;
+            basepoints = caster->SpellDamageBonusDone(m_target, GetSpellProto(), basepoints, DOT);
+            basepoints = m_target->SpellDamageBonusTaken(caster, GetSpellProto(), basepoints, DOT);
+            m_target->CastCustomSpell(m_target, 64085, &basepoints, NULL, NULL, false, NULL, this, GetCasterGUID());
+            return;
+        }
 
         if (m_removeMode == AURA_REMOVE_BY_DEATH)
         {
-            // Stop caster Arcane Missle chanelling on death
-            if (GetSpellProto()->SpellFamilyName == SPELLFAMILY_MAGE && (GetSpellProto()->SpellFamilyFlags & UI64LIT(0x0000000000000800)))
+            //Remove arcane blast
+            if (Unit* caster = GetCaster())
+                caster->RemoveAurasDueToSpell(36032);
+
+            //Stop channeling at death
+            if (m_removeMode == AURA_REMOVE_BY_DEATH)
             {
                 if (Unit* caster = GetCaster())
                     caster->InterruptSpell(CURRENT_CHANNELED_SPELL);
-
                 return;
             }
         }
@@ -2706,13 +2992,24 @@ void Aura::HandleAuraDummy(bool apply, bool Real)
                     int32 bp0 = m_modifier.m_amount;
 
                     if (Unit* caster = GetCaster())
-                        target->CastCustomSpell(caster,48210,&bp0,NULL,NULL,true);
+                        target->CastCustomSpell(caster,48210,&bp0,NULL,NULL,true,0,0, caster->GetObjectGuid());
                 }
             }
             break;
         }
         case SPELLFAMILY_PRIEST:
         {
+            // Penance
+            if (m_spellProto->SpellIconID == 2818)
+            {
+                Unit* caster = GetCaster();
+                if (!caster || caster->GetTypeId() != TYPEID_PLAYER)
+                    return;
+
+                if (apply && m_target)
+                    ((Player*)caster)->SetSelection(m_target->GetGUID());
+                return;
+            }
             // Pain and Suffering
             if (GetSpellProto()->SpellIconID == 2874 && target->GetTypeId()==TYPEID_PLAYER)
             {
@@ -2773,7 +3070,7 @@ void Aura::HandleAuraDummy(bool apply, bool Real)
                 }
             }
 
-            // Lifebloom
+           // Lifebloom
             if (GetSpellProto()->SpellFamilyFlags & UI64LIT(0x1000000000))
             {
                 if (apply)
@@ -2783,9 +3080,15 @@ void Aura::HandleAuraDummy(bool apply, bool Real)
                         // prevent double apply bonuses
                         if (target->GetTypeId() != TYPEID_PLAYER || !((Player*)target)->GetSession()->PlayerLoading())
                         {
-                            m_modifier.m_amount = caster->SpellHealingBonusDone(target, GetSpellProto(), m_modifier.m_amount, SPELL_DIRECT_DAMAGE);
-                            m_modifier.m_amount = target->SpellHealingBonusTaken(caster, GetSpellProto(), m_modifier.m_amount, SPELL_DIRECT_DAMAGE);
-                        }
+                            if(m_stackAmount <= 1)
+                            {
+                                const SpellEntry* finalBloomEntry = sSpellStore.LookupEntry(33778);
+                                m_modifier.m_amount = caster->SpellHealingBonusDone(target, finalBloomEntry, m_modifier.m_amount, HEAL);
+                                m_modifier.m_amount = target->SpellHealingBonusTaken(caster, finalBloomEntry, m_modifier.m_amount, HEAL);
+                            }
+                            else
+                                m_modifier.m_amount += (m_stackAmount == 2) ? m_modifier.m_amount : (m_modifier.m_amount / 2);
+                        } 
                     }
                 }
                 else
@@ -2804,9 +3107,10 @@ void Aura::HandleAuraDummy(bool apply, bool Real)
                     // final heal
                     if (target->IsInWorld() && GetStackAmount() > 0)
                     {
-                        int32 amount = m_modifier.m_amount / GetStackAmount();
-                        target->CastCustomSpell(target, 33778, &amount, NULL, NULL, true, NULL, this, GetCasterGUID());
+                        //Heal
+                        target->CastCustomSpell(target, 33778, &m_modifier.m_amount, NULL, NULL, true, NULL, this, GetCasterGUID());
 
+                        //Return mana
                         if (Unit* caster = GetCaster())
                         {
                             int32 returnmana = (GetSpellProto()->ManaCostPercentage * caster->GetCreateMana() / 100) * GetStackAmount() / 2;
@@ -3020,7 +3324,9 @@ void Aura::HandleAuraModShapeshift(bool apply, bool Real)
         return;
     }
 
-    if (ssEntry->modelID_A)
+    modelid = m_target->GetModelForForm(form);
+
+    if (!modelid && ssEntry->modelID_A)
     {
         // i will asume that creatures will always take the defined model from the dbc
         // since no field in creature_templates describes wether an alliance or
@@ -3069,6 +3375,7 @@ void Aura::HandleAuraModShapeshift(bool apply, bool Real)
     switch(form)
     {
         case FORM_CAT:
+        case FORM_SHADOW_DANCE:
             PowerType = POWER_ENERGY;
             break;
         case FORM_BEAR:
@@ -3135,7 +3442,8 @@ void Aura::HandleAuraModShapeshift(bool apply, bool Real)
         if(target->m_ShapeShiftFormSpellId)
             target->RemoveAurasDueToSpell(target->m_ShapeShiftFormSpellId, this);
 
-        target->SetByteValue(UNIT_FIELD_BYTES_2, 3, form);
+        // For Shadow Dance we must apply Stealth form (30) instead of current (13)
+        target->SetByteValue(UNIT_FIELD_BYTES_2, 3, (form == FORM_SHADOW_DANCE) ? uint8(FORM_STEALTH) : form);
 
         if(modelid > 0)
             target->SetDisplayId(modelid);
@@ -3204,6 +3512,10 @@ void Aura::HandleAuraModShapeshift(bool apply, bool Real)
                         target->SetPower(POWER_RAGE, Rage_val);
                     break;
                 }
+                // Shadow Dance - apply stealth mode stand flag
+                case FORM_SHADOW_DANCE:
+                    m_target->SetStandFlags(UNIT_STAND_FLAGS_CREEP);
+                    break;
                 default:
                     break;
             }
@@ -3244,6 +3556,10 @@ void Aura::HandleAuraModShapeshift(bool apply, bool Real)
                 if(Aura* dummy = target->GetDummyAura(37324) )
                     target->CastSpell(target, 37325, true, NULL, dummy);
                 break;
+            // Shadow Dance - remove stealth mode stand flag
+            case FORM_SHADOW_DANCE:
+                m_target->RemoveStandFlags(UNIT_STAND_FLAGS_CREEP);
+                break;
             default:
                 break;
         }
@@ -3260,6 +3576,8 @@ void Aura::HandleAuraModShapeshift(bool apply, bool Real)
     // add/remove the shapeshift aura's boosts
     HandleShapeshiftBoosts(apply);
 
+    target->UpdateSpeed(MOVE_RUN, true);
+
     if(target->GetTypeId() == TYPEID_PLAYER)
         ((Player*)target)->InitDataForForm();
 }
@@ -3519,7 +3837,7 @@ void Aura::HandleChannelDeathItem(bool apply, bool Real)
         if( msg != EQUIP_ERR_OK )
         {
             count-=noSpaceForCount;
-            ((Player*)caster)->SendEquipError( msg, NULL, NULL, spellInfo->EffectItemType[m_effIndex] );
+            ((Player*)caster)->SendEquipError( msg, NULL, NULL, spellInfo->EffectItemType[m_effIndex]);
             if (count==0)
                 return;
         }
@@ -3631,7 +3949,7 @@ void Aura::HandleModPossess(bool apply, bool Real)
             target->GetMotionMaster()->Clear();
             target->GetMotionMaster()->MoveIdle();
         }
-        else if(target->GetTypeId() == TYPEID_PLAYER)
+        else if(target->GetTypeId() == TYPEID_PLAYER && !target->GetVehicleGUID())
         {
             ((Player*)target)->SetClientControl(target, 0);
         }
@@ -3660,7 +3978,7 @@ void Aura::HandleModPossess(bool apply, bool Real)
 
         target->SetCharmerGUID(0);
 
-        if(target->GetTypeId() == TYPEID_PLAYER)
+        if(target->GetTypeId() == TYPEID_PLAYER && !target->GetVehicleGUID())
         {
             ((Player*)target)->setFactionForRace(target->getRace());
             ((Player*)target)->SetClientControl(target, 1);
@@ -3901,6 +4219,9 @@ void Aura::HandleAuraModDisarm(bool apply, bool Real)
 
 void Aura::HandleAuraModStun(bool apply, bool Real)
 {
+    if(m_target->isInFlight())
+        return;
+
     if(!Real)
         return;
 
@@ -3927,10 +4248,13 @@ void Aura::HandleAuraModStun(bool apply, bool Real)
             target->SetStandState(UNIT_STAND_STATE_STAND);// in 1.5 client
         }
 
-        WorldPacket data(SMSG_FORCE_MOVE_ROOT, 8);
-        data << target->GetPackGUID();
-        data << uint32(0);
-        target->SendMessageToSet(&data, true);
+        if(!target->hasUnitState(UNIT_STAT_ON_VEHICLE))
+        {
+            WorldPacket data(SMSG_FORCE_MOVE_ROOT, 8);
+            data << target->GetPackGUID();
+            data << uint32(0);
+            target->SendMessageToSet(&data,true);
+        }
 
         // Summon the Naj'entus Spine GameObject on target if spell is Impaling Spine
         if(GetId() == 39837)
@@ -3980,7 +4304,7 @@ void Aura::HandleAuraModStun(bool apply, bool Real)
         target->clearUnitState(UNIT_STAT_STUNNED);
         target->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
 
-        if(!target->hasUnitState(UNIT_STAT_ROOT))         // prevent allow move if have also root effect
+        if(!target->hasUnitState(UNIT_STAT_ROOT | UNIT_STAT_ON_VEHICLE))         // prevent allow move if have also root effect
         {
             if(target->getVictim() && target->isAlive())
                 target->SetTargetGUID(target->getVictim()->GetGUID());
@@ -4030,6 +4354,8 @@ void Aura::HandleModStealth(bool apply, bool Real)
 
     if (apply)
     {
+        // stop being attacked and interrupt casts
+        m_target->CombatStop();
         // drop flag at stealth in bg
         target->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_IMMUNE_OR_LOST_SELECTION);
 
@@ -4064,6 +4390,7 @@ void Aura::HandleModStealth(bool apply, bool Real)
                     // Overkill
                     else if ((*i)->GetId() == 58426 && GetSpellProto()->SpellFamilyFlags & UI64LIT(0x0000000000400000))
                     {
+                        target->RemoveAurasDueToSpell(58428);
                         target->CastSpell(target, 58427, true);
                     }
                 }
@@ -4102,13 +4429,7 @@ void Aura::HandleModStealth(bool apply, bool Real)
                     target->CastSpell(target, 31666, true);
                 // Overkill
                 else if ((*i)->GetId() == 58426 && GetSpellProto()->SpellFamilyFlags & UI64LIT(0x0000000000400000))
-                {
-                    if (Aura* aura = target->GetAura(58427, EFFECT_INDEX_0))
-                    {
-                        aura->SetAuraMaxDuration(20*IN_MILLISECONDS);
-                        aura->RefreshAura();
-                    }
-                }
+                    target->CastSpell(target, 58428, true);
             }
         }
     }
@@ -4208,11 +4529,13 @@ void Aura::HandleAuraModRoot(bool apply, bool Real)
 
         if(target->GetTypeId() == TYPEID_PLAYER)
         {
-            WorldPacket data(SMSG_FORCE_MOVE_ROOT, 10);
-            data << target->GetPackGUID();
-            data << (uint32)2;
-            target->SendMessageToSet(&data, true);
-
+            if(!target->hasUnitState(UNIT_STAT_ON_VEHICLE))
+            {
+                WorldPacket data(SMSG_FORCE_MOVE_ROOT, 10);
+                data << target->GetPackGUID();
+                data << (uint32)2;
+                target->SendMessageToSet(&data,true);
+            }
             //Clear unit movement flags
             ((Player*)target)->m_movementInfo.SetMovementFlags(MOVEFLAG_NONE);
         }
@@ -4250,7 +4573,7 @@ void Aura::HandleAuraModRoot(bool apply, bool Real)
 
         target->clearUnitState(UNIT_STAT_ROOT);
 
-        if(!target->hasUnitState(UNIT_STAT_STUNNED))      // prevent allow move if have also stun effect
+        if(!target->hasUnitState(UNIT_STAT_STUNNED | UNIT_STAT_ON_VEHICLE))      // prevent allow move if have also stun effect
         {
             if(target->getVictim() && target->isAlive())
                 target->SetTargetGUID(target->getVictim()->GetGUID());
@@ -4422,9 +4745,16 @@ void Aura::HandleAuraModIncreaseFlightSpeed(bool apply, bool Real)
     {
         WorldPacket data;
         if(apply)
+        {
+            ((Player*)target)->SetCanFly(true);
             data.Initialize(SMSG_MOVE_SET_CAN_FLY, 12);
+        }
         else
+        {
             data.Initialize(SMSG_MOVE_UNSET_CAN_FLY, 12);
+            ((Player*)target)->SetCanFly(false);
+        }
+        //data.append(m_target->GetPackGUID());
         data << target->GetPackGUID();
         data << uint32(0);                                      // unknown
         target->SendMessageToSet(&data, true);
@@ -4538,7 +4868,7 @@ void Aura::HandleModMechanicImmunity(bool apply, bool /*Real*/)
         uint32 mechanic = 1 << (misc-1);
 
         //immune movement impairment and loss of control
-        if(GetId()==42292 || GetId()==59752)
+        if(GetId()==42292 || GetId()==59752 || GetId()==53490)
             mechanic=IMMUNE_TO_MOVEMENT_IMPAIRMENT_AND_LOSS_CONTROL_MASK;
 
         target->RemoveAurasAtMechanicImmunity(mechanic,GetId());
@@ -4546,6 +4876,19 @@ void Aura::HandleModMechanicImmunity(bool apply, bool /*Real*/)
 
     target->ApplySpellImmune(GetId(),IMMUNITY_MECHANIC,misc,apply);
 
+    // Demonic Circle
+    if (GetSpellProto()->SpellFamilyName == SPELLFAMILY_WARLOCK && GetSpellProto()->SpellIconID == 3221)
+    {
+        if (m_target->GetTypeId() != TYPEID_PLAYER)
+            return;
+        if (apply)
+        {
+            GameObject* obj = m_target->GetGameObject(48018);
+            if (obj)
+                ((Player*)m_target)->TeleportTo(obj->GetMapId(),obj->GetPositionX(),obj->GetPositionY(),obj->GetPositionZ(),obj->GetOrientation());
+        }
+    }
+
     // Bestial Wrath
     if (GetSpellProto()->SpellFamilyName == SPELLFAMILY_HUNTER && GetSpellProto()->SpellIconID == 1680)
     {
@@ -4593,6 +4936,8 @@ void Aura::HandleAuraModEffectImmunity(bool apply, bool /*Real*/)
     {
         if( BattleGround *bg = ((Player*)target)->GetBattleGround() )
             bg->EventPlayerDroppedFlag(((Player*)target));
+        else
+            sOutdoorPvPMgr.HandleDropFlag((Player*)target,GetSpellProto()->Id);
     }
 
     target->ApplySpellImmune(GetId(), IMMUNITY_EFFECT, m_modifier.m_miscvalue, apply);
@@ -4701,6 +5046,10 @@ void Aura::HandleAuraModStalked(bool apply, bool /*Real*/)
         GetTarget()->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_TRACK_UNIT);
     else
         GetTarget()->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_TRACK_UNIT);
+
+    // assassins mark fix
+    if(m_removeMode == AURA_REMOVE_BY_DEFAULT && m_duration <= 0 && GetSpellProto()->Id == 46459)
+        GetTarget()->DealDamage(GetTarget(), GetTarget()->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
 }
 
 /*********************************************************/
@@ -4726,6 +5075,19 @@ void Aura::HandlePeriodicTriggerSpell(bool apply, bool /*Real*/)
                 if (m_removeMode == AURA_REMOVE_BY_DEFAULT && GetEffIndex() + 1 < MAX_EFFECT_INDEX)
                     target->CastSpell(target, GetSpellProto()->CalculateSimpleValue(SpellEffectIndex(GetEffIndex()+1)), true);
                 return;
+            case 46221:                                     // Animal Blood
+                if (m_removeMode == AURA_REMOVE_BY_DEFAULT && m_target->IsInWater())
+                {
+                    GridMapLiquidData liquid_status;
+
+                    if (m_target->GetMap()->getLiquidStatus(m_target->GetPositionX(), m_target->GetPositionY(), m_target->GetPositionZ(), MAP_ALL_LIQUIDS, &liquid_status))
+                        m_target->CastSpell(m_target->GetPositionX(), m_target->GetPositionY(), liquid_status.level, 63471, true, NULL, this);
+                }
+                return;
+            case 43648:                                     // Electrical Storm - remove cloud around caster
+                if (m_target->HasAura(45213))
+                    m_target->RemoveAurasDueToSpell(45213);
+                return;
             case 51912:                                     // Ultra-Advanced Proto-Typical Shortening Blaster
                 if (m_removeMode == AURA_REMOVE_BY_EXPIRE)
                 {
@@ -4734,6 +5096,10 @@ void Aura::HandlePeriodicTriggerSpell(bool apply, bool /*Real*/)
                 }
 
                 return;
+            case 62776:                                     //Tympanic Tantrum
+                    if (Unit* pCaster = GetCaster())
+                        pCaster->CastSpell(m_target, m_spellProto->EffectTriggerSpell[GetEffIndex()], true, NULL, this);    
+                return;
             default:
                 break;
         }
@@ -4789,6 +5155,18 @@ void Aura::HandlePeriodicEnergize(bool apply, bool Real)
                 break;
         }
     }
+    if (!apply && !loading)
+    {
+        switch (GetId())
+        {
+            case 5229:                                      // Druid Bear Enrage
+                if (m_target->HasAura(51185))               // King of the Jungle self Enrage bonus with infinity duration
+                    m_target->RemoveAurasDueToSpell(51185);
+                break;
+            default:
+                break;
+        }
+    }
 
     m_isPeriodic = apply;
 }
@@ -4812,18 +5190,60 @@ void Aura::HandleAuraPeriodicDummy(bool apply, bool Real)
     SpellEntry const*spell = GetSpellProto();
     switch( spell->SpellFamilyName)
     {
+	    case SPELLFAMILY_GENERIC:
+		{
+		   switch(spell->Id)
+		   {
+		       // Slag Pot (Normal)
+			   case 62717:
+			   {
+			      if (!apply && m_removeMode == AURA_REMOVE_BY_DEFAULT)
+				      m_target->CastSpell(m_target, 62836, true, NULL, this);
+				  break;
+				}
+				// Slag Pot (Heroic)
+				case 63477:
+				{
+				   if (!apply && m_removeMode == AURA_REMOVE_BY_DEFAULT)
+				       m_target->CastSpell(m_target, 63536, true, NULL, this);
+				   break;
+				}
+			}
+			break;
+		}	
         case SPELLFAMILY_ROGUE:
         {
-            if(!apply)
+            switch(spell->Id)
             {
-                switch(spell->Id)
-                {
-                    // Master of Subtlety
-                    case 31666: target->RemoveAurasDueToSpell(31665); break;
-                }
+                // Master of Subtlety
+                case 31666: if(!apply) target->RemoveAurasDueToSpell(31665); break;
+                // Overkill
+                case 58428: if(!apply) target->RemoveAurasDueToSpell(58427); break;
+                // Killing Spree
+                case 51690:
+                    if(apply)
+                        target->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                    else
+                        target->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                    break;
             }
             break;
         }
+        case SPELLFAMILY_WARLOCK:
+        {
+            switch (spell->Id)
+            {
+                case 48018:
+                       if (apply)
+                          m_target->CastSpell(m_target, 62388, true);                
+                        else
+                        {
+                          m_target->RemoveGameObject(spell->Id,true);
+                          m_target->RemoveAurasDueToSpell(62388);
+                        }
+                break;
+            }
+        }
         case SPELLFAMILY_HUNTER:
         {
             Unit* caster = GetCaster();
@@ -4868,7 +5288,11 @@ void Aura::HandlePeriodicHeal(bool apply, bool /*Real*/)
             m_modifier.m_amount += ap > holy ? ap : holy;
         }
 
-        m_modifier.m_amount = caster->SpellHealingBonusDone(target, GetSpellProto(), m_modifier.m_amount, DOT, GetStackAmount());
+        //Lifebloom special stacking
+        if(m_spellProto->SpellFamilyName == SPELLFAMILY_DRUID && (m_spellProto->SpellFamilyFlags & UI64LIT(0x1000000000)) && GetStackAmount() > 1)
+            m_modifier.m_amount += (GetStackAmount() == 2) ? m_modifier.m_amount : (m_modifier.m_amount / 2);
+        else
+            m_modifier.m_amount = caster->SpellHealingBonusDone(target, GetSpellProto(), m_modifier.m_amount, DOT, GetStackAmount());
     }
 }
 
@@ -4941,11 +5365,11 @@ void Aura::HandlePeriodicDamage(bool apply, bool Real)
                     // $AP*0.18/3 bonus per tick
                     m_modifier.m_amount += int32(caster->GetTotalAttackPowerValue(BASE_ATTACK) * 6 / 100);
                 // Lacerate
-                if (spellProto->SpellFamilyFlags & UI64LIT(0x000000010000000000))
+                else if (spellProto->SpellFamilyFlags & UI64LIT(0x000000010000000000))
                     // $AP*0.05/5 bonus per tick
                     m_modifier.m_amount += int32(caster->GetTotalAttackPowerValue(BASE_ATTACK) / 100);
                 // Rip
-                if (spellProto->SpellFamilyFlags & UI64LIT(0x000000000000800000))
+                else if (spellProto->SpellFamilyFlags & UI64LIT(0x000000000000800000))
                 {
                     // 0.01*$AP*cp
                     if (caster->GetTypeId() != TYPEID_PLAYER)
@@ -4966,7 +5390,7 @@ void Aura::HandlePeriodicDamage(bool apply, bool Real)
                     m_modifier.m_amount += int32(caster->GetTotalAttackPowerValue(BASE_ATTACK) * cp / 100);
                 }
                 // Lock Jaw
-                if (spellProto->SpellFamilyFlags & UI64LIT(0x1000000000000000))
+                else if (spellProto->SpellFamilyFlags & UI64LIT(0x1000000000000000))
                     // 0.15*$AP
                     m_modifier.m_amount += int32(caster->GetTotalAttackPowerValue(BASE_ATTACK) * 15 / 100);
                 break;
@@ -4989,11 +5413,11 @@ void Aura::HandlePeriodicDamage(bool apply, bool Real)
                     m_modifier.m_amount += int32(caster->GetTotalAttackPowerValue(BASE_ATTACK) * AP_per_combo[cp]);
                 }
                 // Garrote
-                if (spellProto->SpellFamilyFlags & UI64LIT(0x000000000000000100))
+                else if (spellProto->SpellFamilyFlags & UI64LIT(0x000000000000000100))
                     // $AP*0.07 bonus per tick
                     m_modifier.m_amount += int32(caster->GetTotalAttackPowerValue(BASE_ATTACK) * 7 / 100);
                 // Deadly Poison
-                if (spellProto->SpellFamilyFlags & UI64LIT(0x0000000000010000))
+                else if (spellProto->SpellFamilyFlags & UI64LIT(0x0000000000010000))
                     // 0.12*$AP / 4 * amount of stack
                     m_modifier.m_amount += int32(caster->GetTotalAttackPowerValue(BASE_ATTACK) * 3 * GetStackAmount() / 100);
                 break;
@@ -5005,7 +5429,7 @@ void Aura::HandlePeriodicDamage(bool apply, bool Real)
                     // $RAP*0.2/5 bonus per tick
                     m_modifier.m_amount += int32(caster->GetTotalAttackPowerValue(RANGED_ATTACK) * 0.2 / 5);
                 // Immolation Trap
-                if ((spellProto->SpellFamilyFlags & UI64LIT(0x0000000000000004)) && spellProto->SpellIconID == 678)
+                else if ((spellProto->SpellFamilyFlags & UI64LIT(0x0000000000000004)) && spellProto->SpellIconID == 678)
                     // $RAP*0.1/5 bonus per tick
                     m_modifier.m_amount += int32(caster->GetTotalAttackPowerValue(RANGED_ATTACK) * 10 / 500);
                 break;
@@ -5043,11 +5467,6 @@ void Aura::HandlePeriodicDamage(bool apply, bool Real)
             if(spellProto->DmgClass == SPELL_DAMAGE_CLASS_NONE || spellProto->DmgClass == SPELL_DAMAGE_CLASS_MAGIC)
                 m_modifier.m_amount = caster->SpellDamageBonusDone(target, GetSpellProto(), m_modifier.m_amount, DOT, GetStackAmount());
             // MeleeDamagebonusDone for weapon based spells
-            else
-            {
-                WeaponAttackType attackType = GetWeaponAttackType(GetSpellProto());
-                m_modifier.m_amount = caster->MeleeDamageBonusDone(target, m_modifier.m_amount, attackType, GetSpellProto(), DOT, GetStackAmount());
-            }
         }
     }
     // remove time effects
@@ -5093,22 +5512,6 @@ void Aura::HandlePeriodicManaLeech(bool apply, bool /*Real*/)
 void Aura::HandlePeriodicHealthFunnel(bool apply, bool /*Real*/)
 {
     m_isPeriodic = apply;
-
-    // For prevent double apply bonuses
-    bool loading = (GetTarget()->GetTypeId() == TYPEID_PLAYER && ((Player*)GetTarget())->GetSession()->PlayerLoading());
-
-    // Custom damage calculation after
-    if (apply)
-    {
-        if(loading)
-            return;
-
-        Unit *caster = GetCaster();
-        if (!caster)
-            return;
-
-        m_modifier.m_amount = caster->SpellDamageBonusDone(GetTarget(), GetSpellProto(), m_modifier.m_amount, DOT, GetStackAmount());
-    }
 }
 
 /*********************************************************/
@@ -5123,11 +5526,21 @@ void Aura::HandleAuraModResistanceExclusive(bool apply, bool /*Real*/)
 {
     for(int8 x = SPELL_SCHOOL_NORMAL; x < MAX_SPELL_SCHOOL;x++)
     {
+        int32 oldMaxValue = 0;
         if(m_modifier.m_miscvalue & int32(1<<x))
         {
-            GetTarget()->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_VALUE, float(m_modifier.m_amount), apply);
+            // no same resistance auras stack together
+            Unit::AuraList const& REAuras = GetTarget()->GetAurasByType(SPELL_AURA_MOD_RESISTANCE_EXCLUSIVE);
+            for (Unit::AuraList::const_iterator i = REAuras.begin(); i != REAuras.end(); ++i)
+                if (((*i)->GetMiscValue() & int32(1<<x))  && (*i)->GetSpellProto()->Id != GetSpellProto()->Id)
+                    if (oldMaxValue < (*i)->GetModifier()->m_amount)
+                        oldMaxValue = (*i)->GetModifier()->m_amount;
+
+            float value = (m_modifier.m_amount > oldMaxValue) ? m_modifier.m_amount - oldMaxValue : 0.0f;
+
+            GetTarget()->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_VALUE, value, apply);
             if(GetTarget()->GetTypeId() == TYPEID_PLAYER)
-                GetTarget()->ApplyResistanceBuffModsMod(SpellSchools(x), m_positive, float(m_modifier.m_amount), apply);
+                GetTarget()->ApplyResistanceBuffModsMod(SpellSchools(x), m_positive, value, apply);
         }
     }
 }
@@ -5248,7 +5661,7 @@ void Aura::HandleModSpellDamagePercentFromStat(bool /*apply*/, bool /*Real*/)
     if(GetTarget()->GetTypeId() != TYPEID_PLAYER)
         return;
 
-    // Magic damage modifiers implemented in Unit::SpellDamageBonusDone
+    // Magic damage modifiers implemented in Unit::SpellDamageBonus
     // This information for client side use only
     // Recalculate bonus
     ((Player*)GetTarget())->UpdateSpellDamageAndHealingBonus();
@@ -5277,7 +5690,7 @@ void Aura::HandleModSpellDamagePercentFromAttackPower(bool /*apply*/, bool /*Rea
     if(GetTarget()->GetTypeId() != TYPEID_PLAYER)
         return;
 
-    // Magic damage modifiers implemented in Unit::SpellDamageBonusDone
+    // Magic damage modifiers implemented in Unit::SpellDamageBonus
     // This information for client side use only
     // Recalculate bonus
     ((Player*)GetTarget())->UpdateSpellDamageAndHealingBonus();
@@ -5296,7 +5709,7 @@ void Aura::HandleModHealingDone(bool /*apply*/, bool /*Real*/)
 {
     if(GetTarget()->GetTypeId() != TYPEID_PLAYER)
         return;
-    // implemented in Unit::SpellHealingBonusDone
+    // implemented in Unit::SpellHealingBonus
     // this information is for client side only
     ((Player*)GetTarget())->UpdateSpellDamageAndHealingBonus();
 }
@@ -5852,7 +6265,7 @@ void Aura::HandleModDamageDone(bool apply, bool Real)
         return;
     }
 
-    // Magic damage modifiers implemented in Unit::SpellDamageBonusDone
+    // Magic damage modifiers implemented in Unit::SpellDamageBonus
     // This information for client side use only
     if(target->GetTypeId() == TYPEID_PLAYER)
     {
@@ -5931,7 +6344,7 @@ void Aura::HandleModDamagePercentDone(bool apply, bool Real)
         return;
     }
 
-    // Magic damage percent modifiers implemented in Unit::SpellDamageBonusDone
+    // Magic damage percent modifiers implemented in Unit::SpellDamageBonus
     // Send info to client
     if(target->GetTypeId() == TYPEID_PLAYER)
         for(int i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; ++i)
@@ -6019,7 +6432,6 @@ void Aura::HandleShapeshiftBoosts(bool apply)
     {
         case FORM_CAT:
             spellId1 = 3025;
-            HotWSpellId = 24900;
             MasterShaperSpellId = 48420;
             break;
         case FORM_TREE:
@@ -6036,13 +6448,11 @@ void Aura::HandleShapeshiftBoosts(bool apply)
         case FORM_BEAR:
             spellId1 = 1178;
             spellId2 = 21178;
-            HotWSpellId = 24899;
             MasterShaperSpellId = 48418;
             break;
         case FORM_DIREBEAR:
             spellId1 = 9635;
             spellId2 = 21178;
-            HotWSpellId = 24899;
             MasterShaperSpellId = 48418;
             break;
         case FORM_BATTLESTANCE:
@@ -6076,9 +6486,13 @@ void Aura::HandleShapeshiftBoosts(bool apply)
             break;
         case FORM_SHADOW:
             spellId1 = 49868;
+            spellId2 = 71167;
 
-            if(target->GetTypeId() == TYPEID_PLAYER)      // Spell 49868 have same category as main form spell and share cooldown
+            if(target->GetTypeId() == TYPEID_PLAYER)      // Spell 49868 and 71167 have same category as main form spell and share cooldown
+            {
                 ((Player*)target)->RemoveSpellCooldown(49868);
+                ((Player*)target)->RemoveSpellCooldown(71167);
+            }
             break;
         case FORM_GHOSTWOLF:
             spellId1 = 67116;
@@ -6116,7 +6530,7 @@ void Aura::HandleShapeshiftBoosts(bool apply)
             if (MasterShaperSpellId)
             {
                 Unit::AuraList const& ShapeShifterAuras = target->GetAurasByType(SPELL_AURA_DUMMY);
-                for(Unit::AuraList::const_iterator i = ShapeShifterAuras.begin(); i != ShapeShifterAuras.end(); i++)
+                for(Unit::AuraList::const_iterator i = ShapeShifterAuras.begin(); i != ShapeShifterAuras.end(); ++i)
                 {
                     if ((*i)->GetSpellProto()->SpellIconID == 2851)
                     {
@@ -6143,7 +6557,7 @@ void Aura::HandleShapeshiftBoosts(bool apply)
             if (form == FORM_MOONKIN)
             {
                 Unit::AuraList const& dummyAuras = target->GetAurasByType(SPELL_AURA_DUMMY);
-                for(Unit::AuraList::const_iterator i = dummyAuras.begin(); i != dummyAuras.end(); i++)
+                for(Unit::AuraList::const_iterator i = dummyAuras.begin(); i != dummyAuras.end(); ++i)
                 {
                     if ((*i)->GetSpellProto()->SpellFamilyName==SPELLFAMILY_DRUID &&
                         (*i)->GetSpellProto()->SpellIconID == 2855)
@@ -6166,8 +6580,37 @@ void Aura::HandleShapeshiftBoosts(bool apply)
                 }
             }
 
+            // Improved Barkskin - apply/remove armor bonus due to shapeshift remove
+            if (((Player*)m_target)->HasSpell(63410) || ((Player*)m_target)->HasSpell(63411))
+            {
+                if (form == FORM_TRAVEL)
+                {
+                    m_target->RemoveAurasDueToSpell(66530);
+                    m_target->CastSpell(m_target,66530,true);
+                }
+                else
+                    m_target->RemoveAurasDueToSpell(66530);
+            }
+
+            // Survival of the Fittest (Armor part)
+            if (form == FORM_BEAR || form == FORM_DIREBEAR)
+            {
+                Unit::AuraList const& modAuras = m_target->GetAurasByType(SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE);
+                for (Unit::AuraList::const_iterator i = modAuras.begin(); i != modAuras.end(); ++i)
+                {
+                    if ((*i)->GetSpellProto()->SpellFamilyName==SPELLFAMILY_DRUID &&
+                        (*i)->GetSpellProto()->SpellIconID == 961)
+                    {
+                        int32 bp = (*i)->GetSpellProto()->CalculateSimpleValue(EFFECT_INDEX_2);
+                        if (bp)
+                            m_target->CastCustomSpell(m_target, 62069, &bp, NULL, NULL, true, NULL, this);
+                        break;
+                    }
+                }
+            }
+
             // Heart of the Wild
-            if (HotWSpellId)
+            if (form == FORM_CAT || form == FORM_BEAR || form == FORM_DIREBEAR)
             {
                 Unit::AuraList const& mModTotalStatPct = target->GetAurasByType(SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE);
                 for(Unit::AuraList::const_iterator i = mModTotalStatPct.begin(); i != mModTotalStatPct.end(); ++i)
@@ -6175,10 +6618,26 @@ void Aura::HandleShapeshiftBoosts(bool apply)
                     if ((*i)->GetSpellProto()->SpellIconID == 240 && (*i)->GetModifier()->m_miscvalue == 3)
                     {
                         int32 HotWMod = (*i)->GetModifier()->m_amount;
-                        if(GetModifier()->m_miscvalue == FORM_CAT)
-                            HotWMod /= 2;
+                        HotWMod /= 2;
+
+                        if (form == FORM_CAT)
+                          {
+                            if (HotWMod == 2)       {HotWSpellId = 30902;}
+                            else if (HotWMod == 4)  {HotWSpellId = 30903;}
+                            else if (HotWMod == 6)  {HotWSpellId = 30904;}
+                            else if (HotWMod == 8)  {HotWSpellId = 30905;}
+                            else if (HotWMod == 10) {HotWSpellId = 30906;}
+                           }
+                         else
+                           {
+                             if (HotWMod == 2)       {HotWSpellId = 19255;}
+                             else if (HotWMod == 4)  {HotWSpellId = 19256;}
+                             else if (HotWMod == 6)  {HotWSpellId = 19257;}
+                             else if (HotWMod == 8)  {HotWSpellId = 19258;}
+                             else if (HotWMod == 10) {HotWSpellId = 19259;}
+                            }
 
-                        target->CastCustomSpell(target, HotWSpellId, &HotWMod, NULL, NULL, true, NULL, this);
+                        target->CastCustomSpell(target, HotWSpellId, NULL, NULL, NULL, true, NULL, this);
                         break;
                     }
                 }
@@ -6187,6 +6646,35 @@ void Aura::HandleShapeshiftBoosts(bool apply)
     }
     else
     {
+       // Heart of the Wild (delete aura)
+       if (form == FORM_CAT || form == FORM_BEAR || form == FORM_DIREBEAR)
+       {
+            Unit::AuraList const& mModTotalStatPct = m_target->GetAurasByType(SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE);
+            for(Unit::AuraList::const_iterator i = mModTotalStatPct.begin(); i != mModTotalStatPct.end(); ++i)
+            {
+                if ((*i)->GetSpellProto()->SpellIconID == 240 && (*i)->GetModifier()->m_miscvalue == 3)
+                {
+                    int32 HotWMod = (*i)->GetModifier()->m_amount / 2;
+                    if (form == FORM_CAT)
+                    {
+                        if (HotWMod == 2)       {HotWSpellId = 30902;}
+                        else if (HotWMod == 4)  {HotWSpellId = 30903;}
+                        else if (HotWMod == 6)  {HotWSpellId = 30904;}
+                        else if (HotWMod == 8)  {HotWSpellId = 30905;}
+                        else if (HotWMod == 10) {HotWSpellId = 30906;}
+                    }
+                    else
+                    {
+                        if (HotWMod == 2)       {HotWSpellId = 19255;}
+                        else if (HotWMod == 4)  {HotWSpellId = 19256;}
+                        else if (HotWMod == 6)  {HotWSpellId = 19257;}
+                        else if (HotWMod == 8)  {HotWSpellId = 19258;}
+                        else if (HotWMod == 10) {HotWSpellId = 19259;}
+                    }
+                    m_target->RemoveAurasDueToSpell(HotWSpellId);
+                 }
+             }
+        }
         if(spellId1)
             target->RemoveAurasDueToSpell(spellId1);
         if(spellId2)
@@ -6205,6 +6693,12 @@ void Aura::HandleShapeshiftBoosts(bool apply)
             else
                 ++itr;
         }
+        // Improved Barkskin - apply/remove armor bonus due to shapeshift
+        if (((Player*)m_target)->HasSpell(63410) || ((Player*)m_target)->HasSpell(63411))
+        {
+            m_target->RemoveAurasDueToSpell(66530);
+            m_target->CastSpell(m_target,66530,true);
+        }
     }
 }
 
@@ -6223,8 +6717,50 @@ void Aura::HandleSpellSpecificBoosts(bool apply)
             // Illusionary Barrier
             if(GetId() == 57350 && !apply && m_target->getPowerType() == POWER_MANA)
             {
-                cast_at_remove = true;
-                spellId1 = 60242;                           // Darkmoon Card: Illusion
+                // Illusionary Barrier
+                case 57350:
+                {
+                    if(!apply && m_target->getPowerType() == POWER_MANA)
+                    {
+                        cast_at_remove = true;
+                        spellId1 = 60242;                       // Darkmoon Card: Illusion
+                        break;
+                    }
+                }
+                // Encapsulate
+                case 45661:
+                {
+                    spellId1 = 45665;
+                    break;
+                }
+                // Nether Portal - Perseverance
+                case 30421:
+                {
+                    if (apply)
+                        return;
+                    cast_at_remove = true;
+                    spellId1 = 38637;                           // Nether Exhaustion
+                    break;
+                }
+                // Nether Portal - Serenity
+                case 30422:
+                {
+                    if (apply)
+                        return;
+                    cast_at_remove = true;                      // Nether Exhaustion
+                    spellId1 = 38638;
+                    break;
+                }
+                // Nether Portal  - Dominance
+                case 30423:
+                {
+                    if (apply)
+                        return;
+                    cast_at_remove = true;
+                    spellId1 = 38639;                           // Nether Exhaustion
+                    break;
+                }
+                return;
             }
             else
                 return;
@@ -6317,6 +6853,16 @@ void Aura::HandleSpellSpecificBoosts(bool apply)
                 spellId1 = 30069;                           // Blood Frenzy (Rank 1)
                 spellId2 = 30070;                           // Blood Frenzy (Rank 2)
             }
+            else
+            {
+                // Bloodrage & Item - Warrior T10 Protection 4P Bonus
+                if (GetId() == 29131 && m_target->HasAura(70844))
+                {
+                    int32 bp = int32(m_target->GetMaxHealth() * 20 / 100);
+                    m_target->CastCustomSpell(m_target, 70845, &bp, NULL, NULL, true, NULL, this);
+                    return;
+                }
+            }
             break;
         }
         case SPELLFAMILY_WARLOCK:
@@ -6395,6 +6941,7 @@ void Aura::HandleSpellSpecificBoosts(bool apply)
                 }
                 else
                     return;
+                break;
             }
             // Power Word: Shield
             else if (apply && m_spellProto->SpellFamilyFlags & UI64LIT(0x0000000000000001) && m_spellProto->Mechanic == MECHANIC_SHIELD)
@@ -6452,6 +6999,9 @@ void Aura::HandleSpellSpecificBoosts(bool apply)
         }
         case SPELLFAMILY_DRUID:
         {
+            // Item - Druid T10 Feral 4P Bonus
+            if (GetId() == 5229 && m_target->HasAura(70726))// Enrage
+                spellId1 = 70725;
             // Barkskin
             if (GetId()==22812 && m_target->HasAura(63057)) // Glyph of Barkskin
                 spellId1 = 63058;                           // Glyph - Barkskin 01
@@ -6473,8 +7023,16 @@ void Aura::HandleSpellSpecificBoosts(bool apply)
             break;
         case SPELLFAMILY_HUNTER:
         {
+            // The Beast Within and Bestial Wrath - immunity
+            if (GetId() == 19574 || GetId() == 34471)
+            {
+                spellId1 = 24395;
+                spellId2 = 24396;
+                spellId3 = 24397;
+                spellId4 = 26592;
+            }
             // Freezing Trap Effect
-            if (m_spellProto->SpellFamilyFlags & UI64LIT(0x0000000000000008))
+            else if (m_spellProto->SpellFamilyFlags & UI64LIT(0x0000000000000008))
             {
                 if(!apply)
                 {
@@ -6506,6 +7064,28 @@ void Aura::HandleSpellSpecificBoosts(bool apply)
         }
         case SPELLFAMILY_PALADIN:
         {
+            if (m_spellProto->Id == 19746)                  // Aura Mastery (on Concentration Aura remove and apply)
+            {
+                Unit *caster = GetCaster();
+                if (!caster)
+                    return;
+
+                if (apply && caster->HasAura(31821))
+                    caster->CastSpell(caster, 64364, true, NULL, this);
+                else if (!apply)
+                    caster->RemoveAurasDueToSpell(64364);
+            }
+            if (m_spellProto->Id == 31821)                  // Aura Mastery (on Aura Mastery original buff remove)
+            {
+                Unit *caster = GetCaster();
+                if (!caster)
+                    return;
+
+                if (apply && caster->HasAura(19746))
+                    caster->CastSpell(caster, 64364, true, NULL, this);
+                else if (!apply)
+                    caster->RemoveAurasDueToSpell(64364);
+            }
             if (m_spellProto->Id == 31884)                  // Avenging Wrath
             {
                 if(!apply)
@@ -6786,9 +7366,6 @@ void Aura::HandleAuraUntrackable(bool apply, bool /*Real*/)
 
 void Aura::HandleAuraModPacify(bool apply, bool /*Real*/)
 {
-    if(GetTarget()->GetTypeId() != TYPEID_PLAYER)
-        return;
-
     if(apply)
         GetTarget()->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED);
     else
@@ -6825,9 +7402,15 @@ void Aura::HandleAuraAllowFlight(bool apply, bool Real)
     // allow fly
     WorldPacket data;
     if(apply)
+    {
+        ((Player*)m_target)->SetCanFly(true);
         data.Initialize(SMSG_MOVE_SET_CAN_FLY, 12);
+    }
     else
+    {
         data.Initialize(SMSG_MOVE_UNSET_CAN_FLY, 12);
+        ((Player*)m_target)->SetCanFly(false);
+    }
     data << GetTarget()->GetPackGUID();
     data << uint32(0);                                      // unk
     GetTarget()->SendMessageToSet(&data, true);
@@ -6863,7 +7446,7 @@ void Aura::HandleModRatingFromStat(bool apply, bool Real)
 
 void Aura::HandleForceMoveForward(bool apply, bool Real)
 {
-    if(!Real || GetTarget()->GetTypeId() != TYPEID_PLAYER)
+    if(!Real)
         return;
     if(apply)
         GetTarget()->SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FORCE_MOVE);
@@ -7051,6 +7634,9 @@ void Aura::HandleSchoolAbsorb(bool apply, bool Real)
                     break;
             }
 
+            if(Player* modOwner = caster->GetSpellModOwner())
+                modOwner->ApplySpellMod(m_spellProto->Id, SPELLMOD_ALL_EFFECTS, DoneActualBenefit);
+
             DoneActualBenefit *= caster->CalculateLevelPenalty(GetSpellProto());
 
             m_modifier.m_amount += (int32)DoneActualBenefit;
@@ -7194,42 +7780,54 @@ void Aura::PeriodicTick()
             uint32 pdamage;
 
             if(m_modifier.m_auraname == SPELL_AURA_PERIODIC_DAMAGE)
+            {
                 pdamage = amount;
-            else
-                pdamage = uint32(target->GetMaxHealth()*amount/100);
-
+                // Burn - SWP Brutallus
+                if (m_spellProto->Id == 46394)
+                {
+                    uint32 ticks = GetAuraTicks();
+                    uint32 threashold[] = {10,21,32,43,54};
+                    for (uint8 i = 0; i<5; i++)
+                        if (ticks > threashold[i])
+                            pdamage *=2;
+                        else
+                            break;
+                }
 
-            // SpellDamageBonus for magic spells
-            if(spellProto->DmgClass == SPELL_DAMAGE_CLASS_NONE || spellProto->DmgClass == SPELL_DAMAGE_CLASS_MAGIC)
-                pdamage = target->SpellDamageBonusTaken(pCaster, spellProto, pdamage, DOT, GetStackAmount());
-            // MeleeDamagebonus for weapon based spells
-            else
-            {
-                WeaponAttackType attackType = GetWeaponAttackType(spellProto);
-                pdamage = target->MeleeDamageBonusTaken(pCaster, pdamage, attackType, spellProto, DOT, GetStackAmount());
-            }
+                // SpellDamageBonus for magic spells
+                if(spellProto->DmgClass == SPELL_DAMAGE_CLASS_NONE || spellProto->DmgClass == SPELL_DAMAGE_CLASS_MAGIC)
+                    pdamage = target->SpellDamageBonusTaken(pCaster, spellProto, pdamage, DOT, GetStackAmount());
+                // MeleeDamagebonus for weapon based spells
+                else
+                {
+                    WeaponAttackType attackType = GetWeaponAttackType(spellProto);
+                    pdamage = target->MeleeDamageBonusTaken(pCaster, pdamage, attackType, spellProto, DOT, GetStackAmount());
+                }
 
-            // Calculate armor mitigation if it is a physical spell
-            // But not for bleed mechanic spells
-            if (GetSpellSchoolMask(spellProto) & SPELL_SCHOOL_MASK_NORMAL &&
-                GetEffectMechanic(spellProto, m_effIndex) != MECHANIC_BLEED)
-            {
-                uint32 pdamageReductedArmor = pCaster->CalcArmorReducedDamage(target, pdamage);
-                cleanDamage.damage += pdamage - pdamageReductedArmor;
-                pdamage = pdamageReductedArmor;
-            }
+                // Calculate armor mitigation if it is a physical spell
+                // But not for bleed mechanic spells
+                if (GetSpellSchoolMask(spellProto) & SPELL_SCHOOL_MASK_NORMAL &&
+                    GetEffectMechanic(spellProto, m_effIndex) != MECHANIC_BLEED)
+                {
+                    uint32 pdamageReductedArmor = pCaster->CalcArmorReducedDamage(target, pdamage);
+                    cleanDamage.damage += pdamage - pdamageReductedArmor;
+                    pdamage = pdamageReductedArmor;
+                }
 
-            // Curse of Agony damage-per-tick calculation
-            if (spellProto->SpellFamilyName==SPELLFAMILY_WARLOCK && (spellProto->SpellFamilyFlags & UI64LIT(0x0000000000000400)) && spellProto->SpellIconID==544)
-            {
-                // 1..4 ticks, 1/2 from normal tick damage
-                if (GetAuraTicks() <= 4)
-                    pdamage = pdamage/2;
-                // 9..12 ticks, 3/2 from normal tick damage
-                else if(GetAuraTicks() >= 9)
-                    pdamage += (pdamage + 1) / 2;       // +1 prevent 0.5 damage possible lost at 1..4 ticks
-                // 5..8 ticks have normal tick damage
+                // Curse of Agony damage-per-tick calculation
+                if (spellProto->SpellFamilyName==SPELLFAMILY_WARLOCK && (spellProto->SpellFamilyFlags & UI64LIT(0x0000000000000400)) && spellProto->SpellIconID==544)
+                {
+                    // 1..4 ticks, 1/2 from normal tick damage
+                    if (GetAuraTicks() <= 4)
+                        pdamage = pdamage/2;
+                    // 9..12 ticks, 3/2 from normal tick damage
+                    else if(GetAuraTicks() >= 9)
+                        pdamage += (pdamage + 1) / 2;       // +1 prevent 0.5 damage possible lost at 1..4 ticks
+                    // 5..8 ticks have normal tick damage
+                }
             }
+            else
+                pdamage = uint32(target->GetMaxHealth()*amount/100);
 
             // This method can modify pdamage
             bool isCrit = IsCritFromAbilityAura(pCaster, pdamage);
@@ -7311,16 +7909,29 @@ void Aura::PeriodicTick()
 
             uint32 pdamage = m_modifier.m_amount > 0 ? m_modifier.m_amount : 0;
 
-            //Calculate armor mitigation if it is a physical spell
-            if (GetSpellSchoolMask(spellProto) & SPELL_SCHOOL_MASK_NORMAL)
+            // Calculate armor mitigation if it is a physical spell
+            // But not for bleed mechanic spells
+            if (GetSpellSchoolMask(spellProto) & SPELL_SCHOOL_MASK_NORMAL &&
+                GetEffectMechanic(spellProto, m_effIndex) != MECHANIC_BLEED)
             {
                 uint32 pdamageReductedArmor = pCaster->CalcArmorReducedDamage(target, pdamage);
                 cleanDamage.damage += pdamage - pdamageReductedArmor;
                 pdamage = pdamageReductedArmor;
             }
 
-            pdamage = target->SpellDamageBonusTaken(pCaster, spellProto, pdamage, DOT, GetStackAmount());
+            // Curse of Agony damage-per-tick calculation
+            if (spellProto->SpellFamilyName==SPELLFAMILY_WARLOCK && (spellProto->SpellFamilyFlags & UI64LIT(0x0000000000000400)) && spellProto->SpellIconID==544)
+            {
+                // 1..4 ticks, 1/2 from normal tick damage
+                if (GetAuraTicks() <= 4)
+                    pdamage = pdamage/2;
+                // 9..12 ticks, 3/2 from normal tick damage
+                else if(GetAuraTicks() >= 9)
+                    pdamage += (pdamage + 1) / 2; // +1 prevent 0.5 damage possible lost at 1..4 ticks
+                // 5..8 ticks have normal tick damage
+            }
 
+            // This method can modify pdamage
             bool isCrit = IsCritFromAbilityAura(pCaster, pdamage);
 
             // send critical in hit info for threat calculation
@@ -7425,8 +8036,12 @@ void Aura::PeriodicTick()
             DETAIL_FILTER_LOG(LOG_FILTER_PERIODIC_AFFECTS, "PeriodicTick: %u (TypeId: %u) heal of %u (TypeId: %u) for %u health inflicted by %u",
                 GUID_LOPART(GetCasterGUID()), GuidHigh2TypeId(GUID_HIPART(GetCasterGUID())), target->GetGUIDLow(), target->GetTypeId(), pdamage, GetId());
 
+            // calculate heal absorb and reduce healing
+            uint32 absorb = 0;
+            pCaster->CalculateHealAbsorb(target, GetSpellProto(), pdamage, absorb);
+
             int32 gain = target->ModifyHealth(pdamage);
-            SpellPeriodicAuraLogInfo pInfo(this, pdamage, (pdamage - uint32(gain)), 0, 0, 0.0f, isCrit);
+            SpellPeriodicAuraLogInfo pInfo(this, pdamage, (pdamage - uint32(gain)), absorb, 0, 0.0f, isCrit);
             target->SendPeriodicAuraLog(&pInfo);
 
             // Set trigger flag
@@ -7986,6 +8601,40 @@ void Aura::PeriodicDummyTick()
                         case 2: target->CastSpell(target, 55739, true); break;
                     }
                     return;
+                case 63276:
+                {
+                    Unit* caster = GetCaster();
+                    if(!caster)
+                        return;
+
+                    int32 bp1 = m_spellProto->CalculateSimpleValue(EFFECT_INDEX_0);
+                    caster->CastCustomSpell(m_target, 63278, 0, &bp1, 0, true);
+                    return;
+                }
+                case 66118:                                 // Leeching Swarm 10 man
+                case 68646:
+                {
+                    int32 damage = (m_modifier.m_amount * m_target->GetHealth()) / 100;
+                    if (damage < 250)
+                        damage = 250;
+                    int32 heal = damage * 68 / 100;
+                    m_target->CastCustomSpell(m_target, 66240, &damage, NULL, NULL, true, NULL, this);
+                    if (Unit* caster = GetCaster())
+                        m_target->CastCustomSpell(caster, 66125, &heal, NULL, NULL, true, NULL, this);
+                    return;
+                }
+                case 67630:                                 // Leeching Swarm 25 man
+                case 68647:
+                {
+                    int32 damage = (m_modifier.m_amount * m_target->GetHealth()) / 100;
+                    if (damage < 250)
+                        damage = 250;
+                    int32 heal = damage * 155 / 100;
+                    m_target->CastCustomSpell(m_target, 66240, &damage, NULL, NULL, true, NULL, this);
+                    if (Unit* caster = GetCaster())
+                        m_target->CastCustomSpell(caster, 66125, &heal, NULL, NULL, true, NULL, this);
+                    return;
+                }
 // Exist more after, need add later
                 default:
                     break;
@@ -8009,8 +8658,18 @@ void Aura::PeriodicDummyTick()
         case SPELLFAMILY_MAGE:
         {
             // Mirror Image
-//            if (spell->Id == 55342)
-//                return;
+            if (spell->Id == 55342)
+            {
+                if(m_target->GetTypeId() != TYPEID_PLAYER)
+                    break;
+                //Clear target
+                WorldPacket data(SMSG_CLEAR_TARGET, 8);
+                data << m_target->GetGUID();
+                ((Player*)m_target)->SendMessageToSetInRange(&data, 80.0f, false, false, true);
+                // Set name of summons to name of caster
+                m_target->CastSpell(m_target, m_spellProto->EffectTriggerSpell[m_effIndex], true);
+                m_isPeriodic = false;
+            }
             break;
         }
         case SPELLFAMILY_DRUID:
@@ -8043,6 +8702,25 @@ void Aura::PeriodicDummyTick()
             }
             break;
         }
+        case SPELLFAMILY_WARLOCK:
+            switch (spell->Id)
+            {
+                case 48018:
+                    GameObject* obj = m_target->GetGameObject(spell->Id);
+                    if (!obj)
+                    {
+                         m_target->RemoveAurasDueToSpell(spell->Id);
+                         m_target->RemoveAurasDueToSpell(62388); 
+                         return;
+                    }
+                    // We must take a range of teleport spell, not summon.
+                    const SpellEntry* goToCircleSpell = sSpellStore.LookupEntry(48020);
+                    if (m_target->IsWithinDist(obj,GetSpellMaxRange(sSpellRangeStore.LookupEntry(goToCircleSpell->rangeIndex))))
+                        m_target->CastSpell(m_target, 62388, true);
+                    else
+                        m_target->RemoveAurasDueToSpell(62388);
+            }
+            break;
         case SPELLFAMILY_ROGUE:
         {
             switch (spell->Id)
@@ -8145,6 +8823,14 @@ void Aura::PeriodicDummyTick()
                 }
                 return;
             }
+            // Hysteria
+            if (spell->SpellFamilyFlags & UI64LIT(0x0000000020000000))
+            {
+                uint32 deal = m_modifier.m_amount * m_target->GetMaxHealth() / 100;
+                m_target->DealDamage(m_target, deal, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                m_target->SendSpellNonMeleeDamageLog(m_target, spell->Id, deal, SPELL_SCHOOL_MASK_NORMAL, 0, 0, false, 0, false);
+                return;
+            }
             // Summon Gargoyle
 //            if (spell->SpellFamilyFlags & UI64LIT(0x0000008000000000))
 //                return;
@@ -8166,6 +8852,13 @@ void Aura::PeriodicDummyTick()
             // Blood of the North
 //            if (spell->SpellIconID == 30412)
 //                return;
+            // Hysteria
+            if (spell->SpellFamilyFlags & UI64LIT(0x0000000020000000))
+            {
+                uint32 deal = m_modifier.m_amount * m_target->GetMaxHealth() / 100;
+                m_target->DealDamage(m_target, deal, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                return;
+            }
             break;
         }
         default:
@@ -8238,28 +8931,37 @@ void Aura::HandleArenaPreparation(bool apply, bool Real)
  */
 void Aura::HandleAuraControlVehicle(bool apply, bool Real)
 {
-    if(!Real)
-        return;
+     if(!Real)
+         return;
 
-    Unit *player = GetCaster();
+    Unit *caster = GetCaster();
     Vehicle *vehicle = dynamic_cast<Vehicle*>(GetTarget());
-    if(!player || player->GetTypeId() != TYPEID_PLAYER || !vehicle)
+    if(!caster || !vehicle)
+        return;
+
+    // this can happen due to wrong caster/target spell handling
+    // note : SPELL_AURA_CONTROL_VEHICLE can have EffectImplicitTargetA
+    // TARGET_SCRIPT, TARGET_DUELVSPLAYER.. etc
+    if(caster->GetGUID() == vehicle->GetGUID())
         return;
 
     if (apply)
     {
-        if(Pet *pet = player->GetPet())
-            pet->Remove(PET_SAVE_AS_CURRENT);
-        ((Player*)player)->EnterVehicle(vehicle);
+        if(caster->GetTypeId() == TYPEID_PLAYER)
+        {
+            WorldPacket data(SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA, 0);
+            ((Player*)caster)->GetSession()->SendPacket(&data);
+        }
+        // if we leave and enter again, this will refresh
+        int32 duration = GetSpellMaxDuration(GetSpellProto());
+        if(duration > 0)
+            vehicle->SetSpawnDuration(duration);
     }
     else
     {
-        SpellEntry const *spell = GetSpellProto();
-
         // some SPELL_AURA_CONTROL_VEHICLE auras have a dummy effect on the player - remove them
-        player->RemoveAurasDueToSpell(spell->Id);
-
-        ((Player*)player)->ExitVehicle(vehicle);
+        caster->RemoveAurasDueToSpell(GetId());
+        caster->RemoveSingleSpellAurasFromStack(53797);
     }
 }
 
@@ -8356,6 +9058,13 @@ void Aura::HandlePhase(bool apply, bool Real)
                 }
             }
         }
+          
+    if(m_target->GetCharm() && !apply)//remove other auras from charm on unapply
+    {
+        Creature * creat=((Creature*)m_target->GetCharm());						
+        creat->GetMap()->CreatureRelocation(creat,m_target->GetPositionX(),m_target->GetPositionY(),m_target->GetPositionZ(),m_target->GetOrientation());
+        creat->RemoveAurasDueToSpellByCancel(GetId());			
+    } 
     }
     else
         target->SetPhaseMask(apply ? GetMiscValue() : PHASEMASK_NORMAL, false);
@@ -8365,6 +9074,16 @@ void Aura::HandlePhase(bool apply, bool Real)
         target->SetVisibility(target->GetVisibility());
 }
 
+void Aura::HandleIgnoreUnitState(bool apply, bool Real)
+{
+    if(m_target->GetTypeId() != TYPEID_PLAYER || !Real)
+        return;
+
+    // for alowing charge/intercept/intervene in different stances
+    if (GetId() == 57499 && apply)
+        SetAuraFlags(19);
+}
+
 void Aura::UnregisterSingleCastAura()
 {
     if (IsSingleTarget())
@@ -8376,7 +9095,7 @@ void Aura::UnregisterSingleCastAura()
         else
         {
             sLog.outError("Couldn't find the caster of the single target aura (SpellId %u), may crash later!", GetId());
-            ASSERT(false);
+            //ASSERT(false);
         }
         m_isSingleTargetAura = false;
     }
@@ -8393,14 +9112,41 @@ void Aura::HandleAuraSafeFall( bool Apply, bool Real )
 
 bool Aura::IsCritFromAbilityAura(Unit* caster, uint32& damage)
 {
+    bool bCanCrit = false;
+
+    switch(m_spellProto->SpellFamilyName)
+    {
+        case SPELLFAMILY_WARLOCK:
+            // Immolate
+            if (m_spellProto->SpellFamilyFlags & UI64LIT(0x0000000000000004))
+                bCanCrit = true;
+            break;
+
+        case SPELLFAMILY_ROGUE:
+            // Rupture
+            if (m_spellProto->SpellFamilyFlags & UI64LIT(0x0000000000100000))
+                bCanCrit = true;
+            break;
+
+        case SPELLFAMILY_SHAMAN:
+            // Flame Shock
+            if (m_spellProto->SpellFamilyFlags & UI64LIT(0x0000000010000000))
+                bCanCrit = true;
+            break;
+
+            default:  break;
+    }
+
     Unit::AuraList const& auras = caster->GetAurasByType(SPELL_AURA_ABILITY_PERIODIC_CRIT);
     for(Unit::AuraList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
     {
         if (!(*itr)->isAffectedOnSpell(GetSpellProto()))
             continue;
-        if (!caster->IsSpellCrit(GetTarget(), GetSpellProto(), GetSpellSchoolMask(GetSpellProto())))
-            break;
+        bCanCrit = true;
+    }
 
+    if (bCanCrit && caster->IsSpellCrit(GetTarget(), GetSpellProto(), GetSpellSchoolMask(GetSpellProto())))
+    {
         damage = caster->SpellCriticalDamageBonus(GetSpellProto(), damage, GetTarget());
         return true;
     }
@@ -8434,6 +9180,39 @@ void Aura::HandleAuraModAllCritChance(bool apply, bool Real)
     ((Player*)target)->UpdateAllSpellCritChances();
 }
 
+void Aura::HandleAuraLinked(bool apply, bool Real)
+{
+    if (!Real)
+        return;
+
+    uint32 linkedSpell = m_spellProto->EffectTriggerSpell[m_effIndex];
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(linkedSpell);
+    if (!spellInfo)
+    {
+        sLog.outError("HandleAuraLinked for spell %u effect %u: triggering unknown spell %u", m_spellProto->Id, m_effIndex, linkedSpell);
+        return;
+    }
+
+    if (apply)
+        m_target->CastSpell(m_target, linkedSpell, true, NULL, this);
+    else
+        m_target->RemoveAurasByCasterSpell(linkedSpell, GetCasterGUID());
+}
+
+void Aura::HandleAuraOpenStable(bool apply, bool Real)
+{
+    if(!apply || !Real)
+        return;
+
+    Unit* caster = GetCaster();
+    if(!caster || !caster->IsInWorld() || caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    WorldPacket data;
+    data << uint64(caster->GetGUID());
+    ((Player*)caster)->GetSession()->HandleListStabledPetsOpcode(data);
+}
+
 void Aura::HandleAllowOnlyAbility(bool apply, bool Real)
 {
     if(!Real)
@@ -8457,18 +9236,78 @@ void Aura::HandleAllowOnlyAbility(bool apply, bool Real)
     target->UpdateDamagePhysical(BASE_ATTACK);
     target->UpdateDamagePhysical(RANGED_ATTACK);
     target->UpdateDamagePhysical(OFF_ATTACK);
+
 }
 
-void Aura::SetAuraMaxDuration( int32 duration )
+void Aura::HandleAuraInitializeImages(bool Apply, bool Real)
 {
-    m_maxduration = duration;
+    if (!Real || !Apply || !m_target || m_target->GetTypeId() != TYPEID_UNIT)
+        return;
+    Unit* caster = GetCaster();
+    Unit* creator = Unit::GetUnit(*m_target,m_target->GetCreatorGUID());
+    Creature* pImmage = (Creature*)m_target;
+    if (!creator || !caster || creator != caster || pImmage->isPet())
+        return;
+
+    // set stats and visual
+    pImmage->SetDisplayId(creator->GetDisplayId());
+    //pImmage->SetLevel(creator->getLevel());
+    pImmage->SetMaxHealth(creator->GetMaxHealth()/5);
+    pImmage->SetHealth(creator->GetHealth()/2);
+    pImmage->SetMaxPower(POWER_MANA, creator->GetMaxPower(POWER_MANA));
+    pImmage->SetPower(POWER_MANA, creator->GetPower(POWER_MANA));
+    pImmage->setFaction(creator->getFaction());
+    pImmage->SetUInt32Value(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_MIRROR_IMAGE | UNIT_FLAG2_REGENERATE_POWER);
+    if (creator->IsPvP())
+        pImmage->SetPvP(true);
     
-    // possible overwrite persistent state
-    if (duration > 0)
-    {
-        if (!(m_isPassive && m_spellProto->DurationIndex == 0))
-            m_permanent = false;
+    if (creator->isInCombat() && pImmage->isAlive())
+        pImmage->CastSpell(pImmage, 58838, true);
+    else
+   {
+       pImmage->GetMotionMaster()->Clear();
+       pImmage->GetMotionMaster()->MoveFollow(creator, pImmage->GetDistance(creator), pImmage->GetAngle(creator));
+   }
+}
+
+void Aura::HandleAuraCloneCaster(bool Apply, bool Real)
+{
+    if (!Real || !Apply)
+        return;
+
+    Unit * caster = GetCaster();
+    if (!caster)
+        return;
+
+    // Set item visual
+    m_target->SetDisplayId(caster->GetDisplayId());
+    m_target->SetUInt32Value(UNIT_FIELD_FLAGS_2, 2064);
+}
+
+void Aura::ApplyHasteToPeriodic()
+{
+    int32 periodic = m_modifier.periodictime;
+    int32 duration = m_origDuration;
+    if(duration == 0 || periodic == 0)
+        return;
 
-        m_auraFlags |= AFLAG_DURATION;
+    int32 ticks = duration / periodic;
+
+    if(!GetCaster())
+        return;
+
+    Player* modOwner = GetCaster()->GetSpellModOwner();
+
+    if(modOwner)
+        modOwner->ApplySpellMod(GetId(), SPELLMOD_ACTIVATION_TIME, periodic);
+
+    if( !(GetSpellProto()->Attributes & (SPELL_ATTR_UNK4|SPELL_ATTR_TRADESPELL)) )
+        duration = int32(duration * GetCaster()->GetFloatValue(UNIT_MOD_CAST_SPEED));
+
+    if(m_origDuration != duration)
+    {
+        periodic = int32(periodic * GetCaster()->GetFloatValue(UNIT_MOD_CAST_SPEED));
+        m_maxduration = periodic * ticks;
     }
-}
\ No newline at end of file
+    m_modifier.periodictime = periodic;
+}
diff --git a/mangos/src/game/SpellAuras.h b/Core/src/game/SpellAuras.h
index 89918a8..f31b1d9 100644
--- a/mangos/src/game/SpellAuras.h
+++ b/Core/src/game/SpellAuras.h
@@ -217,9 +217,14 @@ class MANGOS_DLL_SPEC Aura
         void HandleAuraIncreaseBaseHealthPercent(bool Apply, bool Real);
         void HandleNoReagentUseAura(bool Apply, bool Real);
         void HandlePhase(bool Apply, bool Real);
+        void HandleIgnoreUnitState(bool Apply, bool Real);
         void HandleModTargetArmorPct(bool Apply, bool Real);
         void HandleAuraModAllCritChance(bool Apply, bool Real);
+        void HandleAuraLinked(bool Apply, bool Real);
+        void HandleAuraOpenStable(bool apply, bool Real);
         void HandleAllowOnlyAbility(bool Apply, bool Real);
+        void HandleAuraInitializeImages(bool Apply, bool Real);
+        void HandleAuraCloneCaster(bool Apply, bool Real);
 
         virtual ~Aura();
 
@@ -236,7 +241,9 @@ class MANGOS_DLL_SPEC Aura
         int32 GetBasePoints() const { return m_currentBasePoints; }
 
         int32 GetAuraMaxDuration() const { return m_maxduration; }
-        void SetAuraMaxDuration(int32 duration);
+        void SetAuraMaxDuration(int32 duration) { m_maxduration = duration; }
+        int32 GetAuraOrigDuration() const { return m_origDuration; }
+        void SetAuraOrigDuration(int32 duration) { m_origDuration = duration; }
         int32 GetAuraDuration() const { return m_duration; }
         void SetAuraDuration(int32 duration) { m_duration = duration; }
         time_t GetAuraApplyTime() const { return m_applyTime; }
@@ -251,8 +258,8 @@ class MANGOS_DLL_SPEC Aura
         {
             m_caster_guid = caster_guid;
             m_modifier.m_amount = damage;
-            SetAuraMaxDuration(maxduration);
-            SetAuraDuration(duration);
+            m_maxduration = maxduration;
+            m_duration = duration;
             m_procCharges = charges;
 
             if(uint32 maxticks = GetAuraMaxTicks())
@@ -293,6 +300,7 @@ class MANGOS_DLL_SPEC Aura
 
         void SetAura(bool remove) { m_target->SetVisibleAura(m_auraSlot, remove ? 0 : GetId()); }
         void SendAuraUpdate(bool remove);
+        void SendFakeAuraUpdate(uint32 auraId, bool remove);
 
         uint8 GetStackAmount() {return m_stackAmount;}
         void SetStackAmount(uint8 num);
@@ -350,6 +358,8 @@ class MANGOS_DLL_SPEC Aura
         uint32 const *getAuraSpellClassMask() const { return  m_spellProto->GetEffectSpellClassMask(m_effIndex); }
         bool isAffectedOnSpell(SpellEntry const *spell) const;
         bool isWeaponBuffCoexistableWith(Aura* ref);
+
+        void ApplyHasteToPeriodic();
     protected:
         Aura(SpellEntry const* spellproto, SpellEffectIndex eff, int32 *currentBasePoints, Unit *target, Unit *caster = NULL, Item* castItem = NULL);
 
@@ -378,6 +388,7 @@ class MANGOS_DLL_SPEC Aura
         int32 m_timeCla;                                    // Timer for power per sec calcultion
         int32 m_periodicTimer;                              // Timer for periodic auras
         uint32 m_periodicTick;                              // Tick count pass (including current if use in tick code) from aura apply, used for some tick count dependent aura effects
+        uint32 m_origDuration;                              // Duration before applying haste, etc...
 
         AuraRemoveMode m_removeMode:8;                      // Store info for know remove aura reason
         DiminishingGroup m_AuraDRGroup:8;                   // Diminishing
diff --git a/Core/src/game/SpellDBCHacks.cpp b/Core/src/game/SpellDBCHacks.cpp
new file mode 100644
index 0000000..da58a37
--- /dev/null
+++ b/Core/src/game/SpellDBCHacks.cpp
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2005-2010 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "Unit.h"
+#include "SpellMgr.h"
+#include "SharedDefines.h"
+#include "DBCStores.h"
+#include "SpellAuraDefines.h"
+
+void SpellMgr::ApplySpellHacks()
+{
+    //Shaman totem bar hack-fix
+    SpellEntry *sfix1 = const_cast<SpellEntry*>(sSpellStore.LookupEntry(66842));
+    sfix1->EffectImplicitTargetA[0] = TARGET_SELF;
+    SpellEntry *sfix2 = const_cast<SpellEntry*>(sSpellStore.LookupEntry(66843));
+    sfix2->EffectImplicitTargetA[0] = TARGET_SELF;
+    SpellEntry *sfix3 = const_cast<SpellEntry*>(sSpellStore.LookupEntry(66844));
+    sfix3->EffectImplicitTargetA[0] = TARGET_SELF;
+
+    //Surge of power spells should be longer
+    SpellEntry *sfix4 = const_cast<SpellEntry*>(sSpellStore.LookupEntry(57407));
+    sfix4->DurationIndex = 28;
+    SpellEntry *sfix5 = const_cast<SpellEntry*>(sSpellStore.LookupEntry(60936));
+    sfix5->DurationIndex = 28;
+
+    //Lifebloom final heal
+    SpellEntry *sfix6 = const_cast<SpellEntry*>(sSpellStore.LookupEntry(33778));
+    sfix6->DmgClass = SPELL_DAMAGE_CLASS_MAGIC;
+
+    //Spirit of Redemption has AURA_INTERRUPT_FLAG_CAST, what the...? Maybe blizz changed this flag
+    SpellEntry *sfix7 = const_cast<SpellEntry*>(sSpellStore.LookupEntry(27827));
+    sfix7->AuraInterruptFlags = 0;
+
+    //Twilight Torment - relly dunno what blizzard intended to do
+    SpellEntry *sfix8 = const_cast<SpellEntry*>(sSpellStore.LookupEntry(57935));
+    sfix8->AttributesEx = 0;
+    sfix8->AttributesEx4 = SPELL_ATTR_EX4_NOT_STEALABLE;
+    sfix8->CastingTimeIndex = 1;
+    sfix8->RecoveryTime = 0;
+    sfix8->procFlags = (PROC_FLAG_TAKEN_MELEE_HIT | PROC_FLAG_TAKEN_MELEE_SPELL_HIT | PROC_FLAG_TAKEN_RANGED_HIT | PROC_FLAG_TAKEN_RANGED_SPELL_HIT | PROC_FLAG_TAKEN_NEGATIVE_SPELL_HIT);
+    sfix8->procChance = 100;
+    sfix8->procCharges = 0;
+    sfix8->rangeIndex = 1;
+    sfix8->StackAmount = 0;
+    sfix8->Effect[EFFECT_INDEX_1] = 0;
+    sfix8->EffectDieSides[EFFECT_INDEX_1] = 0;
+    sfix8->EffectBasePoints[EFFECT_INDEX_0] = -1;
+    sfix8->EffectImplicitTargetA[EFFECT_INDEX_0] = 6;
+    sfix8->EffectImplicitTargetA[EFFECT_INDEX_1] = 0;
+    sfix8->EffectImplicitTargetB[EFFECT_INDEX_0] = 0;
+    sfix8->EffectImplicitTargetB[EFFECT_INDEX_1] = 0;
+    sfix8->EffectRadiusIndex[EFFECT_INDEX_0] = 0;
+    sfix8->EffectRadiusIndex[EFFECT_INDEX_1] = 0;
+    sfix8->EffectApplyAuraName[EFFECT_INDEX_0] = SPELL_AURA_PROC_TRIGGER_SPELL;
+    sfix8->EffectApplyAuraName[EFFECT_INDEX_1] = 0;
+    sfix8->EffectAmplitude[EFFECT_INDEX_0] = 0;
+    sfix8->EffectAmplitude[EFFECT_INDEX_1] = 0;
+    sfix8->EffectMiscValue[EFFECT_INDEX_0] = 0;
+    sfix8->EffectMiscValue[EFFECT_INDEX_1] = 0;
+    sfix8->EffectMiscValueB[EFFECT_INDEX_0] = 0;
+    sfix8->EffectMiscValueB[EFFECT_INDEX_1] = 0;
+    sfix8->EffectTriggerSpell[EFFECT_INDEX_0] = 57988;
+    sfix8->EffectTriggerSpell[EFFECT_INDEX_1] = 0;
+}
diff --git a/mangos/src/game/SpellEffects.cpp b/Core/src/game/SpellEffects.cpp
index f0c6fcf..e4812cc 100644
--- a/mangos/src/game/SpellEffects.cpp
+++ b/Core/src/game/SpellEffects.cpp
@@ -46,6 +46,7 @@
 #include "BattleGround.h"
 #include "BattleGroundEY.h"
 #include "BattleGroundWS.h"
+#include "OutdoorPvPMgr.h"
 #include "VMapFactory.h"
 #include "Language.h"
 #include "SocialMgr.h"
@@ -54,9 +55,12 @@
 #include "ScriptCalls.h"
 #include "SkillDiscovery.h"
 #include "Formulas.h"
+#include "Vehicle.h"
 #include "GridNotifiers.h"
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
+#include "Item.h"
+#include "ItemPrototype.h"
 
 pEffect SpellEffects[TOTAL_SPELL_EFFECTS]=
 {
@@ -147,9 +151,9 @@ pEffect SpellEffects[TOTAL_SPELL_EFFECTS]=
     &Spell::EffectStuck,                                    // 84 SPELL_EFFECT_STUCK
     &Spell::EffectSummonPlayer,                             // 85 SPELL_EFFECT_SUMMON_PLAYER
     &Spell::EffectActivateObject,                           // 86 SPELL_EFFECT_ACTIVATE_OBJECT
-    &Spell::EffectNULL,                                     // 87 SPELL_EFFECT_WMO_DAMAGE (57 spells in 3.3.2)
-    &Spell::EffectNULL,                                     // 88 SPELL_EFFECT_WMO_REPAIR (2 spells in 3.3.2)
-    &Spell::EffectNULL,                                     // 89 SPELL_EFFECT_WMO_CHANGE (7 spells in 3.3.2)
+    &Spell::EffectWMODamage,                                // 87 SPELL_EFFECT_WMO_DAMAGE
+    &Spell::EffectWMORepair,                                // 88 SPELL_EFFECT_WMO_REPAIR
+    &Spell::EffectUnused,                                   // 89 SPELL_EFFECT_WMO_CHANGE
     &Spell::EffectKillCreditPersonal,                       // 90 SPELL_EFFECT_KILL_CREDIT              Kill credit but only for single person
     &Spell::EffectUnused,                                   // 91 SPELL_EFFECT_THREAT_ALL               one spell: zzOLDBrainwash
     &Spell::EffectEnchantHeldItem,                          // 92 SPELL_EFFECT_ENCHANT_HELD_ITEM
@@ -269,6 +273,30 @@ void Spell::EffectInstaKill(SpellEffectIndex /*eff_idx*/)
     if( !unitTarget || !unitTarget->isAlive() )
         return;
 
+    // Gift that keeps on Giving shouldn't kill players
+    if(m_spellInfo->Id==52479 && unitTarget->GetTypeId()==TYPEID_PLAYER)
+        return;
+
+    // Demonic Sacrifice
+    if(m_spellInfo->Id==18788 && unitTarget->GetTypeId()==TYPEID_UNIT)
+    {
+        uint32 entry = unitTarget->GetEntry();
+        uint32 spellID;
+        switch(entry)
+        {
+            case   416: spellID=18789; break;               //imp
+            case   417: spellID=18792; break;               //fellhunter
+            case  1860: spellID=18790; break;               //void
+            case  1863: spellID=18791; break;               //succubus
+            case 17252: spellID=35701; break;               //fellguard
+            default:
+                sLog.outError("EffectInstaKill: Unhandled creature entry (%u) case.", entry);
+                return;
+        }
+
+        m_caster->CastSpell(m_caster, spellID, true);
+    }
+
     if(m_caster == unitTarget)                              // prevent interrupt message
         finish();
 
@@ -318,13 +346,22 @@ void Spell::EffectSchoolDMG(SpellEffectIndex effect_idx)
                     case 72624: case 72625:                 // Ooze Eruption
                     {
                         uint32 count = 0;
-                        for(std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin();ihit != m_UniqueTargetInfo.end();++ihit)
+                        for(tbb::concurrent_vector<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin();ihit != m_UniqueTargetInfo.end();++ihit)
                             if(ihit->effectMask & (1<<effect_idx))
                                 ++count;
 
                         damage /= count;                    // divide to all targets
                         break;
                     }
+                    // AoE spells, which damage is reduced with distance from the initial hit point 
+                    case 62598: case 62937:     // Detonate 
+                    case 65279:                 // Lightning Nova 
+                    case 62311: case 64596:     // Cosmic Smash 
+                    { 
+                        float distance = unitTarget->GetDistance2d(m_targets.m_destX, m_targets.m_destY); 
+                        damage *= exp(-distance/15.0f); 
+                        break; 
+                    }
                     // percent from health with min
                     case 25599:                             // Thundercrash
                     {
@@ -354,6 +391,17 @@ void Spell::EffectSchoolDMG(SpellEffectIndex effect_idx)
                         damage = unitTarget->GetMaxHealth() / 2;
                         break;
                     }
+                    // Explode
+                    case 47496:
+                    {
+                        // Special Effect only for caster (ghoul in this case)
+                        if (unitTarget->GetEntry() == 26125 && (unitTarget->GetGUID() == m_caster->GetGUID()))
+                        {
+                            // After explode the ghoul must be killed
+                            unitTarget->DealDamage(unitTarget, unitTarget->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                        }
+                        break;
+                    }
                     // Tympanic Tantrum
                     case 62775:
                     {
@@ -493,7 +541,9 @@ void Spell::EffectSchoolDMG(SpellEffectIndex effect_idx)
                     if (aura)
                     {
                         int32 damagetick = aura->GetModifier()->m_amount;
-                        damage += damagetick * 4;
+                        // Save value of further damage
+                        m_currentBasePoints[1] = damagetick * 2 / 3;
+                        damage += damagetick * 3;
 
                         // Glyph of Conflagrate
                         if (!m_caster->HasAura(56235))
@@ -619,6 +669,10 @@ void Spell::EffectSchoolDMG(SpellEffectIndex effect_idx)
                         // Eviscerate and Envenom Bonus Damage (item set effect)
                         if(m_caster->GetDummyAura(37169))
                             damage += combo*40;
+                            
+                        // Apply spell mods
+                        if (Player* modOwner = m_caster->GetSpellModOwner())
+                            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DAMAGE, damage);
                     }
                 }
                 // Gouge
@@ -756,7 +810,10 @@ void Spell::EffectSchoolDMG(SpellEffectIndex effect_idx)
                 else if (m_spellInfo->Id == 54158)
                 {
                     // [1 + 0.25 * SPH + 0.16 * AP]
-                    damage += int32(m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.16f);
+                    float ap = m_caster->GetTotalAttackPowerValue(BASE_ATTACK);
+                    int32 holy = m_caster->SpellBaseDamageBonusDone(GetSpellSchoolMask(m_spellInfo)) +
+                                 unitTarget->SpellBaseDamageBonusTaken(GetSpellSchoolMask(m_spellInfo));
+                    damage += int32(ap * 0.16f) + int32(holy * 25 / 100);
                 }
                 break;
             }
@@ -769,6 +826,8 @@ void Spell::EffectSchoolDMG(SpellEffectIndex effect_idx)
 
 void Spell::EffectDummy(SpellEffectIndex eff_idx)
 {
+    uint8 hit = 0;
+
     if (!unitTarget && !gameObjTarget && !itemTarget)
         return;
 
@@ -779,6 +838,8 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
         {
             switch(m_spellInfo->Id)
             {
+                   // Magic Pull
+                case 51336: m_caster->CastSpell(unitTarget,50770,true); break; 
                 case 8063:                                  // Deviate Fish
                 {
                     if (m_caster->GetTypeId() != TYPEID_PLAYER)
@@ -943,7 +1004,7 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
 
                     pGameObj->SetRespawnTime(creatureTarget->GetRespawnTime()-time(NULL));
                     pGameObj->SetOwnerGUID(m_caster->GetGUID() );
-                    pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel() );
+                    //pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel() );
                     pGameObj->SetSpellId(m_spellInfo->Id);
 
                     creatureTarget->ForcedDespawn();
@@ -1232,7 +1293,9 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
                     creatureTarget->ForcedDespawn();
 
                     //cast spell Raptor Capture Credit
-                    m_caster->CastSpell(m_caster, 42337, true, NULL);
+                    if(Unit * pCaster = m_originalCaster)
+					    pCaster->CastSpell(pCaster, 42337, true);
+						
                     return;
                 }
                 case 44997:                                 // Converting Sentry
@@ -1488,6 +1551,14 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
                     m_caster->CastSpell(m_caster, 30452, true, NULL);
                     return;
                 }
+            case 51858:						// Siphon of Acherus - Complete Quest
+            {               
+                    if (!m_caster || !m_caster->isAlive())
+                        return;
+
+               ((Player*)m_originalCaster->GetCharmer())->KilledMonsterCredit(m_caster->GetEntry(), m_caster->GetGUID());                    					
+                        
+            }
                 case 51840:                                 // Despawn Fruit Tosser
                 {
                     if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
@@ -1669,6 +1740,13 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
                     m_caster->CastSpell(m_caster, spellShrink, true);
                     return;
                 }
+                case 54171:                                 // Divine Storm
+                {
+                    // split between targets
+                    int32 bp = damage / m_UniqueTargetInfo.size();
+                    m_caster->CastCustomSpell(unitTarget, 54172, &bp, NULL, NULL, true);
+                    return;
+                }
                 case 55004:                                 // Nitro Boosts
                 {
                     if (!m_CastItem)
@@ -1681,6 +1759,26 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
 
                     return;
                 }
+                case 55804:                                 // Healing Finished (triggered by item spell Telluric Poultice)
+                {
+                   Unit* pCaster = GetAffectiveCaster();
+                   if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT || unitTarget->isInCombat() || !pCaster || pCaster->GetTypeId() != TYPEID_PLAYER)
+                       return;
+                    
+                   switch(urand(0,3))
+                   {
+                       case 0: unitTarget->MonsterSay("Let us fight the Irons together!",LANG_UNIVERSAL,pCaster->GetGUID());break;
+                       case 1: unitTarget->MonsterSay("Thank you! I thought I was doomed.",LANG_UNIVERSAL,pCaster->GetGUID());break;
+                       case 2: unitTarget->MonsterSay("Let me fight by your side!",LANG_UNIVERSAL,pCaster->GetGUID());break;
+                       case 3: unitTarget->MonsterSay("I was certain I was going to die out here.",LANG_UNIVERSAL,pCaster->GetGUID());break;
+                   }
+                   ((Creature*)unitTarget)->ForcedDespawn(30000);
+                   unitTarget->SetByteValue(UNIT_FIELD_BYTES_1,0,UNIT_STAND_STATE_STAND);
+                   unitTarget->GetMotionMaster()->Clear();
+                   unitTarget->GetMotionMaster()->MoveFollow(pCaster,PET_FOLLOW_DIST,unitTarget->GetAngle(pCaster));
+                   ((Player*)pCaster)->KilledMonsterCredit(unitTarget->GetEntry(),unitTarget->GetGUID());
+                   return;
+                }
                 case 55818:                                 // Hurl Boulder
                 {
                     // unclear how many summon min/max random, best guess below
@@ -1691,6 +1789,21 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
 
                     return;
                 }
+                case 55965:                                 // Shadowstep (Ahn'Kahet dummy)
+                {
+                    if (!unitTarget)
+                        return;
+                    // set Vanish
+                    m_caster->CastSpell(m_caster, 55964, true);
+                    // cast Shadowstep
+                    m_caster->CastSpell(unitTarget, 55966, true);
+                    // remove Vanish auras
+                    m_caster->RemoveAurasDueToSpell(55964);
+                    // shadowstep
+                    if (m_caster->GetMap() && m_caster->GetMap()->IsDungeon())
+                        m_caster->CastSpell(unitTarget, m_caster->GetMap()->IsRegularDifficulty() ? 55959 : 59513, false);
+                    return;
+				}	
                 case 57908:                                 // Stain Cloth
                 {
                     // nothing do more
@@ -1735,6 +1848,36 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
                     m_caster->CastSpell(unitTarget,60934,true,NULL);
                     return;
                 }
+                case 62653:                                 // Tidal Wave - nonheroic version
+                {
+                    if(!unitTarget)
+                        return;
+
+                    m_caster->CastSpell(unitTarget, 62654, true);
+                    return;
+                }
+                case 62973:                                 // Foam Sword Attack
+                {
+                    // Stop if there is no target
+					if(!unitTarget)
+                        return;
+                    // Stop if the target is not a player (it has to be one)
+                    if (m_caster->GetTypeId()!=TYPEID_PLAYER)
+                        return;
+
+                    Player* pTarget = (Player*)unitTarget;
+					Item* pItem = pTarget->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+					if (pItem->GetProto()->ItemId == 45179 || pItem->GetProto()->ItemId == 45178 || pItem->GetProto()->ItemId == 45176 || pItem->GetProto()->ItemId == 45061 || pItem->GetProto()->ItemId == 45177)
+						hit = hit+1;
+                    // If this spell has been cast 3 times (3 hits) cast defeat on the target
+                    if (hit == 3)
+                    {
+                        hit = 0;
+						// Cast Foam Sword Defeat on the target
+                        m_caster->CastSpell(unitTarget, 62994, true);
+                    }
+                    return;
+                }
                 case 67019:                                 // Flask of the North
                 {
                     if (m_caster->GetTypeId() != TYPEID_PLAYER)
@@ -1861,13 +2004,18 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
 
                 uint32 rage = m_caster->GetPower(POWER_RAGE);
 
-                // up to max 30 rage cost
-                if (rage > 300)
-                    rage = 300;
+                if (!rage)
+                    m_caster->SetPower(POWER_RAGE, 1);
 
-                // Glyph of Execution bonus
-                uint32 rage_modified = rage;
+                uint32 rage_addition = rage;
+
+                // up to max 30 total rage cost
+                if (rage_addition + GetPowerCost() > 300)
+                    rage_addition = 300 - GetPowerCost();
+
+                uint32 rage_modified = rage_addition;
 
+                // Glyph of Execution bonus
                 if (Aura *aura = m_caster->GetDummyAura(58367))
                     rage_modified +=  aura->GetModifier()->m_amount*10;
 
@@ -1876,25 +2024,26 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
 
                 m_caster->CastCustomSpell(unitTarget, 20647, &basePoints0, NULL, NULL, true, 0);
 
+                uint32 new_rage = rage - rage_addition;
+
                 // Sudden Death
-                if (m_caster->HasAura(52437))
+                Unit::AuraList const& auras = m_caster->GetAurasByType(SPELL_AURA_PROC_TRIGGER_SPELL);
+                for (Unit::AuraList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
                 {
-                    Unit::AuraList const& auras = m_caster->GetAurasByType(SPELL_AURA_PROC_TRIGGER_SPELL);
-                    for (Unit::AuraList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                    // Only Sudden Death have this SpellIconID with SPELL_AURA_PROC_TRIGGER_SPELL
+                    if ((*itr)->GetSpellProto()->SpellIconID == 1989)
                     {
-                        // Only Sudden Death have this SpellIconID with SPELL_AURA_PROC_TRIGGER_SPELL
-                        if ((*itr)->GetSpellProto()->SpellIconID == 1989)
-                        {
-                            // saved rage top stored in next affect
-                            uint32 lastrage = (*itr)->GetSpellProto()->CalculateSimpleValue(EFFECT_INDEX_1)*10;
-                            if(lastrage < rage)
-                                rage -= lastrage;
-                            break;
-                        }
+                        // saved rage top stored in next affect
+                        uint32 save_rage = (*itr)->GetSpellProto()->CalculateSimpleValue(EFFECT_INDEX_1)*10;
+
+                        if (new_rage < save_rage)
+                            new_rage = save_rage;
+
+                        break;
                     }
                 }
 
-                m_caster->SetPower(POWER_RAGE,m_caster->GetPower(POWER_RAGE)-rage);
+                m_caster->SetPower(POWER_RAGE, new_rage);
                 return;
             }
             // Slam
@@ -2098,6 +2247,9 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
 
                         if (spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && (spellInfo->SpellFamilyFlags & UI64LIT(0x0000024000000860)))
                             ((Player*)m_caster)->RemoveSpellCooldown((itr++)->first,true);
+                        // Glyph of Preparation
+                        else if (m_caster->HasAura(56819) && (spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && (spellInfo->SpellFamilyFlags & 0x40000010 || spellInfo->Id == 51722)))
+                            ((Player*)m_caster)->RemoveSpellCooldown((itr++)->first,true);
                         else
                             ++itr;
                     }
@@ -2108,6 +2260,16 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
                     m_caster->CastSpell(m_caster, 45182, true);
                     return;
                 }
+                case 51662:                                 // Hunger for Blood
+                {
+                    m_caster->CastSpell(m_caster, 63848, true);
+                    return;
+                }
+                case 51690:                                 // Killing Spree - second effect
+                {
+                    m_caster->CastSpell(m_caster, 61851, true);
+                    return;
+                }
             }
             break;
         }
@@ -2285,7 +2447,7 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
 
                     // Righteous Defense (step 2) (in old version 31980 dummy effect)
                     // Clear targets for eff 1
-                    for(std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin();ihit != m_UniqueTargetInfo.end();++ihit)
+                    for(tbb::concurrent_vector<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin();ihit != m_UniqueTargetInfo.end();++ihit)
                         ihit->effectMask &= ~(1<<1);
 
                     // not empty (checked), copy
@@ -2340,6 +2502,8 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
                 {
                     if (Unit *owner = m_caster->GetOwner())
                     {
+                        damage += int32(m_caster->GetOwner()->SpellDamageBonusDone(unitTarget, m_spellInfo, 0, HEAL) * 0.45f);
+
                         // Restorative Totems
                         Unit::AuraList const& mDummyAuras = owner->GetAurasByType(SPELL_AURA_DUMMY);
                         for(Unit::AuraList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
@@ -2432,6 +2596,18 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
         }
         case SPELLFAMILY_DEATHKNIGHT:
         {
+            // Corpse Explosion
+            if(m_spellInfo->SpellIconID == 1737)
+            {
+                // Living ghoul as a target
+                if (unitTarget->GetEntry() == 26125 && unitTarget->isAlive())
+                {
+                    int32 bp = unitTarget->GetMaxHealth()*0.25f;
+                    unitTarget->CastCustomSpell(unitTarget,47496,&bp,NULL,NULL,true);
+                }
+                else
+                    return;
+            }
             // Death Coil
             if (m_spellInfo->SpellFamilyFlags & UI64LIT(0x002000))
             {
@@ -2445,7 +2621,8 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
                 }
                 else
                 {
-                    int32 bp = damage;
+                    int32 bp = m_caster->SpellDamageBonusDone(unitTarget, m_spellInfo, uint32(damage), SPELL_DIRECT_DAMAGE);
+                    bp = unitTarget->SpellDamageBonusTaken(m_caster, m_spellInfo, uint32(bp), SPELL_DIRECT_DAMAGE);
                     m_caster->CastCustomSpell(unitTarget, 47632, &bp, NULL, NULL, true);
                 }
                 return;
@@ -2491,6 +2668,75 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
                 m_caster->CastCustomSpell(m_caster, 45470, &bp, NULL, NULL, true);
                 return;
             }
+            // Raise dead effect
+            else if(m_spellInfo->Id == 46584) 
+            {
+                if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                    return;
+                // We can have a summoned pet/guardian only in 2 cases:
+                // 1. It was summoned from corpse in EffectScriptEffect.
+                if (getState() == SPELL_STATE_FINISHED)
+                    return;
+                // 2. Cooldown of Raise Dead is finished and we want to repeat the cast with active pet.
+                if (((Player*)m_caster)->GetPet())
+                {
+                    ((Player*)m_caster)->RemoveSpellCooldown(m_spellInfo->Id,true);
+                    SendCastResult(SPELL_FAILED_ALREADY_HAVE_SUMMON);
+                    return;
+                }
+                // We will get here ONLY if we have no corpse.
+                bool allow_cast = false;
+                // We do not need any reagent if we have Glyph of Raise Dead.
+                if (m_caster->HasAura(60200))
+                    allow_cast = true;
+                else
+                    // We need Corpse Dust to cast a spell.
+                    if (((Player*)m_caster)->HasItemCount(37201,1))
+                    {
+                        ((Player*)m_caster)->DestroyItemCount(37201,1,true);
+                        allow_cast = true;
+                    }
+                if (allow_cast)
+                {
+                    if (m_caster->HasSpell(52143))
+                        m_caster->CastSpell(m_caster,52150,true);
+                    else
+                        m_caster->CastSpell(m_caster,46585,true);
+                }
+                else
+                {
+                    ((Player*)m_caster)->RemoveSpellCooldown(m_spellInfo->Id,true);
+                    SendCastResult(SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW);
+                }
+                return;
+            }
+            switch(m_spellInfo->Id)
+            {
+                // Death Grip
+                case 49560:
+                case 49576:
+                {
+                    if (!unitTarget || !m_caster)
+                        return;
+
+                    float x = m_caster->GetPositionX();
+                    float y = m_caster->GetPositionY();
+                    float z = m_caster->GetPositionZ()+1;
+                    float orientation = unitTarget->GetOrientation();
+
+                    m_caster->CastSpell(unitTarget,51399,true,NULL);
+
+                    if(unitTarget->GetTypeId() != TYPEID_PLAYER)
+                    {
+                        unitTarget->GetMap()->CreatureRelocation((Creature*)unitTarget,x,y,z,orientation);
+                        ((Creature*)unitTarget)->SendMonsterMove(x, y, z, SPLINETYPE_NORMAL, SPLINEFLAG_UNKNOWN11, 1);
+                    }
+                    else
+                        unitTarget->NearTeleportTo(x,y,z,orientation,false);
+
+                    return;
+                }
+            }
             break;
         }
     }
@@ -2515,13 +2761,30 @@ void Spell::EffectDummy(SpellEffectIndex eff_idx)
 void Spell::EffectTriggerSpellWithValue(SpellEffectIndex eff_idx)
 {
     uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[eff_idx];
+	
+	switch(m_spellInfo->Id)
+	{
+	    // Heat
+		case 62343:
+		{
+		   if (unitTarget->HasAura(62373) || unitTarget->HasAura(62382))
+		       return;
+		}
+		// Strength of the Creator
+		case 64474:
+		{
+		   unitTarget->CastSpell(unitTarget, triggered_spell_id, true);
+		   return;
+		}
+	};	
+	
 
     // normal case
     SpellEntry const *spellInfo = sSpellStore.LookupEntry( triggered_spell_id );
 
     if(!spellInfo)
     {
-        sLog.outError("EffectTriggerSpellWithValue of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
+        DEBUG_LOG("EffectTriggerSpellWithValue of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
         return;
     }
 
@@ -2536,7 +2799,7 @@ void Spell::EffectTriggerRitualOfSummoning(SpellEffectIndex eff_idx)
 
     if(!spellInfo)
     {
-        sLog.outError("EffectTriggerRitualOfSummoning of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
+        DEBUG_LOG("EffectTriggerRitualOfSummoning of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
         return;
     }
 
@@ -2557,7 +2820,7 @@ void Spell::EffectForceCast(SpellEffectIndex eff_idx)
 
     if(!spellInfo)
     {
-        sLog.outError("EffectForceCast of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
+        DEBUG_LOG("EffectForceCast of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
         return;
     }
 
@@ -2570,7 +2833,7 @@ void Spell::EffectTriggerSpell(SpellEffectIndex effIndex)
     if (!unitTarget)
     {
         if(gameObjTarget || itemTarget)
-            sLog.outError("Spell::EffectTriggerSpell (Spell: %u): Unsupported non-unit case!",m_spellInfo->Id);
+            DEBUG_LOG("Spell::EffectTriggerSpell (Spell: %u): Unsupported non-unit case!",m_spellInfo->Id);
         return;
     }
 
@@ -2582,6 +2845,10 @@ void Spell::EffectTriggerSpell(SpellEffectIndex effIndex)
         // Vanish (not exist)
         case 18461:
         {
+            // Stop combat and remove attackers
+            unitTarget->CombatStop();
+            unitTarget->getHostileRefManager().deleteReferences();
+
             unitTarget->RemoveSpellsCausingAura(SPELL_AURA_MOD_ROOT);
             unitTarget->RemoveSpellsCausingAura(SPELL_AURA_MOD_DECREASE_SPEED);
             unitTarget->RemoveSpellsCausingAura(SPELL_AURA_MOD_STALKED);
@@ -2657,6 +2924,26 @@ void Spell::EffectTriggerSpell(SpellEffectIndex effIndex)
                 pet->CastSpell(pet, 28305, true);
             return;
         }
+        // Electrical Storm Tick
+        case 43657:
+        {
+            SpellEntry const* spell = sSpellStore.LookupEntry(triggered_spell_id);
+            Aura* aura = m_caster->GetAura(43648, effIndex);
+            if (aura && spell)
+            {
+                int32 basedmg = spell->EffectBasePoints[0];
+                int32 ticks = aura->GetAuraTicks();
+                int32 damage = basedmg * ticks + 1;
+                m_caster->CastCustomSpell(m_caster, triggered_spell_id, &damage, NULL, NULL, true, NULL, NULL, m_originalCasterGUID);
+            }
+            return;
+        }
+        // Empower Rune Weapon
+        case 53258:
+        {
+            m_caster->ModifyPower(POWER_RUNIC_POWER, 25);
+            return;
+        }
     }
 
     // normal case
@@ -2986,6 +3273,20 @@ void Spell::EffectApplyAura(SpellEffectIndex eff_idx)
         delete Aur;
         return;
     }
+    // Mixology - increase effect by 30% and duration 100%
+    if(caster->GetTypeId() == TYPEID_PLAYER && Aur->GetSpellProto()->SpellFamilyName == SPELLFAMILY_POTION
+        && caster->HasAura(53042))
+    {
+        SpellSpecific spellSpec = GetSpellSpecific(Aur->GetSpellProto()->Id);
+        if(spellSpec == SPELL_BATTLE_ELIXIR || spellSpec == SPELL_GUARDIAN_ELIXIR || spellSpec == SPELL_FLASK_ELIXIR)
+        {
+            if(caster->HasSpell(Aur->GetSpellProto()->EffectTriggerSpell[0]))
+            {
+               duration *= 2.0f;
+               Aur->GetModifier()->m_amount *= 1.3f;
+            }
+        }
+     }
 
     if(duration != Aur->GetAuraMaxDuration())
     {
@@ -3486,6 +3787,7 @@ void Spell::EffectEnergize(SpellEffectIndex eff_idx)
         case 48542:                                         // Revitalize (mana restore case)
         case 63375:                                         // Improved Stormstrike
         case 68082:                                         // Glyph of Seal of Command
+        case 71132:                                         // Glyph of Shadow Word: Pain
             damage = damage * unitTarget->GetCreateMana() / 100;
             break;
         default:
@@ -3624,7 +3926,7 @@ void Spell::EffectOpenLock(SpellEffectIndex eff_idx)
             if (BattleGround *bg = player->GetBattleGround())
             {
                 // check if it's correct bg
-                if (bg->GetTypeID() == BATTLEGROUND_AB || bg->GetTypeID() == BATTLEGROUND_AV)
+                if (bg->GetTypeID(true) == BATTLEGROUND_AB || bg->GetTypeID(true) == BATTLEGROUND_AV)
                     bg->EventPlayerClickedOnFlag(player, gameObjTarget);
                 return;
             }
@@ -3635,11 +3937,17 @@ void Spell::EffectOpenLock(SpellEffectIndex eff_idx)
             // in battleground check
             if (BattleGround *bg = player->GetBattleGround())
             {
-                if (bg->GetTypeID() == BATTLEGROUND_EY)
+                if (bg->GetTypeID(true) == BATTLEGROUND_EY)
                     bg->EventPlayerClickedOnFlag(player, gameObjTarget);
                 return;
             }
         }
+        // TODO: Add script for spell 41920 - Filling, becouse server it freze when use this spell
+        // handle outdoor pvp object opening, return true if go was registered for handling
+        // these objects must have been spawned by outdoorpvp!
+        else if(gameObjTarget->GetGOInfo()->type == GAMEOBJECT_TYPE_GOOBER && sOutdoorPvPMgr.HandleOpenGo(player, gameObjTarget->GetGUID()))
+            return;
+
         lockId = goInfo->GetLockId();
         guid = gameObjTarget->GetGUID();
     }
@@ -3832,6 +4140,9 @@ void Spell::EffectSummonType(SpellEffectIndex eff_idx)
                     //SUMMON_TYPE_TOTEM2 = 647: 52893, Anti-Magic Zone (npc used)
                     if(prop_id == 121 || prop_id == 647)
                         DoSummonTotem(eff_idx);
+          // Snake trap exception
+                    else if (m_spellInfo->EffectMiscValueB[eff_idx] == 2301)
+                        EffectSummonSnakes(eff_idx);
                     else
                         DoSummonWild(eff_idx, summon_prop->FactionId);
                     break;
@@ -3865,7 +4176,7 @@ void Spell::EffectSummonType(SpellEffectIndex eff_idx)
                 case SUMMON_PROP_TYPE_SIEGE_VEH:
                 case SUMMON_PROP_TYPE_DRAKE_VEH:
                     // TODO
-                    // EffectSummonVehicle(i);
+                    EffectSummonVehicle(eff_idx);
                     break;
                 default:
                     sLog.outError("EffectSummonType: Unhandled summon type %u", summon_prop->Type);
@@ -3886,15 +4197,23 @@ void Spell::EffectSummonType(SpellEffectIndex eff_idx)
         }
         case SUMMON_PROP_GROUP_CONTROLLABLE:
         {
-            // no type here
-            // maybe wrong - but thats the handler currently used for those
-            DoSummonGuardian(eff_idx, summon_prop->FactionId);
+           switch(prop_id)
+            {
+                //SUMMON_TYPE_POSESSED   = 65
+                //SUMMON_TYPE_POSESSED2   = 428
+                case 65:
+                case 428:
+                    EffectSummonPossessed(eff_idx);
+                    break;
+            default: DoSummonGuardian(eff_idx, summon_prop->FactionId);
+            break;
+            }
             break;
         }
         case SUMMON_PROP_GROUP_VEHICLE:
         {
             // TODO
-            // EffectSummonVehicle(i);
+            EffectSummonVehicle(eff_idx);
             break;
         }
         default:
@@ -3903,6 +4222,92 @@ void Spell::EffectSummonType(SpellEffectIndex eff_idx)
     }
 }
 
+// Used only for snake trap
+void Spell::EffectSummonSnakes(SpellEffectIndex eff_idx)
+{
+    uint32 creature_entry = m_spellInfo->EffectMiscValue[eff_idx];
+    if (!creature_entry || !m_caster)
+        return;
+
+    // Find trap GO and get it coordinates to spawn snakes
+    GameObject* pTrap = m_caster->GetMap()->GetGameObject(m_originalCasterGUID);
+    if (!pTrap)
+    {
+       sLog.outError("EffectSummonSnakes faild to find trap for caster %s (GUID: %u)",m_caster->GetName(),m_caster->GetGUID());
+       return;
+    }
+
+    float position_x, position_y, position_z;
+    pTrap->GetPosition(position_x, position_y, position_z);
+
+    // Find summon duration based on DBC
+    int32 duration = GetSpellDuration(m_spellInfo);
+    if(Player* modOwner = m_caster->GetSpellModOwner())
+        modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DURATION, duration);
+
+    int32 amount = damage > 0 ? damage : 1;
+
+    for(int32 count = 0; count < amount; ++count)
+    {
+        // Summon snakes
+        Creature *pSummon = m_caster->SummonCreature(creature_entry, position_x, position_y, position_z, m_caster->GetOrientation(), TEMPSUMMON_TIMED_DESPAWN, duration);
+        if (!pSummon)
+        {
+            sLog.outError("EffectSummonSnakes failed to summon snakes for Unit %s (GUID: %u) bacause of invalid position (x = %f, y = %f, z = %f map = %u)"
+                ,m_caster->GetName(),m_caster->GetGUID(), position_x, position_y, position_z, m_caster->GetMap());
+            delete pSummon;
+            continue;
+        }
+
+        //Apply stats
+        pSummon->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
+        pSummon->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE | UNIT_FLAG_PET_IN_COMBAT | UNIT_FLAG_PVP);
+        pSummon->SetCreatorGUID(m_caster->GetGUID());
+        pSummon->setFaction(m_caster->getFaction());
+        pSummon->SetLevel(m_caster->getLevel());
+        pSummon->SetMaxHealth(m_caster->getLevel()+ urand(20,30));
+     }
+}
+
+void Spell::EffectSummonPossessed(SpellEffectIndex eff_idx)
+{
+    uint32 creature_entry = m_spellInfo->EffectMiscValue[eff_idx];
+    if (!creature_entry)
+        return;
+
+    int32 duration = GetSpellDuration(m_spellInfo);
+
+    float px, py, pz;
+    // If dest location if present
+    if (m_targets.m_targetMask & TARGET_FLAG_DEST_LOCATION)
+    {
+        // Summon 1 unit in dest location
+        px = m_targets.m_destX;
+        py = m_targets.m_destY;
+        pz = m_targets.m_destZ;
+    }
+    // Summon if dest location not present near caster
+    else
+        m_caster->GetClosePoint(px, py, pz, 1.0f);
+
+    TempSummonType summonType = (duration == 0) ? TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN : TEMPSUMMON_TIMED_DESPAWN;
+    Creature *spawnCreature = m_caster->SummonCreature(creature_entry, px, py, pz, m_caster->GetOrientation(), summonType, duration);
+
+    if(!spawnCreature->IsPositionValid())
+    {
+        sLog.outError("Pet (guidlow %d, entry %d) not created base at creature. Suggested coordinates isn't valid (X: %f Y: %f)",
+        spawnCreature->GetGUIDLow(), spawnCreature->GetEntry(), spawnCreature->GetPositionX(), spawnCreature->GetPositionY());
+        delete spawnCreature;
+        return;
+    }
+
+    Unit* caster = GetAffectiveCaster();	 
+    Aura* aur = CreateAura(m_spellInfo, eff_idx, &m_currentBasePoints[eff_idx], spawnCreature, caster, m_CastItem);	 
+    Modifier* modifier=aur->GetModifier();
+    aur->SetModifier(SPELL_AURA_MOD_POSSESS,modifier->m_amount,modifier->periodictime,modifier->m_miscvalue);
+    spawnCreature->AddAura(aur);	 
+} 
+
 void Spell::DoSummon(SpellEffectIndex eff_idx)
 {
     if (m_caster->GetPetGUID())
@@ -3977,7 +4382,7 @@ void Spell::DoSummon(SpellEffectIndex eff_idx)
 
     spawnCreature->SetOwnerGUID(m_caster->GetGUID());
     spawnCreature->SetUInt32Value(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_NONE);
-    spawnCreature->setPowerType(POWER_MANA);
+    spawnCreature->setPowerType(spawnCreature->GetCreatureInfo()->family == CREATURE_FAMILY_GHOUL ? POWER_ENERGY : POWER_MANA);
     spawnCreature->setFaction(m_caster->getFaction());
     spawnCreature->SetUInt32Value(UNIT_FIELD_FLAGS, 0);
     spawnCreature->SetUInt32Value(UNIT_FIELD_BYTES_0, 2048);
@@ -4037,6 +4442,22 @@ void Spell::EffectLearnSpell(SpellEffectIndex eff_idx)
     uint32 spellToLearn = ((m_spellInfo->Id==SPELL_ID_GENERIC_LEARN) || (m_spellInfo->Id==SPELL_ID_GENERIC_LEARN_PET)) ? damage : m_spellInfo->EffectTriggerSpell[eff_idx];
     player->learnSpell(spellToLearn, false);
 
+    if ((sWorld.getConfig(CONFIG_BOOL_ALLOW_FLYING_MOUNTS_EVERYWHERE)) && (m_spellInfo->Id==55884))
+    {
+        SpellEntry const *sEntry = sSpellStore.LookupEntry(spellToLearn);
+        if(sEntry)
+        {
+            if(player->isFlyingSpell(sEntry) || player->isFlyingFormSpell(sEntry))
+            {
+                player->RemoveSpellCooldown(55884, true);
+                return;
+            }
+        }
+        else
+            return;
+    }
+
+    player->learnSpell(spellToLearn,false);
     DEBUG_LOG( "Spell: Player %u has learned spell %u from NpcGUID=%u", player->GetGUIDLow(), spellToLearn, m_caster->GetGUIDLow() );
 }
 
@@ -4138,6 +4559,11 @@ void Spell::EffectDispel(SpellEffectIndex eff_idx)
             {
                 int32 heal_amount = m_spellInfo->CalculateSimpleValue(EFFECT_INDEX_1);
                 m_caster->CastCustomSpell(m_caster, 19658, &heal_amount, NULL, NULL, true);
+
+                // Glyph of Felhunter
+                if (Unit *owner = m_caster->GetOwner())
+                    if (owner->HasAura(56249))
+                        m_caster->CastCustomSpell(owner, 19658, &heal_amount, NULL, NULL, true);
             }
         }
         // Send fail log to client
@@ -4486,11 +4912,6 @@ void Spell::EffectEnchantItemPerm(SpellEffectIndex eff_idx)
     if (!itemTarget)
         return;
 
-    Player* p_caster = (Player*)m_caster;
-
-    // not grow at item use at item case
-    p_caster->UpdateCraftSkill(m_spellInfo->Id);
-
     uint32 enchant_id = m_spellInfo->EffectMiscValue[eff_idx];
     if (!enchant_id)
         return;
@@ -4504,6 +4925,25 @@ void Spell::EffectEnchantItemPerm(SpellEffectIndex eff_idx)
     if (!item_owner)
         return;
 
+    Player* p_caster = (Player*)m_caster;
+
+    // Enchanting a vellum requires special handling, as it creates a new item
+    // instead of modifying an existing one.
+    ItemPrototype const* targetProto = itemTarget->GetProto();
+    if(targetProto->IsVellum() && m_spellInfo->EffectItemType[eff_idx])
+    {
+        unitTarget = m_caster;
+        DoCreateItem(eff_idx,m_spellInfo->EffectItemType[eff_idx]);
+        // Vellum target case: Target becomes additional reagent, new scroll item created instead in Spell::EffectEnchantItemPerm()
+        // cannot already delete in TakeReagents() unfortunately
+        p_caster->DestroyItemCount(targetProto->ItemId, 1, true);
+        return;
+    }
+
+    // not grow at item use at item case, using scrolls does not increase enchanting skill!
+    if (!(m_CastItem && m_CastItem->GetProto()->Flags & ITEM_FLAGS_ENCHANT_SCROLL))
+        p_caster->UpdateCraftSkill(m_spellInfo->Id);
+
     if (item_owner!=p_caster && p_caster->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getConfig(CONFIG_BOOL_GM_LOG_TRADE) )
     {
         sLog.outCommand(p_caster->GetSession()->GetAccountId(),"GM %s (Account: %u) enchanting(perm): %s (Entry: %d) for player: %s (Account: %u)",
@@ -4519,6 +4959,10 @@ void Spell::EffectEnchantItemPerm(SpellEffectIndex eff_idx)
 
     // add new enchanting if equipped
     item_owner->ApplyEnchantment(itemTarget,PERM_ENCHANTMENT_SLOT,true);
+
+    // update trade window for show enchantment for caster in trade window
+    if (m_targets.m_targetMask & TARGET_FLAG_TRADE_ITEM)
+        p_caster->GetSession()->SendUpdateTrade();
 }
 
 void Spell::EffectEnchantItemPrismatic(SpellEffectIndex eff_idx)
@@ -4577,6 +5021,10 @@ void Spell::EffectEnchantItemPrismatic(SpellEffectIndex eff_idx)
 
     // add new enchanting if equipped
     item_owner->ApplyEnchantment(itemTarget,PRISMATIC_ENCHANTMENT_SLOT,true);
+
+    // update trade window for show enchantment for caster in trade window
+    if (m_targets.m_targetMask & TARGET_FLAG_TRADE_ITEM)
+        p_caster->GetSession()->SendUpdateTrade();
 }
 
 void Spell::EffectEnchantItemTmp(SpellEffectIndex eff_idx)
@@ -4670,8 +5118,8 @@ void Spell::EffectEnchantItemTmp(SpellEffectIndex eff_idx)
     // other cases with this SpellVisual already selected
     else if(m_spellInfo->SpellVisual[0] == 215)
         duration = 1800;                                    // 30 mins
-    // some fishing pole bonuses
-    else if(m_spellInfo->SpellVisual[0] == 563)
+    // some fishing pole bonuses except Glow Worm which lasts full hour
+    else if(m_spellInfo->SpellVisual[0] == 563 && m_spellInfo->Id != 64401)
         duration = 600;                                     // 10 mins
     // shaman rockbiter enchantments
     else if(m_spellInfo->SpellVisual[0] == 0)
@@ -4704,6 +5152,10 @@ void Spell::EffectEnchantItemTmp(SpellEffectIndex eff_idx)
 
     // add new enchanting if equipped
     item_owner->ApplyEnchantment(itemTarget, TEMP_ENCHANTMENT_SLOT, true);
+
+    // update trade window for show enchantment for caster in trade window
+    if (m_targets.m_targetMask & TARGET_FLAG_TRADE_ITEM)
+        p_caster->GetSession()->SendUpdateTrade();
 }
 
 void Spell::EffectTameCreature(SpellEffectIndex /*eff_idx*/)
@@ -4854,7 +5306,7 @@ void Spell::EffectSummonPet(SpellEffectIndex eff_idx)
     // this enables popup window (pet dismiss, cancel), hunter pet additional flags set later
     if(m_caster->GetTypeId() == TYPEID_PLAYER)
         NewSummon->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
-
+    
     if(m_caster->IsPvP())
         NewSummon->SetPvP(true);
 
@@ -4868,6 +5320,24 @@ void Spell::EffectSummonPet(SpellEffectIndex eff_idx)
 
     if(NewSummon->getPetType() == SUMMON_PET)
     {
+        // Remove Demonic Sacrifice auras (new pet)
+        Unit::AuraList const& auraClassScripts = m_caster->GetAurasByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+        for(Unit::AuraList::const_iterator itr = auraClassScripts.begin(); itr != auraClassScripts.end();)
+        {
+            if((*itr)->GetModifier()->m_miscvalue == 2228)
+            {
+                m_caster->RemoveAurasDueToSpell((*itr)->GetId());
+                itr = auraClassScripts.begin();
+            }
+            else
+                ++itr;
+        }
+        
+        // Summoned creature is ghoul.
+        if (NewSummon->GetEntry() == 26125)
+            // He must have energy bar instead of mana
+            NewSummon->setPowerType(POWER_ENERGY);
+
         // generate new name for summon pet
         std::string new_name = sObjectMgr.GeneratePetName(petentry);
         if(!new_name.empty())
@@ -4984,14 +5454,86 @@ void Spell::EffectWeaponDmg(SpellEffectIndex eff_idx)
                 case 71021:                                 // Saber Lash
                 {
                     uint32 count = 0;
-                    for(std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                    for(tbb::concurrent_vector<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin();ihit != m_UniqueTargetInfo.end();++ihit)
                         if(ihit->effectMask & (1<<eff_idx))
                             ++count;
 
                     totalDamagePercentMod /= float(count);  // divide to all targets
                     break;
                 }
+                // AoE spells, which damage is reduced with distance from the initial hit point
+                case 62598: case 62937: // Detonate
+                case 65279: // Lightning Nova
+                case 62311: case 64596: // Cosmic Smash
+                {
+                    float distance = unitTarget->GetDistance2d(m_targets.m_destX, m_targets.m_destY);
+                    damage *= exp(-distance/15.0f);
+                    break;
+                }
+                // percent from health with min
+                case 25599: // Thundercrash
+                {
+                    damage = unitTarget->GetHealth() / 2;
+                    if(damage < 200)
+                        damage = 200;
+                    break;
+                }
+                // Intercept (warrior spell trigger)
+                case 20253:
+                case 61491:
+                {
+                    damage+= uint32(m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.12f);
+                    break;
+                }
+                // percent max target health
+                case 29142: // Eyesore Blaster
+                case 35139: // Throw Boom's Doom
+                case 49882: // Leviroth Self-Impale
+                {
+                    damage = damage * unitTarget->GetMaxHealth() / 100;
+                    break;
+                }
+                // Cataclysmic Bolt
+                case 38441:
+                {
+                    damage = unitTarget->GetMaxHealth() / 2;
+                    break;
+                }
+                // Tympanic Tantrum
+                case 62775:
+                {
+                    damage = unitTarget->GetMaxHealth() / 10;
+                    break;
+                }
+                // Hand of Rekoning (name not have typos ;) )
+                case 67485:
+                {
+                    damage += uint32(0.5f * m_caster->GetTotalAttackPowerValue(BASE_ATTACK));
+                    break;
+                }
+                break;
+            }
+            break;
+        }
+        case SPELLFAMILY_DRUID:
+        {
+            // Rend and Tear ( on Maul / Shred )
+            if (m_spellInfo->SpellFamilyFlags & UI64LIT(0x0000000000008800))
+            {
+                if(unitTarget && unitTarget->HasAuraState(AURA_STATE_MECHANIC_BLEED))
+                {
+                    Unit::AuraList const& aura = m_caster->GetAurasByType(SPELL_AURA_DUMMY);
+                    for(Unit::AuraList::const_iterator itr = aura.begin(); itr != aura.end(); ++itr)
+                    {
+                        if ((*itr)->GetSpellProto()->SpellIconID == 2859 && (*itr)->GetEffIndex() == 0)
+                        {
+                            totalDamagePercentMod += (totalDamagePercentMod * (*itr)->GetModifier()->m_amount) / 100;
+                            break;
+                        }
+                    }
+                }
             }
+
             break;
         }
         case SPELLFAMILY_WARRIOR:
@@ -5172,6 +5714,12 @@ void Spell::EffectWeaponDmg(SpellEffectIndex eff_idx)
             {
                 totalDamagePercentMod *= 1.2f;
             }
+            // Rune strike
+            if( m_spellInfo->SpellIconID == 3007)
+            {
+                int32 count = CalculateDamage(EFFECT_INDEX_2, unitTarget);
+                spell_bonus += int32(count * m_caster->GetTotalAttackPowerValue(BASE_ATTACK) / 100.0f);
+            }
             break;
         }
     }
@@ -5239,7 +5787,7 @@ void Spell::EffectWeaponDmg(SpellEffectIndex eff_idx)
             ((Player*)m_caster)->AddComboPoints(unitTarget, 1);
     }
     // Mangle (Cat): CP
-    else if (m_spellInfo->SpellFamilyName==SPELLFAMILY_DRUID && (m_spellInfo->SpellFamilyFlags==UI64LIT(0x0000040000000000)))
+    if (m_spellInfo->SpellFamilyName==SPELLFAMILY_DRUID && (m_spellInfo->SpellFamilyFlags==UI64LIT(0x0000040000000000)))
     {
         if(m_caster->GetTypeId()==TYPEID_PLAYER)
             ((Player*)m_caster)->AddComboPoints(unitTarget, 1);
@@ -5280,6 +5828,23 @@ void Spell::EffectThreat(SpellEffectIndex /*eff_idx*/)
 
     if(!unitTarget->CanHaveThreatList())
         return;
+		
+	// pet's growl bonus threat
+	if( m_spellInfo->SpellFamilyName == SPELLFAMILY_HUNTER && m_spellInfo->SpellIconID == 201)
+	{
+	    // search for "guard dog"
+		Unit::AuraList const& mDummyAuras = m_caster->GetAurasByType(SPELL_AURA_DUMMY);
+		for(Unit::AuraList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
+		{
+		    SpellEntry const *m_spellProto = (*i)->GetSpellProto();
+			if( m_spellProto && m_spellProto->SpellFamilyName == SPELLFAMILY_PET &&
+			    m_spellProto->SpellIconID == 201)
+			{
+			    damage+= (*i)->GetModifier()->m_amount*damage/100;
+				break;
+			}
+		}
+	}	
 
     unitTarget->AddThreat(m_caster, float(damage), false, GetSpellSchoolMask(m_spellInfo), m_spellInfo);
 }
@@ -5296,7 +5861,7 @@ void Spell::EffectHealMaxHealth(SpellEffectIndex /*eff_idx*/)
     m_healing += heal;
 }
 
-void Spell::EffectInterruptCast(SpellEffectIndex /*eff_idx*/)
+void Spell::EffectInterruptCast(SpellEffectIndex eff_idx)
 {
     if(!unitTarget)
         return;
@@ -5313,7 +5878,7 @@ void Spell::EffectInterruptCast(SpellEffectIndex /*eff_idx*/)
             // check if we can interrupt spell
             if ((curSpellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_INTERRUPT) && curSpellInfo->PreventionType == SPELL_PREVENTION_TYPE_SILENCE )
             {
-                unitTarget->ProhibitSpellSchool(GetSpellSchoolMask(curSpellInfo), GetSpellDuration(m_spellInfo));
+                unitTarget->ProhibitSpellSchool(GetSpellSchoolMask(curSpellInfo), unitTarget->CalculateSpellDuration(m_spellInfo, eff_idx, unitTarget));
                 unitTarget->InterruptSpell(CurrentSpellTypes(i),false);
             }
         }
@@ -5366,7 +5931,7 @@ void Spell::EffectSummonObjectWild(SpellEffectIndex eff_idx)
         {
             case 489:                                       //WS
             {
-                if(bg && bg->GetTypeID()==BATTLEGROUND_WS && bg->GetStatus() == STATUS_IN_PROGRESS)
+                if(bg && bg->GetTypeID(true)==BATTLEGROUND_WS && bg->GetStatus() == STATUS_IN_PROGRESS)
                 {
                     uint32 team = ALLIANCE;
 
@@ -5379,7 +5944,7 @@ void Spell::EffectSummonObjectWild(SpellEffectIndex eff_idx)
             }
             case 566:                                       //EY
             {
-                if(bg && bg->GetTypeID()==BATTLEGROUND_EY && bg->GetStatus() == STATUS_IN_PROGRESS)
+                if(bg && bg->GetTypeID(true)==BATTLEGROUND_EY && bg->GetStatus() == STATUS_IN_PROGRESS)
                 {
                     ((BattleGroundEY*)bg)->SetDroppedFlagGUID(pGameObj->GetGUID());
                 }
@@ -5401,6 +5966,38 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
         {
             switch(m_spellInfo->Id)
             {
+                case 6962:                                  // Pet Summoned
+                {
+                    if(m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    Player* plr = ((Player*)m_caster);
+                    if(plr && plr->GetLastPetNumber())
+                    {
+                        PetType NewPetType = (plr->getClass()==CLASS_HUNTER) ? HUNTER_PET : SUMMON_PET;
+                        if (Pet* NewPet = new Pet(NewPetType))
+                        {
+                            if(NewPet->LoadPetFromDB(plr, 0, plr->GetLastPetNumber(), true))
+                            {
+                                NewPet->SetHealth(NewPet->GetMaxHealth());
+                                NewPet->SetPower(NewPet->getPowerType(),NewPet->GetMaxPower(NewPet->getPowerType()));
+
+                                switch (NewPet->GetEntry())
+                                {
+                                    case 11859:
+                                    case    89:
+                                        NewPet->SetEntry(416);
+                                        break;
+                                    default:
+                                        break;
+                                }
+                            }
+                            else
+                                delete NewPet;
+                        }
+                    }
+                    return;
+                }
                 case 8856:                                  // Bending Shinbone
                 {
                     if (!itemTarget && m_caster->GetTypeId()!=TYPEID_PLAYER)
@@ -5671,6 +6268,24 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
                     unitTarget->CastSpell(unitTarget, 44870, true);
                     break;
                 }
+                case 45151:                                 // Burn - SWP Brutallus
+                {
+                    if (!unitTarget || unitTarget == m_caster || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+                    if (unitTarget->HasAura(46394, EFFECT_INDEX_0))
+                        return;
+
+                    unitTarget->CastSpell(unitTarget, 46394, true);
+                    break;
+                }
+                case 45625:                                 // Arcane Chains: Character Force Cast
+                {
+                    if(!unitTarget)
+                        return;
+
+                    unitTarget->CastSpell(m_caster, 45626, true);
+                    break;
+				}	
                 case 45206:                                 // Copy Off-hand Weapon
                 {
                     if (m_caster->GetTypeId() != TYPEID_UNIT || !unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
@@ -5691,7 +6306,7 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
                 }
                 case 45668:                                 // Ultra-Advanced Proto-Typical Shortening Blaster
                 {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT || m_caster->GetTypeId() != TYPEID_PLAYER)
                         return;
 
                     if (roll_chance_i(25))                  // chance unknown, using 25
@@ -5717,6 +6332,7 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
 
                     m_caster->CastSpell(m_caster, spellPlayer[urand(0,4)], true);
                     unitTarget->CastSpell(unitTarget, spellTarget[urand(0,4)], true);
+                    ((Player*)m_caster)->KilledMonsterCredit(25505, unitTarget->GetGUID());
 
                     return;
                 }
@@ -5762,6 +6378,25 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
                     ((Player*)unitTarget)->ModifyMoney(50000000);
                     break;
                 }
+                case 48762:                                 // A Fall from Grace: Scarlet Raven Priest Image - Master
+                {
+                   if (!unitTarget)
+                       return;
+
+                   unitTarget->CastSpell(unitTarget,(unitTarget->getGender() == 1) ? 48761 : 48763,true);
+                    return;
+
+                }
+                case 48769:                                 // A Fall from Grace: Quest Completion Script
+                {
+                   if (!unitTarget)
+                       return;
+
+                   if (unitTarget->HasAura(48761))
+                       unitTarget->RemoveAurasDueToSpell(48761);
+                   if (unitTarget->HasAura(48763))
+                   return;
+                }
                 case 47097:                                 // Surge Needle Teleporter
                 {
                     if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
@@ -5910,6 +6545,38 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
                     }
                     return;
                 }
+                case 51904:                                 // Summon Ghouls Of Scarlet Crusade
+                {
+                    if(!unitTarget)
+                        return;
+                    
+                    unitTarget->CastSpell(unitTarget, 54522, true);
+                    break;
+                } 
+                case 52694:                                 // Recall Eye of Acherus
+                {
+                    if(!m_caster || m_caster->GetTypeId() != TYPEID_UNIT || !(m_caster->isCharmed()))
+                        return;
+ 
+                    Creature *eye = ((Creature*)m_caster);
+                    if(m_caster->GetCharmer()->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    Player *player = ((Player*)m_caster->GetCharmer());					 
+                    if(eye->isInCombat())
+                        return;
+
+                    eye->GetMap()->CreatureRelocation(eye, player->GetPositionX(), player->GetPositionY(), player->GetPositionZ(), player->GetOrientation());
+                    eye->RemoveAurasDueToSpellByCancel(51852);					 
+                }
+                case 51962:
+                {
+                   if (!unitTarget)
+                       return;
+
+                   unitTarget->MonsterSay("Care to try Grimbooze Thunderbrew's new jungle punch?",LANG_UNIVERSAL,NULL);
+                   return;
+                }
                 case 52751:                                 // Death Gate
                 {
                     if (!unitTarget || unitTarget->getClass() != CLASS_DEATH_KNIGHT)
@@ -5973,6 +6640,31 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
                     unitTarget->RemoveSpellsCausingAura(SPELL_AURA_MOD_STUN);
                     return;
                 }
+                case 55328:                                    // Stoneclaw Totem I
+                case 55329:                                    // Stoneclaw Totem II
+                case 55330:                                    // Stoneclaw Totem III
+                case 55332:                                    // Stoneclaw Totem IV
+                case 55333:                                    // Stoneclaw Totem V
+                case 55335:                                    // Stoneclaw Totem VI
+                case 55278:                                    // Stoneclaw Totem VII
+                case 58589:                                    // Stoneclaw Totem VIII
+                case 58590:                                    // Stoneclaw Totem IX
+                case 58591:                                    // Stoneclaw Totem X
+                {
+                    if (!unitTarget)    // Stoneclaw Totem owner
+                        return;
+                    // Absorb shield for totems
+                    for(int itr = 0; itr < MAX_TOTEM_SLOT; ++itr)
+                        if (Totem* totem = unitTarget->GetTotem(TotemSlot(itr)))
+                            m_caster->CastCustomSpell(totem, 55277, &damage, NULL, NULL, true);
+                    // Glyph of Stoneclaw Totem
+                    if(Aura* auraGlyph = unitTarget->GetAura(63298, EFFECT_INDEX_0))
+                    {
+                        int32 playerAbsorb = damage * auraGlyph->GetModifier()->m_amount;
+                        m_caster->CastCustomSpell(unitTarget, 55277, &playerAbsorb, NULL, NULL, true);
+                    }
+                    return;
+                }
                 case 55693:                                 // Remove Collapsing Cave Aura
                 {
                     if (!unitTarget)
@@ -6048,6 +6740,11 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
                         ((Player*)m_caster)->learnSpell(discoveredSpell, false);
 
                     return;
+                }                                           // Rifle the Bodies: Create Magehunter Personal Effects Cover
+                case 61832:
+                {
+                   if (m_caster->GetTypeId() != TYPEID_UNIT)
+                       return;
                 }
                 case 66477:                                 // Bountiful Feast
                 {
@@ -6063,6 +6760,9 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
                     if (!unitTarget)
                         return;
 
+                    ((Creature*)m_caster)->ForcedDespawn(1000);
+                    return;
+                
                     m_caster->CastSpell(unitTarget, 72590, true);
                     return;
                 }
@@ -6082,6 +6782,40 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
                     m_caster->CastSpell(unitTarget, 72588, true);
                     return;
                 }
+                case 62678: // Summon Allies of Nature
+                {
+                    uint32 spellId = 0;
+                    switch(urand(0,2))
+                    {
+                        case 0: spellId = 62688; break;
+                        case 1: spellId = 62686; break;
+                        case 2: spellId = 62685; break;
+                    }
+                    m_caster->CastSpell(m_caster, spellId, true);
+                    return;
+                }				
+                case 62688: // Summon Wave - 10 Mob
+                {
+                    for(int8 i = 0; i < 12; i++)
+                        m_caster->CastSpell(m_caster, 62687, true);
+                    return;
+                }
+                case 62922: // Unstable Energy - Unstable Sun Beam remove part
+                {
+                   if(m_caster)
+                       m_caster->RemoveAurasDueToSpell(m_spellInfo->EffectBasePoints[eff_idx] + 1);
+                   return;
+                }
+                case 62262: // Brightleaf Flux
+                {
+                    if(!unitTarget)
+                        return;
+
+                    uint32 spellId = urand(0,1) ? 62251 : 62252;
+                    m_caster->CastSpell(unitTarget, spellId, true);
+                    if(Aura *pAura = unitTarget->GetAura(spellId, EFFECT_INDEX_0))
+                        pAura->SetStackAmount(urand(1,8));
+                }
             }
             break;
         }
@@ -6258,8 +6992,9 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
                         // Serpent Sting - Instantly deals 40% of the damage done by your Serpent Sting.
                         if ((familyFlag & UI64LIT(0x0000000000004000)) && aura->GetEffIndex() == EFFECT_INDEX_0)
                         {
-                            // m_amount already include RAP bonus
-                            basePoint = aura->GetModifier()->m_amount * aura->GetAuraMaxTicks() * 40 / 100;
+                            // m_amount does not include RAP bonus - must be calculated 
+                            basePoint = m_caster->MeleeDamageBonusDone(target, aura->GetModifier()->m_amount, RANGED_ATTACK, aura->GetSpellProto(), DOT, aura->GetStackAmount());
+                            basePoint = basePoint * (aura->GetAuraMaxDuration() / aura->GetModifier()->periodictime) * 40 / 100; 
                             spellId = 53353;                // Chimera Shot - Serpent
                         }
 
@@ -6298,7 +7033,7 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
                     }
 
                     if (spellId)
-                        m_caster->CastCustomSpell(target, spellId, &basePoint, 0, 0, false);
+                        m_caster->CastCustomSpell(target, spellId, &basePoint, 0, 0, true);
 
                     return;
                 }
@@ -6355,7 +7090,7 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
                     case 57774: spellId1 = 20185; break;    // Judgement of Light
                     case 53408: spellId1 = 20186; break;    // Judgement of Wisdom
                     default:
-                        sLog.outError("Unsupported Judgement (seal trigger) spell (Id: %u) in Spell::EffectScriptEffect",m_spellInfo->Id);
+                        DEBUG_LOG("Unsupported Judgement (seal trigger) spell (Id: %u) in Spell::EffectScriptEffect",m_spellInfo->Id);
                         return;
                 }
 
@@ -6471,6 +7206,50 @@ void Spell::EffectScriptEffect(SpellEffectIndex eff_idx)
 
                     break;
                 }
+                case 46584:		 // Raise dead
+                {
+                    // We will get here ONLY when we have a corpse of humanoid that gives honor or XP.
+                    // If we have active pet, then we should not cast the spell again.
+                    if(m_caster->GetPet())
+                    {
+                        if (m_caster->GetTypeId()==TYPEID_PLAYER)
+                            ((Player*)m_caster)->RemoveSpellCooldown(m_spellInfo->Id,true);
+                        SendCastResult(SPELL_FAILED_ALREADY_HAVE_SUMMON);
+                        return;
+                    }
+                    // Do we have talent Master of Ghouls?
+                    if(m_caster->HasSpell(52143))
+                        // Summon ghoul as a pet
+                        m_caster->CastSpell(unitTarget->GetPositionX(),unitTarget->GetPositionY(),unitTarget->GetPositionZ(),52150,true);
+                    else
+                        // Summon ghoul as a guardian
+                     m_caster->CastSpell(unitTarget->GetPositionX(),unitTarget->GetPositionY(),unitTarget->GetPositionZ(),46585,true);
+                    ((Creature*)unitTarget)->setDeathState(ALIVE);
+                    // Used to prevent further EffectDummy execution
+                    finish();
+                    return;//break;	
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+        {
+            switch(m_spellInfo->Id)
+            {
+                case 64380:                                 // Shattering Throw
+                {
+                    if (!unitTarget || !unitTarget->isAlive())
+                        return;
+
+                    // remove immunity effects
+                    unitTarget->RemoveAurasDueToSpell(642); // Divine Shield
+                    unitTarget->RemoveAurasDueToSpell(1022); // Hand of Protection rank 1
+                    unitTarget->RemoveAurasDueToSpell(5599); // Hand of Protection rank 2
+                    unitTarget->RemoveAurasDueToSpell(10278); // Hand of Protection rank 3
+                    unitTarget->RemoveAurasDueToSpell(19753); // Divine Intervention
+                    unitTarget->RemoveAurasDueToSpell(45438); // Ice Block
+                    break;
+                }
             }
             break;
         }
@@ -6496,6 +7275,9 @@ void Spell::EffectSanctuary(SpellEffectIndex /*eff_idx*/)
     if(m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && (m_spellInfo->SpellFamilyFlags & SPELLFAMILYFLAG_ROGUE_VANISH))
     {
         ((Player *)m_caster)->RemoveSpellsCausingAura(SPELL_AURA_MOD_ROOT);
+        // Overkill 
+        if(((Player*)m_caster)->HasSpell(58426))
+            m_caster->CastSpell(m_caster, 58427, true);
     }
 }
 
@@ -6510,7 +7292,12 @@ void Spell::EffectAddComboPoints(SpellEffectIndex /*eff_idx*/)
     if(damage <= 0)
         return;
 
-    ((Player*)m_caster)->AddComboPoints(unitTarget, damage);
+    if(m_caster->GetTypeId() != TYPEID_PLAYER)
+    {
+        if(((Creature*)m_caster)->isVehicle())
+            ((Player*)m_caster->GetCharmer())->AddComboPoints(unitTarget, damage);
+    }else
+        ((Player*)m_caster)->AddComboPoints(unitTarget, damage);
 }
 
 void Spell::EffectDuel(SpellEffectIndex eff_idx)
@@ -6744,6 +7531,9 @@ void Spell::DoSummonTotem(SpellEffectIndex eff_idx, uint8 slot_dbc)
         modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DURATION, duration);
     pTotem->SetDuration(duration);
 
+    if (m_spellInfo->Id == 16190)
+        damage = m_caster->GetMaxHealth() * m_spellInfo->CalculateSimpleValue(EFFECT_INDEX_1) / 100;
+
     if (damage)                                             // if not spell info, DB values used
     {
         pTotem->SetMaxHealth(damage);
@@ -6923,7 +7713,16 @@ void Spell::EffectSummonObject(SpellEffectIndex eff_idx)
     }
     // Summon in random point all other units if location present
     else
-        m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
+    {
+        if(m_spellInfo->Id == 48018)
+        {
+            x = m_caster->GetPositionX();
+            y = m_caster->GetPositionY();
+            z = m_caster->GetPositionZ();
+        }
+        else
+            m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
+    }
 
     Map *map = m_caster->GetMap();
     if(!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), go_id, map,
@@ -7020,26 +7819,80 @@ void Spell::EffectLeapForward(SpellEffectIndex eff_idx)
     if(unitTarget->isInFlight())
         return;
 
-    if( m_spellInfo->rangeIndex == 1)                       //self range
+    if( m_spellInfo->rangeIndex== 1)                        //self range
     {
+        uint32 mapid = m_caster->GetMapId();
         float dis = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[eff_idx]));
-
-        // before caster
-        float fx, fy, fz;
-        unitTarget->GetClosePoint(fx, fy, fz, unitTarget->GetObjectSize(), dis);
-        float ox, oy, oz;
-        unitTarget->GetPosition(ox, oy, oz);
-
-        float fx2, fy2, fz2;                                // getObjectHitPos overwrite last args in any result case
-        if(VMAP::VMapFactory::createOrGetVMapManager()->getObjectHitPos(unitTarget->GetMapId(), ox,oy,oz+0.5f, fx,fy,oz+0.5f,fx2,fy2,fz2, -0.5f))
+        //For glyph of blink
+        if(m_caster->GetTypeId() == TYPEID_PLAYER)
+            ((Player*)m_caster)->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RADIUS, dis, this);
+
+        // Start Info //
+        float cx,cy,cz;
+        float dx,dy,dz;
+        float angle = unitTarget->GetOrientation();
+        unitTarget->GetPosition(cx,cy,cz);
+          
+        //Check use of vmaps//
+        bool useVmap = false;
+        bool swapZone = true;
+
+        if( unitTarget->GetMap()->GetHeight(cx, cy, cz, false) <  unitTarget->GetMap()->GetHeight(cx, cy, cz, true) )
+            useVmap = true;
+
+        const int itr = int(dis/0.5f);
+        const float _dx = 0.5f * cos(angle);
+        const float _dy = 0.5f * sin(angle);
+        dx = cx;
+        dy = cy;
+
+        //Going foward 0.5f until max distance
+        for(float i=0.5f; i<dis; i+=0.5f)
         {
-            fx = fx2;
-            fy = fy2;
-            fz = fz2;
-            unitTarget->UpdateGroundPositionZ(fx, fy, fz);
+            //unitTarget->GetNearPoint2D(dx,dy,i,angle);
+            dx += _dx;
+            dy += _dy;
+            MaNGOS::NormalizeMapCoord(dx);
+            MaNGOS::NormalizeMapCoord(dy);
+            dz = cz;
+             
+            //Prevent climbing and go around object maybe 2.0f is to small? use 3.0f?
+            if( unitTarget->GetMap()->IsNextZcoordOK(dx, dy, dz, 3.0f) && (unitTarget->IsWithinLOS(dx, dy, dz)))
+            {
+                //No climb, the z differenze between this and prev step is ok. Store this destination for future use or check.
+                cx = dx;
+                cy = dy;
+                unitTarget->UpdateGroundPositionZ(cx, cy, cz, 3.0f);
+            }
+            else
+            {
+                //Something wrong with los or z differenze... maybe we are going from outer world inside a building or viceversa
+                if(swapZone)
+                {
+                    //so... change use of vamp and go back 1 step backward and recheck again.
+                    swapZone = false;
+                    useVmap = !useVmap;
+                    //i-=0.5f;
+                    --i;
+                    dx -= _dx;
+                    dy -= _dy;
+                }
+                else
+                {
+                    //bad recheck result... so break this and use last good coord for teleport player...
+                    dz += 0.5f;
+                    break;
+                }
+            }
         }
+            
+        //Prevent Falling during swap building/outerspace
+        unitTarget->UpdateGroundPositionZ(cx, cy, cz);
 
-        unitTarget->NearTeleportTo(fx, fy, fz, unitTarget->GetOrientation(), unitTarget == m_caster);
+        if(unitTarget->GetTypeId() == TYPEID_PLAYER)
+            ((Player*)unitTarget)->TeleportTo(mapid, cx, cy, cz, unitTarget->GetOrientation(), TELE_TO_NOT_LEAVE_COMBAT | TELE_TO_NOT_UNSUMMON_PET | (unitTarget==m_caster ? TELE_TO_SPELL : 0));
+        else
+            unitTarget->GetMap()->CreatureRelocation((Creature*)unitTarget, cx, cy, cz, unitTarget->GetOrientation());
     }
 }
 
@@ -7149,7 +8002,18 @@ void Spell::EffectCharge(SpellEffectIndex /*eff_idx*/)
     //TODO: research more ContactPoint/attack distance.
     //3.666666 instead of ATTACK_DISTANCE(5.0f) in below seem to give more accurate result.
     float x, y, z;
-    unitTarget->GetContactPoint(m_caster, x, y, z, 3.666666f);
+    unitTarget->GetContactPoint(m_caster, x, y, z, 3.6f);
+
+    // Try to normalize Z coord cuz GetContactPoint do nothing with Z axis
+    if(!m_caster->GetMap()->IsNextZcoordOK(x, y, z, 30.0f))
+    {
+        SendCastResult(SPELL_FAILED_TRY_AGAIN);
+        return;
+    }
+    m_caster->UpdateGroundPositionZ(x, y, z, 30.0f);
+
+    // Try to normalize Z coord cuz GetContactPoint do nothing with Z axis
+    unitTarget->UpdateGroundPositionZ(x, y, z, 5.0f);
 
     if (unitTarget->GetTypeId() != TYPEID_PLAYER)
         ((Creature *)unitTarget)->StopMoving();
@@ -7160,6 +8024,10 @@ void Spell::EffectCharge(SpellEffectIndex /*eff_idx*/)
     // not all charge effects used in negative spells
     if (unitTarget != m_caster && !IsPositiveSpell(m_spellInfo->Id))
         m_caster->Attack(unitTarget, true);
+        
+    // Warbringer - remove movement imparing effects for Intervene
+    if(m_caster->HasAura(57499) && m_spellInfo->Id == 3411)
+        m_caster->RemoveAurasAtMechanicImmunity(IMMUNE_TO_ROOT_AND_SNARE_MASK,57499,true);
 }
 
 void Spell::EffectCharge2(SpellEffectIndex /*eff_idx*/)
@@ -7175,10 +8043,18 @@ void Spell::EffectCharge2(SpellEffectIndex /*eff_idx*/)
             ((Creature *)unitTarget)->StopMoving();
     }
     else if (unitTarget && unitTarget != m_caster)
-        unitTarget->GetContactPoint(m_caster, x, y, z, 3.666666f);
+        unitTarget->GetContactPoint(m_caster, x, y, z, 3.6f);
     else
         return;
 
+    // Try to normalize Z coord cuz GetContactPoint do nothing with Z axis
+    if(!m_caster->GetMap()->IsNextZcoordOK(x, y, z, 30.0f))
+    {
+        SendCastResult(SPELL_FAILED_TRY_AGAIN);
+        return;
+    }
+    m_caster->UpdateGroundPositionZ(x, y, z, 30.0f);
+
     // Only send MOVEMENTFLAG_WALK_MODE, client has strange issues with other move flags
     m_caster->MonsterMove(x, y, z, 1);
 
@@ -7218,7 +8094,7 @@ void Spell::DoSummonCritter(SpellEffectIndex eff_idx, uint32 forceFaction)
     if(!critter->Create(map->GenerateLocalLowGuid(HIGHGUID_PET), map, m_caster->GetPhaseMask(),
         pet_entry, pet_number))
     {
-        sLog.outError("Spell::EffectSummonCritter, spellid %u: no such creature entry %u", m_spellInfo->Id, pet_entry);
+        DEBUG_LOG("Spell::EffectSummonCritter, spellid %u: no such creature entry %u", m_spellInfo->Id, pet_entry);
         delete critter;
         return;
     }
@@ -7240,7 +8116,7 @@ void Spell::DoSummonCritter(SpellEffectIndex eff_idx, uint32 forceFaction)
 
     if(!critter->IsPositionValid())
     {
-        sLog.outError("Pet (guidlow %d, entry %d) not summoned. Suggested coordinates isn't valid (X: %f Y: %f)",
+        DEBUG_LOG("Pet (guidlow %d, entry %d) not summoned. Suggested coordinates isn't valid (X: %f Y: %f)",
             critter->GetGUIDLow(), critter->GetEntry(), critter->GetPositionX(), critter->GetPositionY());
         delete critter;
         return;
@@ -7296,7 +8172,7 @@ void Spell::EffectPlayerPull(SpellEffectIndex eff_idx)
     if (damage && dist > damage)
         dist = float(damage);
 
-    unitTarget->KnockBackFrom(m_caster,-dist,float(m_spellInfo->EffectMiscValue[eff_idx])/10);
+    unitTarget->KnockBackFrom(m_caster,-dist,float(m_spellInfo->EffectMiscValue[eff_idx])/30);
 }
 
 void Spell::EffectDispelMechanic(SpellEffectIndex eff_idx)
@@ -7360,7 +8236,8 @@ void Spell::EffectSummonAllTotems(SpellEffectIndex eff_idx)
         if (ActionButton const* actionButton = ((Player*)m_caster)->GetActionButton(start_button+slot))
             if (actionButton->GetType()==ACTION_BUTTON_SPELL)
                 if (uint32 spell_id = actionButton->GetAction())
-                    m_caster->CastSpell(unitTarget,spell_id,true);
+					if (!((Player*)m_caster)->HasSpellCooldown(spell_id))
+						m_caster->CastSpell(unitTarget,spell_id,true);
 }
 
 void Spell::EffectDestroyAllTotems(SpellEffectIndex /*eff_idx*/)
@@ -7632,6 +8509,8 @@ void Spell::EffectSpiritHeal(SpellEffectIndex /*eff_idx*/)
 
     ((Player*)unitTarget)->ResurrectPlayer(1.0f);
     ((Player*)unitTarget)->SpawnCorpseBones();
+
+    ((Player*)unitTarget)->CastSpell(unitTarget, 6962, true);
 }
 
 // remove insignia spell effect
@@ -7668,29 +8547,33 @@ void Spell::EffectStealBeneficialBuff(SpellEffectIndex eff_idx)
     // Ok if exist some buffs for dispel try dispel it
     if (!steal_list.empty())
     {
-        std::list < std::pair<uint32,uint64> > success_list;
-        int32 list_size = steal_list.size();
+        std::list < std::pair<uint32,uint64> > success_list;// (spell_id,casterGuid)
+        std::list < uint32 > fail_list;                     // spell_id
         // Dispell N = damage buffs (or while exist buffs for dispel)
-        for (int32 count=0; count < damage && list_size > 0; ++count)
+       for (int32 count=0; count < damage && !steal_list.empty(); ++count)
         {
             // Random select buff for dispel
-            Aura *aur = steal_list[urand(0, list_size-1)];
-            // Not use chance for steal
-            // TODO possible need do it
-            success_list.push_back( std::pair<uint32,uint64>(aur->GetId(),aur->GetCasterGUID()));
+            std::vector<Aura*>::iterator steal_itr = steal_list.begin();
+            std::advance(steal_itr,urand(0, steal_list.size()-1));
 
-            // Remove buff from list for prevent doubles
-            for (std::vector<Aura *>::iterator j = steal_list.begin(); j != steal_list.end(); )
-            {
-                Aura *stealed = *j;
-                if (stealed->GetId() == aur->GetId() && stealed->GetCasterGUID() == aur->GetCasterGUID())
-                {
-                    j = steal_list.erase(j);
-                    --list_size;
-                }
-                else
-                    ++j;
-            }
+            Aura *aur = *steal_itr;
+           // remove entry from steal_list
+            steal_list.erase(steal_itr);
+
+            SpellEntry const* spellInfo = aur->GetSpellProto();
+            // Base dispel chance
+            int32 miss_chance = 0;
+            // Apply dispel mod from aura caster
+            if (Unit *caster = aur->GetCaster())
+           {
+               if ( Player* modOwner = caster->GetSpellModOwner() )
+                    modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_RESIST_DISPEL_CHANCE, miss_chance, this);
+           }
+            // Try dispel
+            if (roll_chance_i(miss_chance))
+                fail_list.push_back(spellInfo->Id);
+            else
+                success_list.push_back(std::pair<uint32,uint64>(aur->GetId(),aur->GetCasterGUID()));
         }
         // Really try steal and send log
         if (!success_list.empty())
@@ -7711,6 +8594,18 @@ void Spell::EffectStealBeneficialBuff(SpellEffectIndex eff_idx)
             }
             m_caster->SendMessageToSet(&data, true);
         }
+       // Send fail log to client
+        if (!fail_list.empty())
+        {
+            // Failed to steal
+            WorldPacket data(SMSG_DISPEL_FAILED, 8+8+4+4*fail_list.size());
+            data << uint64(m_caster->GetGUID());            // Caster GUID
+            data << uint64(unitTarget->GetGUID());          // Victim GUID
+            data << uint32(m_spellInfo->Id);                // Steal spell id
+            for (std::list< uint32 >::iterator j = fail_list.begin(); j != fail_list.end(); ++j)
+               data << uint32(*j);                         // Spell Id
+            m_caster->SendMessageToSet(&data, true);
+        }
     }
 }
 
@@ -7772,6 +8667,42 @@ void Spell::EffectRenamePet(SpellEffectIndex /*eff_idx*/)
     unitTarget->RemoveByteFlag(UNIT_FIELD_BYTES_2, 2, UNIT_CAN_BE_RENAMED);
 }
 
+void Spell::EffectSummonVehicle(SpellEffectIndex eff_idx)
+{
+    uint32 creature_entry = m_spellInfo->EffectMiscValue[eff_idx];
+    if(!creature_entry)
+        return;
+
+    float px, py, pz;
+    // If dest location if present
+    if (m_targets.m_targetMask & TARGET_FLAG_DEST_LOCATION)
+    {
+        // Summon unit in dest location
+        px = m_targets.m_destX;
+        py = m_targets.m_destY;
+        pz = m_targets.m_destZ;
+    }
+    // Summon if dest location not present near caster
+    else
+        m_caster->GetClosePoint(px,py,pz,3.0f);
+
+    Vehicle *v = m_caster->SummonVehicle(creature_entry, px, py, pz, m_caster->GetOrientation());
+    if(!v)
+        return;
+
+    v->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
+    v->SetCreatorGUID(m_caster->GetGUID());
+
+    if(damage)
+    {
+        m_caster->CastSpell(v, damage, true);
+        m_caster->EnterVehicle(v, 0);
+    }
+    int32 duration = GetSpellMaxDuration(m_spellInfo);
+    if(duration > 0)
+        v->SetSpawnDuration(duration);
+}
+
 void Spell::EffectPlayMusic(SpellEffectIndex eff_idx)
 {
     if(!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
@@ -7781,7 +8712,7 @@ void Spell::EffectPlayMusic(SpellEffectIndex eff_idx)
 
     if (!sSoundEntriesStore.LookupEntry(soundid))
     {
-        sLog.outError("EffectPlayMusic: Sound (Id: %u) not exist in spell %u.",soundid,m_spellInfo->Id);
+        DEBUG_LOG("EffectPlayMusic: Sound (Id: %u) not exist in spell %u.",soundid,m_spellInfo->Id);
         return;
     }
 
@@ -7808,6 +8739,29 @@ void Spell::EffectActivateSpec(SpellEffectIndex /*eff_idx*/)
     ((Player*)unitTarget)->ActivateSpec(spec);
 }
 
+void Spell::EffectWMODamage(SpellEffectIndex /*eff_idx*/)
+{
+    if (gameObjTarget && gameObjTarget->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        Unit *caster = m_originalCaster;
+        if (!caster)
+            return;
+
+        FactionTemplateEntry const *casterft, *goft;
+        casterft = caster->getFactionTemplateEntry();
+        goft = sFactionTemplateStore.LookupEntry(gameObjTarget->GetUInt32Value(GAMEOBJECT_FACTION));
+        // Do not allow to damage GO's of friendly factions (ie: Wintergrasp Walls)
+        if (casterft && goft && !casterft->IsFriendlyTo(*goft))
+            gameObjTarget->TakenDamage((uint32)damage, caster);
+    }
+}
+
+void Spell::EffectWMORepair(SpellEffectIndex /*i*/)
+{
+    if (gameObjTarget && gameObjTarget->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+        gameObjTarget->Rebuild();
+}
+
 void Spell::EffectBind(SpellEffectIndex eff_idx)
 {
     if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
@@ -7823,7 +8777,7 @@ void Spell::EffectBind(SpellEffectIndex eff_idx)
         SpellTargetPosition const* st = sSpellMgr.GetSpellTargetPosition(m_spellInfo->Id);
         if (!st)
         {
-            sLog.outError( "Spell::EffectBind - unknown Teleport coordinates for spell ID %u", m_spellInfo->Id );
+            DEBUG_LOG( "Spell::EffectBind - unknown Teleport coordinates for spell ID %u", m_spellInfo->Id );
             return;
         }
 
diff --git a/mangos/src/game/SpellHandler.cpp b/Core/src/game/SpellHandler.cpp
index 86ca9c7..056801f 100644
--- a/mangos/src/game/SpellHandler.cpp
+++ b/Core/src/game/SpellHandler.cpp
@@ -23,10 +23,12 @@
 #include "ObjectMgr.h"
 #include "SpellMgr.h"
 #include "Log.h"
+#include "World.h"
 #include "Opcodes.h"
 #include "Spell.h"
 #include "ScriptCalls.h"
 #include "Totem.h"
+#include "Vehicle.h"
 #include "SpellAuras.h"
 
 void WorldSession::HandleUseItemOpcode(WorldPacket& recvPacket)
@@ -305,6 +307,11 @@ void WorldSession::HandleCastSpellOpcode(WorldPacket& recvPacket)
         return;
     }
 
+    // vehicle spells are handled by CMSG_PET_CAST_SPELL,
+    // but player is still able to cast own spells
+    if(_player->GetCharmGUID() && _player->GetCharmGUID() == _player->GetVehicleGUID())
+        mover = _player;
+
     DEBUG_LOG("WORLD: got cast spell packet, spellId - %u, cast_count: %u, unk_flags %u, data length = %i",
         spellId, cast_count, unk_flags, (uint32)recvPacket.size());
 
@@ -317,6 +324,19 @@ void WorldSession::HandleCastSpellOpcode(WorldPacket& recvPacket)
         return;
     }
 
+    if (sWorld.getConfig(CONFIG_BOOL_ALLOW_FLYING_MOUNTS_EVERYWHERE))
+    {
+        if (_player->isRunningSpell(spellInfo))
+        {
+            _player->Unmount();
+            _player->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
+        }
+        else if (_player->isRunningFormSpell(spellInfo))
+        {
+            _player->RemoveFlyingSpells();
+        }
+    }
+
     if(mover->GetTypeId()==TYPEID_PLAYER)
     {
         // not have spell in spellbook or spell passive and not casted by client
@@ -407,7 +427,7 @@ void WorldSession::HandleCancelAuraOpcode( WorldPacket& recvPacket)
     if (!spellInfo)
         return;
 
-    if (spellInfo->Attributes & SPELL_ATTR_CANT_CANCEL)
+    if (spellInfo->Attributes & SPELL_ATTR_CANT_CANCEL || spellId == 56266 || IsPassiveSpell(spellId))
         return;
 
     if(!IsPositiveSpell(spellId))
@@ -446,6 +466,8 @@ void WorldSession::HandleCancelAuraOpcode( WorldPacket& recvPacket)
 
     // non channeled case
     _player->RemoveAurasDueToSpellByCancel(spellId);
+    if(_player->isFlyingSpell(spellInfo) || _player->isFlyingFormSpell(spellInfo))
+        _player->SetFlyingMountTimer();
 }
 
 void WorldSession::HandlePetCancelAuraOpcode( WorldPacket& recvPacket)
@@ -467,7 +489,7 @@ void WorldSession::HandlePetCancelAuraOpcode( WorldPacket& recvPacket)
         return;
     }
 
-    Creature* pet = GetPlayer()->GetMap()->GetCreatureOrPetOrVehicle(guid);
+    Creature* pet=ObjectAccessor::GetCreatureOrPetOrVehicle(*_player,guid);
 
     if(!pet)
     {
@@ -552,22 +574,155 @@ void WorldSession::HandleSpellClick( WorldPacket & recv_data )
     uint64 guid;
     recv_data >> guid;
 
-    if (_player->isInCombat())                              // client prevent click and set different icon at combat state
-        return;
-
     Creature *unit = _player->GetMap()->GetCreatureOrPetOrVehicle(guid);
     if (!unit || unit->isInCombat())                        // client prevent click and set different icon at combat state
         return;
 
-    SpellClickInfoMapBounds clickPair = sObjectMgr.GetSpellClickInfoMapBounds(unit->GetEntry());
-    for(SpellClickInfoMap::const_iterator itr = clickPair.first; itr != clickPair.second; ++itr)
+    uint32 vehicleId = 0;
+    CreatureDataAddon const *cainfo = unit->GetCreatureAddon();
+    if(cainfo)
+        vehicleId = cainfo->vehicle_id;
+
+    if (_player->isInCombat() && !unit->isVehicle() && !vehicleId)                              // client prevent click and set different icon at combat state
+        return;
+
+    if(!_player->IsWithinDistInMap(unit, 10))
+        return;
+
+    // cheater?
+    if(!unit->HasFlag(UNIT_NPC_FLAGS,UNIT_NPC_FLAG_SPELLCLICK))
+        return;
+
+    // handled other (hacky) way to avoid overwriting auras
+    if(vehicleId || unit->isVehicle())
     {
-        if (itr->second.IsFitToRequirements(_player))
+        if(!unit->isAlive())
+            return;
+
+        if(_player->GetVehicleGUID())
+            return;
+
+        // create vehicle if no one present and kill the original creature to avoid double, triple etc spawns
+        if(!unit->isVehicle())
         {
-            Unit *caster = (itr->second.castFlags & 0x1) ? (Unit*)_player : (Unit*)unit;
-            Unit *target = (itr->second.castFlags & 0x2) ? (Unit*)_player : (Unit*)unit;
+            Vehicle *v = _player->SummonVehicle(unit->GetEntry(), unit->GetPositionX(), unit->GetPositionY(), unit->GetPositionZ(), unit->GetOrientation(), vehicleId);
+            if(!v)
+                return;
 
-            caster->CastSpell(target, itr->second.spellId, true);
+            if(v->GetVehicleFlags() & VF_DESPAWN_NPC)
+            {
+                v->SetSpawnDuration(unit->GetRespawnDelay()*IN_MILLISECONDS);
+                unit->setDeathState(JUST_DIED);
+                unit->RemoveCorpse();
+                unit->SetHealth(0);
+            }
+            unit = v;
         }
+
+        if(((Vehicle*)unit)->GetVehicleData())
+            if(uint32 r_aura = ((Vehicle*)unit)->GetVehicleData()->req_aura)
+                if(!_player->HasAura(r_aura))
+                    return;
+
+        _player->EnterVehicle((Vehicle*)unit, 0);
+    }
+    else
+    {
+        SpellClickInfoMapBounds clickPair = sObjectMgr.GetSpellClickInfoMapBounds(unit->GetEntry());
+        for(SpellClickInfoMap::const_iterator itr = clickPair.first; itr != clickPair.second; ++itr)
+        {
+            if (itr->second.IsFitToRequirements(_player))
+            {
+                Unit *caster = (itr->second.castFlags & 0x1) ? (Unit*)_player : (Unit*)unit;
+                Unit *target = (itr->second.castFlags & 0x2) ? (Unit*)_player : (Unit*)unit;
+                            
+                caster->CastSpell(target, itr->second.spellId, true);
+            }
+        }
+    }
+}
+
+void WorldSession::HandleMirrorImageDataRequest( WorldPacket & recv_data )
+{
+    sLog.outDebug("WORLD: CMSG_GET_MIRRORIMAGE_DATA");
+    uint64 guid;
+    recv_data >> guid;
+
+    // Get unit for which data is needed by client
+    Unit *unit = ObjectAccessor::GetUnit(*_player, guid);
+    if (!unit)
+        return;
+
+    // Get creator of the unit
+    Unit *creator = ObjectAccessor::GetUnit(*_player, unit->GetCreatorGUID());
+    if (!creator)
+        creator = unit;
+
+    if (!creator)
+        return;
+
+    WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
+    data << (uint64)guid;
+    data << (uint32)creator->GetDisplayId();
+    if (creator->GetTypeId() == TYPEID_PLAYER)
+    {
+        Player* pCreator = (Player *)creator;
+        data << (uint8)pCreator->getRace();                         // race
+        data << (uint8)pCreator->getGender();                       // gender
+        data << (uint8)pCreator->getClass();                        // class
+        data << (uint8)pCreator->GetByteValue(PLAYER_BYTES, 0);     // skin
+        data << (uint8)pCreator->GetByteValue(PLAYER_BYTES, 1);     // face
+        data << (uint8)pCreator->GetByteValue(PLAYER_BYTES, 2);     // hair
+        data << (uint8)pCreator->GetByteValue(PLAYER_BYTES, 3);     // haircolor
+        data << (uint8)pCreator->GetByteValue(PLAYER_BYTES_2, 0);   // facialhair
+
+        data << (uint32)0;                                          // unknown
+
+        static const EquipmentSlots ItemSlots[] =
+        {
+            EQUIPMENT_SLOT_HEAD,
+            EQUIPMENT_SLOT_SHOULDERS,
+            EQUIPMENT_SLOT_BODY,
+            EQUIPMENT_SLOT_CHEST,
+            EQUIPMENT_SLOT_WAIST,
+            EQUIPMENT_SLOT_LEGS,
+            EQUIPMENT_SLOT_FEET,
+            EQUIPMENT_SLOT_WRISTS,
+            EQUIPMENT_SLOT_HANDS,
+            EQUIPMENT_SLOT_BACK,
+            EQUIPMENT_SLOT_TABARD,
+            EQUIPMENT_SLOT_END
+        };
+
+        // Display items in visible slots
+        for (EquipmentSlots const* itr = &ItemSlots[0]; *itr != EQUIPMENT_SLOT_END; ++itr)
+            if (Item const* item =  pCreator->GetItemByPos(INVENTORY_SLOT_BAG_0, *itr))
+                data << (uint32)item->GetProto()->DisplayInfoID;    // display id
+            else
+                data << (uint32)0;                                  // no item found, so no id
+
+        if (Item const* item = pCreator->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
+            unit->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, item->GetProto()->ItemId);
+        if (Item const* item = pCreator->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
+            unit->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, item->GetProto()->ItemId);
+    }
+    else
+    {
+        // Skip player data for creatures
+        data << (uint32)0;
+        data << (uint32)0;
+        data << (uint32)0;
+        data << (uint32)0;
+        data << (uint32)0;
+        data << (uint32)0;
+        data << (uint32)0;
+        data << (uint32)0;
+        data << (uint32)0;
+        data << (uint32)0;
+        data << (uint32)0;
+        data << (uint32)0;
+        data << (uint32)0;
+        data << (uint32)0;
     }
+    SendPacket( &data );
 }
diff --git a/mangos/src/game/SpellMgr.cpp b/Core/src/game/SpellMgr.cpp
index a4c9651..5aa6ce5 100644
--- a/mangos/src/game/SpellMgr.cpp
+++ b/Core/src/game/SpellMgr.cpp
@@ -63,19 +63,9 @@ int32 GetSpellMaxDuration(SpellEntry const *spellInfo)
 
 uint32 GetSpellCastTime(SpellEntry const* spellInfo, Spell const* spell)
 {
-    if (spell)
-    {
-        // some triggered spells have data only usable for client
-        if (spell->IsTriggeredSpellWithRedundentData())
-            return 0;
-
-        // spell targeted to non-trading trade slot item instant at trade success apply
-        if (spell->GetCaster()->GetTypeId()==TYPEID_PLAYER)
-            if (TradeData* my_trade = ((Player*)(spell->GetCaster()))->GetTradeData())
-                if (Item* nonTrade = my_trade->GetTraderData()->GetItem(TRADE_SLOT_NONTRADED))
-                    if (nonTrade == spell->m_targets.getItemTarget())
-                        return 0;
-    }
+    // some triggered spells have data only usable for client
+    if (spell && spell->IsTriggeredSpellWithRedundentData())
+        return 0;
 
     SpellCastTimesEntry const *spellCastTimeEntry = sSpellCastTimesStore.LookupEntry(spellInfo->CastingTimeIndex);
 
@@ -232,6 +222,23 @@ uint16 GetSpellAuraMaxTicks(SpellEntry const* spellInfo)
 
     return 6;
 }
+int32 ApplyHasteToChannelSpell(int32 orginalDuration, SpellEntry const* spellInfo, Spell const* spell)
+{
+    if (spell)
+    {
+        if(Player* modOwner = spell->GetCaster()->GetSpellModOwner())
+            modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_CASTING_TIME, orginalDuration, spell);
+
+        if( !(spellInfo->Attributes & (SPELL_ATTR_UNK4|SPELL_ATTR_TRADESPELL)) )
+            orginalDuration = int32(orginalDuration * spell->GetCaster()->GetFloatValue(UNIT_MOD_CAST_SPEED));
+        else
+        {
+            if (spell->IsRangedSpell() && !spell->IsAutoRepeat())
+                orginalDuration = int32(orginalDuration * spell->GetCaster()->m_modAttackSpeedPct[RANGED_ATTACK]);
+        }
+    }
+    return orginalDuration;
+}
 
 float CalculateDefaultCoefficient(SpellEntry const *spellProto, DamageEffectType const damagetype)
 {
@@ -299,6 +306,10 @@ bool IsNoStackAuraDueToAura(uint32 spellId_1, SpellEffectIndex effIndex_1, uint3
         spellInfo_1->EffectApplyAuraName[effIndex_1] != spellInfo_2->EffectApplyAuraName[effIndex_2])
         return false;
 
+    // Potion of Wild Magic stacks with everything
+    if (spellId_1 == 53909 || spellId_2 == 53909)
+      return false;
+
     return true;
 }
 
@@ -392,6 +403,14 @@ SpellSpecific GetSpellSpecific(uint32 spellId)
             // Warlock (Demon Armor | Demon Skin | Fel Armor)
             if (spellInfo->SpellFamilyFlags & UI64LIT(0x2000002000000000) || spellInfo->SpellFamilyFlags2 & 0x00000010)
                 return SPELL_WARLOCK_ARMOR;
+           
+            // Unstable Affliction & Immolate
+            if (spellInfo->SpellFamilyFlags & UI64LIT(0x10000000004))
+                return SPELL_UA_IMMOLATE;
+
+            // Unstable Affliction & Immolate
+            if (spellInfo->SpellFamilyFlags & UI64LIT(0x10000000004))
+                return SPELL_UA_IMMOLATE;
 
             break;
         }
@@ -479,6 +498,7 @@ bool IsSingleFromSpellSpecificPerTargetPerCaster(SpellSpecific spellSpec1,SpellS
         case SPELL_POSITIVE_SHOUT:
         case SPELL_JUDGEMENT:
         case SPELL_HAND:
+        case SPELL_UA_IMMOLATE:
             return spellSpec1==spellSpec2;
         default:
             return false;
@@ -602,6 +622,22 @@ bool IsPositiveEffect(uint32 spellId, SpellEffectIndex effIndex)
     SpellEntry const *spellproto = sSpellStore.LookupEntry(spellId);
     if (!spellproto) return false;
 
+    if(spellproto->Id == 56266)
+        return false;
+
+    switch(spellId)
+    {
+        case 47540:                                         // Penance start dummy aura - Rank 1
+        case 53005:                                         // Penance start dummy aura - Rank 2
+        case 53006:                                         // Penance start dummy aura - Rank 3
+        case 53007:                                         // Penance start dummy aura - Rank 4
+        case 47757:                                         // Penance heal effect trigger - Rank 1
+        case 52986:                                         // Penance heal effect trigger - Rank 2
+        case 52987:                                         // Penance heal effect trigger - Rank 3
+        case 52988:                                         // Penance heal effect trigger - Rank 4
+            return true;
+    }
+
     switch(spellproto->Effect[effIndex])
     {
         case SPELL_EFFECT_DUMMY:
@@ -674,6 +710,7 @@ bool IsPositiveEffect(uint32 spellId, SpellEffectIndex effIndex)
                         return true;                        // some expected positive spells have SPELL_ATTR_EX_NEGATIVE or unclear target modes
                     break;
                 case SPELL_AURA_ADD_TARGET_TRIGGER:
+                case SPELL_AURA_INITIALIZE_IMAGES:
                     return true;
                 case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
                     if (spellId != spellproto->EffectTriggerSpell[effIndex])
@@ -695,7 +732,16 @@ bool IsPositiveEffect(uint32 spellId, SpellEffectIndex effIndex)
                         }
                     }
                     break;
-                case SPELL_AURA_PROC_TRIGGER_SPELL:
+                case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
+                    {
+                        if(spellproto->SpellFamilyName == SPELLFAMILY_PRIEST && spellproto->SpellIconID == 548)
+                            return false;
+                    }
+                    //Vortex
+                     if(spellproto->Id == 56266)
+                         return false;
+                    break;
+                    case SPELL_AURA_PROC_TRIGGER_SPELL:
                     // many positive auras have negative triggered spells at damage for example and this not make it negative (it can be canceled for example)
                     break;
                 case SPELL_AURA_MOD_STUN:                   //have positive and negative spells, we can't sort its correctly at this moment.
@@ -752,6 +798,7 @@ bool IsPositiveEffect(uint32 spellId, SpellEffectIndex effIndex)
                     switch(spellproto->Id)
                     {
                         case 802:                           // Mutate Bug, wrongly negative by target modes
+                        case 47747:                         // Charge Rifts, Nexus: Nexus (boss_anomalus)
                             return true;
                         case 36900:                         // Soul Split: Evil!
                         case 36901:                         // Soul Split: Good
@@ -792,6 +839,11 @@ bool IsPositiveEffect(uint32 spellId, SpellEffectIndex effIndex)
                     if(spellproto->Id==42792)               // Recently Dropped Flag (prevent cancel)
                         return false;
                     break;
+                case SPELL_AURA_CONTROL_VEHICLE:
+                    //Vortex
+                    if(spellproto->Id == 56266)
+                        return false;
+                    break;
                 default:
                     break;
             }
@@ -1668,6 +1720,15 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
     if ((spellInfo_1->Attributes & SPELL_ATTR_PASSIVE)!=(spellInfo_2->Attributes & SPELL_ATTR_PASSIVE))
         return false;
 
+    //NOTHING can remove 66233 
+    if (spellInfo_1->Id == 66233 || spellInfo_2->Id == 66233) 
+        return false;
+
+    //Renewed hope and gift of the naaru(have diff spell families)
+    if (spellInfo_2->SpellIconID == 329 && spellInfo_2->SpellFamilyName == SPELLFAMILY_PRIEST &&
+        spellInfo_1->SpellIconID == 329 && spellInfo_1->SpellVisual[0] == 7625)
+        return false;
+
     // Specific spell family spells
     switch(spellInfo_1->SpellFamilyName)
     {
@@ -1676,6 +1737,24 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
             {
                 case SPELLFAMILY_GENERIC:                   // same family case
                 {
+                    // Charge Rift spells (boss_anomalus instance Nexus: Nexus)
+                    if (spellInfo_1->SpellVisual[0] == 7921 || spellInfo_2->SpellVisual[0] == 7921)
+                        return false;
+ 
+                    // Summon Telestra Clones (visual aura) - instance Nexus 
+                    if (spellInfo_1->Id == 47710 || spellInfo_2->Id == 47710)
+                        return false;
+ 
+                    // Dark Essence & Light Essence
+                    if ((spellInfo_1->Id == 65684 && spellInfo_2->Id == 65686) ||
+                        (spellInfo_2->Id == 65684 && spellInfo_1->Id == 65686))
+                        return true;
+
+                    // Potent Fungus and Mini must remove each other (Amanitar encounter, Ahn'kahet)
+                    if ((spellInfo_1->Id == 57055 && spellInfo_2->Id == 56648) ||
+                        (spellInfo_2->Id == 57055 && spellInfo_1->Id == 56648))
+                        return true;
+
                     // Thunderfury
                     if ((spellInfo_1->Id == 21992 && spellInfo_2->Id == 27648) ||
                         (spellInfo_2->Id == 21992 && spellInfo_1->Id == 27648))
@@ -1724,12 +1803,38 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
                     if( spellInfo_1->SpellIconID == 3559 && spellInfo_2->SpellIconID == 3559 )
                         return false;
 
+                    // Solace of the Defeated Heroic & Normal versions
+                    if( (spellInfo_1->Id == 67696 && spellInfo_2->Id == 67750) ||
+                        (spellInfo_2->Id == 67696 && spellInfo_1->Id == 67750) )
+                        return false;
+                    
+                    // All flame tsunami spells (Obsidian Sanctum)
+                    if(spellInfo_1->SpellIconID == 3087 && spellInfo_2->SpellIconID == 3087)
+                        return false;
+
+                    // Blue Flame Shield and Blue Power Focus (more generic rule needed for all spells with dummy auras)
+                    if( (spellInfo_1->Id == 46796 && spellInfo_2->Id == 46789) ||
+                        (spellInfo_2->Id == 46796 && spellInfo_1->Id == 46789) )
+                         return false;
+
+                    // Blue Flame Shield and Blue Power Focus (more generic rule needed for all spells with dummy auras)
+                    if( (spellInfo_1->Id == 46796 && spellInfo_2->Id == 46789) ||
+                        (spellInfo_2->Id == 46796 && spellInfo_1->Id == 46789) )
+                        return false;
                     break;
                 }
                 case SPELLFAMILY_MAGE:
                     // Arcane Intellect and Insight
                     if( spellInfo_2->SpellIconID == 125 && spellInfo_1->Id == 18820 )
                         return false;
+						
+					// Ignite and Molten
+					if (spellInfo_2->Id == 12654 && spellInfo_1->SpellIconID == 937)
+					    return false;
+
+                    //Mirror image frostbolt and mage frostbolt
+                    if( spellInfo_2->SpellIconID == 188 && spellInfo_1->Id == 59638 )
+                        return false;
                     break;
                 case SPELLFAMILY_WARRIOR:
                 {
@@ -1743,6 +1848,21 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
 
                     break;
                 }
+                case SPELLFAMILY_PRIEST:
+                {
+                    // Runescroll of Fortitude & Prayer/PW  Fortitude
+                    if (spellInfo_1->Id == 72590 && spellInfo_2->SpellVisual[0] == 278)
+                        return true;
+
+                    // Berserking/Enrage PvE spells and Mind Trauma
+                    if(spellInfo_1->SpellIconID == 95 && spellInfo_2->Id == 48301)
+                        return false;
+                    // Last Stand and Weakened Soul (multi-family check)
+                    if( spellInfo_1->Id == 12976 && spellInfo_2->Id == 6788 )
+                        return false;
+
+                    break;
+                }
                 case SPELLFAMILY_DRUID:
                 {
                     // Scroll of Stamina and Leader of the Pack (multi-family check)
@@ -1753,6 +1873,10 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
                     if (spellId_1 == 40216 && spellId_2 == 42016 )
                         return false;
 
+                    // Leeching Swarm and Insect Swarm
+                    if ( spellInfo_1->SpellIconID == 1771 && spellInfo_1->SpellVisual[0] == 0 && spellInfo_2->SpellIconID == 1771 )
+                        return false;
+
                     break;
                 }
                 case SPELLFAMILY_ROGUE:
@@ -1761,6 +1885,10 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
                     if( spellInfo_1->SpellIconID == 498 && spellInfo_1->SpellVisual[0] == 0 && spellInfo_2->SpellIconID == 498  )
                         return false;
 
+                    // Killing Spree
+                    if( spellInfo_1->Id == 61851 && spellInfo_2->Id == 51690)
+                        return false;
+
                     break;
                 }
                 case SPELLFAMILY_HUNTER:
@@ -1798,6 +1926,11 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
         case SPELLFAMILY_MAGE:
             if( spellInfo_2->SpellFamilyName == SPELLFAMILY_MAGE )
             {
+                // Living Bomb & Ignite
+                if( (spellInfo_1->SpellIconID == 3000) && (spellInfo_2->SpellIconID == 937) ||
+                    (spellInfo_2->SpellIconID == 3000) && (spellInfo_1->SpellIconID == 937) )
+                    return false;
+
                 // Blizzard & Chilled (and some other stacked with blizzard spells
                 if( (spellInfo_1->SpellFamilyFlags & UI64LIT(0x80)) && (spellInfo_2->SpellFamilyFlags & UI64LIT(0x100000)) ||
                     (spellInfo_2->SpellFamilyFlags & UI64LIT(0x80)) && (spellInfo_1->SpellFamilyFlags & UI64LIT(0x100000)) )
@@ -1808,6 +1941,10 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
                     (spellInfo_2->SpellFamilyFlags & UI64LIT(0x0000000000010000)) && (spellInfo_1->SpellVisual[0] == 72 && spellInfo_1->SpellIconID == 1499) )
                     return false;
 
+                // Fingers of Frost effects
+                if( spellInfo_1->SpellIconID == 2947 && spellInfo_2->SpellIconID == 2947)
+                    return false;
+
                 // Living Bomb & Ignite (Dots)
                 if( (spellInfo_1->SpellFamilyFlags & UI64LIT(0x2000000000000)) && (spellInfo_2->SpellFamilyFlags & UI64LIT(0x8000000)) ||
                     (spellInfo_2->SpellFamilyFlags & UI64LIT(0x2000000000000)) && (spellInfo_1->SpellFamilyFlags & UI64LIT(0x8000000)) )
@@ -1817,6 +1954,30 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
                 if( (spellInfo_1->SpellFamilyFlags & UI64LIT(0x1)) && (spellInfo_2->SpellFamilyFlags & UI64LIT(0x400000)) ||
                     (spellInfo_2->SpellFamilyFlags & UI64LIT(0x1)) && (spellInfo_1->SpellFamilyFlags & UI64LIT(0x400000)) )
                     return false;
+
+                // Arcane Intellect and Dalaran Intellect
+                if( (spellInfo_1->SpellFamilyFlags & UI64LIT(0x400)) && (spellInfo_2->SpellFamilyFlags & UI64LIT(0x400)) )
+                    return true;
+
+                //Focus magic 30min buff and 10s proc
+                if( (spellInfo_1->Id == 54648) && (spellInfo_2->Id == 54646) ||
+                    (spellInfo_2->Id == 54648) && (spellInfo_1->Id == 54646) )
+                    return false;
+
+                //Focus magic(30 min buff) and Praxis (T8 set bonus)
+                if( (spellInfo_1->Id == 54646) && (spellInfo_2->Id == 64868) ||
+                    (spellInfo_2->Id == 54646) && (spellInfo_1->Id == 64868) )
+                    return false;
+
+                //Focus magic(10s buff) and Praxis (T8 set bonus)
+                if( (spellInfo_1->Id == 54648) && (spellInfo_2->Id == 64868) ||
+                    (spellInfo_2->Id == 54648) && (spellInfo_1->Id == 64868) )
+                    return false;
+
+                //Improved scorch and Winter's Chill
+                if( (spellInfo_1->Id == 22959) && (spellInfo_2->Id == 12579) ||
+                    (spellInfo_2->Id == 22959) && (spellInfo_1->Id == 12579) )
+                    return false;
             }
             // Detect Invisibility and Mana Shield (multi-family check)
             if( spellInfo_2->Id == 132 && spellInfo_1->SpellIconID == 209 && spellInfo_1->SpellVisual[0] == 968 )
@@ -1829,7 +1990,10 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
             // Arcane Intellect and Insight
             if( spellInfo_1->SpellIconID == 125 && spellInfo_2->Id == 18820 )
                 return false;
-
+			
+			// Ignite and Molten
+			if (spellInfo_1->Id == 12654 && spellInfo_2->SpellIconID == 937)
+			    return false;
             break;
         case SPELLFAMILY_WARLOCK:
             if( spellInfo_2->SpellFamilyName == SPELLFAMILY_WARLOCK )
@@ -1855,9 +2019,23 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
                     (spellInfo_2->SpellIconID == 313 || spellInfo_2->SpellIconID == 2039) && (spellInfo_1->SpellIconID == 544  || spellInfo_1->SpellIconID == 91) )
                     return false;
 
+                // Shadowflame and Curse of Agony
+                if (((spellInfo_1->SpellFamilyFlags2 & 0x2) && spellInfo_2->SpellIconID == 544) ||
+                    ((spellInfo_2->SpellFamilyFlags2 & 0x2) && spellInfo_1->SpellIconID == 544))
+                    return false;
+
+                // Shadowflame and Corruption
+                if (((spellInfo_1->SpellFamilyFlags2 & 0x2) && spellInfo_2->SpellIconID == 313) ||
+                    ((spellInfo_2->SpellFamilyFlags2 & 0x2) && spellInfo_1->SpellIconID == 313))
+                    return false;
+
                 // Metamorphosis, diff effects
                 if (spellInfo_1->SpellIconID == 3314 && spellInfo_2->SpellIconID == 3314)
                     return false;
+
+                // Nether Protection effects
+                if( spellInfo_2->SpellIconID == 1985 && spellInfo_1->SpellIconID == 1985 && spellInfo_1->SpellVisual[0] == 9750 )
+                    return false;
             }
             // Detect Invisibility and Mana Shield (multi-family check)
             if( spellInfo_1->Id == 132 && spellInfo_2->SpellIconID == 209 && spellInfo_2->SpellVisual[0] == 968 )
@@ -1875,6 +2053,11 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
                 if( (spellInfo_1->SpellIconID == 456 && spellInfo_2->SpellIconID == 2006) ||
                     (spellInfo_2->SpellIconID == 456 && spellInfo_1->SpellIconID == 2006) )
                     return false;
+
+                // Taste of Blood and Sudden Death
+                if( (spellInfo_1->Id == 52437 && spellInfo_2->Id == 60503) ||
+                    (spellInfo_2->Id == 52437 && spellInfo_1->Id == 60503) )
+                    return false;
             }
 
             // Hamstring -> Improved Hamstring (multi-family check)
@@ -1893,6 +2076,14 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
         case SPELLFAMILY_PRIEST:
             if( spellInfo_2->SpellFamilyName == SPELLFAMILY_PRIEST )
             {
+                // Runescroll of Fortitude & Prayer/PW  Fortitude
+                if (spellInfo_1->Id == 72590 && spellInfo_2->SpellVisual[0] == 278)
+                     return true;
+
+                // Berserking/Enrage PvE spells and Mind Trauma
+                if(spellInfo_1->SpellIconID == 95 && spellInfo_2->Id == 48301)
+                    return false;
+            
                 //Devouring Plague and Shadow Vulnerability
                 if ((spellInfo_1->SpellFamilyFlags & UI64LIT(0x2000000)) && (spellInfo_2->SpellFamilyFlags & UI64LIT(0x800000000)) ||
                     (spellInfo_2->SpellFamilyFlags & UI64LIT(0x2000000)) && (spellInfo_1->SpellFamilyFlags & UI64LIT(0x800000000)))
@@ -1906,7 +2097,39 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
                 if ((spellInfo_1->Id == 47585 && spellInfo_2->Id == 60069) ||
                     (spellInfo_2->Id == 47585 && spellInfo_1->Id == 60069))
                     return false;
+                // Power Word: Shield and Divine Aegis
+                if ((spellInfo_1->SpellIconID == 566 && spellInfo_2->SpellIconID == 2820) ||
+                    (spellInfo_2->SpellIconID == 566 && spellInfo_1->SpellIconID == 2820))
+                    return false;
+                // Shadowform
+                if ((spellInfo_1->Id == 15473 && spellInfo_2->Id == 49868) ||
+                    (spellInfo_2->Id == 15473 && spellInfo_1->Id == 49868))
+                    return false;
+                if ((spellInfo_1->Id == 15473 && spellInfo_2->Id == 71167) ||
+                    (spellInfo_2->Id == 15473 && spellInfo_1->Id == 71167))
+                    return false;
+
+                if ((spellInfo_1->Id == 49868 && spellInfo_2->Id == 71167) ||
+                    (spellInfo_2->Id == 49868 && spellInfo_1->Id == 71167))
+                    return false;
+  
+            }
+            else if (spellInfo_2->SpellFamilyName == SPELLFAMILY_GENERIC)
+            {
+                // Mind Trauma and Berserk/Enrage (PvE spells)
+                if(spellInfo_1->Id == 48301 && spellInfo_2->SpellIconID == 95)
+                    return false;
+
+                // Prayer/PW  Fortitude && Runescroll of Fortitude
+                if (spellInfo_1->SpellVisual[0] == 278 && spellInfo_2->Id == 72590)
+                    return true;
             }
+            // Weakened Soul and Last Stand (multi-family check)
+            if (spellInfo_1->Id == 6788 && spellInfo_2->Id == 12976)
+                return false;
+            //Renewed hope and gift of the naaru(have diff spell families)
+            else if (spellInfo_1->SpellIconID == 329 && spellInfo_2->SpellIconID == 329 && spellInfo_2->SpellVisual[0] == 7625)
+                return false;
             break;
         case SPELLFAMILY_DRUID:
             if( spellInfo_2->SpellFamilyName == SPELLFAMILY_DRUID )
@@ -1998,11 +2221,22 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
                 if( (spellInfo_1->SpellFamilyFlags & UI64LIT(0x4)) && (spellInfo_2->SpellFamilyFlags & UI64LIT(0x00000004000)) ||
                     (spellInfo_2->SpellFamilyFlags & UI64LIT(0x4)) && (spellInfo_1->SpellFamilyFlags & UI64LIT(0x00000004000)) )
                     return false;
+                    
+                // Deterrence
+                if( spellInfo_1->SpellIconID == 83 && spellInfo_2->SpellIconID == 83 )
+                    return false;
+
+                // Deterrence
+                if( spellInfo_1->SpellIconID == 83 && spellInfo_2->SpellIconID == 83 )
+                    return false;
 
                 // Bestial Wrath
                 if( spellInfo_1->SpellIconID == 1680 && spellInfo_2->SpellIconID == 1680 )
                     return false;
             }
+            // Repentance and Track Humanoids
+            if (spellInfo_2->SpellFamilyName == SPELLFAMILY_PALADIN && spellInfo_1->SpellIconID == 316 && spellInfo_2->SpellIconID == 316)
+                    return false;			
 
             // Wing Clip -> Improved Wing Clip (multi-family check)
             if( (spellInfo_1->SpellFamilyFlags & UI64LIT(0x40)) && spellInfo_2->Id == 19229 )
@@ -2019,6 +2253,10 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
                 if (IsSealSpell(spellInfo_1) && IsSealSpell(spellInfo_2))
                     return true;
 
+                // Repentance removes Righteous Vengeance
+                if (spellInfo_1->Id == 20066 && spellInfo_2->Id == 61840)
+                    return true;
+
                 // Swift Retribution / Improved Devotion Aura (talents) and Paladin Auras
                 if ((spellInfo_1->SpellFamilyFlags2 & 0x00000020) && (spellInfo_2->SpellIconID == 291 || spellInfo_2->SpellIconID == 3028) ||
                     (spellInfo_2->SpellFamilyFlags2 & 0x00000020) && (spellInfo_1->SpellIconID == 291 || spellInfo_1->SpellIconID == 3028))
@@ -2039,12 +2277,37 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
                 // Divine Sacrifice and Divine Guardian
                 if (spellInfo_1->SpellIconID == 3837 && spellInfo_2->SpellIconID == 3837)
                     return false;
-            }
+
+                // Sacred Shield and Blessing of Sanctuary
+                if ((( spellInfo_1->SpellFamilyFlags & UI64LIT(0x0008000000000000)) &&
+                    (spellInfo_2->Id == 25899 || spellInfo_2->Id == 20911)) ||
+                    (( spellInfo_2->SpellFamilyFlags & UI64LIT(0x0008000000000000))
+                    && (spellInfo_1->Id == 25899 || spellInfo_1->Id == 20911)))
+                    return false;
+                    
+                // Seal of Corruption/Vengeance DoT and Righteouss Fury
+                if ((spellInfo_1->SpellIconID == 3025 && spellInfo_2->SpellIconID == 2292) ||
+                    (spellInfo_1->SpellIconID == 2292 && spellInfo_2->SpellIconID == 3025))
+                    return false;
+
+                // Repentance removes Righteous Vengeance
+                if (spellInfo_1->Id == 20066 && spellInfo_2->Id == 61840)
+                    return true;				
+                    
+                // Seal of Vengeance/Corruption and Righteous Vengeance
+                if (spellInfo_1->SpellIconID == 2292 && spellInfo_2->SpellIconID == 3025 ||
+                    spellInfo_2->SpellIconID == 2292 && spellInfo_1->SpellIconID == 3025)
+                    return false;            }
 
             // Blessing of Sanctuary (multi-family check, some from 16 spell icon spells)
             if (spellInfo_2->Id == 67480 && spellInfo_1->Id == 20911)
                 return false;
 
+            // Inner Fire and Consecration
+            if(spellInfo_2->SpellFamilyName == SPELLFAMILY_PRIEST)
+                if(spellInfo_1->SpellIconID == 51 && spellInfo_2->SpellIconID == 51)
+                return false;
+
             // Combustion and Fire Protection Aura (multi-family check)
             if( spellInfo_2->Id == 11129 && spellInfo_1->SpellIconID == 33 && spellInfo_1->SpellVisual[0] == 321 )
                 return false;
@@ -2056,7 +2319,23 @@ bool SpellMgr::IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) cons
             // *Seal of Command and Band of Eternal Champion (multi-family check)
             if( spellInfo_1->SpellIconID==561 && spellInfo_1->SpellVisual[0]==7992 && spellId_2 == 35081)
                 return false;
-            break;
+            
+            // Devotion Aura and Essence of Gossamer
+            if (spellInfo_1->SpellIconID == 291 && spellInfo_2->SpellIconID == 291 && spellInfo_2->SpellFamilyName == SPELLFAMILY_GENERIC)
+                return false;
+            
+            // Inner Fire and Consecration
+            if (spellInfo_1->SpellIconID == 51 && spellInfo_2->SpellIconID == 51 && spellInfo_2->SpellFamilyName == SPELLFAMILY_PRIEST)
+                return false;
+            
+            // Repentance and Track Humanoids
+            if (spellInfo_2->SpellFamilyName == SPELLFAMILY_HUNTER && spellInfo_1->SpellIconID == 316 && spellInfo_2->SpellIconID == 316)
+                return false;			
+
+            // [Greater] Blessing of Kings and Blessing of Forgotten Kings
+            if ((spellId_1 == 20217 || spellId_1 == 25898) && spellId_2 == 69378)
+              return true;
+              break; 
         case SPELLFAMILY_SHAMAN:
             if( spellInfo_2->SpellFamilyName == SPELLFAMILY_SHAMAN )
             {
@@ -2326,7 +2605,7 @@ void SpellMgr::LoadSpellChains()
 
         if (mSpellChains.find(spell_id) != mSpellChains.end())
         {
-            sLog.outErrorDb("Spell %u already added (talent?) and non need in `spell_chain`",spell_id);
+            sLog.outErrorDb("Spell %u already added (talent?) and not needed in `spell_chain`",spell_id);
             continue;
         }
 
@@ -3314,6 +3593,28 @@ void SpellMgr::LoadSpellAreas()
 
 SpellCastResult SpellMgr::GetSpellAllowedInLocationError(SpellEntry const *spellInfo, uint32 map_id, uint32 zone_id, uint32 area_id, Player const* player)
 {
+    if (sWorld.getConfig(CONFIG_BOOL_ALLOW_FLYING_MOUNTS_EVERYWHERE))
+    {
+        if(player && (player->isFlyingSpell(spellInfo) || player->isFlyingFormSpell(spellInfo)))
+        {
+            uint32 v_map = GetVirtualMapForMapAndZone(map_id, zone_id);
+            MapEntry const* mapEntry = sMapStore.LookupEntry(v_map);
+            if(!mapEntry)
+                return SPELL_FAILED_NOT_HERE;
+            /*else if(mapEntry->Instanceable())
+                return SPELL_FAILED_NOT_HERE;*/
+            else if(mapEntry->IsDungeon())
+                return SPELL_FAILED_NOT_HERE;
+            else if(mapEntry->IsRaid())
+                return SPELL_FAILED_NOT_HERE;
+            else if(mapEntry->IsBattleArena())
+                return SPELL_FAILED_NOT_HERE;
+            else if(mapEntry->IsBattleGround())
+                return SPELL_FAILED_NOT_HERE;
+            else
+                return SPELL_CAST_OK;
+        }
+    }
     // normal case
     if (spellInfo->AreaGroupId > 0)
     {
@@ -3364,15 +3665,22 @@ SpellCastResult SpellMgr::GetSpellAllowedInLocationError(SpellEntry const *spell
     }
 
     // bg spell checks
-
-    // do not allow spells to be cast in arenas
-    // - with SPELL_ATTR_EX4_NOT_USABLE_IN_ARENA flag
-    // - with greater than 10 min CD
-    if ((spellInfo->AttributesEx4 & SPELL_ATTR_EX4_NOT_USABLE_IN_ARENA) ||
-         (GetSpellRecoveryTime(spellInfo) > 10 * MINUTE * IN_MILLISECONDS && !(spellInfo->AttributesEx4 & SPELL_ATTR_EX4_USABLE_IN_ARENA)))
-        if (player && player->InArena())
+    if(player && player->InArena())
+    {
+        // do not allow spells to be cast in arenas
+        // - with SPELL_ATTR_EX4_NOT_USABLE_IN_ARENA flag
+        // - with greater than 15 min CD
+        if ((spellInfo->AttributesEx4 & SPELL_ATTR_EX4_NOT_USABLE_IN_ARENA) ||
+            (GetSpellRecoveryTime(spellInfo) > 15 * MINUTE * IN_MILLISECONDS && !(spellInfo->AttributesEx4 & SPELL_ATTR_EX4_USABLE_IN_ARENA)))   
             return SPELL_FAILED_NOT_IN_ARENA;
 
+        for(int i = EFFECT_INDEX_0; i < MAX_EFFECT_INDEX; ++i)
+        {
+            if((spellInfo->Effect[i] == SPELL_EFFECT_RESURRECT) || (spellInfo->Effect[i] == SPELL_EFFECT_RESURRECT_NEW))
+                return SPELL_FAILED_NOT_IN_ARENA;
+        }
+    }
+
     // Spell casted only on battleground
     if ((spellInfo->AttributesEx3 & SPELL_ATTR_EX3_BATTLEGROUND))
         if (!player || !player->InBattleGround())
diff --git a/mangos/src/game/SpellMgr.h b/Core/src/game/SpellMgr.h
index 0108e78..5491d3a 100644
--- a/mangos/src/game/SpellMgr.h
+++ b/Core/src/game/SpellMgr.h
@@ -103,6 +103,7 @@ enum SpellSpecific
     SPELL_FOOD              = 20,
     SPELL_DRINK             = 21,
     SPELL_FOOD_AND_DRINK    = 22,
+    SPELL_UA_IMMOLATE       = 23,
 };
 
 SpellSpecific GetSpellSpecific(uint32 spellId);
@@ -442,7 +443,7 @@ inline uint32 GetDispellMask(DispelType dispel)
     else
         return (1 << dispel);
 }
-
+int32 ApplyHasteToChannelSpell(int32 orginalDuration, SpellEntry const* spellInfo, Spell const* spell);
 // Diminishing Returns interaction with spells
 DiminishingGroup GetDiminishingReturnsGroupForSpell(SpellEntry const* spellproto, bool triggered);
 bool IsDiminishingReturnsGroupDurationLimited(DiminishingGroup group);
@@ -902,6 +903,16 @@ class SpellMgr
             return false;
         }
 
+        uint8 IsHighestRankOfSpell(uint32 spell) const
+        {
+            SpellChainMapNext::const_iterator itr = mSpellChainsNext.find(spell);
+
+            if (!(itr == mSpellChainsNext.end()) && (itr->second)) // the spell is in the chain list and a higher-rank spell is available
+                return false;
+            else
+                return true;
+        }
+
         bool IsRankSpellDueToSpell(SpellEntry const *spellInfo_1,uint32 spellId_2) const;
         static bool canStackSpellRanks(SpellEntry const *spellInfo);
         bool IsNoStackSpellDueToSpell(uint32 spellId_1, uint32 spellId_2) const;
@@ -1039,6 +1050,13 @@ class SpellMgr
         void LoadPetDefaultSpells();
         void LoadSpellAreas();
 
+        // DEVELOPMENT CODE START 
+        void LoadSpellStack(); 
+        void LoadSpellStackGroup(); 
+        // DEVELOPMENT CODE END
+
+        void ApplySpellHacks();
+
     private:
         SpellScriptTarget  mSpellScriptTarget;
         SpellChainMap      mSpellChains;
diff --git a/mangos/src/game/StatSystem.cpp b/Core/src/game/StatSystem.cpp
index f6e30e1..eedade6 100644
--- a/mangos/src/game/StatSystem.cpp
+++ b/Core/src/game/StatSystem.cpp
@@ -39,11 +39,18 @@ bool Player::UpdateStats(Stats stat)
 
     SetStat(stat, int32(value));
 
-    if(stat == STAT_STAMINA || stat == STAT_INTELLECT)
+    if(stat == STAT_STAMINA || stat == STAT_INTELLECT || stat == STAT_STRENGTH)
     {
         Pet *pet = GetPet();
         if(pet)
+        {
             pet->UpdateStats(stat);
+            if (getClass() == CLASS_DEATH_KNIGHT && pet->getPetType() == SUMMON_PET)
+            {
+                pet->RemoveAllAuras();
+                pet->CastPetAuras(true);
+            }
+        }
     }
 
     switch(stat)
@@ -103,7 +110,7 @@ void Player::ApplySpellPowerBonus(int32 amount, bool apply)
 
 void Player::UpdateSpellDamageAndHealingBonus()
 {
-    // Magic damage modifiers implemented in Unit::SpellDamageBonusDone
+    // Magic damage modifiers implemented in Unit::SpellDamageBonus
     // This information for client side use only
     // Get healing bonus for all schools
     SetStatInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_ALL));
@@ -875,9 +882,18 @@ bool Pet::UpdateStats(Stats stat)
     Unit *owner = GetOwner();
     if ( stat == STAT_STAMINA )
     {
-        if(owner)
+        if(owner && owner->GetTypeId() == TYPEID_PLAYER  && owner->getClass() == CLASS_WARLOCK)
+            value += float(owner->GetStat(stat)) * 0.75f;
+        else if (owner)
             value += float(owner->GetStat(stat)) * 0.3f;
     }
+	else if ( stat == STAT_STRENGTH && getPetType() == SUMMON_PET )
+    {
+        if (owner && (owner->getClass() == CLASS_DEATH_KNIGHT))
+        {
+            value += float(owner->GetStat(stat)) * 1.0f;
+        }
+    }
                                                             //warlock's and mage's pets gain 30% of owner's intellect
     else if ( stat == STAT_INTELLECT && getPetType() == SUMMON_PET )
     {
@@ -956,10 +972,22 @@ void Pet::UpdateMaxHealth()
 {
     UnitMods unitMod = UNIT_MOD_HEALTH;
     float stamina = GetStat(STAT_STAMINA) - GetCreateStat(STAT_STAMINA);
+    float multiplicator;
+
+    // nesocips warlock pet stats calculation
+    switch(GetEntry())
+    {
+        case 416:   multiplicator = 8.4f;  break; // imp
+        case 1860:                                // voidwalker
+        case 17252: multiplicator = 11.0f; break; // felguard
+        case 1863:  multiplicator = 9.1f;  break; // succubus
+        case 417:   multiplicator = 9.5f;  break; // felhunter
+        default:    multiplicator = 10.0f; break;
+    }
 
     float value   = GetModifierValue(unitMod, BASE_VALUE) + GetCreateHealth();
     value  *= GetModifierValue(unitMod, BASE_PCT);
-    value  += GetModifierValue(unitMod, TOTAL_VALUE) + stamina * 10.0f;
+    value  += GetModifierValue(unitMod, TOTAL_VALUE) + stamina * multiplicator;
     value  *= GetModifierValue(unitMod, TOTAL_PCT);
 
     SetMaxHealth((uint32)value);
@@ -970,10 +998,22 @@ void Pet::UpdateMaxPower(Powers power)
     UnitMods unitMod = UnitMods(UNIT_MOD_POWER_START + power);
 
     float addValue = (power == POWER_MANA) ? GetStat(STAT_INTELLECT) - GetCreateStat(STAT_INTELLECT) : 0.0f;
+    float multiplicator;
+
+    // nesocips warlock pet stats calculation
+    switch(GetEntry())
+    {
+        case 416:   multiplicator = 4.95f; break; // imp
+        case 1860:                                // voidwalker
+        case 1863:                                // succubus
+        case 417:                                 // felhunter
+        case 17252: multiplicator = 11.5f; break; // felguard
+        default:    multiplicator = 15.0f; break;
+    }
 
     float value  = GetModifierValue(unitMod, BASE_VALUE) + GetCreatePowers(power);
     value *= GetModifierValue(unitMod, BASE_PCT);
-    value += GetModifierValue(unitMod, TOTAL_VALUE) +  addValue * 15.0f;
+    value += GetModifierValue(unitMod, TOTAL_VALUE) + addValue * multiplicator;
     value *= GetModifierValue(unitMod, TOTAL_PCT);
 
     SetMaxPower(power, uint32(value));
@@ -1001,6 +1041,12 @@ void Pet::UpdateAttackPowerAndDamage(bool ranged)
             bonusAP = owner->GetTotalAttackPowerValue(RANGED_ATTACK) * 0.22f;
             SetBonusDamage( int32(owner->GetTotalAttackPowerValue(RANGED_ATTACK) * 0.1287f));
         }
+        //ghouls benefit from deathknight's attack power
+        else if(getPetType() == SUMMON_PET && owner->getClass() == CLASS_DEATH_KNIGHT)
+        {
+            bonusAP = owner->GetTotalAttackPowerValue(BASE_ATTACK) * 0.82f;
+            SetBonusDamage( int32(owner->GetTotalAttackPowerValue(BASE_ATTACK) * 0.8287f));
+        }
         //demons benefit from warlocks shadow or fire damage
         else if(getPetType() == SUMMON_PET && owner->getClass() == CLASS_WARLOCK)
         {
diff --git a/mangos/src/game/TaxiHandler.cpp b/Core/src/game/TaxiHandler.cpp
index 18eac6b..404ab10 100644
--- a/mangos/src/game/TaxiHandler.cpp
+++ b/Core/src/game/TaxiHandler.cpp
@@ -117,7 +117,7 @@ void WorldSession::SendDoFlight( uint32 mountDisplayId, uint32 path, uint32 path
     if (GetPlayer()->hasUnitState(UNIT_STAT_DIED))
         GetPlayer()->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
 
-    while(GetPlayer()->GetMotionMaster()->GetCurrentMovementGeneratorType()==FLIGHT_MOTION_TYPE)
+    while(GetPlayer()->GetMotionMaster()->GetCurrentMovementGeneratorType()==FLIGHT_MOTION_TYPE) 
         GetPlayer()->GetMotionMaster()->MovementExpired(false);
 
     if (mountDisplayId)
@@ -198,6 +198,7 @@ void WorldSession::HandleMoveSplineDoneOpcode(WorldPacket& recv_data)
     // 1) end taxi path in far (multi-node) flight
     // 2) switch from one map to other in case multi-map taxi path
     // we need process only (1)
+
     uint32 curDest = GetPlayer()->m_taxi.GetTaxiDestination();
     if(!curDest)
         return;
diff --git a/mangos/src/game/TemporarySummon.cpp b/Core/src/game/TemporarySummon.cpp
index 184ea0e..ac4f94e 100644
--- a/mangos/src/game/TemporarySummon.cpp
+++ b/Core/src/game/TemporarySummon.cpp
@@ -104,18 +104,13 @@ void TemporarySummon::Update( uint32 diff )
                 return;
             }
 
-            if (!isInCombat())
+            if (m_timer <= diff)
             {
-                if (m_timer <= diff)
-                {
-                    UnSummon();
-                    return;
-                }
-                else
-                    m_timer -= diff;
+                UnSummon();
+                return;
             }
-            else if (m_timer != m_lifetime)
-                m_timer = m_lifetime;
+            else
+                m_timer -= diff;
             break;
         }
         case TEMPSUMMON_TIMED_OR_DEAD_DESPAWN:
@@ -127,18 +122,13 @@ void TemporarySummon::Update( uint32 diff )
                 return;
             }
 
-            if (!isInCombat() && isAlive() )
+            if (m_timer <= diff)
             {
-                if (m_timer <= diff)
-                {
-                    UnSummon();
-                    return;
-                }
-                else
-                    m_timer -= diff;
+                UnSummon();
+                return;
             }
-            else if (m_timer != m_lifetime)
-                m_timer = m_lifetime;
+            else
+                m_timer -= diff;
             break;
         }
         default:
diff --git a/mangos/src/game/TradeHandler.cpp b/Core/src/game/TradeHandler.cpp
index 5fc3ec4..51feb85 100644
--- a/mangos/src/game/TradeHandler.cpp
+++ b/Core/src/game/TradeHandler.cpp
@@ -25,11 +25,37 @@
 #include "Opcodes.h"
 #include "Player.h"
 #include "Item.h"
-#include "Spell.h"
 #include "SocialMgr.h"
 #include "Language.h"
 
-void WorldSession::SendTradeStatus(TradeStatus status)
+enum TradeStatus
+{
+    TRADE_STATUS_BUSY           = 0,
+    TRADE_STATUS_BEGIN_TRADE    = 1,
+    TRADE_STATUS_OPEN_WINDOW    = 2,
+    TRADE_STATUS_TRADE_CANCELED = 3,
+    TRADE_STATUS_TRADE_ACCEPT   = 4,
+    TRADE_STATUS_BUSY_2         = 5,
+    TRADE_STATUS_NO_TARGET      = 6,
+    TRADE_STATUS_BACK_TO_TRADE  = 7,
+    TRADE_STATUS_TRADE_COMPLETE = 8,
+    // 9?
+    TRADE_STATUS_TARGET_TO_FAR  = 10,
+    TRADE_STATUS_WRONG_FACTION  = 11,
+    TRADE_STATUS_CLOSE_WINDOW   = 12,
+    // 13?
+    TRADE_STATUS_IGNORE_YOU     = 14,
+    TRADE_STATUS_YOU_STUNNED    = 15,
+    TRADE_STATUS_TARGET_STUNNED = 16,
+    TRADE_STATUS_YOU_DEAD       = 17,
+    TRADE_STATUS_TARGET_DEAD    = 18,
+    TRADE_STATUS_YOU_LOGOUT     = 19,
+    TRADE_STATUS_TARGET_LOGOUT  = 20,
+    TRADE_STATUS_TRIAL_ACCOUNT  = 21,                       // Trial accounts can not perform that action
+    TRADE_STATUS_ONLY_CONJURED  = 22                        // You can only trade conjured items... (cross realm BG related).
+};
+
+void WorldSession::SendTradeStatus(uint32 status)
 {
     WorldPacket data;
 
@@ -78,23 +104,47 @@ void WorldSession::HandleBusyTradeOpcode(WorldPacket& /*recvPacket*/)
     // recvPacket.print_storage();
 }
 
-void WorldSession::SendUpdateTrade(bool trader_state /*= true*/)
+void WorldSession::SendUpdateTrade()
 {
-    TradeData* view_trade = trader_state ? _player->GetTradeData()->GetTraderData() : _player->GetTradeData();
+    if (!_player)
+        return;
+
+    TradeData* my_trade = _player->m_trade;
+    if (!my_trade)
+        return;
+
+    Player* trader = my_trade->m_tradeWith;
+
+    TradeData* his_trade = trader->m_trade;
+    if (!his_trade)
+        return;
+
+    // reset trade status
+    if (my_trade->m_acceptedTrade)
+    {
+        my_trade->m_acceptedTrade = false;
+        SendTradeStatus(TRADE_STATUS_BACK_TO_TRADE);
+    }
+
+    if (his_trade->m_acceptedTrade)
+    {
+        his_trade->m_acceptedTrade = false;
+        trader->GetSession()->SendTradeStatus(TRADE_STATUS_BACK_TO_TRADE);
+    }
 
     WorldPacket data(SMSG_TRADE_STATUS_EXTENDED, (100));    // guess size
-    data << uint8(trader_state ? 1 : 0);                    // send trader or own trade windows state (last need for proper show spell apply to non-trade slot)
+    data << uint8(1);                                       // can be different (only seen 0 and 1)
     data << uint32(0);                                      // added in 2.4.0, this value must be equal to value from TRADE_STATUS_OPEN_WINDOW status packet (different value for different players to block multiple trades?)
     data << uint32(TRADE_SLOT_COUNT);                       // trade slots count/number?, = next field in most cases
     data << uint32(TRADE_SLOT_COUNT);                       // trade slots count/number?, = prev field in most cases
-    data << uint32(view_trade->GetMoney());                 // trader gold
-    data << uint32(view_trade->GetSpell());                 // spell casted on lowest slot item
+    data << uint32(his_trade->m_tradeGold);                 // trader gold
+    data << uint32(his_trade->m_tradeSpell);                // spell casted on lowest slot item
 
     for(uint8 i = 0; i < TRADE_SLOT_COUNT; ++i)
     {
         data << uint8(i);                                   // trade slot number, if not specified, then end of packet
 
-        if (Item* item = view_trade->GetItem(TradeSlots(i)))
+        if (Item* item = trader->GetItemByTradeSlot(i))
         {
             data << uint32(item->GetProto()->ItemId);       // entry
             data << uint32(item->GetProto()->DisplayInfoID);// display id
@@ -131,10 +181,10 @@ void WorldSession::SendUpdateTrade(bool trader_state /*= true*/)
 
 void WorldSession::moveItems(Item* myItems[], Item* hisItems[])
 {
-    Player* trader = _player->GetTrader();
-    if (!trader)
+    if (!_player->m_trade)
         return;
 
+    Player* trader = _player->m_trade->m_tradeWith;
 
     for(int i = 0; i < TRADE_SLOT_TRADED_COUNT; ++i)
     {
@@ -207,48 +257,6 @@ void WorldSession::moveItems(Item* myItems[], Item* hisItems[])
 }
 
 //==============================================================
-static void setAcceptTradeMode(TradeData* myTrade, TradeData* hisTrade, Item **myItems, Item **hisItems)
-{
-    myTrade->SetInAcceptProcess(true);
-    hisTrade->SetInAcceptProcess(true);
-
-    // store items in local list and set 'in-trade' flag
-    for(int i = 0; i < TRADE_SLOT_TRADED_COUNT; ++i)
-    {
-        if (Item* item = myTrade->GetItem(TradeSlots(i)))
-        {
-            DEBUG_LOG("player trade item %s bag: %u slot: %u", item->GetObjectGuid().GetString().c_str(), item->GetBagSlot(), item->GetSlot());
-            //Can return NULL
-            myItems[i] = item;
-            myItems[i]->SetInTrade();
-        }
-
-        if (Item* item = hisTrade->GetItem(TradeSlots(i)))
-        {
-            DEBUG_LOG("partner trade item %s bag: %u slot: %u", item->GetObjectGuid().GetString().c_str(), item->GetBagSlot(), item->GetSlot());
-            hisItems[i] = item;
-            hisItems[i]->SetInTrade();
-        }
-    }
-}
-
-static void clearAcceptTradeMode(TradeData* myTrade, TradeData* hisTrade)
-{
-    myTrade->SetInAcceptProcess(false);
-    hisTrade->SetInAcceptProcess(false);
-}
-
-static void clearAcceptTradeMode(Item **myItems, Item **hisItems)
-{
-    // clear 'in-trade' flag
-    for (int i = 0; i < TRADE_SLOT_TRADED_COUNT; ++i)
-    {
-        if (myItems[i])
-            myItems[i]->SetInTrade(false);
-        if (hisItems[i])
-            hisItems[i]->SetInTrade(false);
-    }
-}
 
 void WorldSession::HandleAcceptTradeOpcode(WorldPacket& recvPacket)
 {
@@ -258,7 +266,7 @@ void WorldSession::HandleAcceptTradeOpcode(WorldPacket& recvPacket)
     if (!my_trade)
         return;
 
-    Player* trader = my_trade->GetTrader();
+    Player* trader = my_trade->m_tradeWith;
 
     TradeData* his_trade = trader->m_trade;
     if (!his_trade)
@@ -268,29 +276,28 @@ void WorldSession::HandleAcceptTradeOpcode(WorldPacket& recvPacket)
     Item *hisItems[TRADE_SLOT_TRADED_COUNT] = { NULL, NULL, NULL, NULL, NULL, NULL };
     bool myCanCompleteTrade=true,hisCanCompleteTrade=true;
 
-    // set before checks for propertly undo at problems (it already set in to client)
-    my_trade->SetAccepted(true);
-
     // not accept case incorrect money amount
-    if (my_trade->GetMoney() > _player->GetMoney())
+    if (my_trade->m_tradeGold > _player->GetMoney())
     {
         SendNotification(LANG_NOT_ENOUGH_GOLD);
-        my_trade->SetAccepted(false, true);
+        trader->GetSession()->SendTradeStatus(TRADE_STATUS_BACK_TO_TRADE);
+        my_trade->m_acceptedTrade = false;
         return;
     }
 
     // not accept case incorrect money amount
-    if (his_trade->GetMoney() > trader->GetMoney())
+    if (his_trade->m_tradeGold > trader->GetMoney())
     {
         trader->GetSession( )->SendNotification(LANG_NOT_ENOUGH_GOLD);
-        his_trade->SetAccepted(false, true);
+        SendTradeStatus(TRADE_STATUS_BACK_TO_TRADE);
+        his_trade->m_acceptedTrade = false;
         return;
     }
 
     // not accept if some items now can't be trade (cheating)
     for(int i = 0; i < TRADE_SLOT_TRADED_COUNT; ++i)
     {
-        if (Item* item = my_trade->GetItem(TradeSlots(i)))
+        if (Item* item = _player->GetItemByTradeSlot(i))
         {
             if (!item->CanBeTraded())
             {
@@ -299,7 +306,7 @@ void WorldSession::HandleAcceptTradeOpcode(WorldPacket& recvPacket)
             }
         }
 
-        if (Item* item  = his_trade->GetItem(TradeSlots(i)))
+        if (Item* item  = trader->GetItemByTradeSlot(i))
         {
             if (!item->CanBeTraded())
             {
@@ -309,117 +316,59 @@ void WorldSession::HandleAcceptTradeOpcode(WorldPacket& recvPacket)
         }
     }
 
-    if (his_trade->IsAccepted())
+    my_trade->m_acceptedTrade = true;
+    if (his_trade->m_acceptedTrade)
     {
-        setAcceptTradeMode(my_trade, his_trade, myItems, hisItems);
-
-        Spell* my_spell = NULL;
-        SpellCastTargets my_targets;
-
-        Spell* his_spell = NULL;
-        SpellCastTargets his_targets;
-
-        // not accept if spell can't be casted now (cheating)
-        if (uint32 my_spell_id = my_trade->GetSpell())
-        {
-            SpellEntry const* spellEntry = sSpellStore.LookupEntry(my_spell_id);
-            Item* castItem = my_trade->GetSpellCastItem();
-
-            if (!spellEntry || !his_trade->GetItem(TRADE_SLOT_NONTRADED) ||
-                my_trade->HasSpellCastItem() && !castItem)
-            {
-                clearAcceptTradeMode(my_trade, his_trade);
-                clearAcceptTradeMode(myItems, hisItems);
-
-                my_trade->SetSpell(0);
-                return;
-            }
-
-            my_spell = new Spell(_player, spellEntry, true);
-            my_spell->m_CastItem = castItem;
-            my_targets.setTradeItemTarget(_player);
-            my_spell->m_targets = my_targets;
-
-            SpellCastResult res = my_spell->CheckCast(true);
-            if (res != SPELL_CAST_OK)
-            {
-                my_spell->SendCastResult(res);
-
-                clearAcceptTradeMode(my_trade, his_trade);
-                clearAcceptTradeMode(myItems, hisItems);
-
-                delete my_spell;
-                my_trade->SetSpell(0);
-                return;
-            }
-        }
+        // inform partner client
+        trader->GetSession()->SendTradeStatus(TRADE_STATUS_TRADE_ACCEPT);
 
-        // not accept if spell can't be casted now (cheating)
-        if (uint32 his_spell_id = his_trade->GetSpell())
+        // store items in local list and set 'in-trade' flag
+        for(int i = 0; i < TRADE_SLOT_TRADED_COUNT; ++i)
         {
-            SpellEntry const* spellEntry = sSpellStore.LookupEntry(his_spell_id);
-            Item* castItem = his_trade->GetSpellCastItem();
-
-            if (!spellEntry || !my_trade->GetItem(TRADE_SLOT_NONTRADED) ||
-                his_trade->HasSpellCastItem() && !castItem)
+            if (Item* item = _player->GetItemByTradeSlot(i))
             {
-                delete my_spell;
-                his_trade->SetSpell(0);
-
-                clearAcceptTradeMode(my_trade, his_trade);
-                clearAcceptTradeMode(myItems, hisItems);
-                return;
+                DEBUG_LOG("player trade item %s bag: %u slot: %u", item->GetObjectGuid().GetString().c_str(), item->GetBagSlot(), item->GetSlot());
+                                                            //Can return NULL
+                myItems[i] = item;
+                myItems[i]->SetInTrade();
             }
 
-            his_spell = new Spell(trader, spellEntry, true);
-            his_spell->m_CastItem = castItem;
-            his_targets.setTradeItemTarget(trader);
-            his_spell->m_targets = his_targets;
-
-            SpellCastResult res = his_spell->CheckCast(true);
-            if (res != SPELL_CAST_OK)
+            if (Item* item = trader->GetItemByTradeSlot(i))
             {
-                his_spell->SendCastResult(res);
-
-                clearAcceptTradeMode(my_trade, his_trade);
-                clearAcceptTradeMode(myItems, hisItems);
-
-                delete my_spell;
-                delete his_spell;
-
-                his_trade->SetSpell(0);
-                return;
+                DEBUG_LOG("partner trade item %s bag: %u slot: %u", item->GetObjectGuid().GetString().c_str(), item->GetBagSlot(), item->GetSlot());
+                hisItems[i] = item;
+                hisItems[i]->SetInTrade();
             }
         }
 
-        // inform partner client
-        trader->GetSession()->SendTradeStatus(TRADE_STATUS_TRADE_ACCEPT);
-
         // test if item will fit in each inventory
         hisCanCompleteTrade =  (trader->CanStoreItems( myItems,TRADE_SLOT_TRADED_COUNT )== EQUIP_ERR_OK);
         myCanCompleteTrade = (_player->CanStoreItems( hisItems,TRADE_SLOT_TRADED_COUNT ) == EQUIP_ERR_OK);
 
-        clearAcceptTradeMode(myItems, hisItems);
+        // clear 'in-trade' flag
+        for (int i = 0; i < TRADE_SLOT_TRADED_COUNT; ++i)
+        {
+            if (myItems[i])
+                myItems[i]->SetInTrade(false);
+            if (hisItems[i])
+                hisItems[i]->SetInTrade(false);
+        }
 
         // in case of missing space report error
         if(!myCanCompleteTrade)
         {
-            clearAcceptTradeMode(my_trade, his_trade);
-
             SendNotification(LANG_NOT_FREE_TRADE_SLOTS);
             trader->GetSession( )->SendNotification(LANG_NOT_PARTNER_FREE_TRADE_SLOTS);
-            my_trade->SetAccepted(false);
-            his_trade->SetAccepted(false);
+            SendTradeStatus(TRADE_STATUS_BACK_TO_TRADE);
+            trader->GetSession()->SendTradeStatus(TRADE_STATUS_BACK_TO_TRADE);
             return;
         }
         else if (!hisCanCompleteTrade)
         {
-            clearAcceptTradeMode(my_trade, his_trade);
-
             SendNotification(LANG_NOT_PARTNER_FREE_TRADE_SLOTS);
             trader->GetSession()->SendNotification(LANG_NOT_FREE_TRADE_SLOTS);
-            my_trade->SetAccepted(false);
-            his_trade->SetAccepted(false);
+            SendTradeStatus(TRADE_STATUS_BACK_TO_TRADE);
+            trader->GetSession()->SendTradeStatus(TRADE_STATUS_BACK_TO_TRADE);
             return;
         }
 
@@ -444,36 +393,29 @@ void WorldSession::HandleAcceptTradeOpcode(WorldPacket& recvPacket)
         // logging money
         if (sWorld.getConfig(CONFIG_BOOL_GM_LOG_TRADE))
         {
-            if (_player->GetSession()->GetSecurity() > SEC_PLAYER && my_trade->GetMoney() > 0)
+            if (_player->GetSession()->GetSecurity() > SEC_PLAYER && my_trade->m_tradeGold > 0)
             {
                 sLog.outCommand(_player->GetSession()->GetAccountId(),"GM %s (Account: %u) give money (Amount: %u) to player: %s (Account: %u)",
                     _player->GetName(),_player->GetSession()->GetAccountId(),
-                    my_trade->GetMoney(),
+                    my_trade->m_tradeGold,
                     trader->GetName(), trader->GetSession()->GetAccountId());
             }
-            if (trader->GetSession()->GetSecurity() > SEC_PLAYER && his_trade->GetMoney() > 0)
+            if (trader->GetSession()->GetSecurity() > SEC_PLAYER && his_trade->m_tradeGold > 0)
             {
                 sLog.outCommand(trader->GetSession()->GetAccountId(),"GM %s (Account: %u) give money (Amount: %u) to player: %s (Account: %u)",
                     trader->GetName(), trader->GetSession()->GetAccountId(),
-                    his_trade->GetMoney(),
+                    his_trade->m_tradeGold,
                     _player->GetName(),_player->GetSession()->GetAccountId());
             }
         }
 
         // update money
-        _player->ModifyMoney( -int32(my_trade->GetMoney()) );
-        _player->ModifyMoney(his_trade->GetMoney());
-        trader->ModifyMoney( -int32(his_trade->GetMoney()) );
-        trader->ModifyMoney(my_trade->GetMoney());
-
-        if (my_spell)
-            my_spell->prepare(&my_targets);
-
-        if (his_spell)
-            his_spell->prepare(&his_targets);
+        _player->ModifyMoney( -int32(my_trade->m_tradeGold) );
+        _player->ModifyMoney(his_trade->m_tradeGold );
+        trader->ModifyMoney( -int32(his_trade->m_tradeGold) );
+        trader->ModifyMoney(my_trade->m_tradeGold );
 
         // cleanup
-        clearAcceptTradeMode(my_trade, his_trade);
         delete _player->m_trade;
         _player->m_trade = NULL;
         delete trader->m_trade;
@@ -500,7 +442,8 @@ void WorldSession::HandleUnacceptTradeOpcode(WorldPacket& /*recvPacket*/)
     if (!my_trade)
         return;
 
-    my_trade->SetAccepted(false, true);
+    my_trade->m_tradeWith->GetSession()->SendTradeStatus(TRADE_STATUS_BACK_TO_TRADE);
+    my_trade->m_acceptedTrade = false;
 }
 
 void WorldSession::HandleBeginTradeOpcode(WorldPacket& /*recvPacket*/)
@@ -509,7 +452,7 @@ void WorldSession::HandleBeginTradeOpcode(WorldPacket& /*recvPacket*/)
     if (!my_trade)
         return;
 
-    my_trade->GetTrader()->GetSession()->SendTradeStatus(TRADE_STATUS_OPEN_WINDOW);
+    my_trade->m_tradeWith->GetSession()->SendTradeStatus(TRADE_STATUS_OPEN_WINDOW);
     SendTradeStatus(TRADE_STATUS_OPEN_WINDOW);
 }
 
@@ -603,7 +546,7 @@ void WorldSession::HandleInitiateTradeOpcode(WorldPacket& recvPacket)
         SendTradeStatus(TRADE_STATUS_IGNORE_YOU);
         return;
     }
-
+    
     if (pOther->GetTeam() !=_player->GetTeam() )
     {
         SendTradeStatus(TRADE_STATUS_WRONG_FACTION);
@@ -617,8 +560,8 @@ void WorldSession::HandleInitiateTradeOpcode(WorldPacket& recvPacket)
     }
 
     // OK start trade
-    _player->m_trade = new TradeData(_player, pOther);
-    pOther->m_trade = new TradeData(pOther, _player);
+    _player->m_trade = new TradeData(pOther);
+    pOther->m_trade = new TradeData(_player);
 
     WorldPacket data(SMSG_TRADE_STATUS, 12);
     data << (uint32) TRADE_STATUS_BEGIN_TRADE;
@@ -632,12 +575,14 @@ void WorldSession::HandleSetTradeGoldOpcode(WorldPacket& recvPacket)
 
     recvPacket >> gold;
 
-    TradeData* my_trade = _player->GetTradeData();
+    TradeData* my_trade = _player->m_trade;
     if (!my_trade)
         return;
 
     // gold can be incorrect, but this is checked at trade finished.
-    my_trade->SetMoney(gold);
+    my_trade->m_tradeGold = gold;
+
+    my_trade->m_tradeWith->GetSession()->SendUpdateTrade();
 }
 
 void WorldSession::HandleSetTradeItemOpcode(WorldPacket& recvPacket)
@@ -678,7 +623,9 @@ void WorldSession::HandleSetTradeItemOpcode(WorldPacket& recvPacket)
         return;
     }
 
-    my_trade->SetItem(TradeSlots(tradeSlot), item);
+    my_trade->m_tradeItems[tradeSlot] = item->GetObjectGuid();
+
+    my_trade->m_tradeWith->GetSession()->SendUpdateTrade();
 }
 
 void WorldSession::HandleClearTradeItemOpcode(WorldPacket& recvPacket)
@@ -694,5 +641,7 @@ void WorldSession::HandleClearTradeItemOpcode(WorldPacket& recvPacket)
     if (tradeSlot >= TRADE_SLOT_COUNT)
         return;
 
-    my_trade->SetItem(TradeSlots(tradeSlot), NULL);
+    my_trade->m_tradeItems[tradeSlot].Clear();
+
+    my_trade->m_tradeWith->GetSession()->SendUpdateTrade();
 }
diff --git a/mangos/src/game/Unit.cpp b/Core/src/game/Unit.cpp
index ae03a34..dbcde70 100644
--- a/mangos/src/game/Unit.cpp
+++ b/Core/src/game/Unit.cpp
@@ -41,11 +41,13 @@
 #include "Util.h"
 #include "Totem.h"
 #include "BattleGround.h"
+#include "OutdoorPvP.h"
 #include "InstanceSaveMgr.h"
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
 #include "Path.h"
 #include "Traveller.h"
+#include "Vehicle.h"
 #include "VMapFactory.h"
 #include "MovementGenerator.h"
 
@@ -251,6 +253,9 @@ Unit::Unit()
     // remove aurastates allowing special moves
     for(int i=0; i < MAX_REACTIVE; ++i)
         m_reactiveTimer[i] = 0;
+
+    m_auraUpdateMask = 0;
+    m_vehicleGUID = 0;
 }
 
 Unit::~Unit()
@@ -289,8 +294,11 @@ void Unit::Update( uint32 p_time )
     // WARNING! Order of execution here is important, do not change.
     // Spells must be processed with event system BEFORE they go to _UpdateSpells.
     // Or else we may have some SPELL_STATE_FINISHED spells stalled in pointers, that is bad.
+    #pragma omp critical(UpdateThreadSafety)
+    {
     m_Events.Update( p_time );
     _UpdateSpells( p_time );
+    }
 
     CleanupDeletedAuras();
 
@@ -315,7 +323,12 @@ void Unit::Update( uint32 p_time )
         {
             // m_CombatTimer set at aura start and it will be freeze until aura removing
             if (m_CombatTimer <= p_time)
-                CombatStop();
+            {
+                if(HasAuraType(SPELL_AURA_MOD_STEALTH) || (getVictim() && getVictim()->HasAuraType(SPELL_AURA_MOD_STEALTH)))
+                    CombatStop();
+                else
+                    ClearInCombat();
+            }
             else
                 m_CombatTimer -= p_time;
         }
@@ -422,20 +435,14 @@ void Unit::SendMonsterMoveWithSpeed(float x, float y, float z, uint32 transitTim
 
 void Unit::BuildHeartBeatMsg(WorldPacket *data) const
 {
-    MovementFlags move_flags = GetTypeId()==TYPEID_PLAYER
-        ? ((Player const*)this)->m_movementInfo.GetMovementFlags()
-        : MOVEFLAG_NONE;
+    //Hack for flying creatures, but it works!
+    if(GetTypeId()!=TYPEID_PLAYER && ((Creature*)this)->canFly() &&
+        !m_movementInfo.HasMovementFlag(MOVEFLAG_FLYING))
+        ((Unit*)this)->m_movementInfo.AddMovementFlag(MOVEFLAG_FLYING);
 
-    data->Initialize(MSG_MOVE_HEARTBEAT, 32);
+    data->Initialize(MSG_MOVE_HEARTBEAT);
     *data << GetPackGUID();
-    *data << uint32(move_flags);                            // movement flags
-    *data << uint16(0);                                     // 2.3.0
-    *data << uint32(getMSTime());                           // time
-    *data << float(GetPositionX());
-    *data << float(GetPositionY());
-    *data << float(GetPositionZ());
-    *data << float(GetOrientation());
-    *data << uint32(0);
+    ((Unit*)this)->m_movementInfo.Write(*data);
 }
 
 void Unit::resetAttackTimer(WeaponAttackType type)
@@ -532,6 +539,16 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
     if(pVictim != this)
         pVictim->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
 
+    //Get in CombatState
+    if(pVictim != this && damagetype != DOT)
+    {
+        SetInCombatWith(pVictim);
+        pVictim->SetInCombatWith(this);
+
+        if(Player* attackedPlayer = pVictim->GetCharmerOrOwnerPlayerOrPlayerItself())
+            SetContestedPvP(attackedPlayer);
+    }
+
     // remove affects from attacker at any non-DoT damage (including 0 damage)
     if( damagetype != DOT)
     {
@@ -558,7 +575,16 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
     // root type spells do not dispel the root effect
     if (!spellProto || !(spellProto->Mechanic == MECHANIC_ROOT || IsSpellHaveAura(spellProto,SPELL_AURA_MOD_ROOT)))
         pVictim->RemoveSpellbyDamageTaken(SPELL_AURA_MOD_ROOT, damage);
-
+		
+	WeaponAttackType attType = GetWeaponAttackType(spellProto);
+
+	// on weapon hit casts, proc from melee damage implemented in DealMeleeDamage() (sent with spellProto == NULL, which determines possible double proc) 
+    if(GetTypeId() == TYPEID_PLAYER &&
+	   spellProto &&
+	   (spellProto->DmgClass == SPELL_DAMAGE_CLASS_MELEE ||
+	   spellProto->DmgClass == SPELL_DAMAGE_CLASS_RANGED))
+	    ((Player*)this)->CastItemCombatSpell(pVictim, attType);
+		
     // no xp,health if type 8 /critters/
     if(pVictim->GetTypeId() != TYPEID_PLAYER && pVictim->GetCreatureType() == CREATURE_TYPE_CRITTER)
     {
@@ -591,15 +617,6 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
 
         duel_hasEnded = true;
     }
-    //Get in CombatState
-    if(pVictim != this && damagetype != DOT)
-    {
-        SetInCombatWith(pVictim);
-        pVictim->SetInCombatWith(this);
-
-        if(Player* attackedPlayer = pVictim->GetCharmerOrOwnerPlayerOrPlayerItself())
-            SetContestedPvP(attackedPlayer);
-    }
 
     // Rage from Damage made (only from direct weapon damage)
     if( cleanDamage && damagetype==DIRECT_DAMAGE && this != pVictim && GetTypeId() == TYPEID_PLAYER && (getPowerType() == POWER_RAGE))
@@ -656,8 +673,13 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
     if (pVictim->GetTypeId() == TYPEID_PLAYER)
         ((Player*)pVictim)->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HIT_RECEIVED, damage);
 
-    if (pVictim->GetTypeId() == TYPEID_UNIT && !((Creature*)pVictim)->isPet() && !((Creature*)pVictim)->HasLootRecipient())
-        ((Creature*)pVictim)->SetLootRecipient(this);
+    if (pVictim->GetTypeId() == TYPEID_UNIT && !((Creature*)pVictim)->isPet())
+    {
+        if(!((Creature*)pVictim)->HasLootRecipient())
+            ((Creature*)pVictim)->SetLootRecipient(this);
+
+        ((Creature*)pVictim)->IncrementReceivedDamage(this, health < damage ? health : damage);
+    }
 
     if (health <= damage)
     {
@@ -671,13 +693,15 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
         // find owner of pVictim, used for creature cases, AI calls
         Unit* pOwner = pVictim->GetCharmerOrOwner();
 
+        bool bRewardIsAllowed = true;
         // in creature kill case group/player tap stored for creature
         if (pVictim->GetTypeId() == TYPEID_UNIT)
         {
             group_tap = ((Creature*)pVictim)->GetGroupLootRecipient();
 
             if (Player* recipient = ((Creature*)pVictim)->GetOriginalLootRecipient())
-                player_tap = recipient;
+                if (bRewardIsAllowed)
+                    player_tap = recipient;
         }
         // in player kill case group tap selected by player_tap (killer-player itself, or charmer, or owner, etc)
         else
@@ -688,16 +712,28 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
 
         if (pVictim->GetTypeId() == TYPEID_PLAYER)
         {
+            if(GetTypeId() == TYPEID_PLAYER)
+                group_tap = ((Player*)this)->GetGroup();
+
             ((Player*)pVictim)->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_DAMAGE_RECEIVED, health);
             if (player_tap)
                 player_tap->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL,1,0,pVictim);
         }
 
         // call kill spell proc event (before real die and combat stop to triggering auras removed at death/combat stop)
-        if(player_tap && player_tap != pVictim)
+        if (player_tap && player_tap != pVictim && bRewardIsAllowed)
         {
             player_tap->ProcDamageAndSpell(pVictim, PROC_FLAG_KILL, PROC_FLAG_KILLED, PROC_EX_NONE, 0);
 
+            ///PVP Announcer
+            if (pVictim->GetTypeId() == TYPEID_PLAYER)
+                sWorld.SendPvPAnnounce(player_tap, ((Player*)pVictim));
+            
+            // PvP Token
+            int8 leveldiff = player_tap->getLevel() - pVictim->getLevel();
+            if((pVictim->GetTypeId() == TYPEID_PLAYER) && leveldiff < 10)
+                player_tap->ReceiveToken();
+            
             WorldPacket data(SMSG_PARTYKILLLOG, (8+8));     //send event PARTY_KILL
             data << player_tap->GetObjectGuid();            //player with killing blow
             data << pVictim->GetObjectGuid();              //victim
@@ -741,6 +777,10 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
             }
         }
 
+        if(((Creature*)pVictim)->isTemporarySummon())//if charm dies too far from charmer(other loc, map) for summons only
+            if(pOwner)
+                pVictim->GetMap()->CreatureRelocation(((Creature*)pVictim), pOwner->GetPositionX(), pOwner->GetPositionY(), pOwner->GetPositionZ(), pOwner->GetOrientation());		
+
         DEBUG_FILTER_LOG(LOG_FILTER_DAMAGE,"SET JUST_DIED");
         if(!spiritOfRedemtionTalentReady)
             pVictim->setDeathState(JUST_DIED);
@@ -867,13 +907,22 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
             he->DuelComplete(DUEL_INTERUPTED);
         }
 
+        if (player_tap && this != pVictim)
+            if (OutdoorPvP * pvp = player_tap->GetOutdoorPvP())
+                pvp->HandleKill(player_tap, pVictim);
+
         // battleground things (do this at the end, so the death state flag will be properly set to handle in the bg->handlekill)
         if(pVictim->GetTypeId() == TYPEID_PLAYER && ((Player*)pVictim)->InBattleGround())
         {
             Player *killed = ((Player*)pVictim);
             if(BattleGround *bg = killed->GetBattleGround())
                 if(player_tap)
+                {
                     bg->HandleKillPlayer(killed, player_tap);
+                    player_tap->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL,1);
+                    player_tap->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GET_KILLING_BLOWS,1);
+                    player_tap->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA,1);
+                }
         }
         else if(pVictim->GetTypeId() == TYPEID_UNIT)
         {
@@ -1233,7 +1282,6 @@ void Unit::CalculateSpellDamage(SpellNonMeleeDamage *damageInfo, int32 damage, S
             //Calculate damage bonus
             damage = MeleeDamageBonusDone(pVictim, damage, attackType, spellInfo, SPELL_DIRECT_DAMAGE);
             damage = pVictim->MeleeDamageBonusTaken(this, damage, attackType, spellInfo, SPELL_DIRECT_DAMAGE);
-
             // if crit add critical bonus
             if (crit)
             {
@@ -1255,7 +1303,6 @@ void Unit::CalculateSpellDamage(SpellNonMeleeDamage *damageInfo, int32 damage, S
             // Calculate damage bonus
             damage = SpellDamageBonusDone(pVictim, spellInfo, damage, SPELL_DIRECT_DAMAGE);
             damage = pVictim->SpellDamageBonusTaken(this, spellInfo, damage, SPELL_DIRECT_DAMAGE);
-
             // If crit add critical bonus
             if (crit)
             {
@@ -1323,6 +1370,30 @@ void Unit::DealSpellDamage(SpellNonMeleeDamage *damageInfo, bool durabilityLoss)
     // Call default DealDamage (send critical in hit info for threat calculation)
     CleanDamage cleanDamage(0, BASE_ATTACK, damageInfo->HitInfo & SPELL_HIT_TYPE_CRIT ? MELEE_HIT_CRIT : MELEE_HIT_NORMAL);
     DealDamage(pVictim, damageInfo->damage, &cleanDamage, SPELL_DIRECT_DAMAGE, damageInfo->schoolMask, spellProto, durabilityLoss);
+
+    // Check if effect can trigger anything actually (is this a right ATTR ?)
+    if( spellProto->AttributesEx3 & SPELL_ATTR_EX3_UNK16 )
+        return;
+
+    bool hasWeaponDmgEffect = false;
+
+    for (uint32 i = 0; i < 3; ++i)
+    {
+        if (spellProto->Effect[i] == SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL || spellProto->Effect[i] == SPELL_EFFECT_WEAPON_PERCENT_DAMAGE || spellProto->Effect[i] == SPELL_EFFECT_WEAPON_DAMAGE || spellProto->Effect[i] == SPELL_EFFECT_NORMALIZED_WEAPON_DMG)
+        {    
+            hasWeaponDmgEffect = true;
+            break;
+        }
+    }
+
+    if (!(damageInfo->HitInfo & HITINFO_MISS) && hasWeaponDmgEffect) 
+    {
+        WeaponAttackType attType = GetWeaponAttackType(spellProto);
+        // on weapon hit casts, proc from melee and ranged spells implemented in DealDamage()
+        if(GetTypeId() == TYPEID_PLAYER && pVictim->isAlive())
+            ((Player*)this)->CastItemCombatSpell(pVictim, attType);
+    }
+
 }
 
 //TODO for melee need create structure as in
@@ -1386,7 +1457,6 @@ void Unit::CalculateMeleeDamage(Unit *pVictim, uint32 damage, CalcDamageInfo *da
     damage += CalculateDamage (damageInfo->attackType, false);
     // Add melee damage bonus
     damage = MeleeDamageBonusDone(damageInfo->target, damage, damageInfo->attackType);
-    damage = damageInfo->target->MeleeDamageBonusTaken(this, damage, damageInfo->attackType);
     // Calculate armor reduction
 
     uint32 armor_affected_damage = CalcNotIgnoreDamageRedunction(damage,damageInfo->damageSchoolMask);
@@ -1711,6 +1781,23 @@ void Unit::DealMeleeDamage(CalcDamageInfo *damageInfo, bool durabilityLoss)
                 alreadyDone.insert(*i);
                 uint32 damage=(*i)->GetModifier()->m_amount;
                 SpellEntry const *i_spellProto = (*i)->GetSpellProto();
+
+                // Thorns
+                if (i_spellProto->SpellFamilyName == SPELLFAMILY_DRUID && i_spellProto->SpellFamilyFlags & UI64LIT(0x00000100))
+                {
+                    Unit::AuraList const& dummyList = pVictim->GetAurasByType(SPELL_AURA_DUMMY);
+                    for(Unit::AuraList::const_iterator iter = dummyList.begin(); iter != dummyList.end(); ++iter)
+                    {
+                        // Brambles
+                        if((*iter)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_DRUID &&
+                            (*iter)->GetSpellProto()->SpellIconID == 53)
+                        {
+                            damage += uint32(damage * (*iter)->GetModifier()->m_amount / 100);
+                            break;
+                        }
+                    }
+                }
+
                 //Calculate absorb resist ??? no data in opcode for this possibly unable to absorb or resist?
                 //uint32 absorb;
                 //uint32 resist;
@@ -1805,8 +1892,26 @@ uint32 Unit::CalcArmorReducedDamage(Unit* pVictim, const uint32 damage)
 
     // Apply Player CR_ARMOR_PENETRATION rating and percent talents
     if (GetTypeId()==TYPEID_PLAYER)
-        armor *= 1.0f - ((Player*)this)->GetArmorPenetrationPct() / 100.0f;
+    {
+        // calculate Armor Penetration constant
+        float targetLevel = (float)pVictim->getLevel(); 
+        float arPenConstant = 400.0f + 85.0f * targetLevel;
+        if (targetLevel > 59.0f)
+            arPenConstant += 382.5f * (targetLevel - 59.0f); // 85.0f * 4.5f = 382.5f 
+        // calculate  Armor Penetration cap 
+        float armorReduction = (armor + arPenConstant) / 3.0f;
+        if (armor < armorReduction)
+            armorReduction = armor;
+
+        float armorPenetrationCoeff = ((Player*)this)->GetArmorPenetrationPct() / 100.0f;
+
+        if (armorPenetrationCoeff > 1.0f)
+        armorPenetrationCoeff = 1.0f;
 
+        armorReduction *= armorPenetrationCoeff;
+        armor -= armorReduction;
+    }
+    
     if (armor < 0.0f)
         armor = 0.0f;
 
@@ -1835,32 +1940,43 @@ void Unit::CalculateAbsorbAndResist(Unit *pCaster, SpellSchoolMask schoolMask, D
     // Magic damage, check for resists
     if ((schoolMask & SPELL_SCHOOL_MASK_NORMAL)==0)
     {
-        // Get base victim resistance for school
-        float tmpvalue2 = (float)GetResistance(GetFirstSchoolInMask(schoolMask));
-        // Ignore resistance by self SPELL_AURA_MOD_TARGET_RESISTANCE aura
-        tmpvalue2 += (float)pCaster->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, schoolMask);
-
-        tmpvalue2 *= (float)(0.15f / getLevel());
-        if (tmpvalue2 < 0.0f)
-            tmpvalue2 = 0.0f;
-        if (tmpvalue2 > 0.75f)
-            tmpvalue2 = 0.75f;
-        uint32 ran = urand(0, 100);
-        float faq[4] = {24.0f,6.0f,4.0f,6.0f};
-        uint8 m = 0;
-        float Binom = 0.0f;
-        for (uint8 i = 0; i < 4; ++i)
-        {
-            Binom += 2400 *( powf(tmpvalue2, float(i)) * powf( (1-tmpvalue2), float(4-i)))/faq[i];
-            if (ran > Binom )
-                ++m;
-            else
-                break;
+        float victimResistance = float(pCaster->GetResistance(GetFirstSchoolInMask(schoolMask)));
+        victimResistance += float(GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, schoolMask));
+        if(victimResistance < 0.0f)
+            victimResistance = 0.0f;
+
+        float resistConst = pCaster->getLevel() * 5.0f;
+        if(pCaster->GetTypeId()==TYPEID_UNIT && ((Creature*)pCaster)->isWorldBoss())
+            resistConst = 510.0f;
+
+        float averageResist = victimResistance / (victimResistance + resistConst);
+
+        // partial resists occur in multiples of 10%
+        float discreteResistProbability[11];
+        for (uint32 i = 0; i < 11; i++)
+        {
+            discreteResistProbability[i] = 0.5f - 2.5f * fabs(0.1f * i - averageResist);
+            if (discreteResistProbability[i] < 0.0f)
+                discreteResistProbability[i] = 0.0f;
         }
-        if (damagetype == DOT && m == 4)
-            *resist += uint32(damage - 1);
-        else
-            *resist += uint32(damage * m / 4);
+
+        // formula for low resistance values
+        if (averageResist <= 0.1f)
+        {
+            discreteResistProbability[0] = 1.0f - 7.5f * averageResist;
+            discreteResistProbability[1] = 5.0f * averageResist;
+            discreteResistProbability[2] = 2.5f * averageResist;
+        }
+
+        float psum = 0.0f;
+        uint32 i = 0;
+        float norm = rand_norm_f();
+
+        while (norm >= psum && i < 11)
+            psum += discreteResistProbability[i++];
+
+        *resist += uint32(damage * (i>0?i-1:0) / 10.0f);
+
         if(*resist > damage)
             *resist = damage;
     }
@@ -2000,8 +2116,8 @@ void Unit::CalculateAbsorbAndResist(Unit *pCaster, SpellSchoolMask schoolMask, D
                 // Primal Tenacity
                 if (spellProto->SpellIconID == 2253)
                 {
-                    //reduces all damage taken while Stunned and in Cat Form
-                    if (m_form == FORM_CAT && (unitflag & UNIT_FLAG_STUNNED))
+                    //reduces all damage taken while Stunned
+                    if (unitflag & UNIT_FLAG_STUNNED)
                         RemainingDamage -= RemainingDamage * currentAbsorb / 100;
                     continue;
                 }
@@ -2022,6 +2138,43 @@ void Unit::CalculateAbsorbAndResist(Unit *pCaster, SpellSchoolMask schoolMask, D
                 }
                 break;
             }
+            case SPELLFAMILY_PALADIN:
+            {
+                // Ardent Defender
+                if (spellProto->SpellIconID == 2135 && GetTypeId() == TYPEID_PLAYER)
+                {
+                    int32 remainingHealth = GetHealth() - RemainingDamage;
+                    uint32 allowedHealth = GetMaxHealth() * 0.35f;
+                    // If damage kills us
+                    if (remainingHealth <= 0 && !HasAura(66233))
+                    {
+                        // Cast healing spell, completely avoid damage
+                        RemainingDamage = 0;
+                        
+                        uint32 defenseSkillValue = GetDefenseSkillValue();
+                        // Max heal when defense skill denies critical hits from raid bosses
+                        // Formula: max defense at level + 140 (raiting from gear)
+                        uint32 reqDefForMaxHeal  = getLevel() * 5 + 140;
+                        float pctFromDefense = (defenseSkillValue >= reqDefForMaxHeal)
+                            ? 1.0f
+                            : float(defenseSkillValue) / float(reqDefForMaxHeal);
+
+                        int32 healAmount = GetMaxHealth() * ((*i)->GetSpellProto()->EffectBasePoints[1] + 1) / 100.0f * pctFromDefense;
+                        CastSpell(this, 66233, true);
+                        CastCustomSpell(this, 66235, &healAmount, NULL, NULL, true);
+                    }
+                    else if (remainingHealth < int32(allowedHealth))
+                    {
+                        // Reduce damage that brings us under 35% (or full damage if we are already under 35%) by x%
+                        uint32 damageToReduce = (GetHealth() < allowedHealth)
+                            ? RemainingDamage
+                            : allowedHealth - remainingHealth;
+                        RemainingDamage -= damageToReduce * currentAbsorb / 100;
+                    }
+                    continue;
+                }
+                break;
+            }
             case SPELLFAMILY_PRIEST:
             {
                 // Guardian Spirit
@@ -2363,6 +2516,67 @@ void Unit::CalculateAbsorbResistBlock(Unit *pCaster, SpellNonMeleeDamage *damage
     damageInfo->damage-= damageInfo->absorb + damageInfo->resist;
 }
 
+void Unit::CalculateHealAbsorb(Unit *pVictim, const SpellEntry *spellProto, uint32 &HealAmount, uint32 &Absorbed)
+{
+    int32 finalAmount = int32(HealAmount);
+    bool existExpired = false;
+
+    // handle heal absorb effects
+    AuraList const& healAbsorbAuras = pVictim->GetAurasByType(SPELL_AURA_SCHOOL_HEAL_ABSORB);
+    for (AuraList::const_iterator aura = healAbsorbAuras.begin(); aura != healAbsorbAuras.end() && finalAmount > 0; ++aura)
+    {
+        Modifier* mod = (*aura)->GetModifier();
+
+        // check if affects this school
+        if (!(mod->m_miscvalue & spellProto->SchoolMask))
+            continue;
+
+        // max amount that can be absorbed by this aura
+        int32 currentAbsorb = mod->m_amount;
+
+       // found empty aura (impossible but..)
+        if (currentAbsorb <= 0)
+        {
+            existExpired = true;
+           continue;
+        }
+
+        // can't absorb more than heal amount
+        if (finalAmount < currentAbsorb)
+            currentAbsorb = finalAmount;
+
+        // reduce heal amount by absorb amount
+        finalAmount -= currentAbsorb;
+
+        // reduce aura amount
+        mod->m_amount -= currentAbsorb;
+
+        if ((*aura)->DropAuraCharge())
+            mod->m_amount = 0;
+
+        // check if aura needs to be removed
+        if (mod->m_amount <= 0)
+            existExpired = true;
+    }
+    // Remove all consumed absorb auras
+    if (existExpired)
+    {
+        for (AuraList::const_iterator aura = healAbsorbAuras.begin(); aura != healAbsorbAuras.end(); )
+        {
+            if ((*aura)->GetModifier()->m_amount <= 0)
+            {
+                pVictim->RemoveAurasDueToSpell((*aura)->GetId());
+                aura = healAbsorbAuras.begin();
+            }
+            else
+                ++aura;
+        }
+    }
+
+    Absorbed = HealAmount - finalAmount;
+    HealAmount = finalAmount;
+}
+
 void Unit::AttackerStateUpdate (Unit *pVictim, WeaponAttackType attType, bool extra )
 {
     if(hasUnitState(UNIT_STAT_CAN_NOT_REACT) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED) )
@@ -2446,6 +2660,9 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(const Unit *pVictim, WeaponAttackT
     // Critical hit chance
     float crit_chance = GetUnitCriticalChance(attType, pVictim);
 
+    if (crit_chance < 0.0f)
+        crit_chance = 0.0f;
+
     // stunned target cannot dodge and this is check in GetUnitDodgeChance() (returned 0 in this case)
     float dodge_chance = pVictim->GetUnitDodgeChance();
     float block_chance = pVictim->GetUnitBlockChance();
@@ -2508,7 +2725,7 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit *pVictim, WeaponAttack
             dodge_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE)*25;
 
         // Modify dodge chance by attacker SPELL_AURA_MOD_COMBAT_RESULT_CHANCE
-        dodge_chance+= GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_COMBAT_RESULT_CHANCE, VICTIMSTATE_DODGE);
+        dodge_chance+= GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_COMBAT_RESULT_CHANCE, VICTIMSTATE_DODGE)*100;
 
         tmp = dodge_chance;
         if (   (tmp > 0)                                        // check if unit _can_ dodge
@@ -2523,7 +2740,7 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit *pVictim, WeaponAttack
     // parry & block chances
 
     // check if attack comes from behind, nobody can parry or block if attacker is behind
-    if (!pVictim->HasInArc(M_PI_F,this))
+    if (!pVictim->HasInArc(M_PI_F,this) && !pVictim->HasAura(19263))
     {
         DEBUG_FILTER_LOG(LOG_FILTER_COMBAT, "RollMeleeOutcomeAgainst: attack came from behind.");
     }
@@ -2665,6 +2882,9 @@ float Unit::CalculateLevelPenalty(SpellEntry const* spellProto) const
     if(spellProto->spellLevel <= 0)
         return 1.0f;
 
+    if (sSpellMgr.IsHighestRankOfSpell(spellProto->Id))
+        return 1.0f;
+
     float LvlPenalty = 0.0f;
 
     if(spellProto->spellLevel < 20)
@@ -2736,48 +2956,44 @@ bool Unit::IsSpellBlocked(Unit *pCaster, SpellEntry const * /*spellProto*/, Weap
 float Unit::MeleeSpellMissChance(Unit *pVictim, WeaponAttackType attType, int32 skillDiff, SpellEntry const *spell)
 {
     // Calculate hit chance (more correct for chance mod)
-    int32 HitChance;
+    float hitChance;
 
-    // PvP - PvE melee chances
-    int32 lchance = pVictim->GetTypeId() == TYPEID_PLAYER ? 5 : 7;
-    int32 leveldif = pVictim->getLevelForTarget(this) - getLevelForTarget(pVictim);
-    if(leveldif < 3)
-        HitChance = 95 - leveldif;
+    if ( pVictim->GetTypeId() == TYPEID_PLAYER )
+        hitChance = 95.0f + skillDiff * (skillDiff > 0 ? 0.02f : 0.04f);
+    else if ( skillDiff < -10 )
+        hitChance = 94.0f + (skillDiff + 10) * 0.4f;
     else
-        HitChance = 93 - (leveldif - 2) * lchance;
+        hitChance = 95.0f + skillDiff * 0.1f;
 
     // Hit chance depends from victim auras
     if(attType == RANGED_ATTACK)
-        HitChance += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_HIT_CHANCE);
+        hitChance += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_HIT_CHANCE);
     else
-        HitChance += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE);
+        hitChance += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE);
 
     // Spellmod from SPELLMOD_RESIST_MISS_CHANCE
     if(Player *modOwner = GetSpellModOwner())
-        modOwner->ApplySpellMod(spell->Id, SPELLMOD_RESIST_MISS_CHANCE, HitChance);
+        modOwner->ApplySpellMod(spell->Id, SPELLMOD_RESIST_MISS_CHANCE, hitChance);
 
     // Miss = 100 - hit
-    float miss_chance= 100.0f - HitChance;
+    float missChance= 100.0f - hitChance;
 
     // Bonuses from attacker aura and ratings
     if (attType == RANGED_ATTACK)
-        miss_chance -= m_modRangedHitChance;
+        missChance -= m_modRangedHitChance;
     else
-        miss_chance -= m_modMeleeHitChance;
-
-    // bonus from skills is 0.04%
-    miss_chance -= skillDiff * 0.04f;
+        missChance -= m_modMeleeHitChance;
 
     // Limit miss chance from 0 to 60%
-    if (miss_chance < 0.0f)
+    if (missChance < 0.0f)
         return 0.0f;
-    if (miss_chance > 60.0f)
+    if (missChance > 60.0f)
         return 60.0f;
-    return miss_chance;
+    return missChance;
 }
 
 // Melee based spells hit result calculations
-SpellMissInfo Unit::MeleeSpellHitResult(Unit *pVictim, SpellEntry const *spell)
+SpellMissInfo Unit::MeleeSpellHitResult(Unit *pVictim, SpellEntry const *spell, bool canMiss)
 {
     WeaponAttackType attType = BASE_ATTACK;
 
@@ -2786,16 +3002,55 @@ SpellMissInfo Unit::MeleeSpellHitResult(Unit *pVictim, SpellEntry const *spell)
 
     // bonus from skills is 0.04% per skill Diff
     int32 attackerWeaponSkill = int32(GetWeaponSkillValue(attType,pVictim));
+
+    // Only for hunters/warriors, other classes do not have ranged attack that would benefit from ranged weapon skill
+    if(spell->SpellFamilyName != SPELLFAMILY_HUNTER ||
+       spell->SpellFamilyName != SPELLFAMILY_WARRIOR ||
+       spell->SpellFamilyName != SPELLFAMILY_GENERIC)
+        attackerWeaponSkill = int32(GetWeaponSkillValue(BASE_ATTACK,pVictim));
+
+    // Probably not needed after [pr456]
+    /*if ( spell->SpellFamilyName == SPELLFAMILY_PALADIN )
+    {
+        // Hammer of Wrath
+        if ( spell->SpellFamilyFlags & UI64LIT(0x0000008000000000) )
+            attackerWeaponSkill = this->GetMaxSkillValueForLevel();
+        // Shield of Righteousness
+        else if ( spell->SpellFamilyFlags & UI64LIT(0x0010000000000000) )
+            attackerWeaponSkill = this->GetMaxSkillValueForLevel();
+        // Avenger's Shield
+        else if ( spell->SpellFamilyFlags & UI64LIT(0x0000000000004000) )
+            attackerWeaponSkill = this->GetMaxSkillValueForLevel();
+        // Judgement ( seal trigger )
+        else if ( spell->Category == SPELLCATEGORY_JUDGEMENT )
+            attackerWeaponSkill = this->GetMaxSkillValueForLevel();
+        // Judgement debuff and damage
+        else if ( GetSpellSpecific( spell->Id ) == SPELL_JUDGEMENT )
+            return SPELL_MISS_NONE;
+        // some Judgement other damage
+        else
+            switch ( spell->Id )
+            {
+                case 20425: // Judgement of Command
+                case 54158: // Judgement
+                    return SPELL_MISS_NONE;
+            }
+    }*/
+
     int32 skillDiff = attackerWeaponSkill - int32(pVictim->GetMaxSkillValueForLevel(this));
     int32 fullSkillDiff = attackerWeaponSkill - int32(pVictim->GetDefenseSkillValue(this));
 
     uint32 roll = urand (0, 10000);
+    uint32 tmp = 0;
 
-    uint32 missChance = uint32(MeleeSpellMissChance(pVictim, attType, fullSkillDiff, spell)*100.0f);
-    // Roll miss
-    uint32 tmp = missChance;
-    if (roll < tmp)
-        return SPELL_MISS_MISS;
+    if(canMiss)
+    {
+        uint32 missChance = uint32(MeleeSpellMissChance(pVictim, attType, fullSkillDiff, spell)*100.0f);
+        // Roll miss
+        tmp += missChance;
+        if (roll < tmp)
+            return SPELL_MISS_MISS;
+    }
 
     // Chance resist mechanic (select max value from every mechanic spell effect)
     int32 resist_mech = 0;
@@ -2818,23 +3073,13 @@ SpellMissInfo Unit::MeleeSpellHitResult(Unit *pVictim, SpellEntry const *spell)
     bool canDodge = true;
     bool canParry = true;
 
-    // Same spells cannot be parry/dodge
+    // Some spells cannot be parry/dodge
     if (spell->Attributes & SPELL_ATTR_IMPOSSIBLE_DODGE_PARRY_BLOCK)
         return SPELL_MISS_NONE;
 
-    // Ranged attack cannot be parry/dodge only deflect
+    // Ranged attack cannot be parry/dodge only miss
     if (attType == RANGED_ATTACK)
-    {
-        // only if in front
-        if (pVictim->HasInArc(M_PI_F,this))
-        {
-            int32 deflect_chance = pVictim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS)*100;
-            tmp+=deflect_chance;
-            if (roll < tmp)
-                return SPELL_MISS_DEFLECT;
-        }
         return SPELL_MISS_NONE;
-    }
 
     // Check for attack from behind
     if (!pVictim->HasInArc(M_PI_F,this))
@@ -2843,7 +3088,8 @@ SpellMissInfo Unit::MeleeSpellHitResult(Unit *pVictim, SpellEntry const *spell)
         if (GetTypeId() == TYPEID_PLAYER && pVictim->GetTypeId() == TYPEID_PLAYER)
             canDodge = false;
         // Can`t parry
-        canParry = false;
+        if (!pVictim->HasAura(19263))
+            canParry = false;
     }
     // Check creatures flags_extra for disable parry
     if(pVictim->GetTypeId()==TYPEID_UNIT)
@@ -2962,6 +3208,10 @@ SpellMissInfo Unit::MagicSpellHitResult(Unit *pVictim, SpellEntry const *spell)
     int32 HitChance = modHitChance * 100;
     // Increase hit chance from attacker SPELL_AURA_MOD_SPELL_HIT_CHANCE and attacker ratings
     HitChance += int32(m_modSpellHitChance*100.0f);
+    
+    // Increase pet spell hit chance by additional master spell hit chance
+    if(GetOwner() && GetOwner()->GetTypeId() == TYPEID_PLAYER)
+        HitChance += int32(GetOwner()->m_modSpellHitChance*100.0f);
 
     // Decrease hit chance from victim rating bonus
     if (pVictim->GetTypeId()==TYPEID_PLAYER)
@@ -2977,14 +3227,10 @@ SpellMissInfo Unit::MagicSpellHitResult(Unit *pVictim, SpellEntry const *spell)
     if (rand < tmp)
         return SPELL_MISS_MISS;
 
-    // cast by caster in front of victim
-    if (pVictim->HasInArc(M_PI_F,this))
-    {
-        int32 deflect_chance = pVictim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS)*100;
-        tmp+=deflect_chance;
-        if (rand < tmp)
-            return SPELL_MISS_DEFLECT;
-    }
+    int32 deflect_chance = pVictim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS)*100;
+    tmp+=deflect_chance;
+    if (rand < tmp)
+        return SPELL_MISS_DEFLECT;
 
     return SPELL_MISS_NONE;
 }
@@ -2997,27 +3243,33 @@ SpellMissInfo Unit::MagicSpellHitResult(Unit *pVictim, SpellEntry const *spell)
 //   Parry
 // For spells
 //   Resist
-SpellMissInfo Unit::SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool CanReflect)
+SpellMissInfo Unit::SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool canReflect, bool canMiss)
 {
     // Return evade for units in evade mode
     if (pVictim->GetTypeId()==TYPEID_UNIT && ((Creature*)pVictim)->IsInEvadeMode())
         return SPELL_MISS_EVADE;
 
-    // Check for immune
-    if (pVictim->IsImmunedToSpell(spell))
-        return SPELL_MISS_IMMUNE;
+    if (!(spell->Id == 64380 || spell->Id == 64382 || spell->Id == 32375 ||
+        spell->Id == 32592 || spell->Id == 39897 || spell->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY))
+    {
+        // Check for immune
+        if (pVictim->IsImmunedToSpell(spell))
+            return SPELL_MISS_IMMUNE;
 
-    // All positive spells can`t miss
-    // TODO: client not show miss log for this spells - so need find info for this in dbc and use it!
-    if (IsPositiveSpell(spell->Id))
-        return SPELL_MISS_NONE;
+        // All positive spells can`t miss
+        // TODO: client not show miss log for this spells - so need find info for this in dbc and use it!
+        if (IsPositiveSpell(spell->Id) && IsFriendlyTo(pVictim))
+            return SPELL_MISS_NONE;
 
-    // Check for immune
-    if (pVictim->IsImmunedToDamage(GetSpellSchoolMask(spell)))
-        return SPELL_MISS_IMMUNE;
+        // Check for immune
+        if (pVictim->IsImmunedToDamage(GetSpellSchoolMask(spell)))
+            return SPELL_MISS_IMMUNE;
+    }
+    else if (IsPositiveSpell(spell->Id) && IsFriendlyTo(pVictim))
+        return SPELL_MISS_NONE;
 
     // Try victim reflect spell
-    if (CanReflect)
+    if (canReflect)
     {
         int32 reflectchance = pVictim->GetTotalAuraModifier(SPELL_AURA_REFLECT_SPELLS);
         Unit::AuraList const& mReflectSpellsSchool = pVictim->GetAurasByType(SPELL_AURA_REFLECT_SPELLS_SCHOOL);
@@ -3040,7 +3292,7 @@ SpellMissInfo Unit::SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool
             return MagicSpellHitResult(pVictim, spell);
         case SPELL_DAMAGE_CLASS_MELEE:
         case SPELL_DAMAGE_CLASS_RANGED:
-            return MeleeSpellHitResult(pVictim, spell);
+            return MeleeSpellHitResult(pVictim, spell, canMiss);
     }
     return SPELL_MISS_NONE;
 }
@@ -3051,7 +3303,7 @@ float Unit::MeleeMissChanceCalc(const Unit *pVictim, WeaponAttackType attType) c
         return 0.0f;
 
     // Base misschance 5%
-    float misschance = 5.0f;
+    float missChance = 5.0f;
 
     // DualWield - Melee spells and physical dmg spells - 5% , white damage 24%
     if (haveOffhandWeapon() && attType != RANGED_ATTACK)
@@ -3066,56 +3318,39 @@ float Unit::MeleeMissChanceCalc(const Unit *pVictim, WeaponAttackType attType) c
             }
         }
         if (isNormal || m_currentSpells[CURRENT_MELEE_SPELL])
-            misschance = 5.0f;
+            missChance = 5.0f;
         else
-            misschance = 24.0f;
+             missChance = 24.0f;
     }
 
-    // PvP : PvE melee misschances per leveldif > 2
-    int32 chance = pVictim->GetTypeId() == TYPEID_PLAYER ? 5 : 7;
+    int32 skillDiff = int32(GetWeaponSkillValue(attType,pVictim)) - int32(pVictim->GetDefenseSkillValue(this));
 
-    int32 leveldif = int32(pVictim->getLevelForTarget(this)) - int32(getLevelForTarget(pVictim));
-    if(leveldif < 0)
-        leveldif = 0;
-
-    // Hit chance from attacker based on ratings and auras
-    float m_modHitChance;
-    if (attType == RANGED_ATTACK)
-        m_modHitChance = m_modRangedHitChance;
+    if ( pVictim->GetTypeId() == TYPEID_PLAYER )
+        missChance -= skillDiff * (skillDiff > 0 ? 0.02f : 0.04f);
+    else if ( skillDiff < -10 )
+        missChance -= (skillDiff + 10) * 0.4f - 1.0f;
     else
-        m_modHitChance = m_modMeleeHitChance;
-
-    if(leveldif < 3)
-        misschance += (leveldif - m_modHitChance);
-    else
-        misschance += ((leveldif - 2) * chance - m_modHitChance);
-
-    // Hit chance for victim based on ratings
-    if (pVictim->GetTypeId()==TYPEID_PLAYER)
-    {
-        if (attType == RANGED_ATTACK)
-            misschance += ((Player*)pVictim)->GetRatingBonusValue(CR_HIT_TAKEN_RANGED);
-        else
-            misschance += ((Player*)pVictim)->GetRatingBonusValue(CR_HIT_TAKEN_MELEE);
-    }
+        missChance -=  skillDiff * 0.1f;
 
     // Modify miss chance by victim auras
     if(attType == RANGED_ATTACK)
-        misschance -= pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_HIT_CHANCE);
+        missChance -= pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_HIT_CHANCE);
     else
-        misschance -= pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE);
+        missChance -= pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE);
 
-    // Modify miss chance from skill difference ( bonus from skills is 0.04% )
-    int32 skillBonus = int32(GetWeaponSkillValue(attType,pVictim)) - int32(pVictim->GetDefenseSkillValue(this));
-    misschance -= skillBonus * 0.04f;
+    // Bonuses from attacker aura and ratings
+    if (attType == RANGED_ATTACK)
+        missChance -= m_modRangedHitChance;
+    else
+        missChance -= m_modMeleeHitChance;
 
     // Limit miss chance from 0 to 60%
-    if ( misschance < 0.0f)
+    if ( missChance < 0.0f )
         return 0.0f;
-    if ( misschance > 60.0f)
+    if ( missChance > 60.0f )
         return 60.0f;
 
-    return misschance;
+    return missChance;
 }
 
 uint32 Unit::GetDefenseSkillValue(Unit const* target) const
@@ -3260,8 +3495,7 @@ float Unit::GetUnitCriticalChance(WeaponAttackType attackType, const Unit *pVict
     // Apply crit chance from defence skill
     crit += (int32(GetMaxSkillValueForLevel(pVictim)) - int32(pVictim->GetDefenseSkillValue(this))) * 0.04f;
 
-    if (crit < 0.0f)
-        crit = 0.0f;
+    // we need to keep this non-capped by null, because of further calculations in IsSpellCrit()
     return crit;
 }
 
@@ -3843,7 +4077,11 @@ bool Unit::AddAura(Aura *Aur)
             for(AuraMap::iterator i2 = m_Auras.lower_bound(spair); i2 != m_Auras.upper_bound(spair); ++i2)
             {
                 Aura* aur2 = i2->second;
-                if(aur2->GetCasterGUID()==Aur->GetCasterGUID())
+                bool vehicle = false;
+                if(Unit *caster = Aur->GetCaster())
+                    if(caster->GetVehicleGUID())
+                        vehicle = true;
+                if(aur2->GetCasterGUID()==Aur->GetCasterGUID() || vehicle)
                 {
                     // Aura can stack on self -> Stack it;
                     if(aurSpellInfo->StackAmount)
@@ -3869,7 +4107,19 @@ bool Unit::AddAura(Aura *Aur)
                     // can be only single (this check done at _each_ aura add
                     RemoveAura(i2,AURA_REMOVE_BY_STACK);
                     break;
+                }  
+                // Judgements are always single 
+                else if (GetSpellSpecific(Aur->GetId()) == SPELL_JUDGEMENT)
+                {
+                    RemoveAura(i2,AURA_REMOVE_BY_STACK);
+                    break;
                 }
+                               // Judgements are always single
+                               else if (GetSpellSpecific(Aur->GetId()) == SPELL_JUDGEMENT)
+                               {
+                                 RemoveAura(i2,AURA_REMOVE_BY_STACK);
+                                 break;
+                               } 
 
                 bool stop = false;
 
@@ -4873,6 +5123,7 @@ void Unit::SendPeriodicAuraLog(SpellPeriodicAuraLogInfo *pInfo)
         case SPELL_AURA_OBS_MOD_HEALTH:
             data << uint32(pInfo->damage);                  // damage
             data << uint32(pInfo->overDamage);              // overheal?
+            data << uint32(pInfo->absorb);                  // absorb
             data << uint8(pInfo->critical ? 1 : 0);         // new 3.1.2 critical flag
             break;
         case SPELL_AURA_OBS_MOD_MANA:
@@ -5169,6 +5420,14 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                     triggered_spell_id = 26654;
                     break;
                 }
+                // Glyph of Blocking
+                if (dummySpell->Id == 58375)
+                {
+                    triggered_spell_id = 58374;
+                    break;
+                }
+                break;
+
                 // Twisted Reflection (boss spell)
                 case 21063:
                     triggered_spell_id = 21064;
@@ -5513,6 +5772,12 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                 case 63320:
                     triggered_spell_id = 63321;
                     break;
+                // Glyph of Shadowflame
+                case 63310:
+                {
+                    triggered_spell_id = 63311;
+                    break;
+                }
                 // Item - Shadowmourne Legendary
                 case 71903:
                 {
@@ -5520,9 +5785,19 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                         return false;
 
                     Aura *aur = GetAura(71905, EFFECT_INDEX_0);
+                    
+                    if (aur && uint32(aur->GetStackAmount()) == 1)
+                        CastSpell(this, 72521, false);       // First Effect
+                    
+                    if (aur && uint32(aur->GetStackAmount()) == 6)
+                    {
+                        RemoveAurasDueToSpell(72521);       // remove First Effect
+                        CastSpell(this, 72523, false);       // Second Effect
+                    }
                     if (aur && uint32(aur->GetStackAmount() + 1) >= aur->GetSpellProto()->StackAmount)
                     {
-                        RemoveAurasDueToSpell(71905);
+                        RemoveAurasDueToSpell(72523);       // remove Second Effect
+                        RemoveAurasDueToSpell(71905);       // remove Shards
                         CastSpell(this, 71904, true);       // Chaos Bane
                         return true;
                     }
@@ -5664,6 +5939,41 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                     CastSpell(this, 28682, true, castItem, triggeredByAura);
                     return (procEx & PROC_EX_CRITICAL_HIT); // charge update only at crit hits, no hidden cooldowns
                 }
+                // Empowered Fire
+                case 12654:
+                {
+                    if (Unit* caster = triggeredByAura->GetCaster())
+                    {
+                        if (pVictim != caster)
+                            return false;
+                        Unit::AuraList const& auras = caster->GetAurasByType(SPELL_AURA_ADD_FLAT_MODIFIER);
+                        for (Unit::AuraList::const_iterator i = auras.begin(); i != auras.end(); i++)
+                        {
+                            switch((*i)->GetId())
+                            {
+                                case 31656:
+                                case 31657:
+                                case 31658:
+                                    if(roll_chance_i((*i)->GetSpellProto()->procChance))
+                                    {
+                                        caster->CastSpell( caster, 67545, true );
+                                        return true;
+                                    }
+                                    break;
+                                default:
+                                    continue;
+                            }
+                            break;
+                        }
+                    }
+                    return false;
+                }
+                // Arcane Blast proc-off only from arcane school and not from self
+                case 36032:
+                {
+                    if(procSpell->EffectTriggerSpell[1] == 36032 || GetSpellSchoolMask(procSpell) != SPELL_SCHOOL_MASK_ARCANE)
+                        return false;
+                }
                 // Glyph of Ice Block
                 case 56372:
                 {
@@ -5684,6 +5994,12 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                     pVictim->RemoveSpellsCausingAura(SPELL_AURA_PERIODIC_DAMAGE_PERCENT);
                     return true;
                 }
+                // Glyph of Drain Soul (warlock's glyph but has mage's spell family...)
+                case 58070:
+                {
+                    triggered_spell_id = 58068;
+                    break;
+                }
                 // Blessing of Ancient Kings
                 case 64411:
                 {
@@ -5755,6 +6071,12 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                 triggered_spell_id = 26654;
                 break;
             }
+            case 12311: // Gag Order rank 1 
+            case 12958: // Gag Order rank 2 
+            { 
+                triggered_spell_id = 18498; 
+                break; 
+            }
             break;
         }
         case SPELLFAMILY_WARLOCK:
@@ -5907,7 +6229,19 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                 // Divine Aegis
                 case 2820:
                 {
-                    basepoints[0] = damage * triggerAmount/100;
+                    if(!pVictim || !pVictim->isAlive())
+                        return false;
+
+                    // find Divine Aegis on the target and get absorb amount
+                    Aura* DivineAegis = pVictim->GetAura(47753,EFFECT_INDEX_0);
+                    if (DivineAegis)
+                        basepoints[0] = DivineAegis->GetModifier()->m_amount;
+                    basepoints[0] += damage * triggerAmount/100;
+
+                    // limit absorb amount
+                    int32 levelbonus = pVictim->getLevel()*125;
+                    if (basepoints[0] > levelbonus)
+                        basepoints[0] = levelbonus;
                     triggered_spell_id = 47753;
                     break;
                 }
@@ -6020,6 +6354,27 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                     // triggered_spell_id in spell data
                     break;
                 }
+                // Item - Priest T10 Healer 4P Bonus
+                case 70799:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+                    
+                    // Circle of Healing
+                    ((Player*)this)->RemoveSpellCategoryCooldown(1204, true);
+
+                    // Penance
+                    ((Player*)this)->RemoveSpellCategoryCooldown(1230, true);
+
+                    return true;
+                }
+                // Glyph of Prayer of Healing
+                case 55680:
+                {
+                    basepoints[0] = int32(damage * 20 / 100 / 2);   // divided in two ticks
+                    triggered_spell_id = 56161;
+                    break;
+                }
             }
             break;
         }
@@ -6118,6 +6473,16 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                     triggered_spell_id = 32747;
                     break;
                 }
+                // Glyph of Rake
+                case 54821:
+                {
+                   if (target->GetTypeId() == TYPEID_UNIT && procSpell->SpellVisual[0] == 750 && procSpell->EffectApplyAuraName[1] == 3)
+                   {
+                       triggered_spell_id = 54820;
+                       break;
+                   }
+                   return false;
+                }
                 // Glyph of Rejuvenation
                 case 54754:
                 {
@@ -6128,6 +6493,14 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                     triggered_spell_id = 54755;
                     break;
                 }
+                // Item - Druid T10 Balance 4P Bonus
+                case 70723:
+                {
+                    basepoints[0] = int32( triggerAmount * damage / 100 );
+                    basepoints[0] = int32( basepoints[0] / 2);
+                    triggered_spell_id = 71023;
+                    break;
+                }
                 // Item - Druid T10 Restoration 4P Bonus (Rejuvenation)
                 case 70664:
                 {
@@ -6151,8 +6524,33 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                     return true;
                 }
             }
+            // King of the Jungle
+            if (dummySpell->SpellIconID == 2850)
+            {
+                if (!procSpell)
+                    return false;
+
+                // Enrage (bear) - single rank - the aura for the bear form from the 2 existing kotj auras has a miscValue == 126
+                if (procSpell->Id == 5229 && triggeredByAura->GetMiscValue() == 126)
+                {
+                    // note : the remove part is done in spellAuras/HandlePeriodicEnergize as RemoveAurasDueToSpell
+                    basepoints[0] = triggerAmount;
+                    triggered_spell_id = 51185;
+                    target = this;
+                    break;
+                }
+                // Tiger Fury (cat) - all ranks - the aura for the cat form from the 2 existing kotj auras has a miscValue != 126
+                if (procSpell->SpellFamilyFlags2 & UI64LIT(0x00000800)  && triggeredByAura->GetMiscValue() != 126)
+                {
+                    basepoints[0] = triggerAmount;
+                    triggered_spell_id = 51178;
+                    target = this;
+                    break;
+                }
+                return false;
+            }
             // Eclipse
-            if (dummySpell->SpellIconID == 2856)
+            else if (dummySpell->SpellIconID == 2856)
             {
                 if (!procSpell)
                     return false;
@@ -6205,6 +6603,49 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                     break;
                 }
             }
+            // Deadly Poison
+            if (dummySpell->SpellIconID == 513)
+            {
+                if (pVictim->GetTypeId() != TYPEID_PLAYER)
+                    return false;
+
+                if (triggeredByAura->GetStackAmount() < dummySpell->StackAmount)
+                    return false;
+
+                Player *pCaster = ((Player*)pVictim);
+
+                Item* castItem = triggeredByAura->GetCastItemGUID() ? pCaster->GetItemByGuid(triggeredByAura->GetCastItemGUID()) : NULL;
+                
+                if (!castItem)
+                    return false;
+
+                Item *item = pCaster->GetWeaponForAttack(castItem->GetSlot() == EQUIPMENT_SLOT_MAINHAND ? OFF_ATTACK : BASE_ATTACK);
+                if (!item)
+                    return false;
+
+                // all poison enchantments is temporary
+                uint32 enchant_id = item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT);
+                if (!enchant_id)
+                    return false;
+
+                SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+                if (!pEnchant)
+                    return false;
+
+                for (int s = 0; s < 3; ++s)
+                {
+                    if (pEnchant->type[s]!=ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL)
+                        continue;
+
+                    SpellEntry const* combatEntry = sSpellStore.LookupEntry(pEnchant->spellid[s]);
+                    if (!combatEntry || combatEntry->Dispel != DISPEL_POISON)
+                        continue;
+
+                    pVictim->CastSpell(this, combatEntry, true, item);
+                }
+
+                return true;
+            }
             // Cut to the Chase
             if (dummySpell->SpellIconID == 2909)
             {
@@ -6322,6 +6763,11 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
         }
         case SPELLFAMILY_PALADIN:
         {
+            // Safety check for Art of War proccing, it should not be removed by spellfamily mask 1073741824 that are not from Flash of Light
+            if( dummySpell->Id == 53489 || dummySpell->Id == 59578 )
+                if( procSpell->SpellFamilyName == 10 && procSpell->SpellIconID == 13 )
+                    return false;
+
             // Seal of Righteousness - melee proc dummy (addition ${$MWS*(0.022*$AP+0.044*$SPH)} damage)
             if ((dummySpell->SpellFamilyFlags & UI64LIT(0x000000008000000)) && effIndex == EFFECT_INDEX_0)
             {
@@ -6354,6 +6800,14 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                 // Judgement of Light
                 case 20185:
                 {
+                    // PPM per victim
+                    float ppmJoL = 15.0f; // must be hard-coded + 100% proc chance in DB
+                    WeaponAttackType attType = BASE_ATTACK; // TODO: attack type based? 
+                    uint32 WeaponSpeed = pVictim->GetAttackTime(attType);
+                    float chanceForVictim = pVictim->GetPPMProcChance(WeaponSpeed, ppmJoL);
+                    if (!roll_chance_f(chanceForVictim))
+                        return false;
+
                     basepoints[0] = int32( pVictim->GetMaxHealth() * triggeredByAura->GetModifier()->m_amount / 100 );
                     pVictim->CastCustomSpell(pVictim, 20267, &basepoints[0], NULL, NULL, true, NULL, triggeredByAura);
                     return true;
@@ -6443,7 +6897,7 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                 // Seal of Vengeance (damage calc on apply aura)
                 case 31801:
                 {
-                    if (effIndex != EFFECT_INDEX_0)         // effect 1,2 used by seal unleashing code
+                    if (effIndex != EFFECT_INDEX_0 || !(procFlag & PROC_FLAG_SUCCESSFUL_MELEE_HIT))         // effect 1,2 used by seal unleashing code
                         return false;
 
                     // At melee attack or Hammer of the Righteous spell damage considered as melee attack
@@ -6608,6 +7062,15 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                     target = this;
                     break;
                 }
+                // Item - Paladin T10 Retribution 2P Bonus
+                case 70765:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    ((Player*)this)->RemoveSpellCooldown(53385, true);
+                    return true;
+                }
             }
             break;
         }
@@ -6806,6 +7269,7 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                 case 64928:
                 {
                     basepoints[0] = int32( triggerAmount * damage / 100 );
+                    basepoints[0] = int32(  basepoints[0] / 2); // basepoints is for 1 tick, not all DoT amount
                     triggered_spell_id = 64930;            // Electrified
                     break;
                 }
@@ -6813,9 +7277,30 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                 case 67228:
                 {
                     basepoints[0] = int32( triggerAmount * damage / 100 );
+                    basepoints[0] = int32(  basepoints[0] / 3); // basepoints is for 1 tick, not all DoT amount
                     triggered_spell_id = 71824;
                     break;
                 }
+                // Item - Shaman T10 Restoration 4P Bonus
+                case 70808:
+                {
+                    basepoints[0] = int32( triggerAmount * damage / 100 );
+                    basepoints[0] = int32( basepoints[0] / 3); // basepoints is for 1 tick, not all DoT amount
+                    triggered_spell_id = 70809;
+                    break;
+                }
+                // Item - Shaman T10 Elemental 4P Bonus
+                case 70817:
+                {
+                    if (Aura *aur = pVictim->GetAura(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_SHAMAN, UI64LIT(0x0000000010000000), 0, GetGUID()))
+                    {
+                        int32 amount = aur->GetAuraDuration() + triggerAmount * IN_MILLISECONDS;
+                        aur->SetAuraDuration(amount);
+                        aur->SendAuraUpdate(false);
+                        return true;
+                    }
+                    return false;
+                }
             }
             // Storm, Earth and Fire
             if (dummySpell->SpellIconID == 3063)
@@ -6854,6 +7339,51 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                 triggered_spell_id = 379;
                 break;
             }
+            // Flametongue Weapon (Passive)
+            if (dummySpell->SpellFamilyFlags & UI64LIT(0x200000))
+            {
+                if(GetTypeId()!=TYPEID_PLAYER)
+                    return false;
+
+                if(!castItem || !castItem->IsEquipped())
+                    return false;
+
+                //  firehit =  dummySpell->EffectBasePoints[0] / ((4*19.25) * 1.3);
+                float fire_onhit = dummySpell->EffectBasePoints[0] / 100.0;
+
+                float add_spellpower = SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_FIRE) +
+                                       pVictim->SpellBaseDamageBonusTaken(SPELL_SCHOOL_MASK_FIRE);
+
+                // 1.3speed = 5%, 2.6speed = 10%, 4.0 speed = 15%, so, 1.0speed = 3.84%
+                add_spellpower= add_spellpower / 100.0 * 3.84;
+
+                // Enchant on Off-Hand and ready?
+                if ( castItem->GetSlot() == EQUIPMENT_SLOT_OFFHAND && isAttackReady(OFF_ATTACK))
+                {
+                    float BaseWeaponSpeed = GetAttackTime(OFF_ATTACK)/1000.0;
+
+                    // Value1: add the tooltip damage by swingspeed + Value2: add spelldmg by swingspeed
+                    basepoints[0] = int32( (fire_onhit * BaseWeaponSpeed) + (add_spellpower * BaseWeaponSpeed) );
+                    triggered_spell_id = 10444;
+                }
+
+                // Enchant on Main-Hand and ready?
+                else if ( castItem->GetSlot() == EQUIPMENT_SLOT_MAINHAND && isAttackReady(BASE_ATTACK))
+                {
+                    float BaseWeaponSpeed = GetAttackTime(BASE_ATTACK)/1000.0;
+
+                    // Value1: add the tooltip damage by swingspeed +  Value2: add spelldmg by swingspeed
+                    basepoints[0] = int32( (fire_onhit * BaseWeaponSpeed) + (add_spellpower * BaseWeaponSpeed) );
+                    triggered_spell_id = 10444;
+                }
+
+                // If not ready, we should  return, shouldn't we?!
+                else
+                    return false;
+
+                CastCustomSpell(pVictim,triggered_spell_id,&basepoints[0],NULL,NULL,true,castItem,triggeredByAura);
+                return true;
+            }
             // Improved Water Shield
             if (dummySpell->SpellIconID == 2287)
             {
@@ -7008,17 +7538,33 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
             if (dummySpell->Id == 49028)
             {
                 // 1 dummy aura for dismiss rune blade
-                if (effIndex != EFFECT_INDEX_2)
+                if (effIndex != EFFECT_INDEX_1)
+                    return false;
+
+                Pet* runeBlade = FindGuardianWithEntry(27893);
+
+                if (runeBlade && pVictim && damage && procSpell)
+                {
+                    int32 procDmg = damage * 0.5;
+                    runeBlade->CastCustomSpell(pVictim, procSpell->Id, &procDmg, NULL, NULL, true, NULL, NULL, runeBlade->GetGUID());
+                    SendSpellNonMeleeDamageLog(pVictim, procSpell->Id, procDmg, SPELL_SCHOOL_MASK_NORMAL, 0, 0, false, 0, false);
+                    break;
+                }
+                else 
                     return false;
-                // TODO: wite script for this "fights on its own, doing the same attacks"
-                // NOTE: Trigger here on every attack and spell cast
-                return false;
             }
             // Mark of Blood
             if (dummySpell->Id == 49005)
             {
                 // TODO: need more info (cooldowns/PPM)
-                triggered_spell_id = 61607;
+                target->CastSpell(target, 61607, true, NULL, triggeredByAura);
+                return true;
+            }
+            // Unholy Blight
+            if (dummySpell->Id == 49194)
+            {
+                basepoints[0] = triggerAmount * damage / 1000;
+                triggered_spell_id = 50536;
                 break;
             }
             // Vendetta
@@ -7132,10 +7678,39 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                 target = this;
                 break;
             }
+            // Sudden Doom
+            if (dummySpell->SpellIconID == 1939)
+            {
+                if (!target || !target->isAlive() || this->GetTypeId() != TYPEID_PLAYER)
+                    return false;
+                
+                // get highest rank of Death Coil spell
+                const PlayerSpellMap& sp_list = ((Player*)this)->GetSpellMap();
+                for (PlayerSpellMap::const_iterator itr = sp_list.begin(); itr != sp_list.end(); ++itr)
+                {
+                    if(!itr->second.active || itr->second.disabled || itr->second.state == PLAYERSPELL_REMOVED)
+                        continue;
+
+                    SpellEntry const *spellInfo = sSpellStore.LookupEntry(itr->first);
+                    if (!spellInfo)
+                        continue;
+
+                    if (spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && spellInfo->SpellFamilyFlags & UI64LIT(0x2000))
+                    {
+                        triggered_spell_id = spellInfo->Id;
+                        break;
+                    }
+                }
+                break;
+            }
             // Wandering Plague
             if (dummySpell->SpellIconID == 1614)
             {
-                if (!roll_chance_f(GetUnitCriticalChance(BASE_ATTACK, pVictim)))
+                // prevent proc from other types than disease 
+                if (procSpell && procSpell->Dispel != DISPEL_DISEASE) 
+                    return false;
+                float chance = GetUnitCriticalChance(BASE_ATTACK, pVictim) > 0.0f ? GetUnitCriticalChance(BASE_ATTACK, pVictim) : 0.0f;
+                if (!roll_chance_f(chance))
                     return false;
                 basepoints[0] = triggerAmount * damage / 100;
                 triggered_spell_id = 50526;
@@ -7151,12 +7726,70 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, Aura* triggeredByAu
                 // triggered_spell_id in spell data
                 break;
             }
+            // Unholy Blight
+            if (dummySpell->Id == 49194)
+            {
+                triggered_spell_id = 50536;
+                SpellEntry const* triggeredEntry = sSpellStore.LookupEntry(triggered_spell_id);
+                if (!triggeredEntry)
+                    return false;
+                basepoints[0] = triggerAmount * damage / 100;
+                basepoints[0] /= (GetSpellDuration(triggeredEntry) / triggeredEntry->EffectAmplitude[EFFECT_INDEX_0]);
+                break;
+            }
+            // Sudden Doom
+            if (dummySpell->SpellIconID == 1939)
+            {
+                int32 casterLevel = getLevel();
+ 
+                // cast correct rank
+                if (casterLevel > 79)
+                    triggered_spell_id = 49895;
+                else if (casterLevel > 75)
+                    triggered_spell_id = 49894;
+                else if (casterLevel > 67)
+                    triggered_spell_id = 49893;
+                else if (casterLevel > 61)
+                    triggered_spell_id = 49892;
+                else
+                    triggered_spell_id = 47541;
+                 break;
+            }
+            // Hungering Cold - not break from diseases
+            if (dummySpell->SpellIconID == 2797)
+            {
+                if (procSpell && procSpell->Dispel == DISPEL_DISEASE)
+                    return false;
+		}
+	    case SPELLFAMILY_PET:
+	    {
+		   // improved cower
+		    if (dummySpell->SpellIconID == 958 && procSpell->SpellIconID == 958)
+		    {
+		       triggered_spell_id = dummySpell->Id == 53180 ? 54200 : 54201;
+			   target = this;
+			   break;
+		    }
+		    // guard dog
+		    if (dummySpell->SpellIconID == 201 && procSpell->SpellIconID == 201)
+		    {
+		       triggered_spell_id = 54445;
+			   target = this;
+			   break;
+		    }
+            // silverback
+			if (dummySpell->SpellIconID == 1582 && procSpell->SpellIconID == 201)
+			{
+			    triggered_spell_id = dummySpell->Id == 62764 ? 62800 : 62801;
+				target = this;
+				break;		
+            }
             break;
         }
         default:
             break;
     }
-
+}
     // processed charge only counting case
     if(!triggered_spell_id)
         return true;
@@ -7273,6 +7906,10 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
                 //case 36207: break:                        // Steal Weapon
                 //case 36576: break:                        // Shaleskin (Shaleskin Flayer, Shaleskin Ripper) 30023 trigger
                 //case 37030: break;                        // Chaotic Temperament
+                case 38164:                                 // Unyielding Knights
+                    if (pVictim->GetEntry() != 19457)
+                        return false;
+                    break;
                 //case 38363: break;                        // Gushing Wound
                 //case 39215: break;                        // Gushing Wound
                 //case 40250: break;                        // Improved Duration
@@ -7386,7 +8023,7 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
                 // This spell originally trigger 13567 - Dummy Trigger (vs dummy efect)
                 basepoints[0] = damage * 15 / 100;
                 target = pVictim;
-                trigger_spell_id = 26470;
+                trigger_spell_id = 64413;
             }
             break;
         case SPELLFAMILY_WARRIOR:
@@ -7543,6 +8180,14 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
             }
             break;
         }
+        case SPELLFAMILY_ROGUE:
+            // Item - Rogue T10 2P Bonus
+            if (auraSpellInfo->Id == 70805)
+            {
+                if (pVictim != this)
+                    return false;
+            }
+            break;
         case SPELLFAMILY_HUNTER:
             // Piercing Shots
             if (auraSpellInfo->SpellIconID == 3247 && auraSpellInfo->SpellVisual[0] == 0)
@@ -7642,6 +8287,12 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
                 trigger_spell_id = 37661;
                 target = pVictim;
             }
+            // Unyielding Knights
+            else if (auraSpellInfo->Id == 38164)
+            {
+                if (pVictim->GetEntry()!=19457)
+                    return false;
+            }
             // Bonus Healing (Crystal Spire of Karabor mace)
             else if (auraSpellInfo->Id == 40971)
             {
@@ -7672,7 +8323,7 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
         case SPELLFAMILY_SHAMAN:
         {
             // Lightning Shield (overwrite non existing triggered spell call in spell.dbc
-            if (auraSpellInfo->SpellFamilyFlags & UI64LIT(0x0000000000000400))
+            if (auraSpellInfo->SpellFamilyFlags & UI64LIT(0x0000000000000400) && auraSpellInfo->SpellVisual[0] == 37)
             {
                 switch(auraSpellInfo->Id)
                 {
@@ -7758,6 +8409,37 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
                         return false;
                 }
             }
+            // Glyph of Death's Embrace
+            else if (auraSpellInfo->Id == 58677)
+            {
+                if (procSpell->Id != 47633)
+                    return false;
+            }
+            // Item - Death Knight T10 Melee 4P Bonus
+            else if (auraSpellInfo->Id == 70656)
+            {
+                if (GetTypeId() != TYPEID_PLAYER || getClass() != CLASS_DEATH_KNIGHT)
+                    return false;
+
+                for(uint32 i = 0; i < MAX_RUNES; ++i)
+                    if (((Player*)this)->GetRuneCooldown(i) == 0)
+                        return false;
+            }
+            // Rune Strike
+            else if (auraSpellInfo->Id == 56816)
+            {
+                if( Aura * pAura = this->GetAura(56816, EFFECT_INDEX_0))
+                    pAura->SendFakeAuraUpdate(56817, false);
+                    return true;
+            }
+            // Glyph of Death Grip
+            if (auraSpellInfo->Id == 62259)
+            {
+                // remove cooldown of Death Grip
+                if (GetTypeId()==TYPEID_PLAYER)
+                    ((Player*)this)->RemoveSpellCooldown(49576, true);
+                return true;
+            }	
             // Blade Barrier
             else if (auraSpellInfo->SpellIconID == 85)
             {
@@ -7796,6 +8478,27 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
     // dummy basepoints or other customs
     switch(trigger_spell_id)
     {
+        // Auras which should proc on area aura source (caster in this case):
+        // Turn the Tables
+        case 52914:
+        case 52915:
+        case 52910:
+        // Honor Among Thieves
+        case 52916:
+        {
+            target = triggeredByAura->GetCaster();
+            if(!target)
+                return false;
+
+            if( cooldown && GetTypeId() == TYPEID_PLAYER && ((Player*)target)->HasSpellCooldown(trigger_spell_id))
+                return false;
+
+            target->CastSpell(target,trigger_spell_id,true,castItem,triggeredByAura);
+
+            if( cooldown && GetTypeId() == TYPEID_PLAYER )
+                ((Player*)this)->AddSpellCooldown(trigger_spell_id,0,time(NULL) + cooldown);
+            return true;
+        }
         // Cast positive spell on enemy target
         case 7099:  // Curse of Mending
         case 39647: // Curse of Mending
@@ -7850,7 +8553,7 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
             int32 curBonus = 0;
             if (Aura* aur = owner->GetAura(48090, EFFECT_INDEX_0))
                 curBonus = aur->GetModifier()->m_amount;
-            int32 spellDamage  = owner->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) - curBonus;
+            int32 spellDamage = owner->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) - curBonus;
             if(spellDamage <= 0)
                 return false;
 
@@ -7883,6 +8586,15 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
             // 5 rank -> 100% 4 rank -> 80% and etc from full rate
             if(!roll_chance_i(20*rank))
                 return false;
+
+            // Item - Shaman T10 Enhancement 4P Bonus
+            if (Aura *aur = GetAura(70832, EFFECT_INDEX_0))
+            {
+                Aura *maelBuff = GetAura(trigger_spell_id, EFFECT_INDEX_0);
+                if (maelBuff && maelBuff->GetStackAmount() + 1 == maelBuff->GetSpellProto()->StackAmount)
+                    if (roll_chance_i(aur->GetModifier()->m_amount))
+                        CastSpell(this, 70831, true, NULL, aur);
+            }
             break;
         }
         // Brain Freeze
@@ -7933,8 +8645,10 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
         // Lock and Load
         case 56453:
         {
-            // Proc only from trap activation (from periodic proc another aura of this spell)
-            if (!(procFlags & PROC_FLAG_ON_TRAP_ACTIVATION) || !roll_chance_i(triggerAmount))
+            // Proc only from trap activation (from periodic proc another aura of this spell). We need to recheck family flags,
+            // because some spells have both flags (ON_TRAP_ACTIVATION and ON_PERIODIC), but should only proc ON_PERIODIC!!
+            if (!(procFlags & PROC_FLAG_ON_TRAP_ACTIVATION) ||
+                !(procSpell->SpellFamilyFlags & 0x00000008 || procSpell->SpellFamilyFlags2 & 0x40000) || !roll_chance_i(triggerAmount))
                 return false;
             break;
         }
@@ -7952,6 +8666,12 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
             basepoints[0] = int32(GetTotalAttackPowerValue(BASE_ATTACK) * triggerAmount / 100);
             break;
         }
+        //Twilight Torment
+        case 57988:
+        {
+            pVictim->CastSpell(pVictim, 57988, true, NULL, NULL, GetGUID());
+            return true;
+        }
     }
 
     if( cooldown && GetTypeId()==TYPEID_PLAYER && ((Player*)this)->HasSpellCooldown(trigger_spell_id))
@@ -8049,9 +8769,6 @@ bool Unit::HandleOverrideClassScriptAuraProc(Unit *pVictim, uint32 /*damage*/, A
         case 5497:                                          // Improved Mana Gems (Serpent-Coil Braid)
             triggered_spell_id = 37445;                     // Mana Surge
             break;
-        case 6953:                                          // Warbringer
-            RemoveAurasAtMechanicImmunity(IMMUNE_TO_ROOT_AND_SNARE_MASK,0,true);
-            return true;
         case 7010:                                          // Revitalize (rank 1)
         case 7011:                                          // Revitalize (rank 2)
         case 7012:                                          // Revitalize (rank 3)
@@ -8069,6 +8786,34 @@ bool Unit::HandleOverrideClassScriptAuraProc(Unit *pVictim, uint32 /*damage*/, A
             }
             break;
         }
+        // Crypt Fever and Ebon Plaguebringer 
+        case 7282: 
+        { 
+            switch (triggeredByAura->GetId()) 
+            { 
+                // Crypt Fever 
+                case 49032: triggered_spell_id = 50508; break; 
+                case 49631: triggered_spell_id = 50509; break; 
+                case 49632: triggered_spell_id = 50510; break; 
+                // Ebon Plaguebringer 
+                case 51099: triggered_spell_id = 51726; break; 
+                case 51160: triggered_spell_id = 51734; break; 
+                case 51161: triggered_spell_id = 51735; break; 
+                default: return false; 
+            } 
+ 
+            // Do not proc Crypt Fever if present Ebon Plaguebringer 
+            if(triggeredByAura->GetSpellProto()->SpellIconID == 264) 
+            { 
+                Unit::AuraList const& mScriptAuras = GetAurasByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS); 
+                for(Unit::AuraList::const_iterator i = mScriptAuras.begin(); i != mScriptAuras.end(); ++i) 
+                { 
+                    if ((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && (*i)->GetSpellProto()->SpellIconID == 1766) 
+                        return false; 
+                } 
+            } 
+            break; 
+        } 
     }
 
     // not processed
@@ -8104,15 +8849,10 @@ void Unit::setPowerType(Powers new_powertype)
         if(((Player*)this)->GetGroup())
             ((Player*)this)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_POWER_TYPE);
     }
-    else if(((Creature*)this)->isPet())
+    else if(Unit* owner = GetCharmerOrOwner())
     {
-        Pet *pet = ((Pet*)this);
-        if(pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if(owner && (owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
-                ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_POWER_TYPE);
-        }
+        if((owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
+            ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_POWER_TYPE);
     }
 
     switch(new_powertype)
@@ -8269,6 +9009,38 @@ bool Unit::IsHostileTo(Unit const* unit) const
     return tester_faction->IsHostileTo(*target_faction);
 }
 
+bool Unit::IsInPartyWith(Unit const *unit) const
+{
+    if(this == unit)
+      return true;
+
+    const Unit *u1 = GetCharmerOrOwnerOrSelf();
+    const Unit *u2 = unit->GetCharmerOrOwnerOrSelf();
+    if(u1 == u2)
+        return true;
+
+    if(u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_PLAYER)
+        return ((Player*)u1)->IsInSameGroupWith((Player*)u2);
+    else
+       return false;
+}
+
+bool Unit::IsInRaidWith(Unit const *unit) const
+{
+    if(this == unit)
+        return true;
+
+    const Unit *u1 = GetCharmerOrOwnerOrSelf();
+    const Unit *u2 = unit->GetCharmerOrOwnerOrSelf();
+    if(u1 == u2)
+        return true;
+
+    if(u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_PLAYER)
+        return ((Player*)u1)->IsInSameRaidWith((Player*)u2);
+    else
+        return false;
+}
+
 bool Unit::IsFriendlyTo(Unit const* unit) const
 {
     // always friendly to self
@@ -8420,6 +9192,21 @@ bool Unit::Attack(Unit *victim, bool meleeAttack)
     if(GetTypeId()==TYPEID_PLAYER && IsMounted())
         return false;
 
+    // player (also npc?) cannot attack on vehicle
+    if(GetTypeId()==TYPEID_PLAYER && GetVehicleGUID())
+    {
+        Vehicle *pVehicle = GetMap()->GetVehicle(GetVehicleGUID());
+        if(!pVehicle)
+            return false;
+
+        if(!(pVehicle->GetVehicleFlags() & VF_ALLOW_MELEE))
+            return false;
+    }
+
+    // player (also npc?) cannot attack on vehicle
+    if(GetTypeId()==TYPEID_UNIT && ((Creature*)this)->isVehicle() && GetCharmerGUID())
+        return false;
+
     // nobody can attack GM in GM-mode
     if(victim->GetTypeId()==TYPEID_PLAYER)
     {
@@ -8679,8 +9466,9 @@ Pet* Unit::GetPet() const
 {
     if(uint64 pet_guid = GetPetGUID())
     {
-        if(Pet* pet = GetMap()->GetPet(pet_guid))
-            return pet;
+        if(IsInWorld())
+            if(Pet* pet = GetMap()->GetPet(pet_guid))
+                return pet;
 
         sLog.outError("Unit::GetPet: Pet %u not exist.",GUID_LOPART(pet_guid));
         const_cast<Unit*>(this)->SetPet(0);
@@ -8727,7 +9515,13 @@ void Unit::SetPet(Pet* pet)
     SetPetGUID(pet ? pet->GetGUID() : 0);
 
     if(pet && GetTypeId() == TYPEID_PLAYER)
+    {
         ((Player*)this)->SendPetGUIDs();
+        // set infinite cooldown for summon spell
+        SpellEntry const *spellInfo = sSpellStore.LookupEntry(pet->GetUInt32Value(UNIT_CREATED_BY_SPELL));
+        if (spellInfo && spellInfo->Attributes & SPELL_ATTR_DISABLED_WHILE_ACTIVE)
+            ((Player*)this)->AddSpellAndCategoryCooldowns(spellInfo, 0, NULL,true);
+    }
 }
 
 void Unit::SetCharm(Unit* pet)
@@ -8738,11 +9532,25 @@ void Unit::SetCharm(Unit* pet)
 void Unit::AddGuardian( Pet* pet )
 {
     m_guardianPets.insert(pet->GetGUID());
+    
+    if(GetTypeId() == TYPEID_PLAYER)
+    {
+        SpellEntry const *spellInfo = sSpellStore.LookupEntry(pet->GetUInt32Value(UNIT_CREATED_BY_SPELL));
+        if (spellInfo && spellInfo->Attributes & SPELL_ATTR_DISABLED_WHILE_ACTIVE)
+            ((Player*)this)->AddSpellAndCategoryCooldowns(spellInfo, 0, NULL,true);
+    }
 }
 
 void Unit::RemoveGuardian( Pet* pet )
 {
     m_guardianPets.erase(pet->GetGUID());
+    
+       if(GetTypeId() == TYPEID_PLAYER)
+    {
+        SpellEntry const *spellInfo = sSpellStore.LookupEntry(pet->GetUInt32Value(UNIT_CREATED_BY_SPELL));
+        if (spellInfo && spellInfo->Attributes & SPELL_ATTR_DISABLED_WHILE_ACTIVE)
+            ((Player*)this)->AddSpellAndCategoryCooldowns(spellInfo, 0, NULL,true);
+    }
 }
 
 void Unit::RemoveGuardians()
@@ -8819,7 +9627,11 @@ void Unit::UnsummonAllTotems()
 
 int32 Unit::DealHeal(Unit *pVictim, uint32 addhealth, SpellEntry const *spellProto, bool critical)
 {
-    int32 gain = pVictim->ModifyHealth(int32(addhealth));
+    // calculate heal absorb and reduce healing
+    uint32 absorb = 0;
+    CalculateHealAbsorb(pVictim, spellProto, addhealth, absorb);
+
+    int32 gain = addhealth ? pVictim->ModifyHealth(int32(addhealth)) : 0;
 
     Unit* unit = this;
 
@@ -8829,7 +9641,7 @@ int32 Unit::DealHeal(Unit *pVictim, uint32 addhealth, SpellEntry const *spellPro
     if (unit->GetTypeId()==TYPEID_PLAYER)
     {
         // overheal = addhealth - gain
-        unit->SendHealSpellLog(pVictim, spellProto->Id, addhealth, addhealth - gain, critical);
+        unit->SendHealSpellLog(pVictim, spellProto->Id, addhealth, addhealth - gain, absorb, critical);
 
         if (BattleGround *bg = ((Player*)unit)->GetBattleGround())
             bg->UpdatePlayerScore((Player*)unit, SCORE_HEALING_DONE, gain);
@@ -8856,7 +9668,8 @@ Unit* Unit::SelectMagnetTarget(Unit *victim, SpellEntry const *spellInfo)
         return NULL;
 
     // Magic case
-    if(spellInfo && (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_NONE || spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC))
+    if(spellInfo && (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_NONE || spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC) &&
+    (spellInfo->SchoolMask & SPELL_SCHOOL_MASK_MAGIC || spellInfo->Mechanic == MECHANIC_GRIP))
     {
         Unit::AuraList const& magnetAuras = victim->GetAurasByType(SPELL_AURA_SPELL_MAGNET);
         for(Unit::AuraList::const_iterator itr = magnetAuras.begin(); itr != magnetAuras.end(); ++itr)
@@ -8872,21 +9685,27 @@ Unit* Unit::SelectMagnetTarget(Unit *victim, SpellEntry const *spellInfo)
             if(Unit* magnet = (*i)->GetCaster())
                 if(magnet->isAlive() && magnet->IsWithinLOSInMap(this))
                     if(roll_chance_i((*i)->GetModifier()->m_amount))
-                        return magnet;
+                        if ((*i)->GetAuraCharges())
+                        {
+                            if((*i)->DropAuraCharge())
+                                victim->RemoveAura((*i),AURA_REMOVE_BY_DEFAULT);
+                            return magnet;
+                        }
     }
 
     return victim;
 }
 
-void Unit::SendHealSpellLog(Unit *pVictim, uint32 SpellID, uint32 Damage, uint32 OverHeal, bool critical)
+void Unit::SendHealSpellLog(Unit *pVictim, uint32 SpellID, uint32 Damage, uint32 OverHeal, uint32 Absorbed, bool critical)
 {
     // we guess size
-    WorldPacket data(SMSG_SPELLHEALLOG, (8+8+4+4+1));
+    WorldPacket data(SMSG_SPELLHEALLOG, (8+8+4+4+4+4+1+1));
     data << pVictim->GetPackGUID();
     data << GetPackGUID();
     data << uint32(SpellID);
     data << uint32(Damage);
     data << uint32(OverHeal);
+    data << uint32(Absorbed);
     data << uint8(critical ? 1 : 0);
     data << uint8(0);                                       // unused in client?
     SendMessageToSet(&data, true);
@@ -8925,7 +9744,21 @@ int32 Unit::SpellBonusWithCoeffs(SpellEntry const *spellProto, int32 total, int3
 
         // apply ap bonus at done part calculation only (it flat total mod so common with taken)
         if (donePart && bonus->ap_bonus)
-            total += int32(bonus->ap_bonus * (GetTotalAttackPowerValue(BASE_ATTACK) + ap_benefit));
+        {
+            float total_bonus = bonus->ap_bonus;
+
+            if (GetTypeId() == TYPEID_PLAYER && ((Player*)this)->getClass() == CLASS_DEATH_KNIGHT)
+            {
+                uint32 impurity_id[5] = {49220,49633,49635,49636,49638};
+                for (int i = 0; i < 5; ++i)
+                    if (((Player*)this)->HasSpell(impurity_id[i]))
+                    {
+                        total_bonus += total_bonus * (sSpellStore.LookupEntry(impurity_id[i])->EffectBasePoints[EFFECT_INDEX_0] + 1) / 100.0f;
+                        break;
+                    }
+            }
+            total += int32(total_bonus * (GetTotalAttackPowerValue(BASE_ATTACK) + ap_benefit));
+        }
     }
     // Default calculation
     else if (benefit)
@@ -8953,6 +9786,7 @@ int32 Unit::SpellBonusWithCoeffs(SpellEntry const *spellProto, int32 total, int3
  * Calculates caster part of spell damage bonuses,
  * also includes different bonuses dependent from target auras
  */
+
 uint32 Unit::SpellDamageBonusDone(Unit *pVictim, SpellEntry const *spellProto, uint32 pdamage, DamageEffectType damagetype, uint32 stack)
 {
     if(!spellProto || !pVictim || damagetype==DIRECT_DAMAGE )
@@ -8965,9 +9799,14 @@ uint32 Unit::SpellDamageBonusDone(Unit *pVictim, SpellEntry const *spellProto, u
             return owner->SpellDamageBonusDone(pVictim, spellProto, pdamage, damagetype);
     }
 
+    // Taken/Done total percent damage auras
     float DoneTotalMod = 1.0f;
+    float TakenTotalMod = 1.0f;
     int32 DoneTotal = 0;
+    int32 TakenTotal = 0;
+    float bonusApCoeff = 1.0f; 
 
+    // ..done
     // Creature damage
     if( GetTypeId() == TYPEID_UNIT && !((Creature*)this)->isPet() )
         DoneTotalMod *= ((Creature*)this)->GetSpellDamageMod(((Creature*)this)->GetCreatureInfo()->rank);
@@ -8996,13 +9835,6 @@ uint32 Unit::SpellDamageBonusDone(Unit *pVictim, SpellEntry const *spellProto, u
         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
             DoneTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
 
-    AuraList const& mDamageDoneCreature = GetAurasByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);
-    for(AuraList::const_iterator i = mDamageDoneCreature.begin();i != mDamageDoneCreature.end(); ++i)
-    {
-        if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-            DoneTotalMod += ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
-    }
-
     // done scripted mod (take it from owner)
     Unit *owner = GetOwner();
     if (!owner) owner = this;
@@ -9095,7 +9927,8 @@ uint32 Unit::SpellDamageBonusDone(Unit *pVictim, SpellEntry const *spellProto, u
             case 7293: // Rage of Rivendare
             {
                 if (pVictim->GetAura(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, UI64LIT(0x0200000000000000)))
-                    DoneTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+                    // Using double of other effect due to missing DBC entry (coincidence match) 
+                    DoneTotalMod *= ((*i)->GetSpellProto()->CalculateSimpleValue(EFFECT_INDEX_1)*2+100.0f)/100.0f; 
                 break;
             }
             // Twisted Faith
@@ -9119,7 +9952,23 @@ uint32 Unit::SpellDamageBonusDone(Unit *pVictim, SpellEntry const *spellProto, u
         }
     }
 
-     // Custom scripted damage
+    // custom scripted mod from dummy
+    AuraList const& mDummy = owner->GetAurasByType(SPELL_AURA_DUMMY);
+    for(AuraList::const_iterator i = mDummy.begin(); i != mDummy.end(); ++i)
+    {
+        SpellEntry const *spell = (*i)->GetSpellProto();
+        //Fire and Brimstone
+        if (spell->SpellFamilyName == SPELLFAMILY_WARLOCK && spell->SpellIconID == 3173)
+        {
+            if (pVictim->HasAuraState(AURA_STATE_CONFLAGRATE) && (spellProto->SpellFamilyName == SPELLFAMILY_WARLOCK && spellProto->SpellFamilyFlags & UI64LIT(0x0002004000000000)))
+            {
+                DoneTotalMod *= ((*i)->GetModifier()->m_amount+100.0f) / 100.0f;
+                break;
+            }
+        }
+    }
+
+    // Custom scripted damage
     switch(spellProto->SpellFamilyName)
     {
         case SPELLFAMILY_MAGE:
@@ -9127,7 +9976,7 @@ uint32 Unit::SpellDamageBonusDone(Unit *pVictim, SpellEntry const *spellProto, u
             // Ice Lance
             if (spellProto->SpellIconID == 186)
             {
-                if (pVictim->isFrozen())
+                if (pVictim->isFrozen() || isIgnoreUnitState(spellProto))
                 {
                     float multiplier = 3.0f;
 
@@ -9158,7 +10007,15 @@ uint32 Unit::SpellDamageBonusDone(Unit *pVictim, SpellEntry const *spellProto, u
             break;
         }
         case SPELLFAMILY_WARLOCK:
+        {
+            // Drain Soul
+            if (spellProto->SpellFamilyFlags & UI64LIT(0x0000000000004000))
+            {
+                if (pVictim->GetHealth() * 100 / pVictim->GetMaxHealth() <= 25)
+                  DoneTotalMod *= 4;
+            }
             break;
+        }
         case SPELLFAMILY_PRIEST:
         {
             // Glyph of Smite
@@ -9194,6 +10051,13 @@ uint32 Unit::SpellDamageBonusDone(Unit *pVictim, SpellEntry const *spellProto, u
         }
         case SPELLFAMILY_DEATHKNIGHT:
         {
+            // Glyph of Unholy Blight 
+            if (spellProto->Id == 50536) 
+            { 
+                if (Aura *glyphAura = GetDummyAura(63332)) 
+                    DoneTotalMod *= (glyphAura->GetModifier()->m_amount + 100.0f)/ 100.0f; 
+                break; 
+            } 
             // Icy Touch and Howling Blast
             if (spellProto->SpellFamilyFlags & UI64LIT(0x0000000200000002))
             {
@@ -9222,11 +10086,37 @@ uint32 Unit::SpellDamageBonusDone(Unit *pVictim, SpellEntry const *spellProto, u
                     }
                 }
             }
+            // Glyph of Unholy Blight
+            if (spellProto->Id == 50536)
+            {
+                if (Aura *glyphAura = GetDummyAura(63332))
+                    DoneTotalMod *= (glyphAura->GetModifier()->m_amount + 100.0f)/ 100.0f;
+                break;
+            }
             break;
         }
         default:
             break;
     }
+    
+    // ..done custom 
+    if (GetTypeId() == TYPEID_PLAYER) 
+    { 
+        // Impurity 
+        uint32 impurityId = 0; 
+        if (HasSpell(49638)) 
+            impurityId = 49638; 
+        else if (HasSpell(49636)) 
+            impurityId = 49636; 
+        else if (HasSpell(49635)) 
+            impurityId = 49635; 
+        else if (HasSpell(49633)) 
+            impurityId = 49633; 
+        else if (HasSpell(49220)) 
+            impurityId = 49220; 
+        if (const SpellEntry *i_spellProto = sSpellStore.LookupEntry(impurityId)) 
+            bonusApCoeff += float(i_spellProto->CalculateSimpleValue(EFFECT_INDEX_0)) / 100.0f;
+    }
 
     // Done fixed damage bonus auras
     int32 DoneAdvertisedBenefit = SpellBaseDamageBonusDone(GetSpellSchoolMask(spellProto));
@@ -9247,10 +10137,6 @@ uint32 Unit::SpellDamageBonusDone(Unit *pVictim, SpellEntry const *spellProto, u
     return tmpDamage > 0 ? uint32(tmpDamage) : 0;
 }
 
-/**
- * Calculates target part of spell damage bonuses,
- * will be called on each tick for periodic damage over time auras
- */
 uint32 Unit::SpellDamageBonusTaken(Unit *pCaster, SpellEntry const *spellProto, uint32 pdamage, DamageEffectType damagetype, uint32 stack)
 {
     if(!spellProto || !pCaster || damagetype==DIRECT_DAMAGE )
@@ -9264,6 +10150,15 @@ uint32 Unit::SpellDamageBonusTaken(Unit *pCaster, SpellEntry const *spellProto,
     AuraList const& mModDamagePercentTaken = GetAurasByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
     for(AuraList::const_iterator i = mModDamagePercentTaken.begin(); i != mModDamagePercentTaken.end(); ++i)
     {
+        // Pulsing Shockwave Aura - Loken (Halls of Ligtning)
+        // Probably should only affect triggered effects - else generating emence dmg from other spells
+        if ((*i)->GetSpellProto()->Id == 59414 && (spellProto->Id == 52942 || spellProto->Id == 59837 || spellProto->Id == 52924))
+        {
+            float fDistance = GetDistance(pCaster);
+            TakenTotal += fDistance < ATTACK_DISTANCE ? 500 : 50;
+            TakenTotalMod *= 1 + (fDistance < ATTACK_DISTANCE ? 0 : fDistance);
+        }
+
         if ((*i)->GetModifier()->m_miscvalue & GetSpellSchoolMask(spellProto))
             TakenTotalMod *= ((*i)->GetModifier()->m_amount + 100.0f) / 100.0f;
     }
@@ -9350,7 +10245,7 @@ int32 Unit::SpellBaseDamageBonusDone(SpellSchoolMask schoolMask)
         }
 
     }
-    return DoneAdvertisedBenefit;
+    return DoneAdvertisedBenefit > 0 ? DoneAdvertisedBenefit : 0;
 }
 
 int32 Unit::SpellBaseDamageBonusTaken(SpellSchoolMask schoolMask)
@@ -9365,11 +10260,15 @@ int32 Unit::SpellBaseDamageBonusTaken(SpellSchoolMask schoolMask)
             TakenAdvertisedBenefit += (*i)->GetModifier()->m_amount;
     }
 
-    return TakenAdvertisedBenefit;
+    return TakenAdvertisedBenefit > 0 ? TakenAdvertisedBenefit : 0;
 }
 
 bool Unit::IsSpellCrit(Unit *pVictim, SpellEntry const *spellProto, SpellSchoolMask schoolMask, WeaponAttackType attackType)
 {
+    // mobs can't crit with spells at all
+    if (GetObjectGuid().IsCreature())
+        return false;
+
     // not critting spell
     if((spellProto->AttributesEx2 & SPELL_ATTR_EX2_CANT_CRIT))
         return false;
@@ -9378,7 +10277,10 @@ bool Unit::IsSpellCrit(Unit *pVictim, SpellEntry const *spellProto, SpellSchoolM
     switch(spellProto->DmgClass)
     {
         case SPELL_DAMAGE_CLASS_NONE:
-            return false;
+        {
+            if (spellProto->Id != 33778) // Lifebloom final tick
+                return false;
+        }
         case SPELL_DAMAGE_CLASS_MAGIC:
         {
             if (schoolMask & SPELL_SCHOOL_MASK_NORMAL)
@@ -9413,9 +10315,9 @@ bool Unit::IsSpellCrit(Unit *pVictim, SpellEntry const *spellProto, SpellSchoolM
                         continue;
                     switch((*i)->GetModifier()->m_miscvalue)
                     {
-                        case  849: if (pVictim->isFrozen()) crit_chance+= 17.0f; break; //Shatter Rank 1
-                        case  910: if (pVictim->isFrozen()) crit_chance+= 34.0f; break; //Shatter Rank 2
-                        case  911: if (pVictim->isFrozen()) crit_chance+= 50.0f; break; //Shatter Rank 3
+                        case  849: if (pVictim->isFrozen() || isIgnoreUnitState(spellProto)) crit_chance+= 17.0f; break; //Shatter Rank 1
+                        case  910: if (pVictim->isFrozen() || isIgnoreUnitState(spellProto)) crit_chance+= 34.0f; break; //Shatter Rank 2
+                        case  911: if (pVictim->isFrozen() || isIgnoreUnitState(spellProto)) crit_chance+= 50.0f; break; //Shatter Rank 3
                         case 7917:                          // Glyph of Shadowburn
                             if (pVictim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
                                 crit_chance+=(*i)->GetModifier()->m_amount;
@@ -9499,6 +10401,26 @@ bool Unit::IsSpellCrit(Unit *pVictim, SpellEntry const *spellProto, SpellSchoolM
             break;
         }
         case SPELL_DAMAGE_CLASS_MELEE:
+            // Rend and Tear crit chance with Ferocious Bite on bleeding target
+            if (spellProto->SpellFamilyName == SPELLFAMILY_DRUID)
+            {
+                if(spellProto->SpellFamilyFlags & UI64LIT(0x0000000000800000))
+                {
+                    if(pVictim->HasAuraState(AURA_STATE_MECHANIC_BLEED))
+                    {
+                        Unit::AuraList const& aura = GetAurasByType(SPELL_AURA_DUMMY);
+                        for(Unit::AuraList::const_iterator itr = aura.begin(); itr != aura.end(); ++itr)
+                        {
+                            if ((*itr)->GetSpellProto()->SpellIconID == 2859 && (*itr)->GetEffIndex() == 1)
+                            {
+                                crit_chance += (*itr)->GetModifier()->m_amount;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+            // do not use break here
         case SPELL_DAMAGE_CLASS_RANGED:
         {
             if (pVictim)
@@ -9598,10 +10520,6 @@ uint32 Unit::SpellCriticalHealingBonus(SpellEntry const *spellProto, uint32 dama
     return damage;
 }
 
-/**
- * Calculates caster part of healing spell bonuses,
- * also includes different bonuses dependent from target auras
- */
 uint32 Unit::SpellHealingBonusDone(Unit *pVictim, SpellEntry const *spellProto, int32 healamount, DamageEffectType damagetype, uint32 stack)
 {
      // For totems get healing bonus from owner (statue isn't totem in fact)
@@ -9615,8 +10533,8 @@ uint32 Unit::SpellHealingBonusDone(Unit *pVictim, SpellEntry const *spellProto,
 
     // Healing Done
     // Done total percent damage auras
-    float  DoneTotalMod = 1.0f;
-    int32  DoneTotal = 0;
+    float DoneTotalMod = 1.0f;
+    int32 DoneTotal = 0;
 
     // Healing done percent
     AuraList const& mHealingDonePct = GetAurasByType(SPELL_AURA_MOD_HEALING_DONE_PERCENT);
@@ -9659,7 +10577,7 @@ uint32 Unit::SpellHealingBonusDone(Unit *pVictim, SpellEntry const *spellProto,
             {
                 int32 stepPercent = (*i)->GetModifier()->m_amount;
 
-                int ownHotCount = 0;                        // counted HoT types amount, not stacks
+                int ownHotCount = 0; // counted HoT types amount, not stacks
 
                 Unit::AuraList const& RejorRegr = pVictim->GetAurasByType(SPELL_AURA_PERIODIC_HEAL);
                 for(Unit::AuraList::const_iterator i = RejorRegr.begin(); i != RejorRegr.end(); ++i)
@@ -9682,10 +10600,10 @@ uint32 Unit::SpellHealingBonusDone(Unit *pVictim, SpellEntry const *spellProto,
         }
     }
 
-    // Nourish 20% of heal increase if target is affected by Druids HOTs
+   // Nourish 20% of heal increase if target is affected by Druids HOTs
     if (spellProto->SpellFamilyName == SPELLFAMILY_DRUID && (spellProto->SpellFamilyFlags & UI64LIT(0x0200000000000000)))
     {
-        int ownHotCount = 0;                        // counted HoT types amount, not stacks
+        int ownHotCount = 0; // counted HoT types amount, not stacks
         Unit::AuraList const& RejorRegr = pVictim->GetAurasByType(SPELL_AURA_PERIODIC_HEAL);
         for(Unit::AuraList::const_iterator i = RejorRegr.begin(); i != RejorRegr.end(); ++i)
             if ((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_DRUID &&
@@ -9694,7 +10612,7 @@ uint32 Unit::SpellHealingBonusDone(Unit *pVictim, SpellEntry const *spellProto,
 
         if (ownHotCount)
         {
-            DoneTotalMod *= 1.2f;                          // base bonus at HoTs
+            DoneTotalMod *= 1.2f; // base bonus at HoTs
 
             if (Aura* glyph = GetAura(62971, EFFECT_INDEX_0))// Glyph of Nourish
                 DoneTotalMod *= (glyph->GetModifier()->m_amount * ownHotCount + 100.0f) / 100.0f;
@@ -9897,6 +10815,15 @@ bool Unit::IsImmunedToSpellEffect(SpellEntry const* spellInfo, SpellEffectIndex
                 ((*iter)->GetModifier()->m_miscvalue & GetSpellSchoolMask(spellInfo)) &&  // Check school
                 !IsPositiveEffect(spellInfo->Id, index))                                  // Harmful
                 return true;
+
+        AuraList const& immuneMechanicAuraApply = GetAurasByType(SPELL_AURA_MECHANIC_IMMUNITY_MASK);
+        for(AuraList::const_iterator i = immuneMechanicAuraApply.begin(); i != immuneMechanicAuraApply.end(); ++i)
+            if ((spellInfo->EffectMechanic[index] & (*i)->GetMiscValue() ||
+                spellInfo->Mechanic & (*i)->GetMiscValue()) ||
+                ((*i)->GetId() == 46924 &&                                                // Bladestorm Immunity
+                spellInfo->EffectMechanic[index] & IMMUNE_TO_MOVEMENT_IMPAIRMENT_AND_LOSS_CONTROL_MASK ||
+                spellInfo->Mechanic & IMMUNE_TO_MOVEMENT_IMPAIRMENT_AND_LOSS_CONTROL_MASK))
+                return true;
     }
 
     return false;
@@ -9945,6 +10872,7 @@ uint32 Unit::MeleeDamageBonusDone(Unit *pVictim, uint32 pdamage,WeaponAttackType
     // FLAT damage bonus auras
     // =======================
     int32 DoneFlat  = 0;
+    int32 TakenFlat = 0;
     int32 APbonus   = 0;
 
     // ..done flat, already included in wepon damage based spells
@@ -9975,16 +10903,23 @@ uint32 Unit::MeleeDamageBonusDone(Unit *pVictim, uint32 pdamage,WeaponAttackType
     {
         APbonus += pVictim->GetTotalAuraModifier(SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS);
         APbonus += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RANGED_ATTACK_POWER_VERSUS, creatureTypeMask);
+        TakenFlat += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN);
     }
     else
     {
         APbonus += pVictim->GetTotalAuraModifier(SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS);
         APbonus += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_MELEE_ATTACK_POWER_VERSUS, creatureTypeMask);
+        TakenFlat += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN);
     }
 
+    // ..taken flat (by school mask)
+    TakenFlat += pVictim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_DAMAGE_TAKEN, schoolMask);
+
     // PERCENT damage auras
     // ====================
     float DonePercent   = 1.0f;
+    float TakenPercent  = 1.0f;
+    float bonusApCoeff  = 1.0f; 
 
     // ..done pct, already included in weapon damage based spells
     if(!isWeaponDamageBasedSpell)
@@ -10008,6 +10943,23 @@ uint32 Unit::MeleeDamageBonusDone(Unit *pVictim, uint32 pdamage,WeaponAttackType
     // ..done pct (by creature type mask)
     DonePercent *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS, creatureTypeMask);
 
+    // ..taken pct (by school mask)
+    TakenPercent *= pVictim->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, schoolMask);
+
+    // ..taken pct (by mechanic mask)
+    TakenPercent *= pVictim->GetTotalAuraMultiplierByMiscValueForMask(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT,mechanicMask);
+
+    // ..taken pct (melee/ranged)
+    if(attType == RANGED_ATTACK)
+        TakenPercent *= pVictim->GetTotalAuraMultiplier(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN_PCT);
+    else
+        TakenPercent *= pVictim->GetTotalAuraMultiplier(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN_PCT);
+
+    // ..taken pct (aoe avoidance)
+    if(spellProto && IsAreaOfEffectSpell(spellProto))
+        TakenPercent *= pVictim->GetTotalAuraMultiplier(SPELL_AURA_MOD_AOE_DAMAGE_AVOIDANCE);
+
+
     // special dummys/class sripts and other effects
     // =============================================
     Unit *owner = GetOwner();
@@ -10047,7 +10999,8 @@ uint32 Unit::MeleeDamageBonusDone(Unit *pVictim, uint32 pdamage,WeaponAttackType
                 case 7293: // Rage of Rivendare
                 {
                     if (pVictim->GetAura(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, UI64LIT(0x0200000000000000)))
-                        DonePercent *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+                        // Using double of other effect due to missing DBC entry (coincidence match) 
+                        DonePercent *= ((*i)->GetSpellProto()->CalculateSimpleValue(EFFECT_INDEX_1)*2+100.0f)/100.0f; 
                     break;
                 }
                 // Marked for Death
@@ -10064,8 +11017,78 @@ uint32 Unit::MeleeDamageBonusDone(Unit *pVictim, uint32 pdamage,WeaponAttackType
             }
         }
     }
+    // ..done custom 
+    if (GetTypeId() == TYPEID_PLAYER) 
+    { 
+        // Impurity 
+        uint32 impurityId = 0; 
+        if (HasSpell(49638)) 
+           impurityId = 49638; 
+        else if (HasSpell(49636)) 
+           impurityId = 49636; 
+        else if (HasSpell(49635)) 
+           impurityId = 49635; 
+        else if (HasSpell(49633)) 
+           impurityId = 49633; 
+        else if (HasSpell(49220)) 
+           impurityId = 49220; 
+ 
+        if (const SpellEntry *i_spellProto = sSpellStore.LookupEntry(impurityId)) 
+           bonusApCoeff += float(i_spellProto->CalculateSimpleValue(EFFECT_INDEX_0)) / 100.0f; 
+    }
+ 
+    // .. taken pct: SPELL_AURA_284
+    AuraList const& mAuraListAura284 = pVictim->GetAurasByType(SPELL_AURA_LINKED);
+    for(AuraList::const_iterator i = mAuraListAura284.begin(); i != mAuraListAura284.end(); ++i)
+    {
+        // Crypt Fever and Ebon Plague
+        if((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT)
+        {
+            if (!spellProto)
+                continue;
+            if (spellProto->Dispel ==  DISPEL_DISEASE)
+                TakenPercent *= ((*i)->GetModifier()->m_amount + 100.0f) / 100.0f;
+        }
+    }
+    // .. taken (dummy auras)
+    AuraList const& mDummyAuras = pVictim->GetAurasByType(SPELL_AURA_DUMMY);
+    for(AuraList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
+    {
+        switch((*i)->GetSpellProto()->SpellIconID)
+        {
+            //Cheat Death
+            case 2109:
+                if((*i)->GetModifier()->m_miscvalue & SPELL_SCHOOL_MASK_NORMAL)
+                {
+                    if(pVictim->GetTypeId() != TYPEID_PLAYER)
+                        continue;
+
+                    float mod = ((Player*)pVictim)->GetRatingBonusValue(CR_CRIT_TAKEN_MELEE)*(-8.0f);
+                    if (mod < float((*i)->GetModifier()->m_amount))
+                        mod = float((*i)->GetModifier()->m_amount);
 
-    // .. done (class scripts)
+                    TakenPercent *= (mod + 100.0f) / 100.0f;
+                }
+                break;
+            case 19:                // Blessing of Sanctuary 
+            case 1804:              // Greater Blessing of Sanctuary 
+                if ((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_PALADIN) 
+                    TakenPercent *= ((*i)->GetModifier()->m_amount + 100.0f) / 100.0f; 
+                break;
+            // Ebon Plague 
+            case 1933: 
+            { 
+                if((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT) 
+                { 
+                    if((*i)->GetModifier()->m_miscvalue & schoolMask) 
+                        TakenPercent *= ((*i)->GetModifier()->m_amount + 100.0f) / 100.0f; 
+                } 
+                break; 
+            }
+        }
+    }
+
+    // .. taken (class scripts)
     AuraList const& mclassScritAuras = GetAurasByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
     for(AuraList::const_iterator i = mclassScritAuras.begin(); i != mclassScritAuras.end(); ++i)
     {
@@ -10084,7 +11107,7 @@ uint32 Unit::MeleeDamageBonusDone(Unit *pVictim, uint32 pdamage,WeaponAttackType
                     }
 
                     // effect 0 have expected value but in negative state
-                    DonePercent *= (-eff0->GetModifier()->m_amount + 100.0f) / 100.0f;
+                    TakenPercent *= (-eff0->GetModifier()->m_amount + 100.0f) / 100.0f;
                 }
                 break;
         }
@@ -10164,14 +11187,12 @@ uint32 Unit::MeleeDamageBonusDone(Unit *pVictim, uint32 pdamage,WeaponAttackType
             modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, tmpDamage);
     }
 
+    tmpDamage = (tmpDamage + TakenFlat) * TakenPercent;
+
     // bonus result can be negative
     return tmpDamage > 0 ? uint32(tmpDamage) : 0;
 }
 
-/**
- * Calculates target part of melee damage bonuses,
- * will be called on each tick for periodic damage over time auras
- */
 uint32 Unit::MeleeDamageBonusTaken(Unit *pCaster, uint32 pdamage,WeaponAttackType attType, SpellEntry const *spellProto, DamageEffectType damagetype, uint32 stack)
 {
      if (!pCaster)
@@ -10182,8 +11203,8 @@ uint32 Unit::MeleeDamageBonusTaken(Unit *pCaster, uint32 pdamage,WeaponAttackTyp
 
     // differentiate for weapon damage based spells
     bool isWeaponDamageBasedSpell = !(spellProto && (damagetype == DOT || IsSpellHaveEffect(spellProto, SPELL_EFFECT_SCHOOL_DAMAGE)));
-    uint32 schoolMask       = spellProto ? spellProto->SchoolMask : GetMeleeDamageSchoolMask();
-    uint32 mechanicMask     = spellProto ? GetAllSpellMechanicMask(spellProto) : 0;
+    uint32 schoolMask = spellProto ? spellProto->SchoolMask : GetMeleeDamageSchoolMask();
+    uint32 mechanicMask = spellProto ? GetAllSpellMechanicMask(spellProto) : 0;
 
     // Shred also have bonus as MECHANIC_BLEED damages
     if (spellProto && spellProto->SpellFamilyName==SPELLFAMILY_DRUID && spellProto->SpellFamilyFlags & UI64LIT(0x00008000))
@@ -10205,7 +11226,7 @@ uint32 Unit::MeleeDamageBonusTaken(Unit *pCaster, uint32 pdamage,WeaponAttackTyp
 
     // PERCENT damage auras
     // ====================
-    float TakenPercent  = 1.0f;
+    float TakenPercent = 1.0f;
 
     // ..taken pct (by school mask)
     TakenPercent *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, schoolMask);
@@ -10302,6 +11323,10 @@ void Unit::ApplySpellDispelImmunity(const SpellEntry * spellProto, DispelType ty
 {
     ApplySpellImmune(spellProto->Id,IMMUNITY_DISPEL, type, apply);
 
+    // such dispell type should not remove auras but only return visibility
+    if(type == DISPEL_STEALTH || type == DISPEL_INVISIBILITY)
+        return;
+
     if (apply && spellProto->AttributesEx & SPELL_ATTR_EX_DISPEL_AURAS_ON_IMMUNITY)
         RemoveAurasWithDispelType(type);
 }
@@ -10421,6 +11446,34 @@ void Unit::SetInCombatState(bool PvP, Unit* enemy)
     if (isCharmed() || (GetTypeId()!=TYPEID_PLAYER && ((Creature*)this)->isPet()))
         SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);
 
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; ++i)
+        {
+            // skip channeled spell (processed differently below)
+            if (i == CURRENT_CHANNELED_SPELL)
+                continue;
+
+            if(Spell* spell = GetCurrentSpell(CurrentSpellTypes(i)))
+            {
+                if(spell->getState() == SPELL_STATE_PREPARING)
+                {
+                    if(spell->m_spellInfo->Attributes & SPELL_ATTR_CANT_USED_IN_COMBAT)
+                        InterruptSpell(CurrentSpellTypes(i));
+                }
+            }
+        }
+
+        if(Spell* spell = m_currentSpells[CURRENT_CHANNELED_SPELL])
+        {
+            if (spell->getState() == SPELL_STATE_CASTING)
+            {
+                if(spell->m_spellInfo->Attributes & SPELL_ATTR_CANT_USED_IN_COMBAT)
+                    InterruptSpell(CURRENT_CHANNELED_SPELL);
+            }
+        }
+    }
+
     if (creatureNotInCombat)
     {
         // should probably be removed for the attacked (+ it's party/group) only, not global
@@ -10669,6 +11722,39 @@ bool Unit::isVisibleForOrDetect(Unit const* u, WorldObject const* viewPoint, boo
     {
         invisible = false;
     }
+    
+    // In DK starting map enemy players should be invisible
+    if(GetMapId() == 609)
+    {
+        if(GetTypeId() == TYPEID_PLAYER && u->GetTypeId() == TYPEID_PLAYER)
+        {
+            if(((Player*)this)->GetTeam() == ((Player*)u)->GetTeam())
+                invisible = false;
+            else
+                invisible = true;
+        }
+        else
+            invisible = false;
+    }
+    
+    // With Arena Preparation players shouldn't see opposite team in arenas
+    if(HasAura(32727))
+    {
+        if(GetTypeId() == TYPEID_PLAYER && u->GetTypeId() == TYPEID_PLAYER)
+        {
+            if( (HasAura(SPELL_HORDE_GOLD_FLAG) && u->HasAura(SPELL_HORDE_GOLD_FLAG)) ||
+                (HasAura(SPELL_ALLIANCE_GOLD_FLAG) && u->HasAura(SPELL_ALLIANCE_GOLD_FLAG)) ||
+                (HasAura(SPELL_HORDE_GREEN_FLAG) && u->HasAura(SPELL_HORDE_GREEN_FLAG)) ||
+                (HasAura(SPELL_ALLIANCE_GREEN_FLAG) && u->HasAura(SPELL_ALLIANCE_GREEN_FLAG)))
+                invisible = false;
+            else
+                invisible = true;
+        }
+    }
+
+    // Arena preparation hack
+    if(HasAura(SPELL_ARENA_PREPARATION))
+        invisible = true;
 
     // special cases for always overwrite invisibility/stealth
     if(invisible || m_Visibility == VISIBILITY_GROUP_STEALTH)
@@ -10689,11 +11775,17 @@ bool Unit::isVisibleForOrDetect(Unit const* u, WorldObject const* viewPoint, boo
         else
         {
             // Hunter mark functionality
-            AuraList const& auras = GetAurasByType(SPELL_AURA_MOD_STALKED);
-            for(AuraList::const_iterator iter = auras.begin(); iter != auras.end(); ++iter)
+            AuraList const& aurasstalked = GetAurasByType(SPELL_AURA_MOD_STALKED);
+            for(AuraList::const_iterator iter = aurasstalked.begin(); iter != aurasstalked.end(); ++iter)
                 if((*iter)->GetCasterGUID()==u->GetGUID())
                     return true;
 
+            // Flare functionality
+            AuraList const& aurasimunity = GetAurasByType(SPELL_AURA_DISPEL_IMMUNITY);
+            for(AuraList::const_iterator iter = aurasimunity.begin(); iter != aurasimunity.end(); ++iter)
+                if((*iter)->GetMiscValue() == uint8(invisible ? DISPEL_INVISIBILITY : DISPEL_STEALTH))
+                    return true;
+
             // else apply detecting check for stealth
         }
 
@@ -10933,7 +12025,27 @@ void Unit::UpdateSpeed(UnitMoveType mtype, bool forced, float ratio)
             return;
     }
 
+    // Remove Druid Dash bonus if not in Cat Form
+    if (m_form != FORM_CAT)
+    {
+        AuraList const& speed_increase_auras = GetAurasByType(SPELL_AURA_MOD_INCREASE_SPEED);
+        for(AuraList::const_iterator itr = speed_increase_auras.begin(); itr != speed_increase_auras.end(); ++itr)
+        {
+            const SpellEntry* aura_proto = (*itr)->GetSpellProto();
+            if (aura_proto->SpellFamilyName == SPELLFAMILY_DRUID && aura_proto->SpellIconID == 959)
+            {
+                main_speed_mod -= (*itr)->GetModifier()->m_amount;
+                break;
+            }
+        }
+    }
+
     float bonus = non_stack_bonus > stack_bonus ? non_stack_bonus : stack_bonus;
+
+    //apply creature's base speed
+    if(GetTypeId() == TYPEID_UNIT)
+        bonus *= ((Creature*)this)->GetBaseSpeed();
+
     // now we ready for speed calculation
     float speed  = main_speed_mod ? bonus*(100.0f + main_speed_mod)/100.0f : bonus;
 
@@ -11130,6 +12242,7 @@ void Unit::setDeathState(DeathState s)
 
     if (s == JUST_DIED)
     {
+        ExitVehicle();
         RemoveAllAurasOnDeath();
         RemoveGuardians();
         UnsummonAllTotems();
@@ -11205,7 +12318,29 @@ float Unit::ApplyTotalThreatModifier(float threat, SpellSchoolMask schoolMask)
 
 void Unit::AddThreat(Unit* pVictim, float threat /*= 0.0f*/, bool crit /*= false*/, SpellSchoolMask schoolMask /*= SPELL_SCHOOL_MASK_NONE*/, SpellEntry const *threatSpell /*= NULL*/)
 {
-    // Only mobs can manage threat lists
+    //Prevent crash, but that should be checked before call this void. Damn SD2
+    if(!pVictim)
+        return;
+
+    if(!pVictim->isAlive())
+        return;
+
+    //Misdirection hack
+    if (pVictim->GetTypeId() == TYPEID_PLAYER && pVictim->HasAura(34477, EFFECT_INDEX_1))
+        if (Group *pGroup = ((Player*)pVictim)->GetGroup())
+            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                if (Unit* realVictim = itr->getSource())
+                    if (Aura* misdirection = realVictim->GetDummyAura(35079))
+                        if (pVictim->GetGUID() == misdirection->GetCasterGUID() && realVictim->IsInMap(pVictim))
+                        {
+                            pVictim = realVictim;
+                            break;
+                        }
+
+    if(!pVictim || !pVictim->isAlive())
+        return;
+
+    //Only mobs can manage threat lists
     if(CanHaveThreatList())
         m_ThreatManager.addThreat(pVictim, threat, crit, schoolMask, threatSpell);
 }
@@ -11355,7 +12490,8 @@ bool Unit::SelectHostileTarget()
     }
 
     // enter in evade mode in other case
-    ((Creature*)this)->AI()->EnterEvadeMode();
+    if(!((Creature*)this)->isVehicle())
+        ((Creature*)this)->AI()->EnterEvadeMode();
 
     return false;
 }
@@ -11366,9 +12502,16 @@ bool Unit::SelectHostileTarget()
 
 int32 Unit::CalculateSpellDamage(Unit const* target, SpellEntry const* spellProto, SpellEffectIndex effect_index, int32 const* effBasePoints)
 {
-    Player* unitPlayer = (GetTypeId() == TYPEID_PLAYER) ? (Player*)this : NULL;
+    Player* unitPlayer;
 
-    uint8 comboPoints = unitPlayer ? unitPlayer->GetComboPoints() : 0;
+    if(GetTypeId() == TYPEID_PLAYER)
+        unitPlayer = (Player*)this;
+    else if(((Creature*)this)->isVehicle())
+        unitPlayer = (Player*)GetCharmer();
+    else
+        unitPlayer = NULL;
+
+    uint8 comboPoints = (GetTypeId() != TYPEID_PLAYER && ((Creature*)this)->isVehicle() ? ((Vehicle*)this)->m_comboPointsForCast : (unitPlayer ? unitPlayer->GetComboPoints() : 0));
 
     int32 level = int32(getLevel());
     if (level > (int32)spellProto->maxLevel && spellProto->maxLevel > 0)
@@ -11431,7 +12574,14 @@ int32 Unit::CalculateSpellDamage(Unit const* target, SpellEntry const* spellProt
 
 int32 Unit::CalculateSpellDuration(SpellEntry const* spellProto, SpellEffectIndex effect_index, Unit const* target)
 {
-    Player* unitPlayer = (GetTypeId() == TYPEID_PLAYER) ? (Player*)this : NULL;
+    Player* unitPlayer;
+
+    if(GetTypeId() == TYPEID_PLAYER)
+        unitPlayer = (Player*)this;
+    else if(((Creature*)this)->isVehicle())
+        unitPlayer = (Player*)GetCharmer();
+    else
+        unitPlayer = NULL;
 
     uint8 comboPoints = unitPlayer ? unitPlayer->GetComboPoints() : 0;
 
@@ -11445,6 +12595,52 @@ int32 Unit::CalculateSpellDuration(SpellEntry const* spellProto, SpellEffectInde
     else
         duration = minduration;
 
+    if (unitPlayer && target == this)
+    {
+        switch(spellProto->SpellFamilyName)
+        {
+            case SPELLFAMILY_DRUID:
+                if (spellProto->SpellFamilyFlags & UI64LIT(0x100))
+                {
+                    // Glyph of Thorns
+                    if (Aura *aur = GetAura(57862, EFFECT_INDEX_0))
+                        duration += aur->GetModifier()->m_amount * MINUTE * IN_MILLISECONDS;
+                }
+                break;
+            case SPELLFAMILY_PALADIN:
+                if (spellProto->SpellIconID == 298 && spellProto->SpellFamilyFlags & UI64LIT(0x00000002))
+                {
+                    // Glyph of Blessing of Might
+                    if (Aura *aur = GetAura(57958, EFFECT_INDEX_0))
+                        duration += aur->GetModifier()->m_amount * MINUTE * IN_MILLISECONDS;
+                }
+                else if (spellProto->SpellIconID == 306 && spellProto->SpellFamilyFlags & UI64LIT(0x00010000))
+                {
+                    // Glyph of Blessing of Wisdom
+                    if (Aura *aur = GetAura(57979, EFFECT_INDEX_0))
+                        duration += aur->GetModifier()->m_amount * MINUTE * IN_MILLISECONDS;
+                }
+                break;
+            default:
+                break;
+        }
+    }
+    // Duration in PvP is limited
+    if (!IsFriendlyTo(target))
+    {
+        Unit const* casterOwner = GetCharmerOrOwner();
+        Unit const* targetOwner = target->GetCharmerOrOwner();
+        casterOwner = casterOwner ? casterOwner : this;
+        targetOwner = targetOwner ? targetOwner : target;
+        if (targetOwner->GetTypeId() == TYPEID_PLAYER && casterOwner->GetTypeId() == TYPEID_PLAYER)
+        {
+            DiminishingGroup diminishingGroup = GetDiminishingReturnsGroupForSpell(spellProto, false/*doesn't matter for this purpose*/);
+            int32 limitPvpDuration = GetDiminishingReturnsLimitDuration(diminishingGroup, spellProto);
+            limitPvpDuration = limitPvpDuration ? limitPvpDuration: 10000;
+            if (diminishingGroup != DIMINISHING_NONE)
+                duration = duration > limitPvpDuration ? limitPvpDuration : duration;
+        }
+    }       
     if (duration > 0)
     {
         int32 mechanic = GetEffectMechanic(spellProto, effect_index);
@@ -11519,7 +12715,7 @@ void Unit::IncrDiminishing(DiminishingGroup group)
 
 void Unit::ApplyDiminishingToDuration(DiminishingGroup group, int32 &duration,Unit* caster,DiminishingLevels Level, int32 limitduration)
 {
-    if(duration == -1 || group == DIMINISHING_NONE || caster->IsFriendlyTo(this) )
+    if(duration == -1 || group == DIMINISHING_NONE)
         return;
 
     // Duration of crowd control abilities on pvp target is limited by 10 sec. (2.2.0)
@@ -11841,15 +13037,10 @@ void Unit::SetHealth(uint32 val)
         if(((Player*)this)->GetGroup())
             ((Player*)this)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_HP);
     }
-    else if(((Creature*)this)->isPet())
+    else if(Unit* owner = GetCharmerOrOwner())
     {
-        Pet *pet = ((Pet*)this);
-        if(pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if(owner && (owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
-                ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_HP);
-        }
+        if((owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
+            ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_HP);
     }
 }
 
@@ -11864,15 +13055,10 @@ void Unit::SetMaxHealth(uint32 val)
         if(((Player*)this)->GetGroup())
             ((Player*)this)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_HP);
     }
-    else if(((Creature*)this)->isPet())
+    else if(Unit* owner = GetCharmerOrOwner())
     {
-        Pet *pet = ((Pet*)this);
-        if(pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if(owner && (owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
-                ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_HP);
-        }
+        if((owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
+            ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_HP);
     }
 
     if(val < health)
@@ -11908,20 +13094,19 @@ void Unit::SetPower(Powers power, uint32 val)
         if(((Player*)this)->GetGroup())
             ((Player*)this)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_POWER);
     }
-    else if(((Creature*)this)->isPet())
+    else if(Unit* owner = GetCharmerOrOwner())
     {
-        Pet *pet = ((Pet*)this);
-        if(pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if(owner && (owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
-                ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_POWER);
-        }
+        if((owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
+            ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_POWER);
 
-        // Update the pet's character sheet with happiness damage bonus
-        if(pet->getPetType() == HUNTER_PET && power == POWER_HAPPINESS)
+        if(((Creature*)this)->isPet())
         {
-            pet->UpdateDamagePhysical(BASE_ATTACK);
+            Pet *pet = ((Pet*)this);
+            // Update the pet's character sheet with happiness damage bonus
+            if(pet->getPetType() == HUNTER_PET && power == POWER_HAPPINESS)
+            {
+                pet->UpdateDamagePhysical(BASE_ATTACK);
+            }
         }
     }
 }
@@ -11937,15 +13122,10 @@ void Unit::SetMaxPower(Powers power, uint32 val)
         if(((Player*)this)->GetGroup())
             ((Player*)this)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_POWER);
     }
-    else if(((Creature*)this)->isPet())
+    else if(Unit* owner = GetCharmerOrOwner())
     {
-        Pet *pet = ((Pet*)this);
-        if(pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if(owner && (owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
-                ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_POWER);
-        }
+        if((owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
+            ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_POWER);
     }
 
     if(val < cur_power)
@@ -11962,15 +13142,10 @@ void Unit::ApplyPowerMod(Powers power, uint32 val, bool apply)
         if(((Player*)this)->GetGroup())
             ((Player*)this)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_POWER);
     }
-    else if(((Creature*)this)->isPet())
+    else if(Unit* owner = GetCharmerOrOwner())
     {
-        Pet *pet = ((Pet*)this);
-        if(pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if(owner && (owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
-                ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_POWER);
-        }
+        if((owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
+            ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_POWER);
     }
 }
 
@@ -11984,15 +13159,10 @@ void Unit::ApplyMaxPowerMod(Powers power, uint32 val, bool apply)
         if(((Player*)this)->GetGroup())
             ((Player*)this)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_POWER);
     }
-    else if(((Creature*)this)->isPet())
+    else if(Unit* owner = GetCharmerOrOwner())
     {
-        Pet *pet = ((Pet*)this);
-        if(pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if(owner && (owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
-                ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_POWER);
-        }
+        if((owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
+            ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_POWER);
     }
 }
 
@@ -12046,6 +13216,7 @@ void Unit::RemoveFromWorld()
 
 void Unit::CleanupsBeforeDelete()
 {
+    ExitVehicle();                                          // make sure we always leave vehicle, otherwise it will crash
     if(m_uint32Values)                                      // only for fully created object
     {
         InterruptNonMeleeSpells(true);
@@ -12513,8 +13684,10 @@ void Unit::ProcDamageAndSpellFor( bool isVictim, Unit * pTarget, uint32 procFlag
                 break;
             }
             case SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN:
+            case SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE:
             case SPELL_AURA_MANA_SHIELD:
             case SPELL_AURA_OBS_MOD_MANA:
+            case SPELL_AURA_MOD_STUN:
             case SPELL_AURA_ADD_PCT_MODIFIER:
             case SPELL_AURA_DUMMY:
             {
@@ -12770,7 +13943,7 @@ void Unit::SetFeared(bool apply, uint64 const& casterGUID, uint32 spellID, uint3
     {
         RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FLEEING);
 
-        GetMotionMaster()->MovementExpired(false);
+        GetMotionMaster()->Clear(false, true);
 
         if( GetTypeId() != TYPEID_PLAYER && isAlive() )
         {
@@ -12787,8 +13960,12 @@ void Unit::SetFeared(bool apply, uint64 const& casterGUID, uint32 spellID, uint3
         }
     }
 
-    if (GetTypeId() == TYPEID_PLAYER)
+    if (GetTypeId() == TYPEID_PLAYER && !GetVehicleGUID())
         ((Player*)this)->SetClientControl(this, !apply);
+
+    if (Unit* owner = GetCharmer())
+        if (owner->GetTypeId() == TYPEID_PLAYER)
+            ((Player*)owner)->SetClientControl(this, !apply);
 }
 
 void Unit::SetConfused(bool apply, uint64 const& casterGUID, uint32 spellID)
@@ -12805,7 +13982,7 @@ void Unit::SetConfused(bool apply, uint64 const& casterGUID, uint32 spellID)
     {
         RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CONFUSED);
 
-        GetMotionMaster()->MovementExpired(false);
+        GetMotionMaster()->Clear(false, true);
 
         if (GetTypeId() != TYPEID_PLAYER && isAlive())
         {
@@ -12817,8 +13994,12 @@ void Unit::SetConfused(bool apply, uint64 const& casterGUID, uint32 spellID)
         }
     }
 
-    if(GetTypeId() == TYPEID_PLAYER)
+    if(GetTypeId() == TYPEID_PLAYER && !GetVehicleGUID())
         ((Player*)this)->SetClientControl(this, !apply);
+
+    if (Unit* owner = GetCharmer())
+        if (owner->GetTypeId() == TYPEID_PLAYER)
+            ((Player*)owner)->SetClientControl(this, !apply);
 }
 
 void Unit::SetFeignDeath(bool apply, uint64 const& casterGUID, uint32 /*spellID*/)
@@ -12922,13 +14103,9 @@ void Unit::SetDisplayId(uint32 modelId)
 {
     SetUInt32Value(UNIT_FIELD_DISPLAYID, modelId);
 
-    if(GetTypeId() == TYPEID_UNIT && ((Creature*)this)->isPet())
+    if(Unit *owner = GetCharmerOrOwner())
     {
-        Pet *pet = ((Pet*)this);
-        if(!pet->isControlled())
-            return;
-        Unit *owner = GetOwner();
-        if(owner && (owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
+        if((owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
             ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MODEL_ID);
     }
 }
@@ -13117,16 +14294,14 @@ void Unit::UpdateAuraForGroup(uint8 slot)
             player->SetAuraUpdateMask(slot);
         }
     }
-    else if(GetTypeId() == TYPEID_UNIT && ((Creature*)this)->isPet())
+    else if(GetTypeId() == TYPEID_UNIT)
     {
-        Pet *pet = ((Pet*)this);
-        if(pet->isControlled())
+        if(Unit *owner = GetCharmerOrOwner())
         {
-            Unit *owner = GetOwner();
-            if(owner && (owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
+            if((owner->GetTypeId() == TYPEID_PLAYER) && ((Player*)owner)->GetGroup())
             {
                 ((Player*)owner)->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_AURAS);
-                pet->SetAuraUpdateMask(slot);
+                SetAuraUpdateMask(slot);
             }
         }
     }
@@ -13290,7 +14465,7 @@ bool Unit::IsTriggeredAtSpellProcEvent(Unit *pVictim, Aura* aura, SpellEntry con
     }
     // Aura added by spell can`t trogger from self (prevent drop charges/do triggers)
     // But except periodic triggers (can triggered from self)
-    if(procSpell && procSpell->Id == spellProto->Id && !(spellProto->procFlags & PROC_FLAG_ON_TAKE_PERIODIC))
+    if(procSpell && procSpell->Id == spellProto->Id && !(spellProto->procFlags & PROC_FLAG_ON_TAKE_PERIODIC) && aura->GetModifier()->m_auraname != SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE)
         return false;
 
     // Check if current equipment allows aura to proc
@@ -13433,6 +14608,7 @@ void Unit::NearTeleportTo( float x, float y, float z, float orientation, bool ca
         ((Player*)this)->TeleportTo(GetMapId(), x, y, z, orientation, TELE_TO_NOT_LEAVE_TRANSPORT | TELE_TO_NOT_LEAVE_COMBAT | TELE_TO_NOT_UNSUMMON_PET | (casting ? TELE_TO_SPELL : 0));
     else
     {
+        ExitVehicle();
         Creature* c = (Creature*)this;
         // Creature relocation acts like instant movement generator, so current generator expects interrupt/reset calls to react properly
         if (!c->GetMotionMaster()->empty())
@@ -13504,6 +14680,121 @@ struct SetPvPHelper
     bool state;
 };
 
+void Unit::ChangeSeat(int8 seatId, bool next)
+{
+    Vehicle *m_vehicle = ObjectAccessor::GetVehicle(GetVehicleGUID());
+
+    if (!m_vehicle)
+        return;
+
+    if (seatId < 0)
+    {
+        seatId = m_vehicle->GetNextEmptySeatNum(m_movementInfo.GetTransportSeat(), next);
+        if (seatId < 0)
+            return;
+    }
+    else if (seatId == m_movementInfo.GetTransportSeat() || !m_vehicle->HasEmptySeat(seatId))
+        return;
+
+    m_vehicle->RemovePassenger(this);
+    EnterVehicle(m_vehicle, seatId);
+}
+
+void Unit::EnterVehicle(Vehicle *vehicle, int8 seat_id, bool force)
+{
+    // dont allow multiple vehicles
+    ExitVehicle();
+
+    RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
+    // NOTE : shapeshift too?
+
+    Vehicle *v = vehicle->FindFreeSeat(&seat_id, force);
+    if(!v)
+        return;
+
+    VehicleEntry const *ve = sVehicleStore.LookupEntry(v->GetVehicleId());
+    if(!ve)
+        return;
+
+    VehicleSeatEntry const *veSeat = sVehicleSeatStore.LookupEntry(ve->m_seatID[seat_id]);
+    if(!veSeat)
+        return;
+
+    m_movementInfo.SetTransportData(v->GetGUID(),
+        (veSeat->m_attachmentOffsetX + v->GetObjectSize()) * GetFloatValue(OBJECT_FIELD_SCALE_X),
+        (veSeat->m_attachmentOffsetY + v->GetObjectSize()) * GetFloatValue(OBJECT_FIELD_SCALE_X),
+        (veSeat->m_attachmentOffsetZ + v->GetObjectSize()) * GetFloatValue(OBJECT_FIELD_SCALE_X),
+        veSeat->m_passengerYaw, v->GetCreationTime(), seat_id, veSeat->m_ID,
+        sObjectMgr.GetSeatFlags(veSeat->m_ID), v->GetVehicleFlags());
+
+    addUnitState(UNIT_STAT_ON_VEHICLE);
+    InterruptNonMeleeSpells(false);
+
+    if(Pet *pet = GetPet())
+        pet->Remove(PET_SAVE_AS_CURRENT);
+
+    if(GetTypeId() == TYPEID_PLAYER)
+        ((Player*)this)->SendEnterVehicle(v, veSeat);
+
+    WorldPacket data(SMSG_MONSTER_MOVE_TRANSPORT, 60);
+    data << GetPackGUID();
+    data << v->GetPackGUID();
+    data << uint8(seat_id);
+    data << uint8(0);                                       // new in 3.1
+    data << v->GetPositionX() << v->GetPositionY() << v->GetPositionZ();
+    data << uint32(getMSTime());
+
+    data << uint8(4);                                       // unknown
+    data << float(0);                                       // facing angle
+
+    data << uint32(SPLINEFLAG_UNKNOWN5);
+
+    data << uint32(0);                                      // Time in between points
+    data << uint32(1);                                      // 1 single waypoint
+    data << m_movementInfo.GetTransportPos()->x;
+    data << m_movementInfo.GetTransportPos()->y;
+    data << m_movementInfo.GetTransportPos()->z;
+    SendMessageToSet(&data, true);
+
+    v->AddPassenger(this, seat_id, force);
+}
+
+void Unit::ExitVehicle()
+{
+    if(uint64 vehicleGUID = GetVehicleGUID())
+    {
+        float v_size = 0.0f;
+        if(Vehicle *vehicle = ObjectAccessor::GetVehicle(vehicleGUID))
+        {
+            if(m_movementInfo.GetVehicleSeatFlags() & SF_MAIN_RIDER)
+            {
+                if(vehicle->GetVehicleFlags() & VF_DESPAWN_AT_LEAVE)
+                {
+                    // will be deleted at next update
+                    vehicle->SetSpawnDuration(1);
+                }
+            }
+            v_size = vehicle->GetObjectSize();
+            vehicle->RemovePassenger(this);
+        }
+        SetVehicleGUID(0);
+
+        clearUnitState(UNIT_STAT_ON_VEHICLE);
+
+        if(GetTypeId() == TYPEID_PLAYER)
+        {
+            ((Player*)this)->ResummonPetTemporaryUnSummonedIfAny();
+            ((Player*)this)->m_movementInfo.RemoveMovementFlag(MOVEFLAG_ROOT);
+        }
+
+        float x = GetPositionX();
+        float y = GetPositionY();
+        float z = GetPositionZ() + 2.0f;
+        GetClosePoint(x, y, z, 2.0f + v_size);
+        SendMonsterMove(x, y, z, SPLINETYPE_NORMAL, SPLINEFLAG_WALKMODE, 0);
+    }
+}
+
 void Unit::SetPvP( bool state )
 {
     if(state)
@@ -13576,6 +14867,27 @@ void Unit::KnockBackFrom(Unit* target, float horizontalSpeed, float verticalSpee
     }
 }
 
+void Unit::KnockBackPlayerWithAngle(float angle, float horizontalSpeed, float verticalSpeed)
+{
+    float vsin = sin(angle);
+    float vcos = cos(angle);
+
+    // Effect propertly implemented only for players
+    if(GetTypeId()==TYPEID_PLAYER)
+    {
+        WorldPacket data(SMSG_MOVE_KNOCK_BACK, 8+4+4+4+4+4);
+        data << GetPackGUID();
+        data << uint32(0);                                  // Sequence
+        data << float(vcos);                                // x direction
+        data << float(vsin);                                // y direction
+        data << float(horizontalSpeed);                     // Horizontal speed
+        data << float(-verticalSpeed);                      // Z Movement speed (vertical)
+        ((Player*)this)->GetSession()->SendPacket(&data);
+    }
+    else
+        sLog.outError("KnockBackPlayer: Target of KnockBackPlayer must be player!");
+}
+
 float Unit::GetCombatRatingReduction(CombatRating cr) const
 {
     if (GetTypeId() == TYPEID_PLAYER)
@@ -13693,6 +15005,232 @@ void Unit::StopAttackFaction(uint32 faction_id)
     CallForAllControlledUnits(StopAttackFactionHelper(faction_id),false,true,true);
 }
 
+bool Unit::isIgnoreUnitState(SpellEntry const *spell)
+{
+    if(!HasAuraType(SPELL_AURA_IGNORE_UNIT_STATE))
+        return false;
+
+    if(spell->SpellFamilyName == SPELLFAMILY_MAGE)
+    {
+        // Ice Lance
+        if(spell->SpellIconID == 186)
+            return true;
+        // Shatter
+        if(spell->Id == 11170 || spell->Id == 12982 || spell->Id == 12983)
+            return true;
+    }
+    Unit::AuraList const& stateAuras = GetAurasByType(SPELL_AURA_IGNORE_UNIT_STATE);
+    for(Unit::AuraList::const_iterator j = stateAuras.begin();j != stateAuras.end(); ++j)
+    {
+        if((*j)->isAffectedOnSpell(spell))
+        {
+            return true;
+            break;
+        }
+    }
+    return false;
+}
+
+uint32 Unit::GetModelForForm(ShapeshiftForm form)
+{
+    switch(form)
+    {
+        case FORM_CAT:
+            // Based on Hair color
+            if (getRace() == RACE_NIGHTELF)
+            {
+                uint8 hairColor = GetByteValue(PLAYER_BYTES, 3);
+                switch (hairColor)
+                {
+                    case 7: // Violet
+                    case 8:
+                        return 29405;
+                    case 3: // Light Blue
+                        return 29406;
+                    case 0: // Green
+                    case 1: // Light Green
+                    case 2: // Dark Green
+                        return 29407;
+                    case 4: // White
+                        return 29408;
+                    default: // original - Dark Blue
+                        return 892;
+                }
+            }
+            // Based on Skin color
+            else if (getRace() == RACE_TAUREN)
+            {
+                uint8 skinColor = GetByteValue(PLAYER_BYTES, 0);
+                // Male
+                if (getGender() == GENDER_MALE)
+                {
+                    switch(skinColor)
+                    {
+                        case 12: // White
+                        case 13:
+                        case 14:
+                        case 18: // Completly White
+                            return 29409;
+                        case 9: // Light Brown
+                        case 10:
+                        case 11:
+                            return 29410;
+                        case 6: // Brown
+                        case 7:
+                        case 8:
+                            return 29411;
+                        case 0: // Dark
+                        case 1:
+                        case 2:
+                        case 3: // Dark Grey
+                        case 4:
+                        case 5:
+                            return 29412;
+                        default: // original - Grey
+                            return 8571;
+                    }
+                }
+                // Female
+                else switch (skinColor)
+                {
+                    case 10: // White
+                        return 29409;
+                    case 6: // Light Brown
+                    case 7:
+                        return 29410;
+                    case 4: // Brown
+                    case 5:
+                        return 29411;
+                    case 0: // Dark
+                    case 1:
+                    case 2:
+                    case 3:
+                        return 29412;
+                    default: // original - Grey
+                        return 8571;
+                }
+            }
+            else if(Player::TeamForRace(getRace())==ALLIANCE)
+                return 892;
+            else
+                return 8571;
+        case FORM_DIREBEAR:
+        case FORM_BEAR:
+            // Based on Hair color
+            if (getRace() == RACE_NIGHTELF)
+            {
+                uint8 hairColor = GetByteValue(PLAYER_BYTES, 3);
+                switch (hairColor)
+                {
+                    case 0: // Green
+                    case 1: // Light Green
+                    case 2: // Dark Green
+                        return 29413; // 29415?
+                    case 6: // Dark Blue
+                        return 29414;
+                    case 4: // White
+                        return 29416;
+                    case 3: // Light Blue
+                        return 29417;
+                    default: // original - Violet
+                        return 2281;
+                }
+            }
+            // Based on Skin color
+            else if (getRace() == RACE_TAUREN)
+            {
+                uint8 skinColor = GetByteValue(PLAYER_BYTES, 0);
+                // Male
+                if (getGender() == GENDER_MALE)
+                {
+                    switch (skinColor)
+                    {
+                        case 0: // Dark (Black)
+                        case 1:
+                        case 2:
+                            return 29418;
+                        case 3: // White
+                        case 4:
+                        case 5:
+                        case 12:
+                        case 13:
+                        case 14:
+                            return 29419;
+                        case 9: // Light Brown/Grey
+                        case 10:
+                        case 11:
+                        case 15:
+                        case 16:
+                        case 17:
+                            return 29420;
+                        case 18: // Completly White
+                            return 29421;
+                        default: // original - Brown
+                            return 2289;
+                    }
+                }
+                // Female
+                else switch (skinColor)
+                {
+                    case 0: // Dark (Black)
+                    case 1:
+                        return 29418;
+                    case 2: // White
+                    case 3:
+                        return 29419;
+                    case 6: // Light Brown/Grey
+                    case 7:
+                    case 8:
+                    case 9:
+                        return 29420;
+                    case 10: // Completly White
+                        return 29421;
+                    default: // original - Brown
+                        return 2289;
+                }
+            }
+            else if(Player::TeamForRace(getRace())==ALLIANCE)
+                return 2281;
+            else
+                return 2289;
+        case FORM_TRAVEL:
+            return 632;
+        case FORM_AQUA:
+            if(Player::TeamForRace(getRace())==ALLIANCE)
+                return 2428;
+            else
+                return 2428;
+        case FORM_GHOUL:
+            return 24994;
+        case FORM_CREATUREBEAR:
+            return 902;
+        case FORM_GHOSTWOLF:
+            return 4613;
+        case FORM_FLIGHT:
+            if(Player::TeamForRace(getRace())==ALLIANCE)
+                return 20857;
+            else
+                return 20872;
+        case FORM_MOONKIN:
+            if(Player::TeamForRace(getRace())==ALLIANCE)
+                return 15374;
+            else
+                return 15375;
+        case FORM_FLIGHT_EPIC:
+            if(Player::TeamForRace(getRace())==ALLIANCE)
+                return 21243;
+            else
+                return 21244;
+        case FORM_METAMORPHOSIS:
+            return 25277;
+        case FORM_TREE:
+            return 864;
+        case FORM_SPIRITOFREDEMPTION:
+            return 16031;
+    }
+    return 0;
+}
+
 void Unit::CleanupDeletedAuras()
 {
     // really delete auras "deleted" while processing its ApplyModify code
@@ -13710,4 +15248,4 @@ bool Unit::CheckAndIncreaseCastCounter()
 
     ++m_castCounter;
     return true;
-}
+}
\ No newline at end of file
diff --git a/mangos/src/game/Unit.h b/Core/src/game/Unit.h
index b4b4077..cfa21f7 100644
--- a/mangos/src/game/Unit.h
+++ b/Core/src/game/Unit.h
@@ -69,7 +69,7 @@ enum SpellAuraInterruptFlags
     AURA_INTERRUPT_FLAG_NOT_UNDERWATER              = 0x00000100,   // 8    removed by leaving water
     AURA_INTERRUPT_FLAG_NOT_SHEATHED                = 0x00000200,   // 9    removed by unsheathing
     AURA_INTERRUPT_FLAG_UNK10                       = 0x00000400,   // 10
-    AURA_INTERRUPT_FLAG_UNK11                       = 0x00000800,   // 11
+    AURA_INTERRUPT_FLAG_CAST                        = 0x00000800,   // 11   removed by casting a spell
     AURA_INTERRUPT_FLAG_UNK12                       = 0x00001000,   // 12   removed by attack?
     AURA_INTERRUPT_FLAG_UNK13                       = 0x00002000,   // 13
     AURA_INTERRUPT_FLAG_UNK14                       = 0x00004000,   // 14
@@ -302,6 +302,7 @@ class Item;
 class Pet;
 class PetAura;
 class Totem;
+class Vehicle;
 
 struct SpellImmune
 {
@@ -407,7 +408,8 @@ enum DeathState
     CORPSE      = 2,
     DEAD        = 3,
     JUST_ALIVED = 4,
-    DEAD_FALLING= 5
+    DEAD_FALLING= 5,
+    GHOULED     = 6
 };
 
 // internal state flags for some auras and movement generators, other.
@@ -438,24 +440,25 @@ enum UnitState
     UNIT_STAT_FOLLOW_MOVE     = 0x00008000,
     UNIT_STAT_FLEEING         = 0x00010000,                     // FleeMovementGenerator/TimedFleeingMovementGenerator active/onstack
     UNIT_STAT_FLEEING_MOVE    = 0x00020000,
+    UNIT_STAT_ON_VEHICLE      = 0x00040000,                     // Unit is on vehicle
 
     // masks (only for check)
 
     // can't move currently
-    UNIT_STAT_CAN_NOT_MOVE    = UNIT_STAT_ROOT | UNIT_STAT_STUNNED | UNIT_STAT_DIED,
+    UNIT_STAT_CAN_NOT_MOVE    = UNIT_STAT_ROOT | UNIT_STAT_STUNNED | UNIT_STAT_DIED | UNIT_STAT_ON_VEHICLE,
 
     // stay by different reasons
     UNIT_STAT_NOT_MOVE        = UNIT_STAT_ROOT | UNIT_STAT_STUNNED | UNIT_STAT_DIED |
-                                UNIT_STAT_DISTRACTED,
+                                UNIT_STAT_DISTRACTED | UNIT_STAT_ON_VEHICLE,
 
     // stay or scripted movement for effect( = in player case you can't move by client command)
     UNIT_STAT_NO_FREE_MOVE    = UNIT_STAT_ROOT | UNIT_STAT_STUNNED | UNIT_STAT_DIED |
                                 UNIT_STAT_IN_FLIGHT |
-                                UNIT_STAT_CONFUSED | UNIT_STAT_FLEEING,
+                                UNIT_STAT_CONFUSED | UNIT_STAT_FLEEING | UNIT_STAT_ON_VEHICLE,
 
     // not react at move in sight or other
     UNIT_STAT_CAN_NOT_REACT   = UNIT_STAT_STUNNED | UNIT_STAT_DIED |
-                                UNIT_STAT_CONFUSED | UNIT_STAT_FLEEING,
+                                UNIT_STAT_CONFUSED | UNIT_STAT_FLEEING | UNIT_STAT_ON_VEHICLE,
 
     // masks (for check or reset)
 
@@ -572,8 +575,10 @@ enum UnitFlags2
     UNIT_FLAG2_FEIGN_DEATH          = 0x00000001,
     UNIT_FLAG2_UNK1                 = 0x00000002,           // Hides unit model (show only player equip)
     UNIT_FLAG2_COMPREHEND_LANG      = 0x00000008,
+    UNIT_FLAG2_MIRROR_IMAGE         = 0x00000010,
     UNIT_FLAG2_FORCE_MOVE           = 0x00000040,
-    UNIT_FLAG2_DISARM               = 0x00000400,           // disarm or something
+    UNIT_FLAG2_DISARM_OFFHAND       = 0x00000080,
+    UNIT_FLAG2_DISARM_RANGED        = 0x00000400,
     UNIT_FLAG2_REGENERATE_POWER     = 0x00000800,
 };
 
@@ -606,7 +611,8 @@ enum NPCFlags
     UNIT_NPC_FLAG_STABLEMASTER          = 0x00400000,       // 100%
     UNIT_NPC_FLAG_GUILD_BANKER          = 0x00800000,       // cause client to send 997 opcode
     UNIT_NPC_FLAG_SPELLCLICK            = 0x01000000,       // cause client to send 1015 opcode (spell click), dynamic, set at loading and don't must be set in DB
-    UNIT_NPC_FLAG_GUARD                 = 0x10000000        // custom flag for guards
+    UNIT_NPC_FLAG_GUARD                 = 0x10000000,       // custom flag for guards
+    UNIT_NPC_FLAG_OUTDOORPVP            = 0x20000000        // custom flag for outdoor pvp creatures
 };
 
 // used in most movement packets (send and received)
@@ -759,7 +765,7 @@ class MovementInfo
 
         // Position manipulations
         Position const *GetPos() const { return &pos; }
-        void SetTransportData(ObjectGuid guid, float x, float y, float z, float o, uint32 time, int8 seat)
+        void SetTransportData(ObjectGuid guid, float x, float y, float z, float o, uint32 time, int8 seat, uint32 dbc_seat = 0, uint32 seat_flags = 0, uint32 vehicle_flags = 0)
         {
             t_guid = guid;
             t_pos.x = x;
@@ -768,6 +774,9 @@ class MovementInfo
             t_pos.o = o;
             t_time = time;
             t_seat = seat;
+            t_dbc_seat = dbc_seat;
+            t_seat_flags = seat_flags;
+            t_vehicle_flags = vehicle_flags;
         }
         void ClearTransportData()
         {
@@ -778,11 +787,17 @@ class MovementInfo
             t_pos.o = 0.0f;
             t_time = 0;
             t_seat = -1;
+            t_dbc_seat = 0;
+            t_seat_flags = 0;
+            t_vehicle_flags = 0;
         }
         ObjectGuid const& GetTransportGuid() const { return t_guid; }
         Position const *GetTransportPos() const { return &t_pos; }
         int8 GetTransportSeat() const { return t_seat; }
         uint32 GetTransportTime() const { return t_time; }
+        uint32 GetTransportDBCSeat() const { return t_dbc_seat; }
+        uint32 GetVehicleSeatFlags() const { return t_seat_flags; }
+        uint32 GetVehicleFlags() const { return t_vehicle_flags; }
         uint32 GetFallTime() const { return fallTime; }
         void ChangePosition(float x, float y, float z, float o) { pos.x = x; pos.y = y; pos.z = z; pos.o = o; }
         void UpdateTime(uint32 _time) { time = _time; }
@@ -799,6 +814,9 @@ class MovementInfo
         uint32   t_time;
         int8     t_seat;
         uint32   t_time2;
+        uint32   t_dbc_seat;
+        uint32   t_seat_flags;
+        uint32   t_vehicle_flags;
         // swimming and flying
         float    s_pitch;
         // last fall time
@@ -1213,6 +1231,9 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         bool IsHostileTo(Unit const* unit) const;
         bool IsHostileToPlayers() const;
         bool IsFriendlyTo(Unit const* unit) const;
+        bool IsInRaidWith(Unit const* unit) const;
+        bool IsInPartyWith(Unit const* unit) const;
+
         bool IsNeutralToAll() const;
         bool IsContestedGuard() const
         {
@@ -1277,14 +1298,15 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         uint32 GetSpellCritDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_CRIT_TAKEN_SPELL, 2.2f, 33.0f, damage); }
 
         // player or player's pet resilience (-1%), cap 100%
-        uint32 GetMeleeDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_CRIT_TAKEN_MELEE, 1.0f, 100.0f, damage); }
-        uint32 GetRangedDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_CRIT_TAKEN_MELEE, 1.0f, 100.0f, damage); }
-        uint32 GetSpellDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_CRIT_TAKEN_MELEE, 1.0f, 100.0f, damage); }
+        // values below increased from 1.0 to 2.0 to match 3.3.3 resillience
+        uint32 GetMeleeDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_CRIT_TAKEN_MELEE, 2.0f, 100.0f, damage); }
+        uint32 GetRangedDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_CRIT_TAKEN_MELEE, 2.0f, 100.0f, damage); }
+        uint32 GetSpellDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_CRIT_TAKEN_MELEE, 2.0f, 100.0f, damage); } 
 
         float  MeleeSpellMissChance(Unit *pVictim, WeaponAttackType attType, int32 skillDiff, SpellEntry const *spell);
-        SpellMissInfo MeleeSpellHitResult(Unit *pVictim, SpellEntry const *spell);
+        SpellMissInfo MeleeSpellHitResult(Unit *pVictim, SpellEntry const *spell, bool canMiss = true);
         SpellMissInfo MagicSpellHitResult(Unit *pVictim, SpellEntry const *spell);
-        SpellMissInfo SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool canReflect = false);
+        SpellMissInfo SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool canReflect = false, bool canMiss = true);
 
         float GetUnitDodgeChance()    const;
         float GetUnitParryChance()    const;
@@ -1343,6 +1365,10 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         }
         bool HasAura(uint32 spellId) const;
 
+        const uint64& GetAuraUpdateMask() const { return m_auraUpdateMask; }
+        void SetAuraUpdateMask(uint8 slot) { m_auraUpdateMask |= (uint64(1) << slot); }
+        void ResetAuraUpdateMask() { m_auraUpdateMask = 0; }
+
         bool virtual HasSpell(uint32 /*spellID*/) const { return false; }
 
         bool HasStealthAura()      const { return HasAuraType(SPELL_AURA_MOD_STEALTH); }
@@ -1352,6 +1378,7 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         bool IsPolymorphed() const;
 
         bool isFrozen() const;
+        bool isIgnoreUnitState(SpellEntry const *spell);
 
         void RemoveSpellbyDamageTaken(AuraType auraType, uint32 damage);
 
@@ -1362,7 +1389,7 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         virtual bool IsUnderWater() const;
         bool isInAccessablePlaceFor(Creature const* c) const;
 
-        void SendHealSpellLog(Unit *pVictim, uint32 SpellID, uint32 Damage, uint32 OverHeal, bool critical = false);
+        void SendHealSpellLog(Unit *pVictim, uint32 SpellID, uint32 Damage, uint32 OverHeal, uint32 Absorbed, bool critical = false);
         void SendEnergizeSpellLog(Unit *pVictim, uint32 SpellID, uint32 Damage,Powers powertype);
         void EnergizeBySpell(Unit *pVictim, uint32 SpellID, uint32 Damage, Powers powertype);
         uint32 SpellNonMeleeDamageLog(Unit *pVictim, uint32 spellID, uint32 damage);
@@ -1443,13 +1470,15 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         Unit* GetCharm() const;
         void Uncharm();
         Unit* GetCharmerOrOwner() const { return GetCharmerGUID() ? GetCharmer() : GetOwner(); }
-        Unit* GetCharmerOrOwnerOrSelf()
+        Unit* GetCharmOrPet() const { return GetCharmGUID() ? GetCharm() : (Unit*)GetPet(); }
+        Unit* GetCharmerOrOwnerOrSelf() const
         {
             if(Unit* u = GetCharmerOrOwner())
                 return u;
 
-            return this;
+            return (Unit*)this;
         }
+
         bool IsCharmerOrOwnerPlayerOrPlayerItself() const;
         Player* GetCharmerOrOwnerPlayerOrPlayerItself();
         float GetCombatDistance( const Unit* target ) const;
@@ -1461,7 +1490,8 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         void RemoveGuardian(Pet* pet);
         void RemoveGuardians();
         Pet* FindGuardianWithEntry(uint32 entry);
-
+        GuardianPetList const& GetGuardians() const { return m_guardianPets; }
+        
         bool isCharmed() const { return GetCharmerGUID() != 0; }
 
         CharmInfo* GetCharmInfo() { return m_charmInfo; }
@@ -1731,7 +1761,6 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         uint32 SpellHealingBonusTaken(Unit *pCaster, SpellEntry const *spellProto, int32 healamount, DamageEffectType damagetype, uint32 stack = 1);
         uint32 MeleeDamageBonusDone(Unit *pVictim, uint32 damage, WeaponAttackType attType, SpellEntry const *spellProto = NULL, DamageEffectType damagetype = DIRECT_DAMAGE, uint32 stack = 1);
         uint32 MeleeDamageBonusTaken(Unit *pCaster, uint32 pdamage,WeaponAttackType attType, SpellEntry const *spellProto = NULL, DamageEffectType damagetype = DIRECT_DAMAGE, uint32 stack = 1);
-
         bool   IsSpellBlocked(Unit *pCaster, SpellEntry const *spellProto, WeaponAttackType attackType = BASE_ATTACK);
         bool   IsSpellCrit(Unit *pVictim, SpellEntry const *spellProto, SpellSchoolMask schoolMask, WeaponAttackType attackType = BASE_ATTACK);
         uint32 SpellCriticalDamageBonus(SpellEntry const *spellProto, uint32 damage, Unit *pVictim);
@@ -1761,6 +1790,7 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         uint32 CalcArmorReducedDamage(Unit* pVictim, const uint32 damage);
         void CalculateAbsorbAndResist(Unit *pCaster, SpellSchoolMask schoolMask, DamageEffectType damagetype, const uint32 damage, uint32 *absorb, uint32 *resist, bool canReflect = false);
         void CalculateAbsorbResistBlock(Unit *pCaster, SpellNonMeleeDamage *damageInfo, SpellEntry const* spellProto, WeaponAttackType attType = BASE_ATTACK);
+        void CalculateHealAbsorb(Unit *pVictim, const SpellEntry *spellProto, uint32 &HealAmount, uint32 &Absorbed);
 
         void  UpdateWalkMode(Unit* source, bool self = true);
         void  UpdateSpeed(UnitMoveType mtype, bool forced, float ratio = 1.0f);
@@ -1772,6 +1802,7 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         bool isHover() const { return HasAuraType(SPELL_AURA_HOVER); }
 
         void KnockBackFrom(Unit* target, float horizontalSpeed, float verticalSpeed);
+        void KnockBackPlayerWithAngle(float angle, float horizontalSpeed, float verticalSpeed);
 
         void _RemoveAllAuraMods();
         void _ApplyAllAuraMods();
@@ -1822,10 +1853,18 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         PetAuraSet m_petAuras;
         void AddPetAura(PetAura const* petSpell);
         void RemovePetAura(PetAura const* petSpell);
+		uint32 GetModelForForm(ShapeshiftForm form);
 
         // Movement info
         MovementInfo m_movementInfo;
 
+         // vehicle system
+         void EnterVehicle(Vehicle *vehicle, int8 seat_id, bool force = false);
+         void ExitVehicle();
+         uint64 GetVehicleGUID() { return m_vehicleGUID; }
+         void SetVehicleGUID(uint64 guid) { m_vehicleGUID = guid; }
+         void ChangeSeat(int8 seatId, bool next);
+
     protected:
         explicit Unit ();
 
@@ -1873,7 +1912,9 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         uint32 m_reactiveTimer[MAX_REACTIVE];
         uint32 m_regenTimer;
         uint32 m_lastManaUseTimer;
-
+        uint64  m_auraUpdateMask;
+        uint64 m_vehicleGUID;
+        uint64 m_InteractionObject;
     private:
         void CleanupDeletedAuras();
 
diff --git a/mangos/src/game/UpdateFields.h b/Core/src/game/UpdateFields.h
index 5c64afb..d5a2d80 100644
--- a/mangos/src/game/UpdateFields.h
+++ b/Core/src/game/UpdateFields.h
@@ -391,6 +391,45 @@ enum EUnitFields
     PLAYER_GLYPHS_ENABLED                     = UNIT_END + 0x0498, // Size: 1, Type: INT, Flags: PRIVATE
     PLAYER_PET_SPELL_POWER                    = UNIT_END + 0x0499, // Size: 1, Type: INT, Flags: PRIVATE
     PLAYER_END                                = UNIT_END + 0x049A,
+    
+    // ----------------------------------------------------------------------------------------------
+
+    ANDEERIA_AP_MELEE_1                        = 0x007B, // TYPE: INT
+    ANDEERIA_AP_MELEE_2                        = 0x007C, // TYPE: INT
+    ANDEERIA_AP_RANGED_1                       = 0x007E, // TYPE: INT
+    ANDEERIA_AP_RANGED_2                       = 0x007F, // TYPE: INT
+    
+    ANDEERIA_BLOCKRATING                       = 0x04D3, // TYPE: INT
+    ANDEERIA_DEFRATING                         = 0x04D0, // TYPE: INT
+    ANDEERIA_DODGERATING                       = 0x04D1, // TYPE: INT
+    ANDEERIA_PARRYRATING                       = 0x04D2, // TYPE: INT
+    ANDEERIA_RESILIENCE                        = 0x04DE, // TYPE: INT
+
+    ANDEERIA_MANAREGEN                         = 0x0028, // TYPE: FLOAT
+
+    ANDEERIA_MELEE_HITRATING                   = 0x04D4, // TYPE: INT
+    ANDEERIA_MELEE_CRITRATING                  = 0x04D7, // TYPE: INT
+    ANDEERIA_MELEE_HASTERATING                 = 0x04E0, // TYPE: INT
+    ANDEERIA_MELEE_MAINMINDMG                  = 0x0046, // TYPE: FLOAT
+    ANDEERIA_MELEE_MAINMAXDMG                  = 0x0047, // TYPE: FLOAT
+    ANDEERIA_MELEE_OFFMINDMG                   = 0x0046, // TYPE: FLOAT
+    ANDEERIA_MELEE_OFFMAXDMG                   = 0x0047, // TYPE: FLOAT
+    ANDEERIA_MELLE_OFFTIME                     = 0x003E, // TYPE: FLOAT
+    ANDEERIA_MELLE_MAINTIME                    = 0x003E, // TYPE: FLOAT
+
+    ANDEERIA_RANGED_CRITRATING                 = 0x04D8, // TYPE: INT
+    ANDEERIA_RANGED_HASTERATING                = 0x04E1, // TYPE: INT
+    ANDEERIA_RANGED_HITRATING                  = 0x04D5, // TYPE: INT
+    ANDEERIA_RANGED_MINDMG                     = 0x0081, // TYPE: FLOAT
+    ANDEERIA_RANGED_MAXDMG                     = 0x0082, // TYPE: FLOAT
+    ANDEERIA_RANGED_ATTACKTIME                 = 0x003F, // TYPE: FLOAT
+    
+    ANDEERIA_SPELL_HITRATING                   = 0x04D6, // TYPE: INT
+    ANDEERIA_SPELL_CRITRATING                  = 0x04D9, // TYPE: INT
+    ANDEERIA_SPELL_HASTERATING                 = 0x04E2, // TYPE: INT
+    ANDEERIA_SPELL_BONUSDMG                    = 0x0496, // TYPE: INT
+    ANDEERIA_SPELL_BONUSHEAL                   = 0x04A8, // TYPE: INT
+    ANDEERIA_SPELL_CRITPROC                    = 0x040B, // TYPE: FLOAT
 };
 
 enum EGameObjectFields
diff --git a/mangos/src/game/Vehicle.cpp b/Core/src/game/Vehicle.cpp
index b92e542..9792500 100644
--- a/mangos/src/game/Vehicle.cpp
+++ b/Core/src/game/Vehicle.cpp
@@ -18,14 +18,18 @@
 
 #include "Common.h"
 #include "Log.h"
-#include "ObjectMgr.h"
 #include "Vehicle.h"
 #include "Unit.h"
 #include "Util.h"
+#include "WorldPacket.h"
+#include "InstanceData.h"
 
-Vehicle::Vehicle() : Creature(CREATURE_SUBTYPE_VEHICLE), m_vehicleId(0)
+Vehicle::Vehicle() : Creature(CREATURE_SUBTYPE_VEHICLE), m_vehicleId(0), m_vehicleInfo(NULL), m_spawnduration(0),
+                     despawn(false), m_creation_time(0), m_VehicleData(NULL)
 {
     m_updateFlag = (UPDATEFLAG_LIVING | UPDATEFLAG_HAS_POSITION | UPDATEFLAG_VEHICLE);
+    m_comboPointsForCast = 0;
+    m_regenUpdateTimer = 100;
 }
 
 Vehicle::~Vehicle()
@@ -51,45 +55,729 @@ void Vehicle::RemoveFromWorld()
     Unit::RemoveFromWorld();
 }
 
+void Vehicle::Respawn()
+{
+    Creature::Respawn();
+    InstallAllAccessories();
+}
+
 void Vehicle::setDeathState(DeathState s)                       // overwrite virtual Creature::setDeathState and Unit::setDeathState
 {
     Creature::setDeathState(s);
+    if(s == JUST_DIED)
+    {
+        if(GetVehicleFlags() & VF_DESPAWN_NPC)
+            Dismiss();
+        else
+            RemoveAllPassengers();
+    }
 }
 
 void Vehicle::Update(uint32 diff)
 {
     Creature::Update(diff);
+
+    if(despawn)
+    {
+        m_spawnduration -= diff;
+        if(m_spawnduration < 0)
+            Dismiss();
+        despawn = false;
+    }
+
+    if(m_regenUpdateTimer <= diff)
+    {
+        RegeneratePower(getPowerType());
+        m_regenTimer = 1000;
+    }
+    else
+        m_regenUpdateTimer -= diff;
+}
+
+void Vehicle::RegeneratePower(Powers power)
+{
+    uint32 curValue = GetPower(power);
+    uint32 maxValue = GetMaxPower(power);
+
+    if (curValue >= maxValue)
+        return;
+
+    float addvalue = 0.0f;
+
+    // hack: needs more research of power type from the dbc. 
+    // It must contains some info about vehicles like Salvaged Chopper.
+    if(m_vehicleInfo->m_powerType == POWER_TYPE_PYRITE)
+        return;
+
+    addvalue = 10.0;
+
+    ModifyPower(power, (int32)addvalue);
+
+    WorldPacket data(SMSG_POWER_UPDATE);
+    data << GetPackGUID();
+    data << uint8(power);
+    data << uint32(addvalue+curValue);
+    SendMessageToSet(&data, true);
 }
 
-bool Vehicle::Create(uint32 guidlow, Map *map, uint32 Entry, uint32 vehicleId, uint32 team)
+bool Vehicle::Create(uint32 guidlow, Map *map, uint32 phaseMask, uint32 Entry, uint32 vehicleId, uint32 team, const CreatureData *data)
 {
     SetMap(map);
+    SetPhaseMask(phaseMask,false);
+
+    CreatureInfo const *cinfo = sObjectMgr.GetCreatureTemplate(Entry);
+    if(!cinfo)
+    {
+        sLog.outErrorDb("Creature entry %u does not exist.", Entry);
+        return false;
+    }
 
     Object::_Create(guidlow, Entry, HIGHGUID_VEHICLE);
 
-    if(!InitEntry(Entry, team))
+    if(!UpdateEntry(Entry, team, data))
         return false;
 
-    m_defaultMovementType = IDLE_MOTION_TYPE;
+    if(!vehicleId)
+    {
+        CreatureDataAddon const *cainfo = GetCreatureAddon();
+        if(!cainfo)
+            return false;
+        vehicleId = cainfo->vehicle_id;
+    }
+    if(!SetVehicleId(vehicleId))
+        return false;
 
-    AIM_Initialize();
+    LoadCreaturesAddon();
 
-    SetVehicleId(vehicleId);
+    m_regenHealth = false;
+    m_creation_time = getMSTime();
 
-    SetUInt32Value(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK);
     SetFloatValue(UNIT_FIELD_HOVERHEIGHT, 1.0f);
+    //RemoveMonsterMoveFlag(MONSTER_MOVE_WALK);
+
+    //Notify the map's instance data.
+    //Only works if you create the object in it, not if it is moves to that map.
+    //Normally non-players do not teleport to other maps.
+    if(map->IsDungeon() && ((InstanceMap*)map)->GetInstanceData())
+    {
+        ((InstanceMap*)map)->GetInstanceData()->OnCreatureCreate(this);
+    SetHealth(GetMaxHealth());
+    }
+    
+    if(m_vehicleInfo->m_powerType == POWER_TYPE_STEAM)
+    {
+        setPowerType(POWER_ENERGY);
+        SetMaxPower(POWER_ENERGY, 100);
+        SetPower(POWER_ENERGY, 100);
+    }
+    else if(m_vehicleInfo->m_powerType == POWER_TYPE_PYRITE)
+    {
+        setPowerType(POWER_ENERGY);
+        SetMaxPower(POWER_ENERGY, 50);
+        SetPower(POWER_ENERGY, 50);
+    }
+    else
+    {
+        for (uint32 i = 0; i < MAX_VEHICLE_SPELLS; ++i)
+        {
+            if(!GetVehicleData()->v_spells[i])
+                continue;
+            SpellEntry const *spellInfo = sSpellStore.LookupEntry(GetVehicleData()->v_spells[i]);
+            if(!spellInfo)
+                continue;
 
-    CreatureInfo const *ci = GetCreatureInfo();
-    setFaction(team == ALLIANCE ? ci->faction_A : ci->faction_H);
+            if(spellInfo->powerType == POWER_MANA)
+                break;
 
-    SelectLevel(ci);
+            if(spellInfo->powerType == POWER_ENERGY)
+            {
+                setPowerType(POWER_ENERGY);
+                SetMaxPower(POWER_ENERGY, 100);
+                SetPower(POWER_ENERGY, 100);
+                break;
+            }
+        }
+    }
+    SetHealth(GetMaxHealth());
+    InstallAllAccessories();
 
     return true;
 }
 
+bool Vehicle::SetVehicleId(uint32 vehicleid)
+{
+    VehicleEntry const *vehicleInfo = sVehicleStore.LookupEntry(vehicleid);
+    if(!vehicleInfo)
+        return false;
+
+    m_vehicleId = vehicleid;
+    m_vehicleInfo = vehicleInfo;
+
+    // can be NULL
+    VehicleDataStructure const *VDStructure = sObjectMgr.GetVehicleData(vehicleid);
+    if(VDStructure)
+        m_VehicleData = VDStructure;
+
+    InitSeats();
+    EmptySeatsCountChanged();
+    return true;
+}
+
+void Vehicle::InitSeats()
+{
+    m_Seats.clear();
+
+    for(uint32 i = 0; i < MAX_SEAT; ++i)
+    {
+        uint32 seatId = m_vehicleInfo->m_seatID[i];
+        if(seatId)
+        {
+            if(VehicleSeatEntry const *veSeat = sVehicleSeatStore.LookupEntry(seatId))
+            {
+                VehicleSeat newseat;
+                newseat.seatInfo = veSeat;
+                newseat.passenger = NULL;
+                newseat.flags = SEAT_FREE;
+                newseat.vs_flags = sObjectMgr.GetSeatFlags(seatId);
+                m_Seats[i] = newseat;
+            }
+        }
+    }
+    // NOTE : there can be vehicles without seats (eg. 180) - probably some TEST vehicles
+}
+void Vehicle::ChangeSeatFlag(uint8 seat, uint8 flag)
+{
+    SeatMap::iterator i_seat = m_Seats.find(seat);
+    // this should never happen
+    if(i_seat == m_Seats.end())
+        return;
+
+    if(i_seat->second.flags != flag)
+    {
+        i_seat->second.flags = flag;
+        EmptySeatsCountChanged();
+    }
+}
+Vehicle* Vehicle::FindFreeSeat(int8 *seatid, bool force)
+{
+    SeatMap::const_iterator i_seat = m_Seats.find(*seatid);
+    if(i_seat == m_Seats.end())
+        return GetFirstEmptySeat(seatid, force);
+    if((i_seat->second.flags & (SEAT_FULL | SEAT_VEHICLE_FULL)) || (!force && (i_seat->second.vs_flags & SF_UNACCESSIBLE)))
+        return GetNextEmptySeat(seatid, true, force);
+    if(i_seat->second.flags & SEAT_VEHICLE_FREE)
+    {
+        // this should never be NULL
+        if(Vehicle *v = (Vehicle*)i_seat->second.passenger)
+            return v->FindFreeSeat(seatid, force);
+        return NULL;
+    }
+    return this;
+}
+
+Vehicle* Vehicle::GetFirstEmptySeat(int8 *seatId, bool force)
+{
+    for(SeatMap::iterator itr = m_Seats.begin(); itr != m_Seats.end(); ++itr)
+    {
+        if(itr->second.flags & SEAT_FREE)
+        {
+            if(!force && (itr->second.vs_flags & SF_UNACCESSIBLE))
+                continue;
+
+            *seatId = itr->first;
+            return this;
+        }
+        else if(itr->second.flags & SEAT_VEHICLE_FREE)
+        {
+            *seatId = itr->first;
+            if(Vehicle *v = (Vehicle*)itr->second.passenger)
+                return v->FindFreeSeat(seatId, force);
+        }
+    }
+
+    return NULL;
+}
+
+Vehicle* Vehicle::GetNextEmptySeat(int8 *seatId, bool next, bool force)
+{
+    SeatMap::const_iterator i_seat = m_Seats.find(*seatId);
+    if(i_seat == m_Seats.end()) return GetFirstEmptySeat(seatId, force);
+
+    while((i_seat->second.flags & (SEAT_FULL | SEAT_VEHICLE_FULL)) || (!force && (i_seat->second.vs_flags & SF_UNACCESSIBLE)))
+    {
+        if(next)
+        {
+            ++i_seat;
+            if(i_seat == m_Seats.end())
+                i_seat = m_Seats.begin();
+        }
+        else
+        {
+            if(i_seat == m_Seats.begin())
+                i_seat = m_Seats.end();
+            --i_seat;
+        }
+        if(i_seat->first == *seatId)
+            return NULL;
+    }
+    *seatId = i_seat->first;
+    if(i_seat->second.flags & SEAT_VEHICLE_FREE)
+    {
+        if(Vehicle *v = (Vehicle*)i_seat->second.passenger)
+            return v->FindFreeSeat(seatId, force);
+        return NULL;
+    }
+
+    return this;
+}
+
+int8 Vehicle::GetEmptySeatsCount(bool force)
+{
+    int8 count = 0;
+    for(SeatMap::iterator itr = m_Seats.begin(); itr != m_Seats.end(); ++itr)
+   {
+        if(itr->second.flags & (SEAT_FREE | SEAT_VEHICLE_FREE))
+        {
+            if(!force && (itr->second.vs_flags & SF_UNACCESSIBLE))
+                continue;
+
+            count++;
+        }
+    }
+
+    return count;
+}
+int8 Vehicle::GetNextEmptySeatNum(int8 seatId, bool next) const
+{
+    SeatMap::const_iterator seat = m_Seats.find(seatId);
+    if(seat == m_Seats.end()) return -1;
+    while(seat->second.passenger || !seat->second.seatInfo->IsUsable())
+    {
+        if(next)
+        {
+            ++seat;
+            if(seat == m_Seats.end())
+                seat = m_Seats.begin();
+        }
+        else
+        {
+            if(seat == m_Seats.begin())
+                seat = m_Seats.end();
+            --seat;
+        }
+        if(seat->first == seatId)
+            return -1; // no available seat
+    }
+    return seat->first;
+}
+
+bool Vehicle::HasEmptySeat(int8 seatId) const
+{
+    SeatMap::const_iterator seat = m_Seats.find(seatId);
+    if(seat == m_Seats.end()) return false;
+    return !seat->second.passenger;
+}
+
+void Vehicle::EmptySeatsCountChanged()
+{
+    uint8 m_count = GetTotalSeatsCount();
+    uint8 p_count = GetEmptySeatsCount(false);
+    uint8 u_count = GetEmptySeatsCount(true);
+
+    // seats accesibles by players
+    if(p_count > 0)
+        SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK);
+    else
+        RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK);
+
+    if(u_count == m_count)
+    {
+        RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+    }
+    else
+        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+
+    if(uint64 vehicleGUID = GetVehicleGUID())
+    {
+        if(Vehicle *vehicle = ObjectAccessor::GetVehicle(vehicleGUID))
+        {
+            if(u_count > 0)
+                vehicle->ChangeSeatFlag(m_movementInfo.GetTransportSeat(), SEAT_VEHICLE_FREE);
+            else
+                vehicle->ChangeSeatFlag(m_movementInfo.GetTransportSeat(), SEAT_VEHICLE_FULL);
+        }
+    }
+}
+
+
+
 void Vehicle::Dismiss()
 {
+    RemoveAllPassengers();
     SendObjectDeSpawnAnim(GetGUID());
     CombatStop();
     AddObjectToRemoveList();
 }
+
+void Vehicle::RelocatePassengers(Map *map)
+{
+    for(SeatMap::iterator itr = m_Seats.begin(); itr != m_Seats.end(); ++itr)
+    {
+        if(itr->second.flags & SEAT_FULL)
+        {
+            // passenger cant be NULL here
+            Unit *passengers = itr->second.passenger;
+            assert(passengers);
+
+            float xx = GetPositionX() + passengers->m_movementInfo.GetTransportPos()->x;
+            float yy = GetPositionY() + passengers->m_movementInfo.GetTransportPos()->y;
+            float zz = GetPositionZ() + passengers->m_movementInfo.GetTransportPos()->z;
+            //float oo = passengers->m_SeatData.Orientation;
+            // this is not correct, we should recalculate
+            // actual rotation depending on vehicle
+            float oo = passengers->GetOrientation();
+
+            if(passengers->GetTypeId() == TYPEID_PLAYER)
+                ((Player*)passengers)->SetPosition(xx, yy, zz, oo);
+            else
+                map->CreatureRelocation((Creature*)passengers, xx, yy, zz, oo);
+        }
+        else if(itr->second.flags & (SEAT_VEHICLE_FULL | SEAT_VEHICLE_FREE))
+        {
+            // passenger cant be NULL here
+            Unit *passengers = itr->second.passenger;
+            assert(passengers);
+
+            float xx = GetPositionX() + passengers->m_movementInfo.GetTransportPos()->x;
+            float yy = GetPositionY() + passengers->m_movementInfo.GetTransportPos()->y;
+            float zz = GetPositionZ() + passengers->m_movementInfo.GetTransportPos()->z;
+            //float oo = passengers->m_SeatData.Orientation;
+            // this is not correct, we should recalculate
+            // actual rotation depending on vehicle
+            float oo = passengers->GetOrientation();
+
+            map->CreatureRelocation((Creature*)passengers, xx, yy, zz, oo);
+            ((Vehicle*)passengers)->RelocatePassengers(map);
+        }
+    }
+}
+
+void Vehicle::AddPassenger(Unit *unit, int8 seatId, bool force)
+{
+    SeatMap::iterator seat;
+    seat = m_Seats.find(seatId);
+
+    // this should never happen
+    if(seat == m_Seats.end())
+        return;
+
+    unit->SetVehicleGUID(GetGUID());
+    unit->m_movementInfo.AddMovementFlag(MOVEFLAG_ONTRANSPORT);
+
+    seat->second.passenger = unit;
+    if(unit->GetTypeId() == TYPEID_UNIT && ((Creature*)unit)->isVehicle())
+    {
+        if(((Vehicle*)unit)->GetEmptySeatsCount(true) == 0)
+            seat->second.flags = SEAT_VEHICLE_FULL;
+        else
+            seat->second.flags = SEAT_VEHICLE_FREE;
+    }
+    else
+    {
+        seat->second.flags = SEAT_FULL;
+    }
+
+    if(unit->GetTypeId() == TYPEID_PLAYER)
+    {
+        WorldPacket data0(SMSG_FORCE_MOVE_ROOT, 10);
+        data0 << unit->GetPackGUID();
+        data0 << (uint32)((seat->second.vs_flags & SF_CAN_CAST) ? 2 : 0);
+        unit->SendMessageToSet(&data0,true);
+    }
+
+    if(seat->second.vs_flags & SF_MAIN_RIDER)
+    {
+        if(!(GetVehicleFlags() & VF_MOVEMENT))
+        {
+            GetMotionMaster()->Clear(false);
+            GetMotionMaster()->MoveIdle();
+            SetCharmerGUID(unit->GetGUID());
+            unit->SetUInt64Value(UNIT_FIELD_CHARM, GetGUID());
+            if(unit->GetTypeId() == TYPEID_PLAYER)
+            {
+                ((Player*)unit)->SetMover(this);
+                ((Player*)unit)->SetMoverInQueve(this);
+                ((Player*)unit)->SetClientControl(this, 1);
+            }
+            if(canFly() || HasAuraType(SPELL_AURA_FLY) || HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED))
+            {
+                WorldPacket data3(SMSG_MOVE_SET_CAN_FLY, 12);
+                data3<< GetPackGUID();
+                data3 << (uint32)(0);
+                SendMessageToSet(&data3,false);
+            }
+        }
+
+        SpellClickInfoMapBounds clickPair = sObjectMgr.GetSpellClickInfoMapBounds(GetEntry());
+        for(SpellClickInfoMap::const_iterator itr = clickPair.first; itr != clickPair.second; ++itr)
+        {
+            if (unit->GetTypeId() == TYPEID_UNIT || itr->second.IsFitToRequirements((Player*)unit))
+            {
+                Unit *caster = (itr->second.castFlags & 0x1) ? unit : this;
+                Unit *target = (itr->second.castFlags & 0x2) ? unit : this;
+
+                caster->CastSpell(target, itr->second.spellId, true);
+            }
+        }
+        if(unit->GetTypeId() == TYPEID_PLAYER)
+        {
+            // it should be added only on rider enter?
+            if(((Player*)unit)->GetGroup())
+                ((Player*)unit)->SetGroupUpdateFlag(GROUP_UPDATE_VEHICLE);
+
+            ((Player*)unit)->SetFarSightGUID(GetGUID());
+
+            BuildVehicleActionBar((Player*)unit);
+        }
+
+        if(!(GetVehicleFlags() & VF_FACTION))
+            setFaction(unit->getFaction());
+
+        if(GetVehicleFlags() & VF_CANT_MOVE)
+        {
+            WorldPacket data2(SMSG_FORCE_MOVE_ROOT, 10);
+            data2<< GetPackGUID();
+            data2 << (uint32)(2);
+            SendMessageToSet(&data2,false);
+        }
+
+        if(GetVehicleFlags() & VF_NON_SELECTABLE)
+            SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+    }
+    if(seat->second.vs_flags & SF_UNATTACKABLE)
+        unit->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+
+    EmptySeatsCountChanged();
+}
+
+void Vehicle::RemovePassenger(Unit *unit)
+{
+    SeatMap::iterator seat;
+    for(seat = m_Seats.begin(); seat != m_Seats.end(); ++seat)
+    {
+        if((seat->second.flags & (SEAT_FULL | SEAT_VEHICLE_FREE | SEAT_VEHICLE_FULL)) && seat->second.passenger == unit)
+        {
+            unit->SetVehicleGUID(0);
+
+            if(seat->second.vs_flags & SF_MAIN_RIDER)
+            {
+                RemoveSpellsCausingAura(SPELL_AURA_CONTROL_VEHICLE);
+                if(unit->GetTypeId() == TYPEID_PLAYER)
+                {
+                    ((Player*)unit)->SetMover(unit);
+                    ((Player*)unit)->SetClientControl(unit, 1);
+                    ((Player*)unit)->SetMoverInQueve(NULL);
+                    ((Player*)unit)->RemovePetActionBar();
+
+                    if(((Player*)unit)->GetGroup())
+                        ((Player*)unit)->SetGroupUpdateFlag(GROUP_UPDATE_VEHICLE);
+                }
+                unit->SetCharm(NULL);
+                SetCharmerGUID(NULL);
+                setFaction(GetCreatureInfo()->faction_A);
+            }
+            if(GetVehicleFlags() & VF_NON_SELECTABLE)
+                RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+            if(seat->second.vs_flags & SF_UNATTACKABLE)
+                unit->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+            // restore player control
+            if(unit->GetTypeId() == TYPEID_PLAYER)
+            {
+                ((Player*)unit)->SetFarSightGUID(NULL);
+
+                if(seat->second.vs_flags & SF_CAN_CAST)
+                {
+                    WorldPacket data0(SMSG_FORCE_MOVE_UNROOT, 10);
+                    data0 << unit->GetPackGUID();
+                    data0 << (uint32)(2);                        // can rotate
+                    unit->SendMessageToSet(&data0,true);
+                }
+                else
+                {
+                    WorldPacket data1(SMSG_FORCE_MOVE_UNROOT, 10);
+                    data1 << unit->GetPackGUID();
+                    data1 << (uint32)(0);                        // cannot rotate
+                    unit->SendMessageToSet(&data1,true);
+                }
+            }
+            unit->m_movementInfo.ClearTransportData();
+            seat->second.passenger = NULL;
+            seat->second.flags = SEAT_FREE;
+
+            unit->m_movementInfo.RemoveMovementFlag(MOVEFLAG_ONTRANSPORT);
+            EmptySeatsCountChanged();
+            break;
+        }
+    }
+}
+
+void Vehicle::RemoveAllPassengers()
+{
+    for(SeatMap::iterator itr = m_Seats.begin(); itr != m_Seats.end(); ++itr)
+    {
+        if(itr->second.flags & SEAT_FULL)
+        {
+            if(Unit *passenger = itr->second.passenger)                     // this cant be NULL, but..
+                passenger->ExitVehicle();
+        }
+        else if(itr->second.flags & (SEAT_VEHICLE_FULL | SEAT_VEHICLE_FREE))
+        {
+            if(Unit *passenger = itr->second.passenger)                     // this cant be NULL, but..
+            {
+                passenger->ExitVehicle();
+                ((Vehicle*)passenger)->Dismiss();
+            }
+        }
+    }
+    // make sure everything is cleared
+    InitSeats();
+}
+
+bool Vehicle::HasSpell(uint32 spell) const
+{
+    if(!m_VehicleData)
+        return false;
+
+    for(uint8 j = 0; j < MAX_VEHICLE_SPELLS; j++)
+    {
+        if(m_VehicleData->v_spells[j] == spell)
+            return true;
+    }
+
+    return false;
+}
+
+void Vehicle::BuildVehicleActionBar(Player *plr) const
+{
+    WorldPacket data(SMSG_PET_SPELLS, 8+2+4+4+4*10+1+1);
+    data << uint64(GetGUID());
+    data << uint16(0x00000000);                     // creature family, not used in vehicles
+    data << uint32(0x00000000);                     // unk
+    data << uint32(0x00000101);                     // react state
+
+    for(uint32 i = 0; i <= MAX_VEHICLE_SPELLS; ++i)
+    {
+        data << uint16(m_VehicleData ? m_VehicleData->v_spells[i] : NULL) << uint8(0) << uint8(i+8);
+    }
+
+    data << uint8(0);                               //aditional spells in spellbook, not used in vehicles
+
+    uint8 cooldownsCount = m_CreatureSpellCooldowns.size() + m_CreatureCategoryCooldowns.size();
+    data << uint8(cooldownsCount);
+    time_t curTime = time(NULL);
+
+    for(CreatureSpellCooldowns::const_iterator itr = m_CreatureSpellCooldowns.begin(); itr != m_CreatureSpellCooldowns.end(); ++itr)
+    {
+        time_t cooldown = (itr->second > curTime) ? (itr->second - curTime) * IN_MILLISECONDS : 0;
+
+        data << uint32(itr->first);                         // spellid
+        data << uint16(0);                                  // spell category?
+        data << uint32(cooldown);                           // cooldown
+        data << uint32(0);                                  // category cooldown
+    }
+
+    for(CreatureSpellCooldowns::const_iterator itr = m_CreatureCategoryCooldowns.begin(); itr != m_CreatureCategoryCooldowns.end(); ++itr)
+    {
+        time_t cooldown = (itr->second > curTime) ? (itr->second - curTime) * IN_MILLISECONDS : 0;
+
+        data << uint32(itr->first);                         // spellid
+        data << uint16(0);                                  // spell category?
+        data << uint32(0);                                  // cooldown
+        data << uint32(cooldown);                           // category cooldown
+    }
+
+    plr->GetSession()->SendPacket(&data);
+
+    data.Initialize(SMSG_PET_GUIDS, 12);
+    data << uint32(1);                                        // count
+    data << uint64(GetGUID());
+    plr->GetSession()->SendPacket(&data);
+}
+void Vehicle::InstallAllAccessories()
+{
+    if(!GetMap())
+       return;
+
+    CreatureDataAddon const *cainfo = GetCreatureAddon();
+    if(!cainfo || !cainfo->passengers)
+        return;
+    for (CreatureDataAddonPassengers const* cPassanger = cainfo->passengers; cPassanger->seat_idx != -1; ++cPassanger)
+    {
+        // Continue if seat already taken
+        if(GetPassenger(cPassanger->seat_idx))
+            continue;
+
+        uint32 guid = 0;
+        bool isVehicle = false;
+        // Set guid and check whatever it is
+        if(cPassanger->guid != 0)
+            guid = cPassanger->guid;
+        else
+        {
+            CreatureDataAddon const* passAddon;
+            passAddon = ObjectMgr::GetCreatureTemplateAddon(cPassanger->entry);
+            if(passAddon && passAddon->vehicle_id != 0)
+                isVehicle = true;
+            else
+                guid = sObjectMgr.GenerateLowGuid(HIGHGUID_UNIT);
+        }
+        // Create it
+        Creature *pPassenger = new Creature;
+        if(!isVehicle)
+        {
+            uint32 entry = cPassanger->entry;
+            if(entry == 0)
+            {
+                CreatureData const* data = sObjectMgr.GetCreatureData(guid);
+                if(!data)
+                {
+                    delete pPassenger;
+                    continue;
+                }
+                entry = data->id;
+            }     
+            if(!pPassenger->Create(guid, GetMap(), GetPhaseMask(), entry, 0))
+            {
+                delete pPassenger;
+                continue;
+            }
+            pPassenger->LoadFromDB(guid, GetMap());
+            pPassenger->Relocate(GetPositionX(), GetPositionY(), GetPositionZ());
+            GetMap()->Add(pPassenger);
+            pPassenger->AIM_Initialize();
+        }
+        else
+            pPassenger = (Creature*)SummonVehicle(cPassanger->entry, GetPositionX(), GetPositionY(), GetPositionZ(), 0);
+        // Enter vehicle...
+        pPassenger->EnterVehicle(this, cPassanger->seat_idx, true);
+        // ...and send update. Without this, client wont show this new creature/vehicle...
+        WorldPacket data;
+        pPassenger->BuildHeartBeatMsg(&data);
+        pPassenger->SendMessageToSet(&data, false);
+    }
+}
+
+Unit *Vehicle::GetPassenger(int8 seatId) const
+{
+    SeatMap::const_iterator seat = m_Seats.find(seatId);
+    if(seat == m_Seats.end()) return NULL;
+    return seat->second.passenger;
+}
+void Vehicle::Die()
+{
+    for (SeatMap::iterator itr = m_Seats.begin(); itr != m_Seats.end(); ++itr)
+        if(Unit *passenger = itr->second.passenger)
+            if(((Creature*)passenger)->isVehicle())
+                ((Vehicle*)passenger)->Dismiss();
+    RemoveAllPassengers();
+}
\ No newline at end of file
diff --git a/mangos/src/game/Vehicle.h b/Core/src/game/Vehicle.h
index 4233db6..f6c189d 100644
--- a/mangos/src/game/Vehicle.h
+++ b/Core/src/game/Vehicle.h
@@ -22,8 +22,36 @@
 #include "ObjectGuid.h"
 #include "Creature.h"
 #include "Unit.h"
+#include "ObjectMgr.h"
 
-class Vehicle : public Creature
+struct VehicleSeat
+{
+    VehicleSeatEntry const *seatInfo;
+    Unit* passenger;
+    uint8 flags;
+    uint32 vs_flags;
+};
+
+enum VehicleSeatFlags
+{
+    SEAT_FREE           = 0x01,                             // free seat
+    SEAT_FULL           = 0x02,                             // seat occupied by player/creature
+    // special cases
+    SEAT_VEHICLE_FREE   = 0x04,                             // seat occupied by vehicle, but that vehicle is free
+    SEAT_VEHICLE_FULL   = 0x08                              // seat occupied by vehicle and that vehicle is full too
+};
+
+enum PowerType
+{
+    POWER_TYPE_PYRITE = 41,
+    POWER_TYPE_STEAM  = 61
+};
+
+#define MAX_SEAT 8
+
+typedef std::map<int8, VehicleSeat> SeatMap;
+
+class MANGOS_DLL_SPEC Vehicle : public Creature
 {
     public:
         explicit Vehicle();
@@ -32,19 +60,59 @@ class Vehicle : public Creature
         void AddToWorld();
         void RemoveFromWorld();
 
-        bool Create (uint32 guidlow, Map *map, uint32 Entry, uint32 vehicleId, uint32 team);
+        void Die();
+        bool Create (uint32 guidlow, Map *map, uint32 phaseMask, uint32 Entry, uint32 vehicleId, uint32 team, const CreatureData *data = NULL);
+        void Respawn();
 
         void setDeathState(DeathState s);                   // overwrite virtual Creature::setDeathState and Unit::setDeathState
         void Update(uint32 diff);                           // overwrite virtual Creature::Update and Unit::Update
 
+        void RegeneratePower(Powers power);
+
         uint32 GetVehicleId() { return m_vehicleId; }
-        void SetVehicleId(uint32 vehicleid) { m_vehicleId = vehicleid; }
+        bool SetVehicleId(uint32 vehicleid);
+
+        void InitSeats();
+
+        void ChangeSeatFlag(uint8 seat, uint8 flag);
+        Vehicle* FindFreeSeat(int8 *seatid, bool force = true);
+        Vehicle* GetNextEmptySeat(int8 *seatId, bool next = true, bool force = true);
+        Vehicle* GetFirstEmptySeat(int8 *seatId, bool force = true);
+        int8 GetEmptySeatsCount(bool force = true);
+        void EmptySeatsCountChanged();
+        int8 GetTotalSeatsCount() { return m_Seats.size(); }
+        uint8 m_comboPointsForCast;
+        bool HasEmptySeat(int8 seatId) const;
+        int8 GetNextEmptySeatNum(int8 seatId, bool next) const;
 
         void Dismiss();
 
+        void RelocatePassengers(Map *map);
+        void AddPassenger(Unit *unit, int8 seatId, bool force = true);
+        void RemovePassenger(Unit *unit);
+        void RemoveAllPassengers();
+
+        bool HasSpell(uint32 spell) const;
+        void SetSpawnDuration(int32 duration)
+        {
+            duration < 1 ? despawn = false : despawn = true;
+            m_spawnduration = duration;
+        }
+        VehicleDataStructure const* GetVehicleData() { return m_VehicleData; }
+        uint32 GetVehicleFlags() { return m_VehicleData ? m_VehicleData->v_flags : NULL; }
+        uint32 GetCreationTime() { return m_creation_time; }
+        void BuildVehicleActionBar(Player *plr) const;
+        void InstallAllAccessories();
+        Unit *GetPassenger(int8 seatId) const;
     protected:
         uint32 m_vehicleId;
-
+        VehicleEntry const *m_vehicleInfo;
+        VehicleDataStructure const *m_VehicleData;
+        uint32 m_creation_time;
+        SeatMap m_Seats;
+        bool despawn;
+        int32 m_spawnduration;
+        uint32 m_regenUpdateTimer;
     private:
         void SaveToDB(uint32, uint8)                        // overwrited of Creature::SaveToDB     - don't must be called
         {
diff --git a/mangos/src/game/WaypointMovementGenerator.cpp b/Core/src/game/WaypointMovementGenerator.cpp
index ba6bd7e..dee5ac8 100644
--- a/mangos/src/game/WaypointMovementGenerator.cpp
+++ b/Core/src/game/WaypointMovementGenerator.cpp
@@ -309,11 +309,15 @@ void FlightPathMovementGenerator::Initialize(Player &player)
 
 void FlightPathMovementGenerator::Finalize(Player & player)
 {
+    if(!player.IsInWorld())
+	    return;
+		
     // remove flag to prevent send object build movement packets for flight state and crash (movement generator already not at top of stack)
     player.clearUnitState(UNIT_STAT_IN_FLIGHT);
 
     float x, y, z;
     i_destinationHolder.GetLocationNow(player.GetBaseMap(), x, y, z);
+    player.Anti__SetLastTeleTime(time(NULL));
     player.SetPosition(x, y, z, player.GetOrientation());
 
     player.Unmount();
diff --git a/mangos/src/game/World.cpp b/Core/src/game/World.cpp
index abf273d..e6b58da 100644
--- a/mangos/src/game/World.cpp
+++ b/Core/src/game/World.cpp
@@ -49,6 +49,8 @@
 #include "CreatureAIRegistry.h"
 #include "Policies/SingletonImp.h"
 #include "BattleGroundMgr.h"
+#include "Language.h"
+#include "OutdoorPvPMgr.h"
 #include "TemporarySummon.h"
 #include "VMapFactory.h"
 #include "GameEventMgr.h"
@@ -60,6 +62,7 @@
 #include "WaypointManager.h"
 #include "GMTicketMgr.h"
 #include "Util.h"
+#include "AuctionHouseBot.h"
 #include "CharacterDatabaseCleaner.h"
 
 INSTANTIATE_SINGLETON_1( World );
@@ -77,6 +80,21 @@ float World::m_MaxVisibleDistanceInFlight     = DEFAULT_VISIBILITY_DISTANCE;
 float World::m_VisibleUnitGreyDistance        = 0;
 float World::m_VisibleObjectGreyDistance      = 0;
 
+///PVP Announcer
+void World::SendPvPAnnounce(Player* killer, Player* killed)
+{
+  std::ostringstream msg;
+  std::ostringstream KillerName;
+  std::ostringstream KilledName;
+
+  KillerName << killer->GetName();
+  KilledName << killed->GetName();
+
+  msg << "|CFFFFFF01[" << KillerName.str().c_str() << "]" << "|CFF0042FF Has Killed " << "|CFFFFFF01[" << KilledName.str().c_str() << "]" << "|CFFE55BB0 in " << "|CFFFE8A0E[" << killer->GetBaseMap()->GetMapName() << "]";
+  if (sWorld.getConfig(CONFIG_BOOL_PVP_ANNOUNCER))
+    SendWorldText(LANG_SYSTEMMESSAGE, msg.str().c_str());
+}
+
 /// World constructor
 World::World()
 {
@@ -86,6 +104,7 @@ World::World()
     m_ShutdownTimer = 0;
     m_gameTime=time(NULL);
     m_startTime=m_gameTime;
+    world_diff_time = 0;
     m_maxActiveSessionCount = 0;
     m_maxQueuedSessionCount = 0;
     m_resultQueue = NULL;
@@ -511,6 +530,28 @@ void World::LoadConfigSettings(bool reload)
     setConfigPos(CONFIG_FLOAT_CREATURE_FAMILY_FLEE_ASSISTANCE_RADIUS, "CreatureFamilyFleeAssistanceRadius", 30.0f);
 
     ///- Read other configuration items from the config file
+
+    // movement anticheat
+    m_MvAnticheatEnable                     = sConfig.GetBoolDefault("Anticheat.Movement.Enable",false);
+    m_MvAnticheatKick                       = sConfig.GetBoolDefault("Anticheat.Movement.Kick",false);
+    m_MvAnticheatAnnounce                   = sConfig.GetBoolDefault("Anticheat.Movement.Announce",false);
+    m_MvAnticheatAlarmCount                 = (uint32)sConfig.GetIntDefault("Anticheat.Movement.AlarmCount", 5);
+    m_MvAnticheatAlarmPeriod                = (uint32)sConfig.GetIntDefault("Anticheat.Movement.AlarmTime", 5000);
+    m_MvAntiCheatBan                        = (unsigned char)sConfig.GetIntDefault("Anticheat.Movement.BanType",0);
+    m_MvAnticheatBanTime                    = sConfig.GetStringDefault("Anticheat.Movement.BanTime","1m");
+    m_MvAnticheatGmLevel                    = (unsigned char)sConfig.GetIntDefault("Anticheat.Movement.GmLevel",0);
+    m_MvAnticheatKill                       = sConfig.GetBoolDefault("Anticheat.Movement.Kill",false);
+    m_MvAnticheatMaxXYT                     = sConfig.GetFloatDefault("Anticheat.Movement.MaxXYT",0.04f);
+    m_MvAnticheatIgnoreAfterTeleport        = (uint16)sConfig.GetIntDefault("Anticheat.Movement.IgnoreSecAfterTeleport",10);
+
+    m_MvAnticheatSpeedCheck                 = sConfig.GetBoolDefault("Anticheat.Movement.DetectSpeedHack",1);
+    m_MvAnticheatWaterCheck                 = sConfig.GetBoolDefault("Anticheat.Movement.DetectWaterWalk",1);
+    m_MvAnticheatFlyCheck                   = sConfig.GetBoolDefault("Anticheat.Movement.DetectFlyHack",1);
+    m_MvAnticheatMountainCheck              = sConfig.GetBoolDefault("Anticheat.Movement.DetectMountainHack",1);
+    m_MvAnticheatJumpCheck                  = sConfig.GetBoolDefault("Anticheat.Movement.DetectAirJumpHack",1);
+    m_MvAnticheatTeleportCheck              = sConfig.GetBoolDefault("Anticheat.Movement.DetectTeleportHack",1);
+    m_MvAnticheatTeleport2PlaneCheck        = sConfig.GetBoolDefault("Anticheat.Movement.DetectTeleport2PlaneHack",0);
+
     setConfigMinMax(CONFIG_UINT32_COMPRESSION, "Compression", 1, 1, 9);
     setConfig(CONFIG_BOOL_ADDON_CHANNEL, "AddonChannel", true);
     setConfig(CONFIG_BOOL_CLEAN_CHARACTER_DB, "CleanCharacterDB", true);
@@ -523,6 +564,8 @@ void World::LoadConfigSettings(bool reload)
     if (reload)
         sMapMgr.SetGridCleanUpDelay(getConfig(CONFIG_UINT32_INTERVAL_GRIDCLEAN));
 
+    setConfig(CONFIG_UINT32_NUMTHREADS, "MapUpdate.Threads", 2);
+
     setConfigMin(CONFIG_UINT32_INTERVAL_MAPUPDATE, "MapUpdateInterval", 100, MIN_MAP_UPDATE_DELAY);
     if (reload)
         sMapMgr.SetMapUpdateInterval(getConfig(CONFIG_UINT32_INTERVAL_MAPUPDATE));
@@ -719,6 +762,7 @@ void World::LoadConfigSettings(bool reload)
     setConfig(CONFIG_UINT32_BATTLEGROUND_INVITATION_TYPE,              "Battleground.InvitationType", 0);
     setConfig(CONFIG_UINT32_BATTLEGROUND_PREMATURE_FINISH_TIMER,       "BattleGround.PrematureFinishTimer", 5 * MINUTE * IN_MILLISECONDS);
     setConfig(CONFIG_UINT32_BATTLEGROUND_PREMADE_GROUP_WAIT_FOR_MATCH, "BattleGround.PremadeGroupWaitForMatch", 30 * MINUTE * IN_MILLISECONDS);
+    setConfigMinMax(CONFIG_UINT32_RANDOM_BG_RESET_HOUR,                "BattleGround.Random.ResetHour", 6, 0, 23);
     setConfig(CONFIG_UINT32_ARENA_MAX_RATING_DIFFERENCE,               "Arena.MaxRatingDifference", 150);
     setConfig(CONFIG_UINT32_ARENA_RATING_DISCARD_TIMER,                "Arena.RatingDiscardTimer", 10 * MINUTE * IN_MILLISECONDS);
     setConfig(CONFIG_BOOL_ARENA_AUTO_DISTRIBUTE_POINTS,                "Arena.AutoDistributePoints", false);
@@ -727,6 +771,24 @@ void World::LoadConfigSettings(bool reload)
     setConfig(CONFIG_BOOL_ARENA_QUEUE_ANNOUNCER_EXIT,                  "Arena.QueueAnnouncer.Exit", false);
     setConfig(CONFIG_UINT32_ARENA_SEASON_ID,                           "Arena.ArenaSeason.ID", 1);
     setConfig(CONFIG_BOOL_ARENA_SEASON_IN_PROGRESS,                    "Arena.ArenaSeason.InProgress", true);
+    setConfig(CONFIG_UINT32_LOSERNOCHANGE,                             "Arena.LoserNoChange", 0);
+    setConfig(CONFIG_UINT32_LOSERHALFCHANGE,                           "Arena.LoserHalfChange", 0);
+
+    setConfig(CONFIG_UINT32_HONORABLE_KILL,                            "HonorableKill", 124);
+    setConfig(CONFIG_UINT32_BONUS_HONOR_AB_WIN,                        "BG.BonusHonor.AB.Win", 1);
+    setConfig(CONFIG_UINT32_BONUS_HONOR_AB_END,                        "BG.BonusHonor.AB.End", 1);
+    setConfig(CONFIG_UINT32_BONUS_HONOR_WSG_WIN,                       "BG.BonusHonor.WSG.Win", 5);
+    setConfig(CONFIG_UINT32_BONUS_HONOR_WSG_END,                       "BG.BonusHonor.WSG.End", 5);
+    setConfig(CONFIG_UINT32_BONUS_HONOR_AV_WIN,                        "BG.BonusHonor.AV.Win", 5);
+    setConfig(CONFIG_UINT32_BONUS_HONOR_AV_END,                        "BG.BonusHonor.AV.End", 5);
+    setConfig(CONFIG_UINT32_BONUS_HONOR_EOS_WIN,                       "BG.BonusHonor.EOS.Win", 1);
+    setConfig(CONFIG_UINT32_BONUS_HONOR_EOS_END,                       "BG.BonusHonor.EOS.End", 1);
+    setConfig(CONFIG_UINT32_BONUS_HONOR_HOLIDAY,                       "BG.BonusHonor.Holiday",5);
+
+    setConfig(CONFIG_UINT32_BONUS_HONOR_FLAG_WSG,                      "BG.BonusHonor.WSG.Flag",2);
+    setConfig(CONFIG_UINT32_BONUS_HONOR_FLAG_AB,                       "BG.BonusHonor.AB.Flag", 2);
+    setConfig(CONFIG_UINT32_BONUS_HONOR_FLAG_AV,                       "BG.BonusHonor.AV.Flag", 2);
+    setConfig(CONFIG_UINT32_BONUS_HONOR_FLAG_EOS,                      "BG.BonusHonor.EOS.Flag",2);
 
     setConfig(CONFIG_BOOL_OFFHAND_CHECK_AT_TALENTS_RESET, "OffhandCheckAtTalentsReset", false);
 
@@ -756,6 +818,37 @@ void World::LoadConfigSettings(bool reload)
     setConfig(CONFIG_UINT32_TIMERBAR_FIRE_GMLEVEL,    "TimerBar.Fire.GMLevel", SEC_CONSOLE);
     setConfig(CONFIG_UINT32_TIMERBAR_FIRE_MAX,        "TimerBar.Fire.Max", 1);
 
+    /* PvP Token System */
+    setConfig(CONFIG_PVP_TOKEN_ENABLE,"PvPToken.Enable", true);
+    setConfig(CONFIG_PVP_TOKEN_ITEMID,"PvPToken.ItemID", 29434);
+    setConfig(CONFIG_PVP_TOKEN_ITEMCOUNT,"PvPToken.ItemCount", 1);
+    setConfig(CONFIG_PVP_TOKEN_RESTRICTION,"PvPToken.MapRestriction", 4);
+
+    if(getConfig(CONFIG_PVP_TOKEN_ITEMCOUNT) < 1)
+        setConfig(CONFIG_PVP_TOKEN_ITEMCOUNT,"PvPToken.ItemCount",1);
+
+    setConfig(CONFIG_BOOL_ALLOW_FLYING_MOUNTS_EVERYWHERE, "Custom.AllowFlyingMountsEverywhere", false);
+    setConfig(CONFIG_BOOL_MAIL_ITEM_REFUNDABLE, "Custom.MailItemRefundable", false);
+    setConfig(CONFIG_MIN_LEVEL_DUALSPEC, "Custom.MinLevelDualSpec", 40);
+    setConfig(CONFIG_BOOL_EVERYONE_DRUNK, "Custom.EveryoneDrunk", false);
+    setConfig(CONFIG_BOOL_DK_NO_QUESTS_FOR_TP, "Custom.DeathKnightNoQuestsForTP", false);
+    setConfig(CONFIG_BOOL_PVP_ANNOUNCER, "Custom.PvPAnnouncer", false);
+    setConfig(CONFIG_BOOL_DUALSPEC_AT_CREATE, "Custom.DualSpecAtCreate", false);
+    setConfig(CONFIG_BOOL_EXTRA_SANCTUARY, "Custom.AddExtraSanctuary", false);
+    setConfig(CONFIG_BOOL_EXTRA_PVP, "Custom.AddExtraPvPZones", false);
+    setConfig(CONFIG_UINT32_SANCTUARY_ID, "Custom.SanctuaryZone", 0);
+    setConfig(CONFIG_UINT32_PVP_ID_1, "Custom.PvPZone1", 0);
+    setConfig(CONFIG_UINT32_PVP_ID_2, "Custom.PvPZone2", 0);
+    setConfig(CONFIG_UINT32_PVP_ID_3, "Custom.PvPZone3", 0);
+    setConfig(CONFIG_UINT32_PVP_ID_4, "Custom.PvPZone4", 0);
+    setConfig(CONFIG_BOOL_LIMIT_ALLOWED_MOUNTS, "Custom.LimitAllowedMounts", false);
+    setConfig(CONFIG_UINT32_ALLOWED_MOUNT1, "Custom.AllowedMount1", 0);
+    setConfig(CONFIG_UINT32_ALLOWED_MOUNT2, "Custom.AllowedMount2", 0);
+    setConfig(CONFIG_UINT32_ALLOWED_MOUNT3, "Custom.AllowedMount3", 0);
+    setConfig(CONFIG_BOOL_ALL_WEAPONS_MAX_SKILL, "Custom.AllWeaponSkillsAtMax", false);
+    setConfig(CONFIG_BOOL_PLAYER_AUTO_RESS, "Custom.AutoRessPlayersOnDeath", false);
+    setConfig(CONFIG_BOOL_ALL_WEAPONS_FOR_CLASS_MAX_SKILL, "Custom.AllWeaponSkillsForClassAtMax", false);
+
     m_VisibleUnitGreyDistance = sConfig.GetFloatDefault("Visibility.Distance.Grey.Unit", 1);
     if(m_VisibleUnitGreyDistance >  MAX_VISIBILITY_DISTANCE)
     {
@@ -858,6 +951,42 @@ void World::LoadConfigSettings(bool reload)
     sLog.outString( "WORLD: VMap support included. LineOfSight:%i, getHeight:%i",enableLOS, enableHeight);
     sLog.outString( "WORLD: VMap data directory is: %svmaps",m_dataPath.c_str());
     sLog.outString( "WORLD: VMap config keys are: vmap.enableLOS, vmap.enableHeight, vmap.ignoreMapIds, vmap.ignoreSpellIds");
+
+    /* AHBot Configuration Settings */
+    setConfig(CONFIG_BOOL_AHBOT_SELLER_ENABLED  , "AuctionHouseBot.Seller.Enabled"  , false);
+    setConfig(CONFIG_BOOL_AHBOT_BUYER_ENABLED   , "AuctionHouseBot.Buyer.Enabled"   , false);
+
+    setConfig(CONFIG_UINT32_AHBOT_ACCOUNT_ID    , "AuctionHouseBot.Account"         , 0);
+    setConfig(CONFIG_UINT32_AHBOT_CHARACTER_ID  , "AuctionHouseBot.Character"       , 0);
+
+    setConfig(CONFIG_BOOL_AHBOT_ITEMS_VENDOR    , "AuctionHouseBot.Items.Vendor"    , false);
+    setConfig(CONFIG_BOOL_AHBOT_ITEMS_LOOT      , "AuctionHouseBot.Items.Loot"      , true);
+    setConfig(CONFIG_BOOL_AHBOT_ITEMS_MISC      , "AuctionHouseBot.Items.Misc"      , false);
+
+    setConfig(CONFIG_BOOL_AHBOT_BIND_NO         , "AuctionHouseBot.Bind.No"         , true);
+    setConfig(CONFIG_BOOL_AHBOT_BIND_PICKUP     , "AuctionHouseBot.Bind.Pickup"     , false);
+    setConfig(CONFIG_BOOL_AHBOT_BIND_EQUIP      , "AuctionHouseBot.Bind.Equip"      , true);
+    setConfig(CONFIG_BOOL_AHBOT_BIND_USE        , "AuctionHouseBot.Bind.Use"        , true);
+    setConfig(CONFIG_BOOL_AHBOT_BIND_QUEST      , "AuctionHouseBot.Bind.Quest"      , false);
+
+    setConfig(CONFIG_BOOL_AHBOT_BUYPRICE_SELLER , "AuctionHouseBot.BuyPrice.Seller" , false);
+    setConfig(CONFIG_BOOL_AHBOT_BUYPRICE_BUYER  , "AuctionHouseBot.BuyPrice.Buyer"  , false);
+
+    setConfig(CONFIG_UINT32_AHBOT_ITEMS_CYCLE   , "AuctionHouseBot.ItemsPerCycle"   , 200);
+
+    setConfig(CONFIG_UINT32_AHBOT_ITEM_MIN_ITEM_LEVEL    , "AuctionHouseBot.Items.ItemLevel.Min"         , 0);
+    setConfig(CONFIG_UINT32_AHBOT_ITEM_MAX_ITEM_LEVEL    , "AuctionHouseBot.Items.ItemLevel.Max"         , 0);
+    setConfig(CONFIG_UINT32_AHBOT_ITEM_MIN_REQ_LEVEL     , "AuctionHouseBot.Items.ReqLevel.Min"          , 0);
+    setConfig(CONFIG_UINT32_AHBOT_ITEM_MAX_REQ_LEVEL     , "AuctionHouseBot.Items.ReqLevel.Max"          , 0);
+    setConfig(CONFIG_UINT32_AHBOT_ITEM_MIN_SKILL_RANK    , "AuctionHouseBot.Items.ReqSkill.Min"          , 0);
+    setConfig(CONFIG_UINT32_AHBOT_ITEM_MAX_SKILL_RANK    , "AuctionHouseBot.Items.ReqSkill.Max"          , 0);
+
+    setConfig(CONFIG_UINT32_AHBOT_TG_MIN_ITEM_LEVEL      , "AuctionHouseBot.Tradegoods.ItemLevel.Min"    , 0);
+    setConfig(CONFIG_UINT32_AHBOT_TG_MAX_ITEM_LEVEL      , "AuctionHouseBot.Tradegoods.ItemLevel.Max"    , 0);
+    setConfig(CONFIG_UINT32_AHBOT_TG_MIN_REQ_LEVEL       , "AuctionHouseBot.Tradegoods.ReqLevel.Min"     , 0);
+    setConfig(CONFIG_UINT32_AHBOT_TG_MAX_REQ_LEVEL       , "AuctionHouseBot.Tradegoods.ReqLevel.Max"     , 0);
+    setConfig(CONFIG_UINT32_AHBOT_TG_MIN_SKILL_RANK      , "AuctionHouseBot.Tradegoods.ReqSkill.Min"     , 0);
+    setConfig(CONFIG_UINT32_AHBOT_TG_MAX_SKILL_RANK      , "AuctionHouseBot.Tradegoods.ReqSkill.Max"     , 0);
 }
 
 /// Initialize the World
@@ -1106,6 +1235,9 @@ void World::SetInitialWorldSettings()
     sLog.outString( "Loading Player level dependent mail rewards..." );
     sObjectMgr.LoadMailLevelRewards();
 
+    sLog.outString( "Loading Spell disabled..." );
+    sObjectMgr.LoadSpellDisabledEntrys();
+
     sLog.outString( "Loading Loot Tables..." );
     sLog.outString();
     LoadLootTables();
@@ -1196,6 +1328,9 @@ void World::SetInitialWorldSettings()
     sLog.outString( "Returning old mails..." );
     sObjectMgr.ReturnOrDeleteOldMails(false);
 
+    // Loads the jail conf out of the database
+    sObjectMgr.LoadJailConf();
+
     ///- Load and initialize scripts
     sLog.outString( "Loading Scripts..." );
     sLog.outString();
@@ -1210,6 +1345,11 @@ void World::SetInitialWorldSettings()
     sLog.outString( "Loading Scripts text locales..." );    // must be after Load*Scripts calls
     sObjectMgr.LoadDbScriptStrings();
 
+    sLog.outString( "Loading VehicleData..." );
+    sObjectMgr.LoadVehicleData();
+    sLog.outString( "Loading VehicleSeatData..." );
+    sObjectMgr.LoadVehicleSeatData();
+
     sLog.outString( "Loading CreatureEventAI Texts...");
     sEventAIMgr.LoadCreatureEventAI_Texts(false);       // false, will checked in LoadCreatureEventAI_Scripts
 
@@ -1236,8 +1376,10 @@ void World::SetInitialWorldSettings()
     sprintf( isoDate, "%04d-%02d-%02d %02d:%02d:%02d",
         local.tm_year+1900, local.tm_mon+1, local.tm_mday, local.tm_hour, local.tm_min, local.tm_sec);
 
-    loginDatabase.PExecute("INSERT INTO uptime (realmid, starttime, startstring, uptime) VALUES('%u', " UI64FMTD ", '%s', 0)",
-        realmID, uint64(m_startTime), isoDate);
+    loginDatabase.PExecute("INSERT INTO uptime (realmid, starttime, startstring, uptime) VALUES('%u', " UI64FMTD ", '%s', 0)", realmID, uint64(m_startTime), isoDate);
+
+    static uint32 abtimer = 0;
+    abtimer = sConfig.GetIntDefault("AutoBroadcast.Timer", 60000);
 
     m_timers[WUPDATE_OBJECTS].SetInterval(0);
     m_timers[WUPDATE_SESSIONS].SetInterval(0);
@@ -1246,7 +1388,9 @@ void World::SetInitialWorldSettings()
     m_timers[WUPDATE_UPTIME].SetInterval(m_configUint32Values[CONFIG_UINT32_UPTIME_UPDATE]*MINUTE*IN_MILLISECONDS);
                                                             //Update "uptime" table based on configuration entry in minutes.
     m_timers[WUPDATE_CORPSES].SetInterval(3*HOUR*IN_MILLISECONDS);
+    m_timers[WUPDATE_AUTOBROADCAST].SetInterval(abtimer);
     m_timers[WUPDATE_DELETECHARS].SetInterval(DAY*IN_MILLISECONDS); // check for chars to delete every day
+    m_timers[WUPDATE_AUTOBROADCAST].SetInterval(abtimer);
 
     //to set mailtimer to return mails every day between 4 and 5 am
     //mailtimer is increased when updating auctions
@@ -1269,6 +1413,15 @@ void World::SetInitialWorldSettings()
     sBattleGroundMgr.CreateInitialBattleGrounds();
     sBattleGroundMgr.InitAutomaticArenaPointDistribution();
 
+
+    ///- Initialize outdoor pvp
+    sLog.outString( "Starting Outdoor PvP System" );
+    sOutdoorPvPMgr.InitOutdoorPvP();
+
+    ///- Apply spell hacks
+    sLog.outString( "Apply spell hacks..." );
+    sSpellMgr.ApplySpellHacks();
+
     //Not sure if this can be moved up in the sequence (with static data loading) as it uses MapManager
     sLog.outString( "Loading Transports..." );
     sMapMgr.LoadTransports();
@@ -1282,16 +1435,24 @@ void World::SetInitialWorldSettings()
     sLog.outString("Calculate next weekly quest reset time..." );
     InitWeeklyQuestResetTime();
 
+    sLog.outString("Calculate random battleground reset time..." );
+    InitRandomBGResetTime();
+
     sLog.outString("Starting objects Pooling system..." );
     sPoolMgr.Initialize();
 
     sLog.outString("Starting Game Event system..." );
     uint32 nextGameEvent = sGameEventMgr.Initialize();
     m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);    //depend on next event
-
+    
     // Delete all characters which have been deleted X days before
     Player::DeleteOldCharacters();
 
+    sLog.outString("Starting AuctionHouseBot System...");
+    auctionbot.Initialize();
+    
+    sLog.outString("Starting Autobroadcast system...");
+    
     sLog.outString( "WORLD: World initialized" );
 
     uint32 uStartInterval = getMSTimeDiff(uStartTime, getMSTime());
@@ -1345,6 +1506,7 @@ void World::DetectDBCLang()
 /// Update the World !
 void World::Update(uint32 diff)
 {
+    world_diff_time = diff;
     ///- Update the different timers
     for(int i = 0; i < WUPDATE_COUNT; ++i)
     {
@@ -1359,15 +1521,22 @@ void World::Update(uint32 diff)
 
     /// Handle daily quests reset time
     if (m_gameTime > m_NextDailyQuestReset)
+    {
         ResetDailyQuests();
+        ResetBGDaily();
+    }
 
     /// Handle weekly quests reset time
     if (m_gameTime > m_NextWeeklyQuestReset)
         ResetWeeklyQuests();
 
+    if (m_gameTime > m_NextRandomBGReset)
+        ResetRandomBG();
+
     /// <ul><li> Handle auctions when the timer has passed
     if (m_timers[WUPDATE_AUCTIONS].Passed())
     {
+        auctionbot.Update();
         m_timers[WUPDATE_AUCTIONS].Reset();
 
         ///- Update mails (return old mails with item, or delete them)
@@ -1429,6 +1598,7 @@ void World::Update(uint32 diff)
         sMapMgr.Update(diff);                // As interval = 0
 
         sBattleGroundMgr.Update(diff);
+        sOutdoorPvPMgr.Update(diff);
     }
 
     ///- Delete all characters which have been deleted X days before
@@ -1457,6 +1627,16 @@ void World::Update(uint32 diff)
         m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);
         m_timers[WUPDATE_EVENTS].Reset();
     }
+    static uint32 autobroadcaston = 0;
+    autobroadcaston = sConfig.GetIntDefault("AutoBroadcast.On", 0);
+    if(autobroadcaston == 1)
+    {
+        if (m_timers[WUPDATE_AUTOBROADCAST].Passed())
+        {
+            m_timers[WUPDATE_AUTOBROADCAST].Reset();
+            SendBroadcast();
+        }
+    }
 
     /// </ul>
     ///- Move all creatures with "delayed move" and remove and delete all objects with "delayed remove"
@@ -1871,6 +2051,57 @@ void World::ProcessCliCommands()
     }
 }
 
+void World::SendBroadcast()
+{
+    std::string msg;
+    static int nextid;
+
+    QueryResult *result;
+    if(nextid != 0)
+    {
+        result = loginDatabase.PQuery("SELECT `text`, `next` FROM `autobroadcast` WHERE `id` = %u", nextid);
+    }
+    else
+    {
+        result = loginDatabase.PQuery("SELECT `text`, `next` FROM `autobroadcast` ORDER BY RAND() LIMIT 1");
+    }
+
+    if(!result)
+        return;
+
+    Field *fields = result->Fetch();
+    nextid  = fields[1].GetUInt32();
+    msg = fields[0].GetString();
+    delete result;
+
+    static uint32 abcenter = 0;
+    abcenter = sConfig.GetIntDefault("AutoBroadcast.Center", 0);
+    if(abcenter == 0)
+    {
+        sWorld.SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+
+        sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+    }
+    if(abcenter == 1)
+    {
+        WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
+        data << msg;
+        sWorld.SendGlobalMessage(&data);
+
+        sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+    }
+    if(abcenter == 2)
+    {
+        sWorld.SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+
+        WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
+        data << msg;
+        sWorld.SendGlobalMessage(&data);
+
+        sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+   }
+}
+
 void World::InitResultQueue()
 {
     m_resultQueue = new SqlResultQueue;
@@ -1965,6 +2196,45 @@ void World::InitDailyQuestResetTime()
         delete result;
 }
 
+void World::ResetBGDaily()
+{
+    CharacterDatabase.Execute("DELETE FROM character_battleground_status");
+    for(SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetPlayer())
+            itr->second->GetPlayer()->ResetBGStatus();
+}
+
+void World::InitRandomBGResetTime()
+{
+    QueryResult * result = CharacterDatabase.Query("SELECT NextRandomBGResetTime FROM saved_variables");
+    if (!result)
+        m_NextRandomBGReset = time_t(time(NULL));         // game time not yet init
+    else
+        m_NextRandomBGReset = time_t((*result)[0].GetUInt64());
+
+    // generate time by config
+    time_t curTime = time(NULL);
+    tm localTm = *localtime(&curTime);
+    localTm.tm_hour = getConfig(CONFIG_UINT32_RANDOM_BG_RESET_HOUR);
+    localTm.tm_min  = 0;
+    localTm.tm_sec  = 0;
+
+    // current day reset time
+    time_t nextDayResetTime = mktime(&localTm);
+
+    // next reset time before current moment
+    if (curTime >= nextDayResetTime)
+        nextDayResetTime += DAY;
+
+    // normalize reset time
+    m_NextRandomBGReset = m_NextRandomBGReset < curTime ? nextDayResetTime - DAY : nextDayResetTime;
+
+    if (!result)
+        CharacterDatabase.PExecute("INSERT INTO saved_variables (NextRandomBGResetTime) VALUES ('"UI64FMTD"')", uint64(m_NextRandomBGReset));
+    else
+        delete result;
+}
+
 void World::ResetDailyQuests()
 {
     DETAIL_LOG("Daily quests reset for all characters.");
@@ -1989,10 +2259,22 @@ void World::ResetWeeklyQuests()
     CharacterDatabase.PExecute("UPDATE saved_variables SET NextWeeklyQuestResetTime = '"UI64FMTD"'", uint64(m_NextWeeklyQuestReset));
 }
 
+void World::ResetRandomBG()
+{
+    sLog.outDetail("Random BG status reset for all characters.");
+    CharacterDatabase.Execute("DELETE FROM character_battleground_random");
+    for(SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetPlayer())
+            itr->second->GetPlayer()->SetRandomWinner(false);
+
+    m_NextRandomBGReset = time_t(m_NextRandomBGReset + DAY);
+    CharacterDatabase.PExecute("UPDATE saved_variables SET NextRandomBGResetTime = '"UI64FMTD"'", uint64(m_NextRandomBGReset));
+}
+
 void World::SetPlayerLimit( int32 limit, bool needUpdate )
 {
-    if (limit < -SEC_ADMINISTRATOR)
-        limit = -SEC_ADMINISTRATOR;
+    if(limit <= -SEC_CONSOLE)
+        limit = -(SEC_CONSOLE-1);
 
     // lock update need
     bool db_update_need = needUpdate || (limit < 0) != (m_playerLimit < 0) || (limit < 0 && m_playerLimit < 0 && limit != m_playerLimit);
diff --git a/mangos/src/game/World.h b/Core/src/game/World.h
index b289b91..fa9bea3 100644
--- a/mangos/src/game/World.h
+++ b/Core/src/game/World.h
@@ -23,6 +23,7 @@
 #ifndef __WORLD_H
 #define __WORLD_H
 
+#include <omp.h>
 #include "Common.h"
 #include "Timer.h"
 #include "Policies/Singleton.h"
@@ -70,15 +71,16 @@ enum ShutdownExitCode
 /// Timers for different object refresh rates
 enum WorldTimers
 {
-    WUPDATE_OBJECTS     = 0,
-    WUPDATE_SESSIONS    = 1,
-    WUPDATE_AUCTIONS    = 2,
-    WUPDATE_WEATHERS    = 3,
-    WUPDATE_UPTIME      = 4,
-    WUPDATE_CORPSES     = 5,
-    WUPDATE_EVENTS      = 6,
-    WUPDATE_DELETECHARS = 7,
-    WUPDATE_COUNT       = 8
+    WUPDATE_OBJECTS       = 0,
+    WUPDATE_SESSIONS      = 1,
+    WUPDATE_AUCTIONS      = 2,
+    WUPDATE_WEATHERS      = 3,
+    WUPDATE_UPTIME        = 4,
+    WUPDATE_CORPSES       = 5,
+    WUPDATE_EVENTS        = 6,
+    WUPDATE_DELETECHARS   = 7,
+    WUPDATE_AUTOBROADCAST = 8,
+    WUPDATE_COUNT         = 9
 };
 
 /// Configuration elements
@@ -177,11 +179,73 @@ enum eConfigUInt32Values
     CONFIG_UINT32_TIMERBAR_BREATH_MAX,
     CONFIG_UINT32_TIMERBAR_FIRE_GMLEVEL,
     CONFIG_UINT32_TIMERBAR_FIRE_MAX,
-    CONFIG_UINT32_MIN_LEVEL_STAT_SAVE,
     CONFIG_UINT32_CHARDELETE_KEEP_DAYS,
     CONFIG_UINT32_CHARDELETE_METHOD,
     CONFIG_UINT32_CHARDELETE_MIN_LEVEL,
+
+    /* Start AHBot */
+    CONFIG_UINT32_AHBOT_ACCOUNT_ID,
+    CONFIG_UINT32_AHBOT_CHARACTER_ID,
+    CONFIG_UINT32_AHBOT_ITEMS_CYCLE,
+
+    CONFIG_UINT32_AHBOT_ITEM_MIN_ITEM_LEVEL,
+    CONFIG_UINT32_AHBOT_ITEM_MAX_ITEM_LEVEL,
+    CONFIG_UINT32_AHBOT_TG_MIN_ITEM_LEVEL,
+    CONFIG_UINT32_AHBOT_TG_MAX_ITEM_LEVEL,
+
+    CONFIG_UINT32_AHBOT_ITEM_MIN_REQ_LEVEL,
+    CONFIG_UINT32_AHBOT_ITEM_MAX_REQ_LEVEL,
+    CONFIG_UINT32_AHBOT_TG_MIN_REQ_LEVEL,
+    CONFIG_UINT32_AHBOT_TG_MAX_REQ_LEVEL,
+
+    CONFIG_UINT32_AHBOT_ITEM_MIN_SKILL_RANK,
+    CONFIG_UINT32_AHBOT_ITEM_MAX_SKILL_RANK,
+    CONFIG_UINT32_AHBOT_TG_MIN_SKILL_RANK,
+    CONFIG_UINT32_AHBOT_TG_MAX_SKILL_RANK,
+    /* End AHBot*/
+
+    CONFIG_UINT32_MIN_LEVEL_STAT_SAVE,
+    
+    /* Honor Options for BG */
+    CONFIG_UINT32_HONORABLE_KILL,
+    CONFIG_UINT32_BONUS_HONOR_AB_WIN,
+    CONFIG_UINT32_BONUS_HONOR_AB_END,
+    CONFIG_UINT32_BONUS_HONOR_WSG_WIN,
+    CONFIG_UINT32_BONUS_HONOR_WSG_END,
+    CONFIG_UINT32_BONUS_HONOR_AV_WIN,
+    CONFIG_UINT32_BONUS_HONOR_AV_END,
+    CONFIG_UINT32_BONUS_HONOR_EOS_WIN,
+    CONFIG_UINT32_BONUS_HONOR_EOS_END,
+    CONFIG_UINT32_BONUS_HONOR_FLAG_WSG,
+    CONFIG_UINT32_BONUS_HONOR_FLAG_AB,
+    CONFIG_UINT32_BONUS_HONOR_FLAG_EOS,
+    CONFIG_UINT32_BONUS_HONOR_FLAG_AV,
+    CONFIG_UINT32_BONUS_HONOR_HOLIDAY,
+    CONFIG_UINT32_TEAM_BG_FACTION_BLUE,
+    CONFIG_UINT32_TEAM_BG_FACTION_RED,
+    CONFIG_UINT32_TEAM_BG_BUFF_BLUE,
+    CONFIG_UINT32_TEAM_BG_BUFF_RED,
+    CONFIG_UINT32_RANDOM_BG_RESET_HOUR,
+
+    /* Darkrulerz' customs */
+    CONFIG_UINT32_PVP_ID_1,
+    CONFIG_UINT32_PVP_ID_2,
+    CONFIG_UINT32_PVP_ID_3,
+    CONFIG_UINT32_PVP_ID_4,
+    CONFIG_UINT32_SANCTUARY_ID,
+    CONFIG_UINT32_ALLOWED_MOUNT1,
+    CONFIG_UINT32_ALLOWED_MOUNT2,
+    CONFIG_UINT32_ALLOWED_MOUNT3,
+    CONFIG_MIN_LEVEL_DUALSPEC,
+    /* End of Darkrulerz' customs */
+
+    CONFIG_UINT32_NUMTHREADS,
+    CONFIG_UINT32_FACTIONED_MAP_FACTION,
+    CONFIG_UINT32_FACTIONED_MAP_TEAM,
+    CONFIG_UINT32_LOSERNOCHANGE,
+    CONFIG_UINT32_LOSERHALFCHANGE,
     CONFIG_UINT32_VALUE_COUNT
+    
 };
 
 /// Configuration elements
@@ -260,7 +324,13 @@ enum eConfigFloatValues
     CONFIG_FLOAT_CREATURE_FAMILY_ASSISTANCE_RADIUS,
     CONFIG_FLOAT_GROUP_XP_DISTANCE,
     CONFIG_FLOAT_THREAT_RADIUS,
-    CONFIG_FLOAT_VALUE_COUNT
+    CONFIG_FLOAT_VALUE_COUNT,
+    
+    ///PVP Token
+    CONFIG_PVP_TOKEN_ENABLE,
+    CONFIG_PVP_TOKEN_ITEMID,
+    CONFIG_PVP_TOKEN_ITEMCOUNT,
+    CONFIG_PVP_TOKEN_RESTRICTION
 };
 
 /// Configuration elements
@@ -313,6 +383,40 @@ enum eConfigBoolValues
     CONFIG_BOOL_KICK_PLAYER_ON_BAD_PACKET,
     CONFIG_BOOL_STATS_SAVE_ONLY_ON_LOGOUT,
     CONFIG_BOOL_CLEAN_CHARACTER_DB,
+
+    /* Start AHBot */
+    CONFIG_BOOL_AHBOT_SELLER_ENABLED,
+    CONFIG_BOOL_AHBOT_BUYER_ENABLED,
+    CONFIG_BOOL_AHBOT_ITEMS_VENDOR,
+    CONFIG_BOOL_AHBOT_ITEMS_LOOT,
+    CONFIG_BOOL_AHBOT_ITEMS_MISC,
+    CONFIG_BOOL_AHBOT_BIND_NO,
+    CONFIG_BOOL_AHBOT_BIND_PICKUP,
+    CONFIG_BOOL_AHBOT_BIND_EQUIP,
+    CONFIG_BOOL_AHBOT_BIND_USE,
+    CONFIG_BOOL_AHBOT_BIND_QUEST,
+    CONFIG_BOOL_AHBOT_BUYPRICE_SELLER,
+    CONFIG_BOOL_AHBOT_BUYPRICE_BUYER,
+    /* End AHBot*/
+    
+    /* Broadcaster*/
+    CONFIG_BOOL_BROADCAST_ENABLED,
+    
+    /* Darkrulerz' Customs*/
+    CONFIG_BOOL_ALLOW_FLYING_MOUNTS_EVERYWHERE,
+    CONFIG_BOOL_MAIL_ITEM_REFUNDABLE,
+    CONFIG_BOOL_EVERYONE_DRUNK,
+    CONFIG_BOOL_DK_NO_QUESTS_FOR_TP,
+    CONFIG_BOOL_PVP_ANNOUNCER,
+    CONFIG_BOOL_DUALSPEC_AT_CREATE,
+    CONFIG_BOOL_EXTRA_PVP,
+    CONFIG_BOOL_EXTRA_SANCTUARY,
+    CONFIG_BOOL_LIMIT_ALLOWED_MOUNTS,
+    CONFIG_BOOL_ALL_WEAPONS_MAX_SKILL,
+    CONFIG_BOOL_PLAYER_AUTO_RESS,
+    CONFIG_BOOL_ALL_WEAPONS_FOR_CLASS_MAX_SKILL,
+    /* End of Customs*/
+    
     CONFIG_BOOL_VALUE_COUNT
 };
 
@@ -446,6 +550,7 @@ class World
 
         WorldSession* FindSession(uint32 id) const;
         void AddSession(WorldSession *s);
+        void SendBroadcast();
         bool RemoveSession(uint32 id);
         /// Get the number of current active sessions
         void UpdateMaxSessionCounters();
@@ -497,9 +602,11 @@ class World
         time_t const& GetGameTime() const { return m_gameTime; }
         /// Uptime (in secs)
         uint32 GetUptime() const { return uint32(m_gameTime - m_startTime); }
+        uint32 GetDiffTime() const { return world_diff_time; }
         /// Next daily quests reset time
         time_t GetNextDailyQuestsResetTime() const { return m_NextDailyQuestReset; }
         time_t GetNextWeeklyQuestsResetTime() const { return m_NextWeeklyQuestReset; }
+        time_t GetNextRandomBGResetTime() const { return m_NextRandomBGReset; }
 
         /// Get the maximum skill level a player can reach
         uint16 GetConfigMaxSkillValue() const
@@ -517,7 +624,10 @@ class World
         void SendZoneMessage(uint32 zone, WorldPacket *packet, WorldSession *self = 0, uint32 team = 0);
         void SendZoneText(uint32 zone, const char *text, WorldSession *self = 0, uint32 team = 0);
         void SendServerMessage(ServerMessageType type, const char *text = "", Player* player = NULL);
-
+        
+        ///PVP Announcer
+        void SendPvPAnnounce(Player* killer, Player* killed);
+        
         /// Are we in the middle of a shutdown?
         bool IsShutdowning() const { return m_ShutdownTimer > 0; }
         void ShutdownServ(uint32 time, uint32 options, uint8 exitcode);
@@ -575,6 +685,28 @@ class World
         static float GetVisibleUnitGreyDistance()           { return m_VisibleUnitGreyDistance;       }
         static float GetVisibleObjectGreyDistance()         { return m_VisibleObjectGreyDistance;     }
 
+        //movement anticheat enable flag
+        inline bool GetMvAnticheatEnable()             {return m_MvAnticheatEnable;}
+        inline bool GetMvAnticheatKick()               {return m_MvAnticheatKick;}
+        inline bool GetMvAnticheatAnnounce()           {return m_MvAnticheatAnnounce;}
+        inline uint32 GetMvAnticheatAlarmCount()       {return m_MvAnticheatAlarmCount;}
+        inline uint32 GetMvAnticheatAlarmPeriod()      {return m_MvAnticheatAlarmPeriod;}
+        inline unsigned char GetMvAnticheatBan()       {return m_MvAntiCheatBan;}
+        inline std::string GetMvAnticheatBanTime()     {return m_MvAnticheatBanTime;}
+        inline unsigned char GetMvAnticheatGmLevel()   {return m_MvAnticheatGmLevel;}
+        inline bool GetMvAnticheatKill()               {return m_MvAnticheatKill;}
+        inline float GetMvAnticheatMaxXYT()            {return m_MvAnticheatMaxXYT;}
+        inline uint16 GetMvAnticheatIgnoreAfterTeleport()   {return m_MvAnticheatIgnoreAfterTeleport;}
+
+        inline bool GetMvAnticheatSpeedCheck()         {return m_MvAnticheatSpeedCheck;}
+        inline bool GetMvAnticheatWaterCheck()         {return m_MvAnticheatWaterCheck;}
+        inline bool GetMvAnticheatFlyCheck()           {return m_MvAnticheatFlyCheck;}
+        inline bool GetMvAnticheatMountainCheck()      {return m_MvAnticheatMountainCheck;}
+        inline bool GetMvAnticheatJumpCheck()          {return m_MvAnticheatJumpCheck;}
+        inline bool GetMvAnticheatTeleportCheck()      {return m_MvAnticheatTeleportCheck;}
+        inline bool GetMvAnticheatTeleport2PlaneCheck()  {return m_MvAnticheatTeleport2PlaneCheck;}
+
+
         void ProcessCliCommands();
         void QueueCliCommand(CliCommandHolder* commandHolder) { cliCmdQueue.add(commandHolder); }
 
@@ -593,6 +725,8 @@ class World
         //used Script version
         void SetScriptsVersion(char const* version) { m_ScriptsVersion = version ? version : "unknown scripting library"; }
         char const* GetScriptsVersion() { return m_ScriptsVersion.c_str(); }
+		
+		ACE_Thread_Mutex m_spellUpdateLock;
 
     protected:
         void _UpdateGameTime();
@@ -601,8 +735,11 @@ class World
 
         void InitDailyQuestResetTime();
         void InitWeeklyQuestResetTime();
+        void InitRandomBGResetTime();
         void ResetDailyQuests();
+        void ResetBGDaily();
         void ResetWeeklyQuests();
+        void ResetRandomBG();
     private:
         void setConfig(eConfigUInt32Values index, char const* fieldname, uint32 defvalue);
         void setConfig(eConfigInt32Values index, char const* fieldname, int32 defvalue);
@@ -634,6 +771,7 @@ class World
         IntervalTimer m_timers[WUPDATE_COUNT];
         uint32 mail_timer;
         uint32 mail_timer_expires;
+        uint32 world_diff_time;
 
         typedef UNORDERED_MAP<uint32, Weather*> WeatherMap;
         WeatherMap m_weathers;
@@ -666,6 +804,26 @@ class World
         static float m_VisibleUnitGreyDistance;
         static float m_VisibleObjectGreyDistance;
 
+        //movement anticheat enable flag
+        bool m_MvAnticheatEnable;
+        bool m_MvAnticheatKick;
+        bool m_MvAnticheatAnnounce;
+        uint32 m_MvAnticheatAlarmCount;
+        uint32 m_MvAnticheatAlarmPeriod;
+        unsigned char m_MvAntiCheatBan;
+        std::string m_MvAnticheatBanTime;
+        unsigned char m_MvAnticheatGmLevel;
+        bool m_MvAnticheatKill;
+        float m_MvAnticheatMaxXYT;
+        uint16 m_MvAnticheatIgnoreAfterTeleport;
+        bool m_MvAnticheatSpeedCheck;
+        bool m_MvAnticheatWaterCheck;
+        bool m_MvAnticheatFlyCheck;
+        bool m_MvAnticheatMountainCheck;
+        bool m_MvAnticheatJumpCheck;
+        bool m_MvAnticheatTeleportCheck;
+        bool m_MvAnticheatTeleport2PlaneCheck;
+
         // CLI command holder to be thread safe
         ACE_Based::LockedQueue<CliCommandHolder*,ACE_Thread_Mutex> cliCmdQueue;
         SqlResultQueue *m_resultQueue;
@@ -673,6 +831,7 @@ class World
         // next daily quests reset time
         time_t m_NextDailyQuestReset;
         time_t m_NextWeeklyQuestReset;
+        time_t m_NextRandomBGReset;
 
         //Player Queue
         Queue m_QueuedPlayer;
@@ -691,4 +850,4 @@ extern uint32 realmID;
 
 #define sWorld MaNGOS::Singleton<World>::Instance()
 #endif
-/// @}
+/// @}
\ No newline at end of file
diff --git a/mangos/src/game/WorldSession.cpp b/Core/src/game/WorldSession.cpp
index 273cf08..55d8b80 100644
--- a/mangos/src/game/WorldSession.cpp
+++ b/Core/src/game/WorldSession.cpp
@@ -20,7 +20,7 @@
     \ingroup u2w
 */
 
-#include "WorldSocket.h"                                    // must be first to make ACE happy with ACE includes in it
+#include "WorldSocket.h"                                   // must be first to make ACE happy with ACE includes in it
 #include "Common.h"
 #include "Database/DatabaseEnv.h"
 #include "Log.h"
@@ -39,6 +39,10 @@
 #include "Auth/HMACSHA1.h"
 #include "zlib/zlib.h"
 
+// Playerbot mod
+#include "PlayerbotMgr.h"
+#include "PlayerbotAI.h"
+
 /// WorldSession constructor
 WorldSession::WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale) :
 LookingForGroup_auto_join(false), LookingForGroup_auto_add(false), m_muteTime(mute_time),
@@ -90,6 +94,14 @@ char const* WorldSession::GetPlayerName() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket const* packet)
 {
+    // Playerbot mod: send packet to bot AI
+    if (GetPlayer()) {
+        if (GetPlayer()->GetPlayerbotAI())
+            GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+        else if (GetPlayer()->GetPlayerbotMgr())
+            GetPlayer()->GetPlayerbotMgr()->HandleMasterOutgoingPacket(*packet);
+    }
+
     if (!m_Socket)
         return;
 
@@ -190,6 +202,11 @@ bool WorldSession::Update(uint32 /*diff*/)
                             LogUnprocessedTail(packet);
                     }
                     // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
+
+                    // playerbot mod
+                    if (_player && _player->GetPlayerbotMgr())
+                        _player->GetPlayerbotMgr()->HandleMasterIncomingPacket(*packet);
+                    // playerbot mod end
                     break;
                 case STATUS_LOGGEDIN_OR_RECENTLY_LOGGEDOUT:
                     if(!_player && !m_playerRecentlyLogout)
@@ -272,6 +289,31 @@ bool WorldSession::Update(uint32 /*diff*/)
         delete packet;
     }
 
+    // Playerbot mod - Process player bot packets
+    // The PlayerbotAI class adds to the packet queue to simulate a real player
+    // since Playerbots are known to the World obj only by its master's WorldSession object
+    // we need to process all master's bot's packets.
+    if (GetPlayer() && GetPlayer()->GetPlayerbotMgr()) {
+        for (PlayerBotMap::const_iterator itr = GetPlayer()->GetPlayerbotMgr()->GetPlayerBotsBegin();
+                itr != GetPlayer()->GetPlayerbotMgr()->GetPlayerBotsEnd(); ++itr)
+        {
+            Player* const botPlayer = itr->second;
+            WorldSession* const pBotWorldSession = botPlayer->GetSession();
+            if (botPlayer->IsBeingTeleported())
+                botPlayer->GetPlayerbotAI()->HandleTeleportAck();
+            else if (botPlayer->IsInWorld())
+            {
+                WorldPacket* packet;
+                while (pBotWorldSession->_recvQueue.next(packet))
+                {
+                    OpcodeHandler& opHandle = opcodeTable[packet->GetOpcode()];
+                    (pBotWorldSession->*opHandle.handler)(*packet);
+                    delete packet;
+                }
+            }
+        }
+    }
+
     ///- Cleanup socket pointer if need
     if (m_Socket && m_Socket->IsClosed ())
     {
@@ -302,6 +344,10 @@ void WorldSession::LogoutPlayer(bool Save)
 
     if (_player)
     {
+        // Playerbot mod: log out all player bots owned by this toon
+        if (_player->GetPlayerbotMgr())
+            _player->GetPlayerbotMgr()->LogoutAllBots();
+
         sLog.outChar("Account: %d (IP: %s) Logout Character:[%s] (guid: %u)", GetAccountId(), GetRemoteAddress().c_str(), _player->GetName() ,_player->GetGUIDLow());
 
         if (uint64 lguid = GetPlayer()->GetLootGUID())
@@ -389,7 +435,8 @@ void WorldSession::LogoutPlayer(bool Save)
         ///- Reset the online field in the account table
         // no point resetting online in character table here as Player::SaveToDB() will set it to 1 since player has not been removed from world at this stage
         // No SQL injection as AccountID is uint32
-        loginDatabase.PExecute("UPDATE account SET active_realm_id = 0 WHERE id = '%u'", GetAccountId());
+        if (! _player->GetPlayerbotAI())
+            loginDatabase.PExecute("UPDATE account SET active_realm_id = 0 WHERE id = '%u'", GetAccountId());
 
         ///- If the player is in a guild, update the guild roster and broadcast a logout message to other guild members
         Guild *guild = sObjectMgr.GetGuildById(_player->GetGuildId());
@@ -438,6 +485,9 @@ void WorldSession::LogoutPlayer(bool Save)
         sSocialMgr.SendFriendStatus(_player, FRIEND_OFFLINE, _player->GetGUIDLow(), true);
         sSocialMgr.RemovePlayerSocial (_player->GetGUIDLow ());
 
+        // Playerbot - remember player GUID for update SQL below
+        uint32 guid = _player->GetGUIDLow();
+
         ///- Remove the player from the world
         // the player may not be in the world when logging out
         // e.g if he got disconnected during a transfer to another map
@@ -452,8 +502,12 @@ void WorldSession::LogoutPlayer(bool Save)
 
         ///- Since each account can only have one online character at any given time, ensure all characters for active account are marked as offline
         //No SQL injection as AccountId is uint32
-        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE account = '%u'",
-            GetAccountId());
+        //CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE account = '%u'",
+        //    GetAccountId());
+
+        // Playerbot mod: commented out above and do this one instead
+        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE guid = '%u'", guid);
+
         DEBUG_LOG( "SESSION: Sent SMSG_LOGOUT_COMPLETE Message" );
     }
 
diff --git a/mangos/src/game/WorldSession.h b/Core/src/game/WorldSession.h
index 8aa6ba9..a7c3ff3 100644
--- a/mangos/src/game/WorldSession.h
+++ b/Core/src/game/WorldSession.h
@@ -150,6 +150,9 @@ class MANGOS_DLL_SPEC WorldSession
         bool PlayerLogout() const { return m_playerLogout; }
         bool PlayerLogoutWithSave() const { return m_playerLogout && m_playerSave; }
 
+        inline bool Anti__CheatOccurred(uint32 CurTime,const char* Reason,float Speed,const char* Op=NULL,float Val1=0.0f,uint32 Val2=0);
+        bool Anti__ReportCheat(const char* Reason,float Speed,const char* Op=NULL,float Val1=0.0f,uint32 Val2=0);
+
         void SizeError(WorldPacket const& packet, uint32 size) const;
 
         void ReadAddonsInfo(WorldPacket &data);
@@ -222,12 +225,12 @@ class MANGOS_DLL_SPEC WorldSession
 
         void SendBattlegGroundList( uint64 guid, BattleGroundTypeId bgTypeId );
 
-        void SendTradeStatus(TradeStatus status);
+        void SendTradeStatus(uint32 status);
         void SendCancelTrade();
 
         void SendStablePet(uint64 guid );
         void SendPetitionQueryOpcode( uint64 petitionguid);
-        void SendUpdateTrade(bool trader_state = true);
+        void SendUpdateTrade();
 
         //pet
         void SendPetNameQuery(uint64 guid, uint32 petnumber);
@@ -423,6 +426,9 @@ class MANGOS_DLL_SPEC WorldSession
         void HandleSetActiveMoverOpcode(WorldPacket &recv_data);
         void HandleMoveNotActiveMover(WorldPacket &recv_data);
         void HandleDismissControlledVehicle(WorldPacket &recv_data);
+        void HandleRequestVehicleExit(WorldPacket &recv_data);
+        void HandleRequestVehicleSwitchSeat(WorldPacket &recv_data);
+        void HandleChangeSeatsOnControlledVehicle(WorldPacket &recv_data);
         void HandleMoveTimeSkippedOpcode(WorldPacket &recv_data);
 
         void HandleRequestRaidInfoOpcode( WorldPacket & recv_data );
@@ -719,6 +725,7 @@ class MANGOS_DLL_SPEC WorldSession
 
         void HandleCancelTempEnchantmentOpcode(WorldPacket& recv_data);
         void HandleItemRefundInfoRequest(WorldPacket& recv_data);
+        void HandleItemRefund(WorldPacket& recv_data);
 
         void HandleChannelVoiceOnOpcode(WorldPacket & recv_data);
         void HandleVoiceSessionEnableOpcode(WorldPacket& recv_data);
@@ -758,9 +765,11 @@ class MANGOS_DLL_SPEC WorldSession
         void HandleCalendarGetNumPending(WorldPacket& recv_data);
 
         void HandleSpellClick(WorldPacket& recv_data);
+        void HandleMirrorImageDataRequest(WorldPacket& recv_data);
         void HandleAlterAppearance(WorldPacket& recv_data);
         void HandleRemoveGlyph(WorldPacket& recv_data);
         void HandleCharCustomize(WorldPacket& recv_data);
+        void HandleCharFactionOrRaceChange(WorldPacket& recv_data);
         void HandleQueryInspectAchievements(WorldPacket& recv_data);
         void HandleEquipmentSetSave(WorldPacket& recv_data);
         void HandleEquipmentSetDelete(WorldPacket& recv_data);
diff --git a/mangos/src/game/WorldSocket.cpp b/Core/src/game/WorldSocket.cpp
index 2b409be..81d986e 100644
--- a/mangos/src/game/WorldSocket.cpp
+++ b/Core/src/game/WorldSocket.cpp
@@ -855,8 +855,8 @@ int WorldSocket::HandleAuthSession (WorldPacket& recvPacket)
 
     id = fields[0].GetUInt32 ();
     security = fields[1].GetUInt16 ();
-    if(security > SEC_ADMINISTRATOR)                        // prevent invalid security settings in DB
-        security = SEC_ADMINISTRATOR;
+    if(security >= SEC_CONSOLE)                        // prevent invalid security settings in DB
+        security = SEC_CONSOLE-1;
 
     K.SetHexStr (fields[2].GetString ());
 
diff --git a/Core/src/game/ZoneScript.h b/Core/src/game/ZoneScript.h
new file mode 100644
index 0000000..43aeef2
--- /dev/null
+++ b/Core/src/game/ZoneScript.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS <http://www.MaNGOScore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef ZONE_SCRIPT_H_
+#define ZONE_SCRIPT_H_
+
+#include "Common.h"
+#include "Creature.h"
+
+//struct CreatureData;
+class Creature;
+class GameObject;
+
+class ZoneScript
+{
+    public:
+        explicit ZoneScript() {}
+
+        virtual uint32 GetCreatureEntry(uint32 guidlow, const CreatureData *data) { return data->id; }
+        virtual uint32 GetGameObjectEntry(uint32 guidlow, uint32 entry) { return entry; }
+
+        virtual void OnCreatureCreate(Creature *, bool add) {}
+        virtual void OnGameObjectCreate(GameObject *go, bool add) {}
+
+        //All-purpose data storage 64 bit
+        virtual uint64 GetData64(uint32 /*DataId*/) { return 0; }
+        virtual void SetData64(uint32 /*DataId*/, uint64 /*Value*/) {}
+
+        //All-purpose data storage 32 bit
+        virtual uint32 GetData(uint32 /*DataId*/) { return 0; }
+        virtual void SetData(uint32 /*DataId*/, uint32 /*Value*/) {}
+
+        virtual void ProcessEvent(GameObject *obj, uint32 eventId) {}
+};
+
+#endif
\ No newline at end of file
diff --git a/mangos/src/game/debugcmds.cpp b/Core/src/game/debugcmds.cpp
index 6a48add..8e0d9c5 100644
--- a/mangos/src/game/debugcmds.cpp
+++ b/Core/src/game/debugcmds.cpp
@@ -636,7 +636,8 @@ bool ChatHandler::HandleDebugSpawnVehicle(const char* args)
 
     Vehicle *v = new Vehicle;
     Map *map = m_session->GetPlayer()->GetMap();
-    if (!v->Create(map->GenerateLocalLowGuid(HIGHGUID_VEHICLE), map, entry, id, m_session->GetPlayer()->GetTeam()))
+
+    if (!v->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_VEHICLE), map, m_session->GetPlayer()->GetPhaseMaskForSpawn(), entry, id, m_session->GetPlayer()->GetTeam()))
     {
         delete v;
         return false;
@@ -656,6 +657,7 @@ bool ChatHandler::HandleDebugSpawnVehicle(const char* args)
     }
 
     map->Add((Creature*)v);
+    v->AIM_Initialize();
 
     return true;
 }
